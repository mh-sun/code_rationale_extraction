[
    {
        "commit_hash": "000b8a699ceefd0a362bb307e01261617b4dbf51",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/client/DefaultRestClientBuilder.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.http.client.ReactorClientHttpRequestFactory;\n+\tprivate static final boolean reactorNettyClientPresent;\n+\n+\t\treactorNettyClientPresent = ClassUtils.isPresent(\"reactor.netty.http.client.HttpClient\", loader);\n+\t\telse if (reactorNettyClientPresent) {\n+\t\t\treturn new ReactorClientHttpRequestFactory();\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Auto-detect Reactor Netty client in RestClient",
        "commit_body": "Closes gh-33635\n",
        "linked_issues": [
            {
                "issue_id": "33635",
                "issue_title": "RestClient should auto-detect ReactorClientHttpRequestFactory",
                "issue_body": "Reactor Netty client support was added in #30835, but it looks like `DefaultRestClientBuilder` was never updated after that to pick it up if available on the classpath.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check for the presence of the `reactor.netty.http.client.HttpClient` class using `ClassUtils.isPresent`.  If the class is present, a `ReactorClientHttpRequestFactory` is returned.  This suggests a conditional instantiation of a client based on the availability of a specific Reactor Netty dependency.  The original code likely had a default client factory, and this change now prioritizes a Reactor Netty-based factory if the dependency is available",
            "avg_logprobs": -0.2608273759180186
        }
    },
    {
        "commit_hash": "009d2a5efd456a37c29fd984be3087f09082c325",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (actualName == null) {\n-\t\t\t// at this point we know the property does not exist\n-\t\t\treturn null;\n-\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary null check in SysEnvPropSource",
        "commit_body": "Remove unnecessary null check and dead code from\nSystemEnvironmentPropertySource.\n\nIssue: SPR-10318\n",
        "linked_issues": [
            {
                "issue_id": "14952",
                "issue_title": "Remove unnecessary null check in SystemEnvironmentPropertySource [SPR-10318]",
                "issue_body": "**[Wujek](https://jira.spring.io/secure/ViewProfile.jspa?name=wujek.srujek@gmail.com)** opened **[SPR-10318](https://jira.spring.io/browse/SPR-10318?redirect=false)** and commented\n\nThe following code is to be found in `SystemEnvironmentPropertySource.getProperty`:\n\n```java\n        @Override\n\tpublic Object getProperty(String name) {\n\t\tAssert.notNull(name, \"property name must not be null\");\n\t\tString actualName = resolvePropertyName(name);\n\t\tif (actualName == null) {\n\t\t\t// at this point we know the property does not exist\n\t\t\treturn null;\n\t\t}\n...\n```\n\nSo, the `resolvePropertyName` method is called to get `actualName`, but it has the following JavaDoc part:\n\n> Never returns {`@code` null}.\n\nand the code actually reflects this. This is also a private method, so can't be overridden in subclasses. In this case, the null check in `getProperty` is completely unnecessary and actually dead code.\n\nI am not sure how this should be fixed - the resolve... method made protected or the check just deleted - so no pull request, no patch, sorry :(\n\n---\n\n**Affects:** 3.2.1\n\n**Issue Links:**\n- #14604 UnsupportedOperationException when accessing Environment with active SecurityManager\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/009d2a5efd456a37c29fd984be3087f09082c325\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nGood spot. I have removed the dead code. If `resolvePropertyName` ever becomes protected we can reintroduce it.\n",
                    "**[Chris Beams](https://jira.spring.io/secure/ViewProfile.jspa?name=cbeams)** commented\n\nThanks, both. Note that changes made for #14604 created the \"dead code\" situation in the first place. Prior to those changes, `#resolvePropertyName` could have returned `null` in certain cases.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removed a check for a null `actualName` and the subsequent return of `null`.  This suggests the previous code was returning `null` if the property name was not found, and now the code assumes `actualName` will always be valid.  This change likely simplifies the code and/or removes a potential null pointer exception",
            "avg_logprobs": -0.3164658076326612
        }
    },
    {
        "commit_hash": "010e8a303b1caf3b80e244fc5e4aebc23d854118",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/client/reactive/JdkClientHttpRequest.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!cookies.isEmpty()) {\n-\t\t\tthis.builder.header(HttpHeaders.COOKIE, cookies.values().stream()\n-\t\t\t\t\t.flatMap(List::stream).map(HttpCookie::toString).collect(Collectors.joining(\";\")));\n+\t\tif (cookies.isEmpty()) {\n+\t\t\treturn;\n+\t\tthis.builder.header(HttpHeaders.COOKIE, cookies.values().stream()\n+\t\t\t\t.flatMap(List::stream).map(HttpCookie::toString).collect(Collectors.joining(\";\")));",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing contribution",
        "commit_body": "Closes gh-32799\n",
        "linked_issues": [
            {
                "issue_id": "32799",
                "issue_title": "Do not send Cookie header in reactive JdkClientHttpRequest if no cookies added",
                "issue_body": "Prevent cookies to be set to empty in the HTTP request if no cookie is present.\r\nThe `Cookie` header should not be sent if no cookie is set in the HTTP message.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the handling of cookies in `JdkClientHttpRequest`.  The original code added a cookie header only if the `cookies` map wasn't empty.  The change now short-circuits the process entirely if the `cookies` map *is* empty, returning early without setting the header.  This avoids unnecessary string concatenation and stream operations when no cookies are present.  The logic has been inverted for efficiency",
            "avg_logprobs": -0.22746682167053223
        }
    },
    {
        "commit_hash": "01c8de0111806d8f9346f332b22ece9dd9fef618",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/target/AbstractBeanFactoryBasedTargetSourceCreator.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tDefaultListableBeanFactory internalBeanFactory = this.internalBeanFactories.get(beanName);\n-\t\t\tif (internalBeanFactory == null) {\n-\t\t\t\tinternalBeanFactory = buildInternalBeanFactory(this.beanFactory);\n-\t\t\t\tthis.internalBeanFactories.put(beanName, internalBeanFactory);\n-\t\t\t}\n-\t\t\treturn internalBeanFactory;\n+\t\t\treturn this.internalBeanFactories.computeIfAbsent(beanName, k -> buildInternalBeanFactory(this.beanFactory));",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify getInternalBeanFactoryForBean",
        "commit_body": "This commit simplifies getInternalBeanFactoryForBean() in\nAbstractBeanFactoryBasedTargetSourceCreator via\nMap::computeIfAbsent.\n\nCloses gh-27234",
        "linked_issues": [
            {
                "issue_id": "27234",
                "issue_title": "Simplify getInternalBeanFactoryForBean",
                "issue_body": "This pull request simplifies `getInternalBeanFactoryForBean` in `AbstractBeanFactoryBasedTargetSourceCreator` and makes its intent more obvious.\r\n\r\nThe problem in https://github.com/spring-projects/spring-framework/issues/25801#issuecomment-698346498 does not apply to this patch since the mapping function in this patch does not modify/access the map itself.\r\n\r\nThis patch was generated automatically by the static analysis tool [Logifix](https://github.com/lyxell/logifix) as part of a research project.",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `main`.\r\n\r\nThanks for your first contribution to the Spring Framework."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a conditional `if` statement with a `computeIfAbsent` method call.  The original code checked if an `internalBeanFactory` existed for a given `beanName`, and if not, built it and stored it.  The new code uses `computeIfAbsent` to efficiently create and store the `internalBeanFactory` only if it's missing, avoiding the need for the explicit `if` statement and the separate assignment",
            "avg_logprobs": -0.20384946823120118
        }
    },
    {
        "commit_hash": "01df63b9cdd12f89763874a14cc50e0c4f8a7e4d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/support/SimpleJmsHeaderMapper.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tSet<Map.Entry<String, Object>> entries = headers.entrySet();\n-\t\t\tfor (Map.Entry<String, Object> entry : entries) {\n+\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {",
        "change_count": 3,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Delete unnecessary variable",
        "commit_body": "See gh-27101\n",
        "linked_issues": [
            {
                "issue_id": "27101",
                "issue_title": "Delete unnecessary variable",
                "issue_body": "I review the PRs of @stsypanov in order to learn some code tips. \r\n\r\nI found the code of https://github.com/spring-projects/spring-framework/pull/23053 may be simpler.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an unnecessary intermediate variable `entries`.  The original code created a `Set` of entries from the `headers` map, then iterated over that set.  The updated code directly iterates over the `headers` map's entry set, eliminating the extra object creation.  This is a minor optimization, improving efficiency by avoiding the creation and use of an intermediate collection",
            "avg_logprobs": -0.1890720844268799
        }
    },
    {
        "commit_hash": "0268e762980f302e251a92743dd6724403660399",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/ExtendedEntityManagerCreator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tSet<Class<?>> ifcs = new LinkedHashSet<>(4);\n-\t\t\t\tifcs.add(key);\n-\t\t\t\tifcs.add(EntityManagerProxy.class);\n-\t\t\t\treturn ClassUtils.toClassArray(ifcs);\n+\t\t\t\tif (EntityManagerProxy.class.equals(key)) {\n+\t\t\t\t\treturn new Class<?>[] {key};\n+\t\t\t\t}\n+\t\t\t\treturn new Class<?>[] {key, EntityManagerProxy.class};",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improve mapping function in ExtendedEntityManagerCreator.createProxy()",
        "commit_body": "Closes gh-27456\n",
        "linked_issues": [
            {
                "issue_id": "27456",
                "issue_title": "Improve mapping function in ExtendedEntityManagerCreator.createProxy()",
                "issue_body": "As soon as there are up to two items in the resulting array we can populate it explicitly which is faster and memory-saving.",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `5.3.x` and `main`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change optimizes the creation of an array of classes.  Previously, it always added both the `key` class and `EntityManagerProxy.class` to a `LinkedHashSet` and then converted it to an array.  The updated code now checks if the `key` is `EntityManagerProxy.class` itself.  If it is, it returns a single-element array containing only `key`; otherwise, it returns an array containing both `key` and `EntityManagerProxy.class`.",
            "avg_logprobs": -0.09856468200683594
        }
    },
    {
        "commit_hash": "02b539c5f50b59d9f5605c21e42d53f0c8e23ae1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.core.SpringProperties;\n+ * @author Sebastien Deleuze\n+\t/**\n+\t * Boolean flag controlled by a {@code spring.xml.ignore} system property that instructs Spring to\n+\t * ignore XML, i.e. to not initialize the XML-related infrastructure.\n+\t * <p>The default is \"false\".\n+\t */\n+\tprivate static final boolean shouldIgnoreXml = SpringProperties.getFlag(\"spring.xml.ignore\");\n+\t\n+\n+\t\t\t\telse if (shouldIgnoreXml) {\n+\t\t\t\t\tthrow new UnsupportedOperationException(\"XML support disabled\");\n+\t\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Leverage spring.ignore.xml flag to avoid XmlBeanDefinitionReader",
        "commit_body": "Closes gh-25338\n",
        "linked_issues": [
            {
                "issue_id": "25338",
                "issue_title": "Leverage spring.ignore.xml flag to avoid XmlBeanDefinitionReader",
                "issue_body": "This issue is a follow up of #25151, it avoids using `XmlBeanDefinitionReader` in `ConfigurationClassBeanDefinitionReader` when `spring.xml.ignore` is `true` in order to avoid triggering XML usage in GraalVM native images.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check for a system property `spring.xml.ignore`.  If this property is set to `true`, an `UnsupportedOperationException` is thrown, effectively disabling XML processing.  This change introduces a conditional check (`else if (shouldIgnoreXml)`) that wasn't present before, preventing XML-related initialization if the property is set",
            "avg_logprobs": -0.12034305572509765
        }
    },
    {
        "commit_hash": "030bc224e30699a91e33e27a6d9782803afbd0d4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/ServletServerHttpRequest.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (!this.inputStream.isFinished() && this.inputStream.isReady()) {\n+\t\t\tif (this.inputStream.isReady() && !this.inputStream.isFinished()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Invert the check for ServletInputStream.isReady()",
        "commit_body": "When checking whether there is still request body the first method\nthat should be checked is ServletInputStream.isReady() and then\nServletInputStream.isFinished(). ServletInputStream.isReady() is the active\nmethod whereas the ServletInputStream.isFinished() is not.\nIt is important to call ServletInputStream.isReady() because if it returns\nfalse it will schedule a dispatch and if the request body is already read it will\nsend onAllDataRead event.\n\nIssue: SPR-16521\n",
        "linked_issues": [
            {
                "issue_id": "21064",
                "issue_title": "JSON with missing quote leads to hanging [SPR-16521]",
                "issue_body": "**[Veit Guna](https://jira.spring.io/secure/ViewProfile.jspa?name=vguna)** opened **[SPR-16521](https://jira.spring.io/browse/SPR-16521?redirect=false)** and commented\n\nHi.\n\nI'm currently creating a REST service based on Spring Boot 2.0.0.RC1, Webflux and Spring Security using Tomcat embedded container. During integration testing via WebTestClient, some strange error occurred.\n\nIn this TestNG testcase, a broken JSON body is send to the server. When using `WebTestClient` it happens, that this blocks indefinetely - until timeout, not returning the expected parsing error response created by Spring. The call looks like this:\n\n```\n@Test\npublic void testBrokenJson() {\n    client.post()\n            .uri(\"/resourcea/1/resourceb/2/test\")\n            .body(BodyInserters.fromObject(\"{\\\"status\\\": \\\"noClosingQuote}\"))\n            .exchange()\n            .expectStatus().isBadRequest()\n            .expectBody(Void.class);\n}\n```\n\nThe funny part comes now: if I simply give another broken JSON like this in the payload instead:\n\n```\n{\"status\": notquoted }\n```\n\nI get the expected error response.\n\nAnother fun part: when sending the same blocking payload via Postman, it returns the expected response.\n\nI could drill it down having something todo with Spring Security. If I take it out of the mix, it seems to work as expected. Not sure though, where the root cause comes from. Since it's working with Postman, I tend to think it's the `WebTestClient`.\n\nI attached a test project that shows that behavior. Maybe it helps.\n\n\n---\n\n**Affects:** 5.0.3\n\n**Attachments:**\n- [test.zip](https://jira.spring.io/secure/attachment/25405/test.zip) (_6.81 kB_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/030bc224e30699a91e33e27a6d9782803afbd0d4, https://github.com/spring-projects/spring-framework/commit/6959e66b25785b4ad056791517411b5fb762ab9f, https://github.com/spring-projects/spring-framework/commit/a6d527e57aedd94a2e23cc8d35572076dbf0e417\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOn the server side, in all cases, the Jackson non-blocking parser reads all the input and then waits for more (and for the closing quote). From there if we receive a Servlet 3.1 `ReadListener#onAllDataRead()` notification, then the Jackson parser knows the input finished and throws \"JsonEOFException: Unexpected end-of-input: was expecting rest of token\". Otherwise the server hangs.\n\nSo this is unrelated to the WebTestClient which hangs because the server isn't responding (and you can see that from the logging output too). The reason a command line tool like curl works is because it sets the content-length and that doesn't lead to the same issue.\n\nThe trigger seems to be Spring Security switching threads, in which case the `onAllDataRead` callback is never received. [Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg) I see you submitted a PR to detect of end of input when `ServletInputStream.read()` returns -1, which would work around the lack of notification, but I still don't understand why we don't get that notification in the first place? I've looked over the Servlet API for non-blocking I/O, and I can't find anything to explain this. So isn't this an issue that needs to be fixed in Tomcat? I did check that switching to Jetty does work.\n\nI didn't try yet but I suspect it might be easy to reproduce this by creating a simple Servlet with a ReadListener that reads the same input off the Servlet container thread.\n",
                    "**[Veit Guna](https://jira.spring.io/secure/ViewProfile.jspa?name=vguna)** commented\n\nThanks Rossen for taking your time having a look at this!\n\nThe problem with Tomcat was just something I encountered when trying to reproduce an error with Jetty regarding the same problematic payload and throwing `Connection closed prematurely` like this:\n\n```\nreactor.core.Exceptions$ReactiveException: java.io.IOException: Connection closed prematurely\n\tat reactor.core.Exceptions.propagate(Exceptions.java:326)\n\tat reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:124)\n\tat reactor.core.publisher.Mono.block(Mono.java:1186)\n\tat org.springframework.test.web.reactive.server.DefaultWebTestClient$DefaultRequestBodyUriSpec.exchange(DefaultWebTestClient.java:282)\n\tat foo.bar.rbs.rest.resource.GenericRestContractIT.testBrokenJson(GenericRestContractIT.java:36)\n\tat sun.reflect.GeneratedMethodAccessor35.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:104)\n\tat org.testng.internal.MethodInvocationHelper$1.runTestMethod(MethodInvocationHelper.java:205)\n\tat org.springframework.test.context.testng.AbstractTestNGSpringContextTests.run(AbstractTestNGSpringContextTests.java:180)\n\tat org.testng.internal.MethodInvocationHelper.invokeHookable(MethodInvocationHelper.java:217)\n\tat org.testng.internal.Invoker.invokeMethod(Invoker.java:641)\n\tat org.testng.internal.Invoker.invokeTestMethod(Invoker.java:851)\n\tat org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1177)\n\tat org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:129)\n\tat org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:112)\n\tat org.testng.internal.thread.ThreadUtil$2.call(ThreadUtil.java:64)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:745)\n\tSuppressed: java.lang.Exception: #block terminated with an error\n\t\tat reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:126)\n\t\t... 20 more\nCaused by: java.io.IOException: Connection closed prematurely\n\tat reactor.ipc.netty.http.client.HttpClientOperations.onInboundClose(HttpClientOperations.java:262)\n\tat reactor.ipc.netty.channel.ChannelOperationsHandler.channelInactive(ChannelOperationsHandler.java:110)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelInactive(ChannelInboundHandlerAdapter.java:75)\n\tat io.netty.handler.codec.http.HttpContentDecoder.channelInactive(HttpContentDecoder.java:205)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)\n\tat io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelInactive(CombinedChannelDuplexHandler.java:420)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:377)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:342)\n\tat io.netty.handler.codec.http.HttpClientCodec$Decoder.channelInactive(HttpClientCodec.java:282)\n\tat io.netty.channel.CombinedChannelDuplexHandler.channelInactive(CombinedChannelDuplexHandler.java:223)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)\n\tat io.netty.handler.logging.LoggingHandler.channelInactive(LoggingHandler.java:167)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1407)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:925)\n\tat io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:822)\n\tat io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)\n\t... 1 more\n```\n\nSadly I can't reproduce it in that test project. My guess is that it might be related (?).\n",
                    "**[Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg)** commented\n\n> So isn't this an issue that needs to be fixed in Tomcat?\n\nI also think so. I'm working on it.\n\nHowever I think that from performance point of view it is better to react on **-1** instead of waiting for container's event.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOkay fair enough that we should react on -1 rather than wait. I'm scheduling for 5.0.5.\n\n[Veit Guna](https://jira.spring.io/secure/ViewProfile.jspa?name=vguna), no worries and thanks for taking the time to report the issue! Let's keep this ticket focused on the hanging issue. You can create a new one with a fresh description for the \"Connection closed prematurely\".\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should be resolved now. In addition to fixing the hanging issue, I've also committed a second a fix to ensure the JsonEOFException is treated as a 400 error (instead of 500) so that the test in the sample application is now green.\n",
                    "**[Veit Guna](https://jira.spring.io/secure/ViewProfile.jspa?name=vguna)** commented\n\nThat are excellent news, thanks guys for the quick fix! Yeah, I'm coming back regarding Jetty, when I can reproduce it in a test project.\n",
                    "**[Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg)** commented\n\nHi,\n\n> So isn't this an issue that needs to be fixed in Tomcat?\n\nI worked on that. It appeared that there is an issue in Spring Framework that needs to be fixed.\nhttps://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/server/reactive/ServletServerHttpRequest.java#L266\n\nThe implementation should check first the active method **isReady** and then **isFinished** as the last is not active.\n\nIn the scenario above in case the request body is read, the current implementation will not invoke **isReady** and thus Tomcat will not schedule a dispatch, and **onAllDataRead** event will never be called.\n\nHere is a PR https://github.com/spring-projects/spring-framework/pull/1722\n\nThe scenario is working with Jetty because it behaves a bit different and there is no read that returns **-1**\n\nLogs with Jetty\n\n```\n2018-03-07 16:55:56.534 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : UNSUBSCRIBED -> SUBSCRIBING\n2018-03-07 16:55:56.536 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : Signal request(32)\n2018-03-07 16:55:56.536 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : SUBSCRIBING -> DEMAND\n2018-03-07 16:55:56.536 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : I/O event onDataAvailable\n2018-03-07 16:55:56.536 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : DEMAND -> READING\n2018-03-07 16:55:56.536 TRACE 37568 --- [     parallel-1] o.s.h.s.r.ServletServerHttpRequest       : InputStream read returned 27 bytes\n2018-03-07 16:55:56.536 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : Data item read, publishing..\n2018-03-07 16:55:56.541 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : Signal request(1)\n2018-03-07 16:55:56.541 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : No more data to read\n2018-03-07 16:55:56.541 TRACE 37568 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : READING -> DEMAND\n2018-03-07 16:55:56.542 TRACE 37568 --- [tp1044965465-21] etServerHttpRequest$RequestBodyPublisher : I/O event onAllDataRead\n2018-03-07 16:55:56.542 TRACE 37568 --- [tp1044965465-21] etServerHttpRequest$RequestBodyPublisher : DEMAND -> COMPLETED\n2018-03-07 16:55:56.544 TRACE 37568 --- [tp1044965465-21] etServerHttpRequest$RequestBodyPublisher : Signal cancel()\n2018-03-07 16:55:56.544 TRACE 37568 --- [tp1044965465-21] etServerHttpRequest$RequestBodyPublisher : Signal cancel()\n```\n\nLogs with Tomcat\n\n```\n2018-03-07 16:58:40.237 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : UNSUBSCRIBED -> SUBSCRIBING\n2018-03-07 16:58:40.239 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : Signal request(32)\n2018-03-07 16:58:40.239 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : SUBSCRIBING -> DEMAND\n2018-03-07 16:58:40.240 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : I/O event onDataAvailable\n2018-03-07 16:58:40.240 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : DEMAND -> READING\n2018-03-07 16:58:40.240 TRACE 37574 --- [     parallel-1] tpHandlerAdapter$TomcatServerHttpRequest : read:27\n2018-03-07 16:58:40.240 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : Data item read, publishing..\n2018-03-07 16:58:40.244 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : Signal request(1)\n2018-03-07 16:58:40.244 TRACE 37574 --- [     parallel-1] tpHandlerAdapter$TomcatServerHttpRequest : read:-1\n2018-03-07 16:58:40.244 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : No more data to read\n2018-03-07 16:58:40.245 TRACE 37574 --- [     parallel-1] etServerHttpRequest$RequestBodyPublisher : READING -> DEMAND\n2018-03-07 16:58:42.307  INFO 37574 --- [       Thread-3] onfigReactiveWebServerApplicationContext : Closing org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@42a15bdc: startup date [Wed Mar 07 16:58:37 EET 2018]; root of context hierarchy\n2018-03-07 16:58:42.375 TRACE 37574 --- [nio-8080-exec-2] etServerHttpRequest$RequestBodyPublisher : I/O event onError: java.lang.IllegalStateException: Async operation timeout.\n2018-03-07 16:58:42.375 TRACE 37574 --- [nio-8080-exec-2] etServerHttpRequest$RequestBodyPublisher : DEMAND -> COMPLETED\n2018-03-07 16:58:42.380 TRACE 37574 --- [nio-8080-exec-2] etServerHttpRequest$RequestBodyPublisher : Signal cancel()\n2018-03-07 16:58:42.380 TRACE 37574 --- [nio-8080-exec-2] etServerHttpRequest$RequestBodyPublisher : Signal cancel()\n```\n\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\n[Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg), thanks for this finding!\n\n> Yeah, I'm coming back regarding Jetty, when I can reproduce it in a test project.\n\n[Veit Guna](https://jira.spring.io/secure/ViewProfile.jspa?name=vguna), I didn't quite catch, did you mean it still doesn't work for Jetty? If so can you verify again once the [current build](https://build.spring.io/browse/SPR-PUB-5868) completes.\n",
                    "**[Veit Guna](https://jira.spring.io/secure/ViewProfile.jspa?name=vguna)** commented\n\nExactly. Running it with Jetty doesn't lockup like Tomcat, but reproduces connection errors from time to time. This is where I started my journey. Actually without Tomcat. I thought this was netty related and created a ticket there initially:\n\nhttps://github.com/reactor/reactor-netty/issues/291\n\nWhile trying to isolate and reproduce in a separate project, I couldn't. But realized, that Tomcat had lockups instead. I thought this might be related and focussed on it - since it was easier to reproduce. I _think_ I checked 5.0.5 with Jetty as well after the fix. But let me doublecheck next week to make sure.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\n> I think I checked 5.0.5 with Jetty as well after the fix.\n\nThere are two fixes now. See the discussion above with [Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg) and her pull request that processed 5 days ago.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change swaps the order of conditions in an `if` statement.  The original `if (!this.inputStream.isFinished() && this.inputStream.isReady())` is now `if (this.inputStream.isReady() && !this.inputStream.isFinished())`.  This is a stylistic change, likely a matter of preference or to potentially improve readability/maintainability.  The logical outcome should be identical, assuming `isReady` and `isFinished` are boolean methods",
            "avg_logprobs": -0.1413168762669419
        }
    },
    {
        "commit_hash": "03468fd9ed2e9b07c672897ef6fd98a0224228bd",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/ReloadableResourceBundleMessageSource.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tmergedHolder = new PropertiesHolder(mergedProps, -1);\n+\t\tlong latestTimestamp = -1;\n+\t\t\t\t\tif (propHolder.getFileTimestamp() > latestTimestamp) {\n+\t\t\t\t\t\tlatestTimestamp = propHolder.getFileTimestamp();\n+\t\t\t\t\t}\n+\t\tmergedHolder = new PropertiesHolder(mergedProps, latestTimestamp);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ReloadableResourceBundleMessageSource sets file timestamp on merged holder",
        "commit_body": "Issue: SPR-14583\n",
        "linked_issues": [
            {
                "issue_id": "19152",
                "issue_title": "Method getMergedProperties in ReloadableResourceBundleMessageSource does not set fileTimestamp [SPR-14583]",
                "issue_body": "**[Igor Stepanov](https://jira.spring.io/secure/ViewProfile.jspa?name=stepio.ua)** opened **[SPR-14583](https://jira.spring.io/browse/SPR-14583?redirect=false)** and commented\n\nHello Spring team,\n\nI'd like to use ReloadableResourceBundleMessageSource to implement REST service to access localized content. And to achieve best performance, I'd like to support caching with \"if-modified-since\". So the idea is to rely on PropertiesHolder.getFileTimestamp() method to understand if some of the underlying property files was updated or not.\n\nI've extended ReloadableResourceBundleMessageSource and call next method:\n\n```java\nprotected PropertiesHolder getMergedProperties(Locale locale) {\n     PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale);\n     if (mergedHolder != null) {\n          return mergedHolder;\n     }\n     Properties mergedProps = newProperties();\n     mergedHolder = new PropertiesHolder(mergedProps, -1);\n     String[] basenames = StringUtils.toStringArray(getBasenameSet());\n     for (int i = basenames.length - 1; i >= 0; i--) {\n          List<String> filenames = calculateAllFilenames(basenames[i], locale);\n          for (int j = filenames.size() - 1; j >= 0; j--) {\n               String filename = filenames.get(j);\n               PropertiesHolder propHolder = getProperties(filename);\n               if (propHolder.getProperties() != null) {\n                        mergedProps.putAll(propHolder.getProperties());\n               }\n          }\n     }\n     PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder);\n     if (existing != null) {\n          mergedHolder = existing;\n     }\n     return mergedHolder;\n}\n```\n\nHowever in current implementation property fileTImestamp is initialized with -1 and never gets updated, so it's not really useful. What do you think about updating it with latest fileTimestamp of the PropertiesHolder instances which are merged into this one?\n\nMoreover, what about adding some setPropertiesChangedCallback() method to make it possible to subscribe to the file updates? In my case this change will allow to push changes to consumer through some message bus and prevent repeated checking through REST interface.\n\n---\n\n**Affects:** 4.3.2\n\n**Issue Links:**\n- #16791 Race condition in ReloadableResourceBundleMessageSource since 4.1.0\n- #15133 ReloadableResourceBundleMessageSource locks properties hashmap and fails under load.\n- #17265 ResourceBundleMessageSource should allow for custom PropertyResourceBundle subclass\n- #14948 Allow adding resources to ReloadableResourceBundleMessageSource\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Igor Stepanov](https://jira.spring.io/secure/ViewProfile.jspa?name=stepio.ua)** commented\n\nAs the first stage I'd like to know just your opinion - if this is really a good idea and worth implementing, or maybe you know a better approach for such use case.\n\nThanks!\n",
                    "**[Igor Stepanov](https://jira.spring.io/secure/ViewProfile.jspa?name=stepio.ua)** commented\n\nThanks for attending #JavaDayKyiv, `@jhoeller`! Hope you've also enjoyed the visit and was not too annoyed with all the attention from the grateful Spring users (including me, of course).\n\nAs discussed, this issue still matters for me, and actually it can be decomposed into two parts:\n1. Just return the correct timestamp in `PropertiesHolder.getFileTimestamp()`.\n2. Add some callback to allow some \"reacting\" when it's detected that properties are modified.\n\nFirst one is simple and looks more like a bug - the method does not return the data, which is promised according to the signature. Second one is a bit more complex, but actually fits well the reactive idea of Spring 5.\n\nIn my case I've implemented a separate micro-service as a server-side holder for i18n content. And it would be rather efficient to allow this service push the updated data to subscribers upon actual content update instead of periodic pulling.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're setting the file timestamp on the merged holder as of 4.3.4 now, simply to the latest timestamp of the original holders.\n\nAs for reacting to changed properties: Effectively, the existing protected `loadProperties` method is only ever called when a new or modified resource has been detected. So by overriding that method, calling `super.loadProperties` first, you could reliably react to property file updates already before letting the base class proceed...\n",
                    "**[Igor Stepanov](https://jira.spring.io/secure/ViewProfile.jspa?name=stepio.ua)** commented\n\nThanks, for the fix, will try the new release.\n\nAlso got the idea about `loadProperties` - yeah, this should do the job.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change optimizes the `ReloadableResourceBundleMessageSource` by tracking the most recent file modification timestamp across multiple property files.  Instead of simply using a fixed timestamp of -1, it now iterates through the `PropertiesHolder` objects, finding the maximum timestamp and using that as the `latestTimestamp` for the merged properties. This ensures the message source only reloads when a *newer* file is available, improving performance by avoiding unnecessary reloads",
            "avg_logprobs": -0.2422943318143804
        }
    },
    {
        "commit_hash": "03b409f891f8ae3e2e22fc347695d07211cf5b8e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tfor (Advisor advisor : advisors) {\n-\t\t\tproxyFactory.addAdvisor(advisor);\n-\t\t}\n-\n+\t\t\n+\t\tproxyFactory.addAdvisors(advisors);\n+",
        "change_count": 7,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Use dedicated addAdvisors",
        "commit_body": "See gh-1469\n",
        "linked_issues": [
            {
                "issue_id": "1469",
                "issue_title": "replace for  with addAdvisors method",
                "issue_body": "replace the code \r\nfor (Advisor advisor : advisors) {\r\n\t\t\tproxyFactory.addAdvisor(advisor);\r\n\t\t}\r\nwith\r\nproxyFactory.addAdvisors(advisors)",
                "issue_state": "closed",
                "issue_comment": [
                    "@IAMTJW Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=1469)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=1469) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@IAMTJW Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=1469)!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a loop adding advisors one by one (`proxyFactory.addAdvisor(advisor)`) with a single method call (`proxyFactory.addAdvisors(advisors)`).  This change is likely a performance optimization, as bulk addition is often more efficient than iterating and adding advisors individually",
            "avg_logprobs": -0.11586782240098523
        }
    },
    {
        "commit_hash": "03d6350e4b3c7e23e3cc84bf3f261f2c53b5b1e9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (providedArgs == null || parameter.hasParameterAnnotations()) {\n+\t\tif (providedArgs == null) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix issue with resolution of WebDataBinder argument",
        "commit_body": "There is usually not need to put annotations on a WebDataBinder\nargument in an `@InitBinder` method. However, the presence of any\nannotation prevented the successful resolution of the argument.\nThis fix addresses the issue.\n\nIssue: SPR-8946\n",
        "linked_issues": [
            {
                "issue_id": "13586",
                "issue_title": "If you annotate any parameter in a @InitBinder method, it fails at runtime. [SPR-8946]",
                "issue_body": "**[Ulon](https://jira.spring.io/secure/ViewProfile.jspa?name=monzonj)** opened **[SPR-8946](https://jira.spring.io/browse/SPR-8946?redirect=false)** and commented\n\nGiven the following init binder method:\n\n    @InitBinder()\n    protected void initBinder(WebDataBinder binder) {\n        .....\n    }\n\nif you annotate the binder parameter with, let's say, `@Nonnull` annotation (very useful for IDE inspection or unit testing) spring MVC is not capable to correctly resolve the parameter\n\n    @InitBinder()\n    protected void initBinder(@Nonnull WebDataBinder binder) {\n        .....\n    }\n\nException:\n\njava.lang.IllegalStateException: No suitable resolver for argument [0] [type=org.springframework.web.bind.WebDataBinder]\n\n\n---\n\n**Affects:** 3.1.1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/03d6350e4b3c7e23e3cc84bf3f261f2c53b5b1e9, https://github.com/spring-projects/spring-framework/commit/229537288a721ea1f73d7fee5ce9dd60ec46c23e\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThe presence of annotations on the WebDataBinder argument should not have any effect. Does it work without the annotation? I assume it does in which case consider reproducing the issue by following these [instructions](https://github.com/SpringSource/spring-framework-issues#readme). What version of Spring do you have? Attaching a more complete stack trace would also be helpful.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis was indeed an issue just as described.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes the `parameter.hasParameterAnnotations()` check from the `if` statement.  Previously, the code checked if `providedArgs` was null *or* if the parameter had annotations.  Now, it only checks if `providedArgs` is null.  This suggests a simplification, potentially removing a redundant check in cases where `providedArgs` is null.  The original check likely had a specific reason, but the change implies that the condition involving annotations was no longer necessary.",
            "avg_logprobs": -0.26692144393920897
        }
    },
    {
        "commit_hash": "044ea17bf935d651c269baad966d58f8fcf6c9aa",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (reactorPresent && ClassUtils.isPresent(\"kotlinx.coroutines.Deferred\", classLoader)) {\n+\t\tif (this.reactorPresent && ClassUtils.isPresent(\"kotlinx.coroutines.Deferred\", classLoader)) {\n-\t\tif (reactorPresent && ClassUtils.isPresent(\"kotlinx.coroutines.flow.Flow\", classLoader)) {\n+\t\tif (this.reactorPresent && ClassUtils.isPresent(\"kotlinx.coroutines.flow.Flow\", classLoader)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `reactorPresent` with `this.reactorPresent` in two `if` statements.  This suggests a change in how `reactorPresent` is accessed, likely moving it from a local variable to an instance field within `ReactiveAdapterRegistry`.  The change implies that `reactorPresent` is now a member variable of the class, rather than a parameter or temporary variable within the method",
            "avg_logprobs": -0.20034096039921404
        }
    },
    {
        "commit_hash": "050e79e45ed0cdab1a4e3f522e2e9b601a13d94d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t * Check if the path has a file extension and whether the extension is either\n-\t * {@link #WHITELISTED_EXTENSIONS whitelisted} or\n-\t * {@link ContentNegotiationManager#getAllFileExtensions() explicitly\n-\t * registered}. If not add a 'Content-Disposition' header with a safe\n-\t * attachment file name (\"f.txt\") to prevent RFD exploits.\n+\t * Check if the path has a file extension and whether the extension is\n+\t * either {@link #WHITELISTED_EXTENSIONS whitelisted} or explicitly\n+\t * {@link ContentNegotiationManager#getAllFileExtensions() registered}.\n+\t * If not, and the status is in the 2xx range, a 'Content-Disposition'\n+\t * header with a safe attachment file name (\"f.txt\") is added to prevent\n+\t * RFD exploits.\n+\t\ttry {\n+\t\t\tint status = response.getServletResponse().getStatus();\n+\t\t\tif (status < 200 || status > 299) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Throwable ex) {\n+\t\t\t// Ignore\n+\t\t}\n+",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip Content-Disposition header if status != 2xx",
        "commit_body": "Issue: SPR-13588\n",
        "linked_issues": [
            {
                "issue_id": "18165",
                "issue_title": "Skip Content-Disposition header when status != 2xx [SPR-13588]",
                "issue_body": "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** opened **[SPR-13588](https://jira.spring.io/browse/SPR-13588?redirect=false)** and commented\n\nThe fix to protect against RFD exploits (#18124) introduced a `\"Content-Disposition:attachment;filename=f.txt\"` response header for `@ResponseBody` methods where the URL appears to have an extension that is neither whitelisted by default nor explicitly registered by the application.\n\nThe URL checked for extensions is always the original URL even in the case of a forwarded request. In the case of an ERROR dispatch, Servlet containers are expected to set up the same request attributes as for forwarded requests.\n\nSince Spring Boot relies on ERROR dispatches, a request with an unknown extension that results in an error can be rendered with a Content-Disposition header. This doesn't appear to cause issues in the browser but we should explore whether we can drop the header in such cases.\n\nNote this issue was originally reported under [Spring Boot ticket #4220](https://github.com/spring-projects/spring-boot/issues/4220#issuecomment-148917466).\n\n---\n\n**Affects:** 3.2.15, 4.1.8, 4.2.2\n\n**Issue Links:**\n- #18190 Skip Content-Disposition header when requestUri is the context and/or the servlet path (_**\"is duplicated by\"**_)\n- #18164 Content-Disposition header causes download in browser for Spring Boot Actuator endpoints\n- #18124 Protect against RFD exploits\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/a8798970639033f5cdcf979c4ee7174ba00157f2, https://github.com/spring-projects/spring-framework/commit/050e79e45ed0cdab1a4e3f522e2e9b601a13d94d\n\n**Backported to:** [4.1.9](https://github.com/spring-projects/spring-framework/milestone/133?closed=1), [3.2.16](https://github.com/spring-projects/spring-framework/milestone/104?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rob Winch](https://jira.spring.io/secure/ViewProfile.jspa?name=rwinch)** commented\n\nI'm not sure this is the best idea since the error page might contain reflected input.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI guess the question is whether the download behavior is different for status 4xx and 5xx. That includes the content types for which specific browsers may force a download (section 2.3.1 in the RFD paper) and/or the hyperlink \"download\" attribute. If an error status precludes a download, then presumably there is no need for a content-disposition header.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nBrowsers I tested with (Firefox, Chrome, IE 7/8/9) don't seem to switch to download when status is 4xx or 5xx. In Firefox/Chrome the presence of a Content-Disposition header actually seems to be treated as an error. In Firefox it shows as 404 ([this ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=364354) looks relevant). Furthermore it doesn't make sense to have Content-Disposition with 3xx either so the final fix checks if response is in 2xx range.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the logic for adding a `Content-Disposition` header to prevent RFD exploits.  The original check for a whitelisted or registered file extension now includes a crucial addition:  **a check for a successful HTTP status code (2xx range).**  If the status code is not in the 2xx range, the header is *not* added.  This prevents the potentially harmful header from being added in cases where the request/response has failed",
            "avg_logprobs": -0.22936553955078126
        }
    },
    {
        "commit_hash": "052bbcc53031bd48dc76d070ba862f5293618600",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ClassUtils.java",
        "change_type": [
            "Add_Condition",
            "Condition_Change"
        ],
        "diff": "+\t\tClass<?>[] parameterTypes = null;\n-\t\t\tClass<?>[] ifcs = current.getInterfaces();\n-\t\t\tfor (Class<?> ifc : ifcs) {\n+\t\t\tif (parameterTypes == null) {\n+\t\t\t\t// Since Method#getParameterTypes() clones the array, we lazily retrieve\n+\t\t\t\t// and cache parameter types to avoid cloning the array multiple times.\n+\t\t\t\tparameterTypes = method.getParameterTypes();\n+\t\t\t}\n+\t\t\tfor (Class<?> ifc : current.getInterfaces()) {\n-\t\t\t\t\treturn ifc.getMethod(method.getName(), method.getParameterTypes());\n+\t\t\t\t\treturn ifc.getMethod(method.getName(), parameterTypes);",
        "change_count": 9,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Cache parameter types array in ClassUtils.findInterfaceMethodIfPossible()",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change optimizes the lookup of methods in interfaces by caching the `parameterTypes`.  Previously, the `parameterTypes` were calculated for each interface in the loop.  Now, `parameterTypes` are only calculated once, if necessary, and reused for subsequent interface checks.  This avoids redundant cloning of the `parameterTypes` array, improving performance",
            "avg_logprobs": -0.26904706954956054
        }
    },
    {
        "commit_hash": "05521027800ef2a49342ac7ef2e5cd1304a080bf",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t/** Maximum number of suppressed exceptions to preserve. */\n+\tprivate static final int SUPPRESSED_EXCEPTIONS_LIMIT = 100;\n+\n+\n-\t/** List of suppressed Exceptions, available for associating related causes. */\n+\t/** Collection of suppressed Exceptions, available for associating related causes. */\n-\t * Register an Exception that happened to get suppressed during the creation of a\n+\t * Register an exception that happened to get suppressed during the creation of a\n+\t * <p>The default implementation preserves any given exception in this registry's\n+\t * collection of suppressed exceptions, up to a limit of 100 exceptions, adding\n+\t * them as related causes to an eventual top-level {@link BeanCreationException}.\n+\t * @see BeanCreationException#getRelatedCauses()\n-\t\t\tif (this.suppressedExceptions != null) {\n+\t\t\tif (this.suppressedExceptions != null && this.suppressedExceptions.size() < SUPPRESSED_EXCEPTIONS_LIMIT) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Enforce limit for storing suppressed exceptions",
        "commit_body": "Closes gh-24902\n",
        "linked_issues": [
            {
                "issue_id": "24902",
                "issue_title": "Put a limit on the size of DefaultSingletonBeanRegistry#suppressedExceptions",
                "issue_body": "Spring 5.1.8\r\n\r\nWhilst converting a particularly complex ball-of-mud legacy application from XML config to `@Configuration`-style config, I am finding that diagnosing circular references that trigger `BeanCurrentlyInCreationException`s causes an `OutOfMemoryError` before any actual exception is thrown during context initialisation. This doesn't happn with the pure XML-based config, only when I mix Java and XML styles.\r\n\r\nWhen I look at the `hprof` file, 96% of the 2.5GB heap is retained by the `DefaultSingletonBeanRegistry#suppressedExceptions` field, which is full of massively-nested `BeanCreationException`s  - 12592 of them, in this case.\r\n\r\nIt woul make sense to me if the `suppressedExceptions` field were to have a size limiter added, to prevent it growing so large. It's only there for diagnostics, and 12000+ exceptons isn't going to help anyone. I on't know what a sensible size imit would be, but more than a few dozen would seem to be unecessary and unhelpful.\r\n\r\nIn my case, the limiter would at least allow the context init to fail \"gracefully\". I don't know what it is about my set up, but its much too complex for me to post as a test case, sorry.\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the handling of suppressed exceptions in `DefaultSingletonBeanRegistry`.  The key change is the introduction of a `SUPPRESSED_EXCEPTIONS_LIMIT` constant (set to 100).  Crucially, the code now checks if the `suppressedExceptions` collection is not null *and* if its size is below the limit before adding a new suppressed exception.  This prevents unbounded growth of the exception list",
            "avg_logprobs": -0.16335229873657225
        }
    },
    {
        "commit_hash": "05683fed7a3f9b51c4a251363504b0aef12826d3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n+\t\tif (!IN_NATIVE_IMAGE && beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip LoadTimeWeaverAwareProcessor with native images",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `IN_NATIVE_IMAGE` before checking if a `LOAD_TIME_WEAVER_BEAN_NAME` exists in the `beanFactory`.  This suggests the original conditional logic was potentially problematic in a native image environment, and the addition of the `IN_NATIVE_IMAGE` check is a safeguard to prevent issues in that context",
            "avg_logprobs": -0.18899764512714587
        }
    },
    {
        "commit_hash": "05b15812bbffc86cd3ee4c664e2eccfb4ec0092b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (attribute instanceof Constructor<?>[]) {\n-\t\t\treturn (Constructor<?>[]) attribute;\n+\t\tif (attribute instanceof Constructor<?>[] constructors) {\n+\t\t\treturn constructors;",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply instanceof pattern matching in RootBeanDefinition",
        "commit_body": "Closes gh-32520\n",
        "linked_issues": [
            {
                "issue_id": "32520",
                "issue_title": "Apply instanceof pattern matching in `RootBeanDefinition`",
                "issue_body": "This pull request applies the instanceof pattern matching in the RootBeanDefinition class. This enhancement will improve code readability.",
                "issue_state": "closed",
                "issue_comment": [
                    "Hi @FelixDes,\r\n\r\nIn the future, please do your best to collect multiple related changes in a PR, since we generally do not like to merge PRs that effectively change a single line of code for style-related reasons.",
                    "This has been merged into `main`.\r\n\r\nThanks",
                    "Thanks a lot for your advice. I'm very glad to see that my PR has been accepted."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `if (attribute instanceof Constructor<?>[])` with `if (attribute instanceof Constructor<?>[] constructors)`.  This is a simple but important change.  It uses a *variable declaration* within the conditional.  This is a more concise and readable way to cast the `attribute` to `Constructor<?>[]` and assign it to the variable `constructors` for use within the `if` block",
            "avg_logprobs": -0.3322121047973633
        }
    },
    {
        "commit_hash": "05d616240ad08f69926368f5549b6472c27a0d5c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\telse if (contentType != null && contentType.isCompatibleWith(MediaType.APPLICATION_JSON)) {\n+\t\t\t// Matching to AbstractJackson2HttpMessageConverter#DEFAULT_CHARSET\n+\t\t\treturn StandardCharsets.UTF_8;\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "StringHttpMessageConverter defaults to UTF-8 for JSON",
        "commit_body": "Issue: SPR-17568\n",
        "linked_issues": [
            {
                "issue_id": "22100",
                "issue_title": "StringHttpMessageConverter should assume charset UTF-8 for application/json [SPR-17568]",
                "issue_body": "**[Thomas Meyer](https://jira.spring.io/secure/ViewProfile.jspa?name=thomasmey)** opened **[SPR-17568](https://jira.spring.io/browse/SPR-17568?redirect=false)** and commented\n\nWhen using \"`@RequestBody` String jsonString\" for an `@Controller`'s `@RequestMapping` and the body is send as application/json with UTF-8 encoding, Spring uses StringHttpMessageConverter to convert the message, as the content-type will be application/json without any explicit encoding, so the StringHttpMessageConverter will fall back to the default encoding ISO-8859-1 which may is in accordance with the HTTP spec but not with RFC7159, which says: \"The default encoding is UTF-8\" (chapter 8.1)\n\n\u00a0\n\nSo the suggestion would be to add an exception in the StringHttpMessageConverter to use UTF-8 charset for application/json.\n\n\u00a0\n\n\u00a0\n\n\n---\n\n**Affects:** 5.1.3\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/05d616240ad08f69926368f5549b6472c27a0d5c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Thomas Meyer](https://jira.spring.io/secure/ViewProfile.jspa?name=thomasmey)** commented\n\nWhen using Jersey as client it's especially problematic as Jersey's StringMessageProvider (https://github.com/jersey/jersey/blob/master/core-common/src/main/java/org/glassfish/jersey/message/internal/StringMessageProvider.java\u00a0) uses default encoding UTF-8 for content-type application/json.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis is also supported by the current HTTP 1.1 spec [RFC 7231](https://tools.ietf.org/html/rfc7231#appendix-B):\n\n> The default charset of ISO-8859-1 for text media types has been\r\n> removed; the default is now whatever the media type definition says.\n\nWe can update `StringHttpMessageConverter` to check for `application/*+json` and use UTF-8, which is what `AbstractJackson2HttpMessageConverter` does by default.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added an `else if` condition to the existing conditional logic.  This new condition checks if the `contentType` is compatible with `MediaType.APPLICATION_JSON`. If true, it returns `StandardCharsets.UTF_8`.  This suggests a change in how the converter handles JSON content, likely to use UTF-8 encoding specifically for JSON",
            "avg_logprobs": -0.13061078389485678
        }
    },
    {
        "commit_hash": "0634555424a8742bbe95333c49975437af6eacf8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t@Override\n+\t@Override\n-\t\tboolean endsWithSlash = pattern.endsWith(\"/\");\n-\t\t\tif (!endsWithSlash && this.pathMatcher.match(pattern + \"/\", lookupPath)) {\n+\t\t\tif (!pattern.endsWith(\"/\") && this.pathMatcher.match(pattern + \"/\", lookupPath)) {\n+\t@Override",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Delay check if pattern ends with slash",
        "commit_body": "This is a minor fix with no actual impact.\n\nIssue: SPR-10504\n",
        "linked_issues": [
            {
                "issue_id": "14998",
                "issue_title": "Unnecessary check in PatternsRequestCondition.getMatchingPattern [SPR-10504]",
                "issue_body": "**[Alex Pogrebnyak](https://jira.spring.io/secure/ViewProfile.jspa?name=alex.spring@reflexion.net)** opened **[SPR-10504](https://jira.spring.io/browse/SPR-10504?redirect=false)** and commented\n\nOn line 259 in `org.springframework.web.servlet.mvc.condition.PatternsRequestCondition` shipped with version 3.2.2 this block from `getMatchingPattern` function has unnecessary code.\n\n```java\nboolean endsWithSlash = pattern.endsWith(\"/\");\nif (this.useTrailingSlashMatch) {\n    if (!endsWithSlash && this.pathMatcher.match(pattern + \"/\", lookupPath)) {\n        return pattern +\"/\";\n    }\n}\n```\n\n`endsWithSlash` initialization should be moved inside `if` statement as it is not used anywhere else in the function\n\n\n---\n\n**Affects:** 3.2.2\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/4bb0916202ac19c20f77cc9883d0746660036389, https://github.com/spring-projects/spring-framework/commit/0634555424a8742bbe95333c49975437af6eacf8\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `endsWithSlash` variable declaration and assignment.  The original code checked if the pattern ended with a slash, and then used that variable in a conditional.  The updated code directly uses the `pattern.endsWith(\"/\")` check within the `if` statement, eliminating the intermediate variable.  This results in a slightly more concise and potentially more efficient expression",
            "avg_logprobs": -0.21357268791694145
        }
    },
    {
        "commit_hash": "0637864b3909ab13727cb228258b778a265da8d9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tA annotation = clazz.getDeclaredAnnotation(annotationType);\n-\t\tif (annotation != null) {\n-\t\t\treturn annotation;\n+\t\tif (isAnnotationDeclaredLocally(annotationType, clazz)) {\n+\t\t\treturn clazz.getAnnotation(annotationType);\n-\t\t\tannotation = findAnnotation(ifc, annotationType, visited);\n+\t\t\tA annotation = findAnnotation(ifc, annotationType, visited);\n-\t\t\t\tannotation = findAnnotation(ann.annotationType(), annotationType, visited);\n+\t\t\t\tA annotation = findAnnotation(ann.annotationType(), annotationType,\n+\t\t\t\t\t\tvisited);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ensure AnnotationUtils is compatible with Java 6",
        "commit_body": "The previous commit introduced a dependency on\nClass.getDeclaredAnnotation() which is a Java 8 API.\n\nThis commit refactors AnnotationUtils.findAnnotation(Class, Class, Set)\nto use Class.getAnnotation() in conjunction with\nisAnnotationDeclaredLocally() in order to achieve the same desired\nbehavior.\n\nIssue: SPR-11475\n",
        "linked_issues": [
            {
                "issue_id": "16100",
                "issue_title": "Favor more locally declared composed annotations over inherited annotations in AnnotationUtils [SPR-11475]",
                "issue_body": "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** opened **[SPR-11475](https://jira.spring.io/browse/SPR-11475?redirect=false)** and commented\n\n#### Status Quo\n\nThe implementations of both `AnnotationUtils` and `AnnotatedElementUtils` (and possibly `AbstractRecursiveAnnotationVisitor` as well) currently favor _inherited_ annotations and _inherited_ composed annotations over composed annotations that are declared closer to the starting class passed to the `findAnnotation()` and `getAnnotationAttributes()` methods.\n\nGiven a class hierarchy with a depth of at least three, if the lowest level (e.g., `Level3`) is not directly annotated but `Level2` (a direct superclass of `Level3`) is directly annotated with `@ComposedAnno` (which is meta-annotated with `@Anno`) and `Level1` (a direct superclass of `@Level2`) is directly annotated with either `@Anno` or a composed annotation that is meta-annotated with `@Anno`, if the `@ComposedAnno` annotation is not declared as `@Inherited`, then any attributes declared via `@Anno` on `@ComposedAnno` (present on class `Level2`) will be _shadowed_ by those declared via `@Anno` on class `Level1`.\n\nThis behavior is very non-intuitive and would likely be considered a _bug_ by any developers who encounter it.\n\n---\n\n#### Concrete Example\n\nGiven...\n\n```java\n@Component(value = \"composed1\")\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@interface Composed1 {}\n\n@Component(value = \"composed2\")\n@Retention(RetentionPolicy.RUNTIME)\n@interface Composed2 {}\n\n@Composed1\nclass Level1 {}\n\n@Composed2\nclass Level2 extends Level1 {}\n\nclass Level3 extends Level2 {}\n```\n\nIf we execute the following unit test, one would likely expect that \"composed2\" should be found, since the immediate superclass is annotated with `@Composed2`; however, with the current implementation \"composed1\" will be found since `@Composed1` is declared as `@Inherited` and therefore _shadows_ `@Composed2`. As such, the test fails on the last line.\n\n```java\n@Test\npublic void findAnnotationFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {\n    Component component = AnnotationUtils.findAnnotation(Level3.class, Component.class);\n    assertNotNull(component);\n    assertEquals(\"composed2\", component.value());\n}\n```\n\n---\n\n#### Proposal\n\nRefactor the affected implementations of `AnnotationUtils` and `AnnotatedElementUtils` so that _more locally declared_ composed annotations are favored over inherited annotations and inherited composed annotations.\n\nThis can likely be achieved by using the `getDeclaredAnnotation()` and `getDeclaredAnnotations()` methods in `java.lang.Class` instead of the `getAnnotation()` and `getAnnotations()` which are currently being used in these utility classes.\n\nNote that `MetaAnnotationUtils` already uses `getDeclaredAnnotations()`.\n\n---\n\n#### Deliverables\n\n1. [x] Refactor `AnnotationUtils` to use `getDeclaredAnnotation()` and `getDeclaredAnnotations()` where appropriate.\n2. [ ] Refactor `AnnotatedElementUtils` to use `getDeclaredAnnotation()` and `getDeclaredAnnotations()` where appropriate.\n\n---\n\n**Affects:** 4.0 GA\n\n**Issue Links:**\n- #16221 Favor more locally declared composed annotations over inherited annotations (_**\"is depended on by\"**_)\n- #16219 Annotations on superclasses are detected by StandardAnnotationMetadata\n- #16960 Favor more locally declared composed annotations over interface annotations in AnnotationUtils\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/a2f1169e820c76df7f06f2b2b921b184b8775b45, https://github.com/spring-projects/spring-framework/commit/0f5a27c3545275bbd7c196124c51f6e66da6d164, https://github.com/spring-projects/spring-framework/commit/1d30bf83a0d6f303ce38526286b90172c3c596c6, https://github.com/spring-projects/spring-framework/commit/0637864b3909ab13727cb228258b778a265da8d9, https://github.com/spring-projects/spring-framework/commit/90b938aa8faf68d433dea19b4688eeac9d8a1416\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nResolved as described in the comments for [GitHub commit 0f5a27c](https://github.com/spring-projects/spring-framework/commit/0f5a27c3545275bbd7c196124c51f6e66da6d164):\n\n> **Favor 'local' annotations over inherited ones**\n> \n> Prior to this commit, the implementations of findAnnotation() in\n> AnnotationUtils and getAnnotationAttributes() in AnnotatedElementUtils\n> favored inherited annotations and inherited composed annotations over\n> composed annotations that are declared closer to the starting class\n> passed to these methods.\n> \n> This commit addresses this issue as follows:\n> \n> - Refactored AnnotationUtils to use getDeclaredAnnotation() and\n>   getDeclaredAnnotations() instead of getAnnotation() and\n>   getAnnotations() where appropriate.\n> \n> - AnnotatedElementUtils.doProcess() supports a traverseClassHierarchy\n>   flag to control whether the class hierarchy should be traversed,\n>   using getDeclaredAnnotations() instead of getAnnotations() if the\n>   flag is true.\n> \n> - Overhauled Javadoc in AnnotatedElementUtils.\n\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nReopening in light of the issues raised in #16219.\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nChanged subject to indicate that this issue only concerns itself with `AnnotationUtils`.\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nThe aforementioned changes have been partially reverted. See the comments in #16219 for details.\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nResolving as _Complete_ again.\n\nFurther work will be continued in #16221.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `AnnotationUtils` replaces a direct `getDeclaredAnnotation` check with a more sophisticated approach using `isAnnotationDeclaredLocally` and `getAnnotation`.  Critically, it now leverages a recursive `findAnnotation` method to search for the annotation on interfaces and superclasses.  This change likely aims to improve efficiency and correctness by prioritizing annotations declared directly on the class itself before traversing the inheritance hierarchy",
            "avg_logprobs": -0.22422077178955077
        }
    },
    {
        "commit_hash": "0720f9e9786a79503420a5c39f079f5d19aa8736",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicates.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (!(result.get(0) instanceof Separator)) {\n+\t\t\t\tif (result.isEmpty() || !(result.get(0) instanceof Separator)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix an eventual IndexOutOfBoundsException in RequestPredicates",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional check.  The original code checked if the first element of the `result` list was not a `Separator`.  The updated code adds a check for an empty `result` list before accessing the first element.  This prevents a `IndexOutOfBoundsException` if the list is empty.  In essence, the change adds a safety net for empty input lists",
            "avg_logprobs": -0.14482456598526391
        }
    },
    {
        "commit_hash": "0728e32e7f3b93e49dfc8c7af20b489b12b3e663",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/rowset/ResultSetWrappingSqlRowSet.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\tthis.columnLabelMap.put(rsmd.getColumnLabel(i), i);\n+\t\t\t\t\tString key = rsmd.getColumnLabel(i);\n+\t\t\t\t\t// Make sure to preserve first matching column for any given name,\n+\t\t\t\t\t// as defined in ResultSet's type-level javadoc (lines 81 to 83).\n+\t\t\t\t\tif (!this.columnLabelMap.containsKey(key)) {\n+\t\t\t\t\t\tthis.columnLabelMap.put(key, i);\n+\t\t\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ResultSetWrappingSqlRowSet preserves first matching column per name (as defined in ResultSet's javadoc)",
        "commit_body": "Issue: SPR-11786\n",
        "linked_issues": [
            {
                "issue_id": "16408",
                "issue_title": "JDBC findColumn gives wrong result in case of duplicate column labels [SPR-11786]",
                "issue_body": "**[Teun Hoogendoorn](https://jira.spring.io/secure/ViewProfile.jspa?name=th76)** opened **[SPR-11786](https://jira.spring.io/browse/SPR-11786?redirect=false)** and commented\n\nConsider the following query:\n\nTable foo1 contains 1 column named fooname.\nTable foo2 ALSO contains 1 column named fooname.\n\nSELECT * FROM foo1, foo2\n\n(result: fooname, fooname)\n\nfindColumn(\"fooname\") should return the FIRST and not the SECOND (LAST) index of fooname.\n\nThis bug is introduced in Spring JDBC since the implementation ResultSetWrappingSqlRowSet uses a HashMap.\n\nThe code should check for existence of the key in the map and not override the value if the key exists.\n\nSee: http://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html\nQUOTE: When a getter method is called with a column name and several columns have the same name, the value of the first matching column will be returned.\n\n\n\n---\n\n**Affects:** 3.2.8, 4.0.4\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/8a28645dd66ca080cf9294db0aa328b88d737c55, https://github.com/spring-projects/spring-framework/commit/0728e32e7f3b93e49dfc8c7af20b489b12b3e663, https://github.com/spring-projects/spring-framework/commit/3ae6c0f4011efee7c42473bd1807fab05afde089\n\n**Backported to:** [3.2.9](https://github.com/spring-projects/spring-framework/milestone/97?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis fix is available in the latest 3.2.9 and 4.0.5 snapshots now. Please give it a try and let us know whether it works for you...\n\nJuergen\n",
                    "**[Teun Hoogendoorn](https://jira.spring.io/secure/ViewProfile.jspa?name=th76)** commented\n\nI've tested with spring-jdbc-3.2.9.BUILD-20140515.132116-16.jar and it is working correctly now.\n\nThanks for the fast response!\n\nTeun Hoogendoorn\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how column labels are mapped to indices in `ResultSetWrappingSqlRowSet`.  Previously, a column label was directly mapped to its index regardless of potential duplicates.  The updated code now checks if a column label already exists in the map.  If it does *not* exist, the label is added to the map; otherwise, the existing mapping is preserved",
            "avg_logprobs": -0.17799655914306642
        }
    },
    {
        "commit_hash": "07a1aea9c73ef9859b7405c7c7d8e1905427e229",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (result instanceof Object[] array) {\n+\t\t\tif (result instanceof Object[] array && array.length > 1) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip array sort when the length of array not greater than 1",
        "commit_body": "Closes gh-30934\n",
        "linked_issues": [
            {
                "issue_id": "30934",
                "issue_title": "Skip array sort when the length of array not greater than 1",
                "issue_body": "Performance optimization(`org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveMultipleBeans`):\r\n\r\nFor the sorting condition of `Collection`  is  `result instanceof List<?> list && list.size() > 1`, when the size of collection isn't greater than 1, it will skip sorting.\r\n\r\nSimilarly, skip array sort when the length of array not greater than 1.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `6.0.x` and `main`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check `&& array.length > 1` to the `if` statement.  Previously, the code checked if `result` was an `Object[]`.  Now, it only proceeds if `result` is an `Object[]` *and* the array has more than one element.  This suggests a potential change in the expected behavior, likely to avoid issues with arrays containing only a single element",
            "avg_logprobs": -0.18092877214605158
        }
    },
    {
        "commit_hash": "085565a771270f7a124186e7691381534018dd03",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/vendor/SpringHibernateJpaPersistenceProvider.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.hibernate.bytecode.enhance.spi.EnhancementContext;\n+\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n+\t\t\t\t\t\tif (!NativeDetector.inNativeImage()) {\n+\t\t\t\t\t\t\tsuper.pushClassTransformer(enhancementContext);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip class transformer in PersistenceUnitInfoDescriptor for native images",
        "commit_body": "In order to restore native support with Hibernate 6.2, this\nchange updates the PersistenceUnitInfoDescriptor instance\ncreated by SpringHibernateJpaPersistenceProvider in order to\nskip the class transformer for native images.\n\nCloses gh-30492\n",
        "linked_issues": [
            {
                "issue_id": "30492",
                "issue_title": "Skip class transformer in `PersistenceUnitInfoDescriptor` for native images",
                "issue_body": "Due to [this change](https://github.com/hibernate/hibernate-orm/commit/800873c43d44bc954cef8f4abb11bfe4719570a8) in Hibernate 6.2, Bytebuddy class enhancement is now invoked via `SpringHibernateJpaPersistenceProvider` -> `PersistenceUnitInfoDescriptor` - > `EnhancingClassTransformerImpl` -> `BytecodeProviderInitiator.buildDefaultBytecodeProvider()`, breaking Hibernate integration when compiling to native images.\r\n\r\nThis change updates the `PersistenceUnitInfoDescriptor` instance created by `SpringHibernateJpaPersistenceProvider` in order to skip the class transformer with native.\r\n\r\nFootprint optimization will require completing #29549 is is outside of the scope of this change.",
                "issue_state": "closed",
                "issue_comment": [
                    "See also related issues:\r\n- https://github.com/oracle/graalvm-reachability-metadata/pull/286\r\n- https://github.com/spring-projects/spring-boot/issues/35423",
                    "Hi @sdeleuze if I use Spring Framework 6.0.10-SNAPSHOT should this issue be resolved? Or is there more to it?",
                    "I opened oracle/graalvm-reachability-metadata#297 a little while ago, as this fix on its own doesn't seem to fix the issue.",
                    "@edeandrea using Spring Framework 6.0.10-SNAPSHOT should be enough, provided the maven-native-plugin uses the latest available reachability metadata version (0.3.1 at the time of writing).\r\n\r\nSee my comment https://github.com/spring-projects/spring-boot/issues/35659#issuecomment-1566804157 for more details.",
                    "Thank you @davidbilge but that unfortunately didn't work.",
                    "> Thank you @davidbilge but that unfortunately didn't work.\r\n\r\nDid you try to use a specific version (0.3.1) of the reachability metadata in your pom.xml?\r\n\r\n",
                    "Yes I did. I opened https://github.com/oracle/graalvm-reachability-metadata/issues/297 for it.",
                    "We are going to release GraalVM metadata `0.3.2` and Native Build Tools `0.9.23` that contains all Hibernate 6.2 fixes."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a conditional check for `NativeDetector.inNativeImage()`.  If running in a native image environment, the `super.pushClassTransformer(enhancementContext)` call is skipped.  This suggests a performance optimization to avoid applying class transformers in native image scenarios, likely because they are unnecessary or less efficient in that context",
            "avg_logprobs": -0.18744230270385742
        }
    },
    {
        "commit_hash": "0933734fbb5dae4c523b3bc0fcfb30a927ddc209",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t * <p><b>Do not raise the number of concurrent consumers for a topic.</b>\n-\t * This would lead to concurrent consumption of the same message,\n-\t * which is hardly ever desirable.\n+\t * <p><b>Do not raise the number of concurrent consumers for a topic,\n+\t * unless vendor-specific setup measures clearly allow for it.</b>\n+\t * With regular setup, this would lead to concurrent consumption\n+\t * of the same message, which is hardly ever desirable.\n-\t@Override\n-\tprotected void validateConfiguration() {\n-\t\tsuper.validateConfiguration();\n-\t\tsynchronized (this.lifecycleMonitor) {\n-\t\t\tif (isSubscriptionDurable() && this.concurrentConsumers != 1) {\n-\t\t\t\tthrow new IllegalArgumentException(\"Only 1 concurrent consumer supported for durable subscription\");\n-\t\t\t}\n-\t\t}\n-\t}\n-",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DefaultMessageListenerContainer allows for concurrent subscription consumers on WebLogic/ActiveMQ",
        "commit_body": "Issue: SPR-10037\n",
        "linked_issues": [
            {
                "issue_id": "14671",
                "issue_title": "Concurrent Consumers Not Allowed for Durable Subscription [SPR-10037]",
                "issue_body": "**[Ales Bukovsky](https://jira.spring.io/secure/ViewProfile.jspa?name=alesbukovsky)** opened **[SPR-10037](https://jira.spring.io/browse/SPR-10037?redirect=false)** and commented\n\nWhile using DefaultMessageListenerContainer for durable subscription listener within Grails 2.1.1 application, the exception is thrown if number of concurrent consumers is increased above 1. This is described in documentation and makes sense in \"vanilla\" JMS configuration.\n\nMost JMS providers however account one way or another for high-availability solution where multiple listeners share the same subscription. For example: ActiveMQ provides concept of virtual destinations and Weblogic has sharable connection factory for this very purpose. Since the solution for shared access to a single subscription is in these cases provided by lower level (vendor-specific) implementation, concurrent consumer restrictions on teh container level effectively prevents the application from using it.\n\nThe simplest solution appears to be the container class extension that bypasses/consumes the corresponding exception. The problem is that a generic invalid argument error is being thrown and the only way to ensure it is the correct one is to actually parse exception message (which is not a good design).\n\nIt would be greatly appreciated if the container class actually provides a simple and clean way to suppress the concurrent consumer restriction should the developer explicitly wish so.\n\n\n---\n\n**Affects:** 3.1.2\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/4058f693e56d149c33f85b69a60d924e3275ff60, https://github.com/spring-projects/spring-framework/commit/0933734fbb5dae4c523b3bc0fcfb30a927ddc209\n\n**Backported to:** [3.1.4](https://github.com/spring-projects/spring-framework/milestone/83?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've simply lifted that restriction, not checking the currentConsumers setting against the subscriptionDurable flag anymore. This means it's up to the JMS provider to detect that case and throw a corresponding exception later when we're trying to create additional consumers.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the validation of `concurrentConsumers` for durable subscriptions.  Previously, it strictly enforced a single concurrent consumer for durable topics, throwing an exception if the value was not 1.  The updated code now allows for multiple concurrent consumers *only if* vendor-specific setup explicitly supports it.  The validation logic has been removed, and a more nuanced message explaining the rationale for the change has been added to the Javadoc",
            "avg_logprobs": -0.3075527572631836
        }
    },
    {
        "commit_hash": "09da10cc6c585995f4623793aa2b2f6a38b5284d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/ChannelSendOperator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t@Nullable\n+\t\tprivate Subscription subscription;\n+\n+\t\t\tthis.subscription = subscription;\n+\t\t\tSubscription subscription = this.subscription;\n+\t\t\tif (subscription != null) {\n+\t\t\t\tsubscription.cancel();\n+\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Propagate the cancel signal to the downstream",
        "commit_body": "Issue: SPR-17609\n",
        "linked_issues": [
            {
                "issue_id": "22141",
                "issue_title": "ChannelSendOperator does not propagate cancel signal to the server  [SPR-17609]",
                "issue_body": "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** opened **[SPR-17609](https://jira.spring.io/browse/SPR-17609?redirect=false)** and commented\n\nThis is a follow-up to #22038 in which writing with `Content-Length: 0` and `byte[0]` was causing hanging. The issue was fixed in 5.1.3 by using `response.setComplete()` instead of writing an empty byte array. However the underlying issue of hanging with `Content-Length: 0` and `byte[0]` remains.\n\nAfter further investigation, there is an issue in `ChanelSendOperator` in that it currently only cancels the upstream write `Publisher`. So in a case where a cancel happens after the first signal (onNext, onError, onComplete) is emitted, and therefore after the server write Subscriber is hooked in, in that scenario only the upstream write Publisher is notified to stop sending, but the server write Subscriber is not aware.\n\nIn addition to the sample in #22038 there is also a sample in https://github.com/reactor/reactor-netty/issues/518.\n\n---\n\n**Affects:** 5.1.3\n\n**Issue Links:**\n- #22038 HTTP GET from Chrome with WebFlux Rest Controller never completes\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/09da10cc6c585995f4623793aa2b2f6a38b5284d\n\n**Backported to:** [5.0.12](https://github.com/spring-projects/spring-framework/milestone/193?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a `subscription` field and ensures that any existing `subscription` is canceled before assigning a new one.  This change implements a proper cleanup mechanism for the `subscription` object, preventing resource leaks",
            "avg_logprobs": -0.2540948174216531
        }
    },
    {
        "commit_hash": "0a92d84778dcb03dd5bf2860f2d997d1db2687f4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/hibernate5/SessionFactoryUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tsession.close();\n+\t\t\t\tif (session.isOpen()) {\n+\t\t\t\t\tsession.close();\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Check open status before close call (aligned with EntityManagerFactoryUtils)",
        "commit_body": "Closes gh-27972\n",
        "linked_issues": [
            {
                "issue_id": "27972",
                "issue_title": "Inconsistent behaviour in spring-orm between EntityManagerFactoryUtils.closeEntityManager() and SessionFactoryUtils.closeSession()",
                "issue_body": "Whereas `EntityManagerFactoryUtils.closeEntityManager()` will check if EntityManager is open before trying to close it, `SessionFactoryUtils.closeSession()` doesn't check if session is open.\r\n\r\nAs a consequence, if EntityManager is closed when entering `closeEntityManager()`, nothing will happen,\r\nwhereas if Session is closed when entering `closeSession()`, a log ERROR will be generated (because of \"org.hibernate.SessionException: Session was already closed\") (tested with Spring 5.2 + Hibernate 5.1).\r\n\r\nMaybe we could have a common behaviour between both classes ?\r\n\r\nSee related commit for EntityManagerFactoryUtils : https://github.com/spring-projects/spring-framework/commit/928f5423af2f64ca9578801adaa8c9612500b952\r\n\r\n---\r\n\r\nContext : \r\n- module spring-orm\r\n  - class `org.springframework.orm.jpa.EntityManagerFactoryUtils`\r\n  - class `org.springframework.orm.hibernate5.SessionFactoryUtils`",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks @jhoeller \ud83d\udc4d "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check (`if (session.isOpen())`) before closing the session.  This prevents a `Session` from being closed if it's already closed, avoiding potential exceptions.  The original `session.close()` was replaced with a safer, more robust approach",
            "avg_logprobs": -0.19178214566460972
        }
    },
    {
        "commit_hash": "0a94dce41dd032d5f6c153863c52b2dcd1dd0e91",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import java.util.List;\n+import java.util.Collection;\n+import java.util.Map;\n-\t\t\t\t\t\tif (merged.stream().anyMatch(VALID_PREDICATE) && List.class.isAssignableFrom(type)) {\n+\t\t\t\t\t\tif (merged.stream().anyMatch(VALID_PREDICATE) &&\n+\t\t\t\t\t\t\t\t(Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type))) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improve HandlerMethod check when method validation applies",
        "commit_body": "Method validation needs to be used for a container such as a List or\nMap, but until now we were only checking for a List container.\nMoreover, in gh-31530 we improved method validation to also cover\nany Collection.\n\nThis change aligns with HandlerMethod check for when method validation\napplies with the underlying ability of method validation.\n",
        "linked_issues": [
            {
                "issue_id": "31530",
                "issue_title": "Improve method validation support for errors on elements within a container",
                "issue_body": "Expands on the validation behaviour added as part of the work for https://github.com/spring-projects/spring-framework/issues/30645, motivated by an issue with Sets containing an object with nested Lists, introduced in https://github.com/spring-projects/spring-framework/issues/29825. The adapter should now better handle nested objects for types beyond those of List or Map.",
                "issue_state": "closed",
                "issue_comment": [
                    "For additional context, see https://github.com/spring-projects/spring-framework/issues/30645#issuecomment-1783969150. In short, currently we support `List` and `Map` containers. The goal is to also support arrays and sets, and other container types for which there is a registered Jakarta `ValueExtractor`.",
                    "Thanks for the report and changes. Element container handling is not only improved but also simpler."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the condition checking if a `merged` list (presumably a list of something) matches a `VALID_PREDICATE` and if the type (`type`) is a `List`.  It now also checks if the type is a `Collection` or a `Map`.  This broadens the types that satisfy the condition, allowing for handling of `Collection` and `Map` objects in addition to `List` objects",
            "avg_logprobs": -0.2242287317911784
        }
    },
    {
        "commit_hash": "0b1639d9635d31adfb6e6280776decf5fc91ec9f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * Set the fetch size for this JdbcTemplate. This is important for processing\n-\t * large result sets: Setting this higher than the default value will increase\n-\t * processing speed at the cost of memory consumption; setting this lower can\n-\t * avoid transferring row data that will never be read by the application.\n-\t * <p>Default is -1, indicating to use the JDBC driver's default\n-\t * (i.e. to not pass a specific fetch size setting on the driver).\n+\t * Set the fetch size for this JdbcTemplate. This is important for processing large\n+\t * result sets: Setting this higher than the default value will increase processing\n+\t * speed at the cost of memory consumption; setting this lower can avoid transferring\n+\t * row data that will never be read by the application.\n+\t * <p>Default is -1, indicating to use the JDBC driver's default configuration\n+\t * (i.e. to not pass a specific fetch size setting on to the driver).\n+\t * <p>Note: As of 4.3, negative values other than -1 will get passed on to the\n+\t * driver, since e.g. MySQL supports special behavior for {@code Integer.MIN_VALUE}.\n-\t * Set the maximum number of rows for this JdbcTemplate. This is important\n-\t * for processing subsets of large result sets, avoiding to read and hold\n-\t * the entire result set in the database or in the JDBC driver if we're\n-\t * never interested in the entire result in the first place (for example,\n-\t * when performing searches that might return a large number of matches).\n-\t * <p>Default is -1, indicating to use the JDBC driver's default\n-\t * (i.e. to not pass a specific max rows setting on the driver).\n+\t * Set the maximum number of rows for this JdbcTemplate. This is important for\n+\t * processing subsets of large result sets, avoiding to read and hold the entire\n+\t * result set in the database or in the JDBC driver if we're never interested in\n+\t * the entire result in the first place (for example, when performing searches\n+\t * that might return a large number of matches).\n+\t * <p>Default is -1, indicating to use the JDBC driver's default configuration\n+\t * (i.e. to not pass a specific max rows setting on to the driver).\n+\t * <p>Note: As of 4.3, negative values other than -1 will get passed on to the\n+\t * driver, in sync with {@link #setFetchSize}'s support for special MySQL values.\n-\t\tif (fetchSize >= 0) {\n+\t\tif (fetchSize != -1) {\n-\t\tif (maxRows >= 0) {\n+\t\tif (maxRows != -1) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "JdbcTemplate passes negative values other than -1 on to the driver (for MySQL's special values)",
        "commit_body": "Issue: SPR-14028\n",
        "linked_issues": [
            {
                "issue_id": "18600",
                "issue_title": "Adding ability to read result sets row-by-row for MySql driver [SPR-14028]",
                "issue_body": "**[Uladzimir Zhuraulevich](https://jira.spring.io/secure/ViewProfile.jspa?name=zhurlik)** opened **[SPR-14028](https://jira.spring.io/browse/SPR-14028?redirect=false)** and commented\n\nIn org.springframework.jdbc.core.JdbcTemplate:\n\n> protected void applyStatementSettings(Statement stmt) throws SQLException {\n> int fetchSize = getFetchSize();\n> if (fetchSize >= 0) {\n> stmt.setFetchSize(fetchSize);\n> }\n> int maxRows = getMaxRows();\n> if (maxRows >= 0) {\n> stmt.setMaxRows(maxRows);\n> }\n> DataSourceUtils.applyTimeout(stmt, getDataSource(), getQueryTimeout());\n> }\n\nThere is no ability to set streaming mode for fetching row-by-row.\nLook at ResultSet here http://dev.mysql.com/doc/connector-j/en/connector-j-reference-implementation-notes.html\n\n\n---\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/0b1639d9635d31adfb6e6280776decf5fc91ec9f\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs of 4.3, `JdbcTemplate` passes negative values other than -1 on to the driver. -1 is defined to have special semantics in `JdbcTemplate` itself, namely using the JDBC driver's own configuration (not setting any specific value on our end).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change clarifies the behavior of `fetchSize` and `maxRows` properties in `JdbcTemplate`.  The most significant change is the addition of a note explaining that, starting with Spring 4.3, negative values other than -1 for `fetchSize` and `maxRows` will be passed to the JDBC driver.  This is consistent with MySQL's support for specific negative values.\\n\\nThe code also refactors the documentation to be more concise and consistent in style",
            "avg_logprobs": -0.23413738250732422
        }
    },
    {
        "commit_hash": "0b580d194d2390c4cb860f337e146b90ba16c6f2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBean.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\t\tthrow new PersistenceException(message + \"; nested exception is \" + causeString, cause);\n+\t\t\t\t\t\tex = new PersistenceException(message + \"; nested exception is \" + causeString, cause);\n+\t\t\tif (logger.isErrorEnabled()) {\n+\t\t\t\tlogger.error(\"Failed to initialize JPA EntityManagerFactory: \" + ex.getMessage());\n+\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Early log entry for async EntityManagerFactory initialization failure",
        "commit_body": "Closes gh-26093\n",
        "linked_issues": [
            {
                "issue_id": "26093",
                "issue_title": "EntityManagerFactory startup failure in deferred mode is only available on first use",
                "issue_body": "Hello everyone!\r\nRecently I observed a strange behavior while starting a simple project with Spring-boot + Hibernate that confuse me a lot. \r\nI wrote a simple JPA entity and tried to start the project, but no entity wrote to a database. After long time searching why I accidentally had seen that the app after around 1-2 minute of correct working shut down with exit code 0 and the answer of my question appeared in a console:  **nested exception is org.hibernate.MappingException: Could not instantiate id generator [entity-name=null]**\r\nBut why the app keeps silent before that moment and doesn`t show me any information about entity creation process? I think this is not trivial and confusing.\r\n\r\nMy application.properties for reproduction\r\n\r\n```\r\nspring.session.store-type=jdbc\r\nspring.datasource.driver-class-name=org.postgresql.Driver\r\nspring.jpa.database-platform=org.hibernate.dialect.PostgreSQL10Dialect\r\nspring.datasource.url= jdbc:postgresql://localhost:5432/***\r\nspring.datasource.username=***\r\nspring.datasource.password=***\r\nspring.jpa.properties.hibernate.default_schema=demo\r\nspring.jpa.generate-ddl=true\r\nspring.jpa.hibernate.ddl-auto=create\r\n```\r\n\r\nAnd a simple JPA entity with error:\r\n```\r\n@Entity\r\npublic class Item {\r\n    @Id\r\n    public Long id;\r\n\r\n    @ElementCollection\r\n    @CollectionTable(name = \"IMAGE\")\r\n    @Column(name = \"FILENAME\")\r\n    @CollectionId(\r\n            columns = @Column(name = \"IMAGE_ID\"),\r\n            type = @Type(type = \"long\"),\r\n            generator = \"SEQUENCE\" <<<<< NOT CORRECT\r\n    )\r\n    protected List<String> images = new ArrayList<>();\r\n}\r\n```\r\nNow if you try to start a project then you will not see any error message for almost a one or two minutes and you doesn`t get what the problem. When you fix the error the entity writes to DB without problems\r\n\r\nSrping-boot version: v2.3.5.RELEASE",
                "issue_state": "closed",
                "issue_comment": [
                    ">  But why the app keeps silent before that moment and doesn`t show me any information about entity creation process?\r\n\r\nI don't know but given what you've shared and the exception it is also unclear why you think this is a problem in Spring Boot. If you want support, please take the time to share a small sample that reproduces the problem. You can do so by attaching a zip to this issue or share a link to a GitHub repository.",
                    "@snicoll \r\nBut it`s almost all that you need to reproduce. I am attaching a zip with all project to this message:\r\n[simple-demo-app.zip](https://github.com/spring-projects/spring-boot/files/5536737/simple-demo-app.zip)",
                    "> But it`s almost all that you need to reproduce\r\n\r\nSorry but guessing what the missing pieces are can lead to wasted efforts. I can reproduce the problem and it's yet another instance of a deadlock due to deferred bootstrap. \r\n\r\nYou can workaround the problem for now by adding the following to your project's configuration:\r\n\r\n```\r\nspring.data.jpa.repositories.bootstrap-mode=default\r\n```",
                    "So this isn't a deadlock as I suspected initially. If you're not using deferred mode for JPA, the JPA instructor is initialised in the main thread and leads to the following:\r\n\r\n```\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.MappingException: Could not instantiate id generator [entity-name=null]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1794) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:516) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:324) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:322) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1109) ~[spring-context-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:869) ~[spring-context-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:551) ~[spring-context-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:143) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:405) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1237) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) ~[spring-boot-2.3.6.RELEASE.jar:2.3.6.RELEASE]\r\n\tat com.example.demo.DemoApplication.main(DemoApplication.java:14) ~[classes/:na]\r\nCaused by: javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.MappingException: Could not instantiate id generator [entity-name=null]\r\n\tat org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:403) ~[spring-orm-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:378) ~[spring-orm-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1853) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1790) ~[spring-beans-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\t... 17 common frames omitted\r\nCaused by: org.hibernate.MappingException: Could not instantiate id generator [entity-name=null]\r\n\tat org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.createIdentifierGenerator(DefaultIdentifierGeneratorFactory.java:124) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.mapping.SimpleValue.createIdentifierGenerator(SimpleValue.java:355) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.persister.collection.AbstractCollectionPersister.<init>(AbstractCollectionPersister.java:455) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.persister.collection.BasicCollectionPersister.<init>(BasicCollectionPersister.java:59) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:na]\r\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490) ~[na:na]\r\n\tat org.hibernate.persister.internal.PersisterFactoryImpl.createCollectionPersister(PersisterFactoryImpl.java:152) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.persister.internal.PersisterFactoryImpl.createCollectionPersister(PersisterFactoryImpl.java:140) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.metamodel.internal.MetamodelImpl.initialize(MetamodelImpl.java:225) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:301) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:469) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:1259) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\tat org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391) ~[spring-orm-5.2.11.RELEASE.jar:5.2.11.RELEASE]\r\n\t... 21 common frames omitted\r\nCaused by: org.hibernate.MappingException: no entity name\r\n\tat org.hibernate.id.Assigned.configure(Assigned.java:45) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\tat org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.createIdentifierGenerator(DefaultIdentifierGeneratorFactory.java:118) ~[hibernate-core-5.4.23.Final.jar:5.4.23.Final]\r\n\t... 37 common frames omitted\r\n```\r\n\r\nIt seems that when using deferred mode, the bean creating fails in the background and is not reported to the main thread. @jhoeller, does that ring a bell. \r\n\r\nIt is possible to make this application fail by injecting the `EntityManager` anywhere, for instance:\r\n\r\n```\r\n@Bean\r\npublic ApplicationRunner useEntityManager(EntityManager entityManager) {\r\n\treturn args -> entityManager.contains(\"test\");\r\n}\r\n```\r\n\r\n",
                    "@DredderGun this sample app doesn't interact with the `EntityManagerFactory` and that doesn't sound very realistic. On first use you'd get the exception as I've indicated in my previous comment.\r\n\r\nThat said, there is a case to log this sooner. I am now going to transfer this issue to the Spring Framework issue tracker as there's nothing we can do in Spring Boot about this. Thanks for the report."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the exception handling when initializing the JPA EntityManagerFactory.  Instead of directly throwing the `PersistenceException`, it now creates a `PersistenceException` object and logs an error message if the logger is enabled. This allows for more informative logging of the failure without immediately terminating the application",
            "avg_logprobs": -0.1838217576344808
        }
    },
    {
        "commit_hash": "0bd923b0a77f5da1d98018dc0c1301a1242e5f56",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/aot/hint/ExecutableHint.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.util.Assert;\n-\t * @return the modes\n+\t * @return the mode\n-\t\t\tif (this.mode == null || !this.mode.includes(mode)) {\n+\t\t\tAssert.notNull(mode, \"'mode' must not be null\");\n+\t\t\tif ((this.mode == null || !this.mode.includes(mode))) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check and a validation for the `mode` parameter.  Previously, the method could accept a null `mode` value.  Now, `Assert.notNull(mode, \"\\'mode\\' must not be null\");` enforces that `mode` cannot be null, improving robustness.  The conditional logic `if (this.mode == null || !this.mode.includes(mode))` remains, but now the null case is handled explicitly by the assertion.",
            "avg_logprobs": -0.21899183273315428
        }
    },
    {
        "commit_hash": "0c2b787cb5e7159ec40f6e5d9bb33a063e866b2d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/asm/MethodWriter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-            if (code.length > 65536) {\n+            if (code.length > 65535) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ASM fix #317578",
        "commit_body": "http://forge.ow2.org/tracker/?func=detail&aid=317578&group_id=23&atid=100023\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change reduces the threshold for the `code.length` check in a conditional statement from 65536 to 65535.  This likely corrects a potential bug or improves efficiency by adjusting the maximum allowed code length.  The original condition was likely too permissive, allowing code exceeding the maximum size that can be represented by a 16-bit unsigned integer",
            "avg_logprobs": -0.35416736602783205
        }
    },
    {
        "commit_hash": "0cc877ad0fb6dd5775b21b56fc773c577fd2d489",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (executorToCheck.get() instanceof ReflectiveMethodExecutor) {\n+\t\tif (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "MethodReference accesses cached executor in a thread-safe manner",
        "commit_body": "Issue: SPR-12269\n",
        "linked_issues": [
            {
                "issue_id": "16874",
                "issue_title": "MethodReference isn't thread-safe [SPR-12269]",
                "issue_body": "**[Bryan Turner](https://jira.spring.io/secure/ViewProfile.jspa?name=bturner)** opened **[SPR-12269](https://jira.spring.io/browse/SPR-12269?redirect=false)** and commented\n\nIn `MethodReference`, `cachedExecutor` is declared `volatile`. That implies that this class is expected to be used by multiple threads, but almost none of the methods that access that field do so safely.\n\nWe're ending up in this method due to Spring Security using SpEL expressions for permission checks. Under light load, the system works fine. Under heavier load, we're seeing `NullPointerException` stacks that are topped like this:\n\n```\n2014-09-27 21:01:04,386 ERROR [threadpool:thread-28592]  c.a.s.i.c.StateTransferringExecutor Error while processing asynchronous task\njava.lang.NullPointerException: null\n        at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:86) ~[MethodReference.class:4.1.0.RELEASE]\n        at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:126) ~[SpelNodeImpl.class:4.1.0.RELEASE]\n        at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:296) ~[SpelExpression.class:4.1.0.RELEASE]\n```\n\nA look at `MethodReference` on line 86 shows:\n\n```\nTypedValue result = getValueInternal(evaluationContext, value, targetType, arguments);\nif (cachedExecutor.get() instanceof ReflectiveMethodExecutor) {\n     ReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) cachedExecutor.get();\n```\n\nThis has 2 problems:\n1. There's no `null` check, but there are multiple other codepaths that can set `cachedExecutor` to `null`\n2. Even if there was, a la `CachedMethodExecutor.isCompilable`, they won't actually _protect_ anything; they're just a race condition.\n\nSince `cachedExecutor` is `volatile`, all of the code that uses it, if they need to touch it multiple times, needs to first assign it to a local variable to freeze its state and then access the local variable instead. Otherwise it will always be susceptible to race conditions. This appears to be missing in:\n* `MethodReference.getValueInternal(ExpressionState)`\n* `MethodValueRef.getValue()`\n* `CachedMethodExecutor.isCompilable()`\n* `CachedMethodExecutor.generateCode()` (This method only touches `cachedExecutor` once, but that's only because it's not `null` checking)\n\n`MethodReference.getCachedExecutor` has exactly the type of code it seems like every method should have:\n\n```\nCachedMethodExecutor executorToCheck = this.cachedExecutor;\nif (executorToCheck != null && executorToCheck.isSuitable(value, target, argumentTypes)) {\n```\n\n\n\n---\n\n**Affects:** 4.1 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/0cc877ad0fb6dd5775b21b56fc773c577fd2d489, https://github.com/spring-projects/spring-framework/commit/c508a70c153c4809bd68071c0fff8fe596b8d918\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch - revised for 4.1.1 now. Please give the upcoming 4.1.1 snapshot a try if you have the chance...\n\nJuergen\n",
                    "**[Bryan Turner](https://jira.spring.io/secure/ViewProfile.jspa?name=bturner)** commented\n\nJuergen,\n\nThanks for the remarkably quick turnaround! I really appreciate it.\n\nIt looks like the new code in `updateExitTypeDescriptor` still isn't quite right, though:\n\n```\nprivate void updateExitTypeDescriptor() {\n    CachedMethodExecutor executorToCheck = this.cachedExecutor;\n    if (executorToCheck.get() instanceof ReflectiveMethodExecutor) {\n        Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();\n        this.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n    }\n}\n```\n\nIt seems like this needs a `executorToCheck != null` before the `executorToCheck.get()`.\n\nThanks again!\nBryan Turner\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch - fixed now!\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for `executorToCheck` before checking if it's an instance of `ReflectiveMethodExecutor`.  This prevents a `NullPointerException` if `executorToCheck` is null",
            "avg_logprobs": -0.07764638856399891
        }
    },
    {
        "commit_hash": "0d4ef4eafe7031781707f296af755387f30bcf88",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/config/DeprecatedBeanWarner.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (StringUtils.hasLength(resourceDescription)) {\n+\t\tif (StringUtils.hasText(resourceDescription)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Omit empty resource description in DeprecatedBeanWarner's log message",
        "commit_body": "Closes gh-32647\n",
        "linked_issues": [
            {
                "issue_id": "32647",
                "issue_title": "Omit empty resource description in `DeprecatedBeanWarner`'s log message",
                "issue_body": "In this context, the hasText() method seems more appropriate. This is because considering cases where the resourceDescription string contains only whitespace ensures clearer logging, as it accounts for scenarios where the string is not empty but consists solely of whitespace characters.",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `main`.\r\n\r\nThanks",
                    "> This has been merged into `main`.\r\n> \r\n> Thanks\r\n\r\nThanks! @sbrannen "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `StringUtils.hasLength(resourceDescription)` with `StringUtils.hasText(resourceDescription)` in the `DeprecatedBeanWarner` class's conditional statement.  This likely alters the condition under which the code block following the `if` statement is executed.  `hasText` checks for non-null and non-empty strings, while `hasLength` only checks for non-null and non-empty strings",
            "avg_logprobs": -0.15346057891845702
        }
    },
    {
        "commit_hash": "0eb73c130c4006b631edb6df6adebe1330fc07a7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context-indexer/src/main/java/org/springframework/context/index/processor/TypeHelper.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (type instanceof DeclaredType) {\n-\t\t\tDeclaredType declaredType = (DeclaredType) type;\n+\t\tif (type instanceof DeclaredType declaredType) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply \"instanceof pattern matching\" Eclipse clean-up in spring-context-indexer",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the explicit cast `(DeclaredType) type` with a more concise and type-safe `instanceof` check combined with a variable declaration.  This leverages Java 16's pattern matching feature, improving code readability and reducing the potential for `ClassCastException` errors",
            "avg_logprobs": -0.25839275610251505
        }
    },
    {
        "commit_hash": "0ef29b204b94ab2aec9333338a2035a11c8d81fb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/GenericBeanDefinition.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\treturn \"Generic bean: \" + super.toString();\n+\t\tStringBuilder sb = new StringBuilder(\"Generic bean\");\n+\t\tif (this.parentName != null) {\n+\t\t\tsb.append(\" with parent '\").append(this.parentName).append(\"'\");\n+\t\t}\n+\t\tsb.append(\": \").append(super.toString());\n+\t\treturn sb.toString();",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "GenericBeanDefinition's toString() takes parent definition into account",
        "commit_body": "Issue: SPR-9671\n",
        "linked_issues": [
            {
                "issue_id": "14305",
                "issue_title": "Overriding bean definition message does not take parent definition into account [SPR-9671]",
                "issue_body": "**[Radim Kolar](https://jira.spring.io/secure/ViewProfile.jspa?name=hsn)** opened **[SPR-9671](https://jira.spring.io/browse/SPR-9671?redirect=false)** and commented\n\nIt seems like this message contains just bean definition values, not real values merged with parent bean definition. It would be more useful if parent bean definition will be merged because for example lazyInit will be different.\n\n2012-08-07 13:51:39,096 INFO [main] org.springframework.beans.factory.support.DefaultListableBeanFactory: Overriding bean definition for bean 'pluginmanager': replacing [Generic bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [nutch/conf/common/pluginmanager.xml]] with [Generic bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in class path resource [nutch/conf/fetch/pluginmanager.xml]]\n\n\n---\n\n**Affects:** 3.1.2\n\n**Attachments:**\n- [pluginmanager.xml](https://jira.spring.io/secure/attachment/20146/pluginmanager.xml) (_594 bytes_)\n- [pluginmanager.xml](https://jira.spring.io/secure/attachment/20145/pluginmanager.xml) (_469 bytes_)\n- [pluginmanager-skeleton.xml](https://jira.spring.io/secure/attachment/20147/pluginmanager-skeleton.xml) (_694 bytes_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/b13c5b237897ba2e77a9d9aa90b28d12fff89e5f, https://github.com/spring-projects/spring-framework/commit/0ef29b204b94ab2aec9333338a2035a11c8d81fb, https://github.com/spring-projects/spring-framework/commit/bed739ce925d6fd88b5fab55403d523d3a3bc53e\n\n**Backported to:** [3.2.9](https://github.com/spring-projects/spring-framework/milestone/97?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAt that point of processing, bean definitions aren't being merged yet, and I would be odd to do so just for logging purposes. However, you do have a point that the parent bean isn't even mentioned in that log output: As a consequence, I've revised GenericBeanDefinition's toString() implementation correspondingly, being similar to ChildBeanDefinition's output now.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `toString()` method to provide more informative output for `GenericBeanDefinition` objects.  The original simply appended \"Generic bean\" to the result of the parent\\'s `toString()`.  The updated version now includes the parent bean\\'s name if available, prepending it with \"with parent \\'\" and closing the parent name with \"\\'\". This enhancement improves the readability and context of the `toString()` output, especially when debugging or inspecting bean definitions with parent relationships",
            "avg_logprobs": -0.2819552758727411
        }
    },
    {
        "commit_hash": "0f36569d75b814a43b081d5a8036534fc1090d62",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/config/FreeMarkerConfigurerBeanDefinitionParser.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tif (locations.isEmpty()) {\n-\t\t\t\tlocations.add(\"/WEB-INF/\");\n-\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove dead fallback code",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a default location (\"/WEB-INF/\") to the `locations` list if it\\'s empty.  This ensures a default location is always available for FreeMarker templates, preventing potential errors if no explicit locations are provided",
            "avg_logprobs": -0.18132532119750977
        }
    },
    {
        "commit_hash": "0f70ac74cd07228bcf67db925b1c01c6b17fc092",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/server/standard/AbstractTyrusRequestUpgradeStrategy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (constructor.getParameterCount() == 9) {\n+\t\t\t\tif (constructor.getParameterTypes().length == 9) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish",
        "commit_body": "Constructor.getParameterCount is JDK8+ only!\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `constructor.getParameterCount()` with `constructor.getParameterTypes().length` in the `AbstractTyrusRequestUpgradeStrategy` class.  This change likely addresses a potential issue with the previous method of counting parameters, which may have been relying on the *number* of parameters rather than the *types* of parameters.  The new method explicitly checks the length of the `ParameterTypes` array, which is a more robust approach to determining the number of parameters in a constructor",
            "avg_logprobs": -0.2913068771362305
        }
    },
    {
        "commit_hash": "10838a636fbbd4a95ac3652bc7209e98c6a11f6c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/multipart/support/StandardMultipartHttpServletRequest.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tif (msg != null && msg.contains(\"size\") && msg.contains(\"exceed\")) {\n-\t\t\tthrow new MaxUploadSizeExceededException(-1, ex);\n+\t\tif (msg != null) {\n+\t\t\tmsg = msg.toLowerCase();\n+\t\t\tif (msg.contains(\"size\") && msg.contains(\"exceed\")) {\n+\t\t\t\tthrow new MaxUploadSizeExceededException(-1, ex);\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Correctly identify MaxUploadSizeExceededException in StandardMultipartHttpServletRequest",
        "commit_body": "This commit correctly identifies MaxUploadSizeExceededException in\nStandardMultipartHttpServletRequest by converting keywords in the\nexception message to lowercase before checking for their presence, for\ncompatibility with Jetty 9.4.x.\n\nCloses gh-28759\n",
        "linked_issues": [
            {
                "issue_id": "28759",
                "issue_title": "Correctly identify MaxUploadSizeExceededException through keywords in message from Jetty 9.4.x",
                "issue_body": "MaxUploadSizeExceededException is recognized based on the exception message containing the words \"size\" and \"exceed\". Jetty server throws a message  [\"Request exceeds maxRequestSize...\".](https://github.com/eclipse/jetty.project/blob/064682b4ce57282e49a80a64b6d7a7a66fb47b28/jetty-util/src/main/java/org/eclipse/jetty/util/MultiPartInputStreamParser.java#L641)  Shouldn't such message also be treated as a MaxUploadSizeExceededException? \r\n\r\nThe proposed change addresses the issue regarding handling errors for too large file uploads when using the Jetty 9.4.x server. Now it is possible that MultipartException is thrown instead of MaxUploadSizeExceededException when the file exceeds the size limit. ",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `5.3.x` and `main`.\r\n\r\nThanks, and congratulations on submitting your first PR to the Spring Framework! \ud83d\udc4d "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of the `msg` string before checking for \"size\" and \"exceed\" keywords.  The original code directly checked `msg` for the keywords.  The updated code now converts `msg` to lowercase using `msg.toLowerCase()` before the checks.  This ensures case-insensitive matching.  The overall effect is to make the exception handling more robust by handling potential variations in error messages",
            "avg_logprobs": -0.23900906793002424
        }
    },
    {
        "commit_hash": "1222ca38fb46a5c461fa41d2d4383469d10a2ede",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/client/RestTemplate.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tthis.messageConverters.clear();\n-\t\tthis.messageConverters.addAll(messageConverters);\n+\t\t// Take getMessageConverters() List as-is when passed in here\n+\t\tif (this.messageConverters != messageConverters) {\n+\t\t\tthis.messageConverters.clear();\n+\t\t\tthis.messageConverters.addAll(messageConverters);\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "RestTemplate accepts getMessageConverters() List on setMessageConverters again",
        "commit_body": "Issue: SPR-11962\n",
        "linked_issues": [
            {
                "issue_id": "16578",
                "issue_title": "Backward compatibility issue in RestTemplate's messageConverters after SPR-11351 [SPR-11962]",
                "issue_body": "**[Boaz](https://jira.spring.io/secure/ViewProfile.jspa?name=boaz)** opened **[SPR-11962](https://jira.spring.io/browse/SPR-11962?redirect=false)** and commented\n\nHi,\n\nWe've recently upgraded our Spring version from 3.2.6 to 3.2.9 and we've encountered a backwards compatibility issue.\nUsually we use `RestTemplate` with it's default set of `messageConverters`, but in some places we add custom message converters to the existing collection of message converters, it looks as follows:\n\n```\nRestTemplate restTemplate = new RestTemplate();\nList<HttpMessageConverter<?>> converters = restTemplate.getMessageConverters();\nconverters.add(new SomeCustomMadeConverter());\nrestTemplate.setMessageConverters(converters);\n```\n\nIn version 3.2.9 (after merging the fix for #15976in commit 425e5a066e3769cc304ce6cd34971a6c38b9a4bb) the `setMessageConverters` method changed from this:\n\n```\nthis.messageConverters = messageConverters;\n```\n\nto this:\n\n```\nthis.messageConverters.clear();\nthis.messageConverters.addAll(messageConverters);\n```\n\nCausing us to loose all the converters instead of adding one and, of course -\n\n```\nIllegalArgumentException: 'messageConverters' must not be empty\n```\n\nWe did an innocent mistake and expected to get from the `getMessageConverters` method a copy of the list (and not have a reference to the inner works of the `RestTemplate`) without consulting the source code.\nIt's clear that other developers might have directly added to that list without calling `setMessageConverters` afterwards, so some flows won't be backward compatible. But I do think that returning a copy of a list in `getMessageConverters` is better then returning the list itself, especially since spring does `this.messageConverters.clear();` in the set.\n\n---\n\n**Affects:** 3.2.9, 4.0.5\n\n**Issue Links:**\n- #15976 Provide alternative RestTemplate constructor to avoid default MessageConverter creation\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/60d3a7f3002757b07174ac6ca2ec12f5c30bc58b, https://github.com/spring-projects/spring-framework/commit/a45d49c8572aca6c5f49d606635897472b8fbbf9, https://github.com/spring-projects/spring-framework/commit/1222ca38fb46a5c461fa41d2d4383469d10a2ede\n\n**Backported to:** [3.2.10](https://github.com/spring-projects/spring-framework/milestone/98?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nRestTemplate accepts the `getMessageConverters()` List on `setMessageConverters` again, simply by checking whether the incoming List reference is identical to the internal one. That should restore backwards compatibility with all previously working scenarios.\n\nJuergen\n",
                    "**[Boaz](https://jira.spring.io/secure/ViewProfile.jspa?name=boaz)** commented\n\nYou're right of course, thanks for the quick fix!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change in `RestTemplate.java` modifies how message converters are set.  Previously, the `messageConverters` list was always cleared and replaced with the provided list.  The updated code now checks if the provided `messageConverters` list is different from the current `messageConverters` list.  If they are different, the existing list is cleared and the new list is added; otherwise, the existing list is left unchanged",
            "avg_logprobs": -0.19142026901245118
        }
    },
    {
        "commit_hash": "1273c90a645a4fcc79719f14b4dc500106dfac2b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "- * {@code <task:annotation-driven>} XML element, and also by the @{@link EnableScheduling}\n- * annotation.\n+ * {@code <task:annotation-driven>} XML element, and also by the\n+ * @{@link EnableScheduling} annotation.\n- * <p>Auto-detects any {@link SchedulingConfigurer} instances in the container,\n- * allowing for customization of the scheduler to be used or for fine-grained control\n- * over task registration (e.g. registration of {@link Trigger} tasks.\n+ * <p>Autodetects any {@link SchedulingConfigurer} instances in the container,\n+ * allowing for customization of the scheduler to be used or for fine-grained\n+ * control over task registration (e.g. registration of {@link Trigger} tasks.\n-\t\tif (!this.nonAnnotatedClasses.contains(bean.getClass())) {\n+\t\tClass<?> targetClass = AopUtils.getTargetClass(bean);\n+\t\tif (!this.nonAnnotatedClasses.contains(targetClass)) {\n-\t\t\tClass<?> targetClass = AopUtils.getTargetClass(bean);\n-\t\t\t\tthis.nonAnnotatedClasses.add(bean.getClass());\n+\t\t\t\tthis.nonAnnotatedClasses.add(targetClass);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ScheduledAnnotationBeanPostProcessor uses target class as cache key in case of proxy",
        "commit_body": "Issue: SPR-12709\n",
        "linked_issues": [
            {
                "issue_id": "17306",
                "issue_title": "@Scheduled no longer works in case of multiple proxied target classes implementing the same interface [SPR-12709]",
                "issue_body": "**[Trent Summerfield](https://jira.spring.io/secure/ViewProfile.jspa?name=tsummerfield)** opened **[SPR-12709](https://jira.spring.io/browse/SPR-12709?redirect=false)** and commented\n\nWe had a number of `@Scheduled` tasks stop firing after upgrading spring 3.2.x. I have tracked down the problem to changes introduced by #16803\n\nWe have a point cut set as such\n\n```java\n@Pointcut(\"execution(* com.example.Processor.process())\")}}\n```\n\nwhere Processor is a simple interface\n\n```java\npublic interface Processor {\n    void process();\n}\n```\n\nThe implementing class looks like\n\n```java\n@Component\npublic class ProcessorImpl implements Processor {\n\n    @Override\n    @Scheduled(cron = \"*/2 * * * * *\")\n    public void process() {\n        System.out.println(\"It works!\");\n    }\n}\n```\n\nThis works as expected in 3.2.11, printing \"It works!\" every 2 seconds. However the scheduled task fails to fire since 3.2.12. I have tested this with aspectj versions 1.7.4 and 1.8.5 and both fail to work.\n\nI have confirmed that reverting commit `37da70629f68b07d83d5c57abb74cecb7ecb358b`, introduced by #16803, fixes this problem.\n\n---\n\n**Affects:** 3.2.12, 3.2.13\n\n**Issue Links:**\n- #16803 Scheduled/JmsListenerAnnotationBeanPostProcessor needlessly scans every scoped instance\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/1273c90a645a4fcc79719f14b4dc500106dfac2b, https://github.com/spring-projects/spring-framework/commit/3b8d8782851fe447db3b40f09444f428e1e7f5c3, https://github.com/spring-projects/spring-framework/commit/f8a8ecd8feafadc2863e0f5fab766543c4f4044c\n\n**Backported to:** [3.2.14](https://github.com/spring-projects/spring-framework/milestone/102?closed=1)\n\n1 votes, 7 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis arguably wasn't ever meant to work: If an interface-based proxy hides underlying annotations, we're usually not discovering them for external invocation purposes... since it's not even guaranteed that the annotated method is visible through the interface. We have a few such inconsistencies in the framework, unfortunately, where invalid variants worked by accident.\n\nAs a general rule, you'll have to declare service-level annotations such that they are visible on the outer facade of a bean. So either declaring the annotation on the interface method or switching your proxy mode to target-class should do the job. Can you confirm that those options do address your problem? Just making sure that I'm not missing something...\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nActually, on review, we do have specific support for `@Scheduled` methods hidden behind proxies, explicitly checking whether a corresponding method exists on the proxy and accepting such a scenario then. So even if I wouldn't recommend such an arrangement, it is a backwards compatibility issue since it has been explicitly supported before.\n\nIn fact, it still is explicitly supported. The problem rather seems to be in the caching of non-annotated classes: Since we're using the bean class as a key, proxies implementing the same interface will only be evaluated once - even if backed by different target classes. Could this be the case in your application? Some Processor implementations featuring an `@Scheduled` annotation while others don't?\n\nFixing this should be straightforward: Using the target class as a key in case of a proxy bean. I'm going to have a look at this for 4.1.5 (to be released next week) but I'm afraid a 3.2.x backport is still far out (since the 3.2.14 maintenance release isn't planned before mid 2015)...\n\nJuergen\n",
                    "**[Trent Summerfield](https://jira.spring.io/secure/ViewProfile.jspa?name=tsummerfield)** commented\n\nThanks for looking at this. In the meantime we'll be hoisting the `@Scheduled` tasks up to a bean above the proxy to work around this. Once you have the fix committed on the 3.2.x branch let me know and I would be happy to build it from source and confirm it is fixed.\n\nTrent\n",
                    "**[Trent Summerfield](https://jira.spring.io/secure/ViewProfile.jspa?name=tsummerfield)** commented\n\n> Could this be the case in your application? Some Processor implementations featuring an `@Scheduled` annotation while others don't?\n\nYes this is exactly our situation. Processor and the aspect provide logging but not all processors are  `@Scheduled` some are called through controllers or other means.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, chances are high that my local fix towards the target class as cache key will resolve your problem then. I'll backport it to the 3.2.x branch tomorrow; no need to build from source, since our CI build for the 3.2.x branch produces a snapshot for each push.\n\nAs for a potential 3.2.14 release date, we can advance it to mid May when 4.2 RC1 and 4.1.6 are scheduled to go live. For the time being, I can only offer a fix in 4.1.5 which is going out any day now. The main 'problem' is that we have hardly any other fixes which apply to 3.2.14 yet, and we're only going to release it with a few more issues resolved.\n\nBTW, any specific reason why you're still on 3.2.x? Any showstoppers for an upgrade to 4.1.x? Just wondering, since we intend to let 3.2.x reach its end-of-life by the end of this year...\n\nJuergen\n",
                    "**[Trent Summerfield](https://jira.spring.io/secure/ViewProfile.jspa?name=tsummerfield)** commented\n\nNo we have multiple applications on spring 4.1.x and are happy with it. But we also have the dusty old ball of mud application that is still on 3.2.x. If I know it is being end-of-life then I can push through the upgrade.\n\nTrent\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nTrent, this is finally available in a 3.2.14 snapshot now:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>3.2.14.BUILD-SNAPSHOT</version>\n    </dependency>\n</dependencies><repositories>\n    <repository>\n        <id>spring-snapshots</id>\n        <name>Spring Snapshots</name>\n        <url>http://repo.spring.io/snapshot</url>\n        <snapshots>\n            <enabled>true</enabled>\n        </snapshots>\n    </repository>\n</repositories>\n```\n\nPlease give it a try if you have the chance, ideally before the 4.1.5 release (scheduled for Friday)!\n\nJuergen\n",
                    "**[Trent Summerfield](https://jira.spring.io/secure/ViewProfile.jspa?name=tsummerfield)** commented\n\nJust confirmed this does indeed fix the problem. Thanks for the quick response to this, I appreciate it.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ScheduledAnnotationBeanPostProcessor` refactors the handling of `SchedulingConfigurer` detection and bean processing.  The most significant change is the use of `AopUtils.getTargetClass(bean)` to determine the class for checking against `nonAnnotatedClasses`.  This change likely addresses a potential issue where the `bean.getClass()` was not correctly identifying the target class for AOP proxies",
            "avg_logprobs": -0.28767000198364256
        }
    },
    {
        "commit_hash": "1278459ad536126a7c707e4b69a0a359f54bb556",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/ReactorHttpHandlerAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+ * @author Rossen Stoyanchev\n-public class ReactorHttpHandlerAdapter\n-\t\timplements BiFunction<HttpServerRequest, HttpServerResponse, Mono<Void>> {\n+public class ReactorHttpHandlerAdapter implements BiFunction<HttpServerRequest, HttpServerResponse, Mono<Void>> {\n-\n-\t\t\tlogger.error(\"Invalid URL \" + ex.getMessage(), ex);\n+\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t\tlogger.warn(\"Invalid URL for incoming request: \" + ex.getMessage());\n+\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ReactorHttpHandlerAdapter logs bad request at warn level only",
        "commit_body": "Issue: SPR-16524\n",
        "linked_issues": [
            {
                "issue_id": "21067",
                "issue_title": "[Reactor Netty] Incorrect error level logging for client bad request [SPR-16524]",
                "issue_body": "**[Nathan Kooij](https://jira.spring.io/secure/ViewProfile.jspa?name=nathankooij)** opened **[SPR-16524](https://jira.spring.io/browse/SPR-16524?redirect=false)** and commented\n\nOn line 65 of ReactorHttpHandlerAdapter a bad request is logged as an error, when it should be logged as a warning instead.\n\nExample:\n`ERROR 6 --- \\[ctor-http-nio-1\\] o.s.h.s.r.ReactorHttpHandlerAdapter      () : Invalid URL Illegal character in path at index \\[...\\]`\n\n\n---\n\n**Affects:** 5.0.4\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/1278459ad536126a7c707e4b69a0a359f54bb556\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point, this should only be warning. Fixed for 5.0.5 now.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging behavior when an invalid URL is encountered.  Previously, an error log was emitted.  Now, a warning log is emitted only if the logger is enabled for warnings. This change reduces the severity of the log message from an error to a warning, potentially improving the application's overall logging output",
            "avg_logprobs": -0.22498911077325995
        }
    },
    {
        "commit_hash": "14bc0d6469d8fa887f6829c7ef827fc227349ead",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t// Look for pre-cached root dir resources, either a direct match\n-\t\t// or for a parent directory in the same classpath locations.\n+\t\t// Look for pre-cached root dir resources, either a direct match or\n+\t\t// a match for a parent directory in the same classpath locations.\n-\t\t\t// No direct match -> search for parent directory match.\n+\t\t\t// No direct match -> search for a common parent directory match\n+\t\t\t// (cached based on repeated searches in the same base location,\n+\t\t\t// in particular for different root directories in the same jar).\n-\t\t\tif (rootDirResources == null & StringUtils.hasLength(commonPrefix)) {\n+\t\t\tif (rootDirResources == null && StringUtils.hasLength(commonPrefix)) {\n-\t\t\t\t\t// Replace existing subdirectory cache entry with common parent directory.\n+\t\t\t\t\t// Replace existing subdirectory cache entry with common parent directory,\n+\t\t\t\t\t// avoiding repeated determination of root directories in the same jar.",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix typo in condition check",
        "commit_body": "See gh-21190\n",
        "linked_issues": [
            {
                "issue_id": "21190",
                "issue_title": "Reduce the effect of different base package configuration on component scanning performance and make the effect more intuitive [SPR-16649]",
                "issue_body": "**[Andy Wilkinson](https://jira.spring.io/secure/ViewProfile.jspa?name=awilkinson)** opened **[SPR-16649](https://jira.spring.io/browse/SPR-16649?redirect=false)** and commented\n\nThe base package configuration that's used for component scanning can have a significant impact on the time that the scan can take. In some cases the impact of narrowing the scan can be counter-intuitive as it actually takes longer to scan fewer packages. I've attached a small sample that reproduces the behaviour that I'll describe below.\n\nIn a large application (200 packages, each with 50 classes) scanning all 200 packages takes 601ms when those packages are available directly on the filesystem:\n\n```\n$ ./gradlew run -Ppackages=single\n\n> Task :run\nScanning single took 601ms\n\n\nBUILD SUCCESSFUL in 10s\n2 actionable tasks: 2 executed\n```\n\nIf the scanning is narrowed to the 100 packages that are of interest, the time taken decreases to 403ms:\n\n```\n./gradlew run -Ppackages=multi\n\n> Task :run\nScanning multi took 403ms\n\n\nBUILD SUCCESSFUL in 1s\n2 actionable tasks: 1 executed, 1 up-to-date\n```\n\nHalving the number of packages that are scanned has reduced the time taken by roughly a third.\n\nIf the application is packaged as a jar file, the time taken to scan all 200 packages increases slightly to 657ms:\n\n```\n$ ./gradlew distZip && unzip build/distributions/component-scanning-performance.zip -d build/distributions && build/distributions/component-scanning-performance/bin/component-scanning-performance single\n\nBUILD SUCCESSFUL in 2s\n4 actionable tasks: 3 executed, 1 up-to-date\nArchive:  build/distributions/component-scanning-performance.zip\n   creating: build/distributions/component-scanning-performance/\n   creating: build/distributions/component-scanning-performance/lib/\n  inflating: build/distributions/component-scanning-performance/lib/component-scanning-performance.jar\n  inflating: build/distributions/component-scanning-performance/lib/spring-context-5.0.4.RELEASE.jar\n  inflating: build/distributions/component-scanning-performance/lib/spring-aop-5.0.4.RELEASE.jar\n  inflating: build/distributions/component-scanning-performance/lib/spring-beans-5.0.4.RELEASE.jar\n  inflating: build/distributions/component-scanning-performance/lib/spring-expression-5.0.4.RELEASE.jar\n  inflating: build/distributions/component-scanning-performance/lib/spring-core-5.0.4.RELEASE.jar\n  inflating: build/distributions/component-scanning-performance/lib/spring-jcl-5.0.4.RELEASE.jar\n   creating: build/distributions/component-scanning-performance/bin/\n  inflating: build/distributions/component-scanning-performance/bin/component-scanning-performance\n  inflating: build/distributions/component-scanning-performance/bin/component-scanning-performance.bat\nScanning single took 657ms\n```\n\nIf we then narrow the scan to focus on the 100 packages of interest, the time taken for the scan increases significantly to 1084ms:\n\n```\n$ build/distributions/component-scanning-performance/bin/component-scanning-performance multi\nScanning multi took 1084ms\n```\n\nOn the surface, I find it unintuitive that narrowing the packages that need to be scanned takes longer when the packages are in a jar file. This problem is exacerbated by the fact that the scan is faster when the scan is narrowed when the packages are on the file system. This means that, for optimal scanning performance, you may need one configuration during development and test and another in production.\n\nThe scan's slower in the jar file case as, when a package exists in a jar file, the whole jar is scanned. This means that when the scan is narrowed by providing 100 sub-packages rather than a single parent package, the whole jar is scanned 100 times rather than once. Would it be possible to provide an entry point to scanning that takes multiple base packages? Then, if multiple base packages resolve to the same jar, the jar could be scanned once to find matches across all the base packages.\n\n\n---\n\n**Affects:** 4.3.14, 5.0.4\n\n**Attachments:**\n- [component-scanning-performance.zip](https://jira.spring.io/secure/attachment/25436/component-scanning-performance.zip) (_4.67 MB_)\n\n0 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "I've introduced custom root directory and jar caching in `PathMatchingResourcePatternResolver` now, bringing scanning performance for all individual subpackages to the same level as a single scan for the root package. No new API necessary (aside from a `clearCache()` method for the application context to call on refresh completion), and the caching applies to any individual scanning attempts against the same `PathMatchingResourcePatternResolver` instance (usually the shared one in the context)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `PathMatchingResourcePatternResolver` refines the logic for finding pre-cached resource directories.  The primary improvement is in the handling of parent directory matches.  Instead of a simple check for a parent directory, it now explicitly searches for a *common* parent directory.  This change is crucial for efficiency, especially when dealing with multiple root directories within the same JAR file, as it avoids redundant calculations",
            "avg_logprobs": -0.26106063842773436
        }
    },
    {
        "commit_hash": "153fd82946c350a0c42be2dbd13774d5ee9ffc0c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.apache.commons.logging.Log;\n-\t\t\t\tif (ex.getMessage().startsWith(event.getClass().getName())) {\n+\t\t\t\tString msg = ex.getMessage();\n+\t\t\t\tif (msg != null && msg.startsWith(event.getClass().getName())) {\n-\t\t\t\t\tLogFactory.getLog(getClass()).debug(\"Non-matching event type for listener: \" + listener, ex);\n+\t\t\t\t\tLog logger = LogFactory.getLog(getClass());\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"Non-matching event type for listener: \" + listener, ex);\n+\t\t\t\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SimpleApplicationEventMulticaster defensively handles ClassCastException without message",
        "commit_body": "Issue: SPR-15145\n",
        "linked_issues": [
            {
                "issue_id": "19711",
                "issue_title": "SimpleApplicationEventMulticaster should not rely on ClassCastException having a message [SPR-15145]",
                "issue_body": "**[Mariusz Luciow](https://jira.spring.io/secure/ViewProfile.jspa?name=mariusz.luciow)** opened **[SPR-15145](https://jira.spring.io/browse/SPR-15145?redirect=false)** and commented\n\nSimpleApplicationEventMulticaster in [this commit](https://github.com/spring-projects/spring-framework/commit/13001b9affad668479ebdb924f2bd491745232a8#diff-2434dcbaad29ced6a104bb6523c4f67e) driven by #19412 changed the **ClassCastException** catch logic to:\n\n```java\ncatch (ClassCastException ex) {\n  if (ex.getMessage().startsWith(event.getClass().getName())) {\n    // Possibly a lambda-defined listener which we could not resolve the generic event type for\n    LogFactory.getLog(getClass()).debug(\"Non-matching event type for listener: \" + listener, ex);\n  } else {\n    throw ex;\n  }\n}\n```\n\nNote that if **ex.getMessage()** returns NULL whole method will throw NPE.\n\nTo speed up execution of methods that frequently throw exceptions, the C2 compiler generates code that uses a pre-built exception (pre-built at compile time). The pre-built exception does not contain neither a stack trace nor a message detailing the exception.\n\nThis means that after some time the compiler can replace normal ClassCastException with empty one, without message nor stack trace.\n\nMore detailed explanation of this behaviour can be found here:\n* [openjdk jira](https://bugs.openjdk.java.net/browse/JDK-8169685?focusedCommentId=14024750&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14024750)\n* [oracle release notes](http://www.oracle.com/technetwork/java/javase/relnotes-139183.html)\n\nThere should be a check in place to ensure that message is not null.\n\n---\n\n**Affects:** 4.3.5\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/commit/13001b9affad668479ebdb924f2bd491745232a8#diff-2434dcbaad29ced6a104bb6523c4f67e\n\n**Issue Links:**\n- #19412 SimpleApplicationEventMulticaster should not generally suppress ClassCastException\n- #20393 SimpleApplicationEventMulticaster does not deal with lambda-defined listeners when ErrorHandler is set\n- #20981 Lambda error detection might not work on JDK 9\n- #21630 Classification of ClassCastExceptions doesn't work in JDK 11 (OpenJDK)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/976d32fc5943a11668b12e83621feaa197677ec4, https://github.com/spring-projects/spring-framework/commit/153fd82946c350a0c42be2dbd13774d5ee9ffc0c, https://github.com/spring-projects/spring-framework/commit/64d4afad9f3cd06d5b911aab9d0656974310a79c, https://github.com/spring-projects/spring-framework/commit/0655d73f8e249b5f053cc10fe36f2d258acad104\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! Fixed in master and to be backported to 4.3.6.\n",
                    "**[Mariusz Luciow](https://jira.spring.io/secure/ViewProfile.jspa?name=mariusz.luciow)** commented\n\nHi Juergen,\n\nI'm not convinced if the check you've made is a good idea:\n\n```java\ncatch (ClassCastException ex) {\n  String msg = ex.getMessage();\n  if (msg != null && msg.startsWith(event.getClass().getName())) {\n    // Possibly a lambda-defined listener which we could not resolve the generic event type for\n    Log logger = LogFactory.getLog(getClass());\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Non-matching event type for listener: \" + listener, ex);\n    }\n  } else {\n    throw ex;\n  }\n}\n```\n\nCurrent behaviour will work only until compiler decides to start throwing pre-build exception. After that the catch logic will completely change, throwing exception instead of swallowing it, which may be even harder to debug.\nHonestly I'm not sure if this issue can be solved here. Maybe Spring should prohibit registration of **ApplicationListener<?>** and throw exceptions during startup instead? For example, the correct way to register listener could look like this, if possible:\n\n```java\n@Bean\n@EventListener(ContextRefreshedEvent.class)\nApplicationListener<ContextRefreshedEvent> contextRefreshedEventApplicationListener() {\n    return System.err::print;\n}\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point. It's actually closer to our intentions if we turn that check into `(msg == null || msg.startsWith(event.getClass().getName()))`, rather over-swallowing than under-swallowing, closer to how we had it originally. If there is some unrelated `ClassCastException` involved, developers are going to notice it on first appearance anyway. I'll do that right away.\n\nAs for other ways of identifying lambda-defined listeners, we got a few related JIRA tickets already. For the time being, we cannot change the rules there since we're in the middle of the 4.3.x line. I'm afraid we can only fine-tune the current approach.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of exceptions when an event listener doesn't match the expected event type.  Previously, a debug message was logged unconditionally if the exception message started with the event class name.  Now, a `Log` object is obtained, and the debug message is only logged if the `logger` is in debug mode.  This change improves efficiency by avoiding unnecessary logging in non-debug environments",
            "avg_logprobs": -0.19822465896606445
        }
    },
    {
        "commit_hash": "157df861f94dd7244a505c479bf6ba4ae8f1bf41",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ExceptionHandlerExceptionResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t// Any other than the original exception is unintended here,\n+\t\t\t// Any other than the original exception (or its cause) is unintended here,\n-\t\t\tif (invocationEx != exception && logger.isWarnEnabled()) {\n+\t\t\tif (invocationEx != exception && invocationEx != exception.getCause() && logger.isWarnEnabled()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Do not warn also if cause is re-thrown",
        "commit_body": "Closes gh-23233\n",
        "linked_issues": [
            {
                "issue_id": "23233",
                "issue_title": "ExceptionHandlerExceptionResolver warns when re-throwing the exception cause",
                "issue_body": "https://github.com/spring-projects/spring-framework/blob/3d913b813412c38e1a235b23e1e61adf39711175/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ExceptionHandlerExceptionResolver.java#L412\r\n\r\nIf an `@ExceptionHandler` method matches and rethrows a cause of the root exception, it will always log this warning. Instead, the warning should only be logged if the exception differs from the one bound to the ExceptionHandler method's parameter.\r\n\r\nInstead, this code should do something like this:\r\n```java\r\n        Throwable evaluatedException = null;\r\n        try {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Invoking @ExceptionHandler method: \" + exceptionHandlerMethod);\r\n            }\r\n            Throwable cause = exception.getCause();\r\n            if (cause != null) {\r\n                // Expose cause as provided argument as well\r\n                evaluatedException = cause;\r\n                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod);\r\n            }\r\n            else {\r\n                // Otherwise, just the given exception as-is\r\n                evaluatedException = exception;\r\n                exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod);\r\n            }\r\n        }\r\n        catch (Throwable invocationEx) {\r\n            // Any other than the original exception is unintended here,\r\n            // probably an accident (e.g. failed assertion or the like).\r\n            if (invocationEx != evaluatedException && logger.isWarnEnabled()) {\r\n                logger.warn(\"Failed to invoke @ExceptionHandler method: \" + exceptionHandlerMethod, invocationEx);\r\n            }\r\n            // Continue with default processing of the original exception...\r\n            return null;\r\n        }\r\n```\r\n\r\nI'm testing on Spring 4.3.24, but the code appears to be the same.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Both the top level exception and the cause are made available, so we should be checking both. The exception handler method could be re-throwing either one."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `exception.getCause()` to the `if` statement.  Previously, only a mismatch between `invocationEx` and `exception` triggered a warning log.  Now, if `invocationEx` is different from *both* `exception` and `exception.getCause()`, a warning is logged.  This likely improves the robustness of the exception handling by catching cases where the wrapped exception is different from the originally thrown exception",
            "avg_logprobs": -0.1698368646765268
        }
    },
    {
        "commit_hash": "15c97b753ef32cd4bf000148f9dddbfc89ddab47",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/DefaultServerHttpRequestBuilder.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (this.uri.getUserInfo() != null || this.uri.getHost() != null) {\n+\t\tif (this.uri.getRawUserInfo() != null || this.uri.getHost() != null) {\n-\t\t\tif (this.uri.getUserInfo() != null) {\n-\t\t\t\turiBuilder.append(this.uri.getUserInfo()).append('@');\n+\t\t\tif (this.uri.getRawUserInfo() != null) {\n+\t\t\t\turiBuilder.append(this.uri.getRawUserInfo()).append('@');\n-\t\tif (this.uri.getFragment() != null) {\n-\t\t\turiBuilder.append('#').append(this.uri.getFragment());\n+\t\tif (this.uri.getRawFragment() != null) {\n+\t\t\turiBuilder.append('#').append(this.uri.getRawFragment());",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Revised URI building in http.server (consistently use raw attributes)",
        "commit_body": "Issue: SPR-16434\n",
        "linked_issues": [
            {
                "issue_id": "20980",
                "issue_title": "ServerHttpRequest.mutate does not preserve encoded chars if path modified [SPR-16434]",
                "issue_body": "**[Spencer Gibb](https://jira.spring.io/secure/ViewProfile.jspa?name=sgibb)** opened **[SPR-16434](https://jira.spring.io/browse/SPR-16434?redirect=false)** and commented\n\nIn the spring cloud gateway, I used `ServerHttpRequest.mutate()` quite often. A few users noticed that encoded query parameters would get decoded before sending downstream causing unintended side effects. I have my own implementation of `ServerHttpRequest.Builder` to work around the issue, but it seems like a simple enhancement could change that.\n\nAdding `ServerHttpRequest build(encoded)` similar to `UriComponentsBuilder.build(encoded)` would fix the issue for me.\n\nMy implementation (once there is an encoded field), would look like:\n\n```java\n\n    private URI getUriToUse() {\n        if (this.uriPath == null) {\n            return this.uri;\n        }\n        try {\n            return UriComponentsBuilder.fromUri(this.uri)\n                    .replacePath(uriPath)\n                    .build(encoded).toUri();\n        }\n        catch (RuntimeException ex) {\n            throw new IllegalStateException(\"Invalid URI path: \\\"\" + this.uriPath + \"\\\"\");\n        }\n    }\n```\n\n\n\n---\n\n**Affects:** 5.0.3\n\n**Reference URL:** https://github.com/spring-cloud/spring-cloud-gateway/issues/147\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/15c97b753ef32cd4bf000148f9dddbfc89ddab47, https://github.com/spring-projects/spring-framework/commit/8a56cd0e8b05ce1517b346f654af5ff707c54282, https://github.com/spring-projects/spring-framework/commit/f4de8615aa300f1fbb082b7880236e3fb460d4f8\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nYes this looks like an issue. The intent was to provide fully encoded path information. This is why the [Javadoc says](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpRequest.Builder.html#path-java.lang.String-) the \"raw path\".\n\nSo there is no need for a flag. It'll just be: `UriComponentsBuilder.fromUri(uri).path(uriPath).build(true).toUri()`\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSince this change unfortunately caused a package cycle between `http.server` and `web.util` (not the first time this happens and not the first time for `UriComponentsBuilder` either), I've revised this change to some local URI building which essentially duplicates code from `HierarchicalUriComponents.toUriString()` in order to break the cycle. We might extract some common code at some point but for the time being the duplication doesn't seem to be too bad either.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThanks [Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `DefaultServerHttpRequestBuilder` modifies the handling of URI components.  Specifically, it replaces `uri.getUserInfo()` with `uri.getRawUserInfo()` and `uri.getFragment()` with `uri.getRawFragment()`.  This suggests a change in how user information and fragments are handled, likely to avoid potential issues with encoding or interpretation of special characters in these components",
            "avg_logprobs": -0.2411660957336426
        }
    },
    {
        "commit_hash": "16410cad4de1042c1c9641890b16fa3d49cc8b33",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ConcurrentReferenceHashMap.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\twhile (value < minimumValue && value < minimumValue) {\n+\t\twhile (value < minimumValue && value < maximumValue) {",
        "change_count": 2,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Fix ConcurrentReferenceHashMap max constraints",
        "commit_body": "Update calculateShift to respect the maximum upper bound as well as the\nminimum value.\n\nIssue: SPR-11720\n",
        "linked_issues": [
            {
                "issue_id": "16342",
                "issue_title": "ConcurrentReferenceHashMap doesn't limit upper concurrency level [SPR-11720]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-11720](https://jira.spring.io/browse/SPR-11720?redirect=false)** and commented\n\nThe `calculateShift` method contains a bug which means that the maximum concurrency level is not respected.\n\n---\n\n**Affects:** 4.0.3\n\n**Issue Links:**\n- #21532 ConcurrentReferenceHashMap does not enforce visibility of cached EntrySet\n\n**Backported to:** [3.2.9](https://github.com/spring-projects/spring-framework/milestone/97?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nhttps://github.com/spring-projects/spring-framework/pull/513\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis seems to be merged into all branches in the meantime...\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a `while` loop condition.  The original condition `value < minimumValue && value < minimumValue` was redundant, checking the same condition twice.  The updated condition `value < minimumValue && value < maximumValue` now correctly ensures that the loop continues as long as the `value` is less than both the `minimumValue` and the `maximumValue`",
            "avg_logprobs": -0.14423099517822266
        }
    },
    {
        "commit_hash": "1678eaaed04c3b9557e26089ca7dd5952976a4b6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (logger.isInfoEnabled()) {\n-\t\t\tlogger.info(\"Destroying singletons in \" + this);\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(\"Destroying singletons in \" + this);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Turn down logging in DefaultSingletonBeanRegistry",
        "commit_body": "Reduce INFO level destroy logging to DEBUG\n\nIssue: SPR-10758\n",
        "linked_issues": [
            {
                "issue_id": "15384",
                "issue_title": "Turn down logging in DefaultListableBeanFactory [SPR-10758]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-10758](https://jira.spring.io/browse/SPR-10758?redirect=false)** and commented\n\nThe INFO log level in `DefaultListableBeanFactory` displays all beans. This can be a little verbose and would perhaps work better as DEBUG\n\n\n---\nNo further details from [SPR-10758](https://jira.spring.io/browse/SPR-10758?redirect=false)",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging level for a message indicating singleton destruction.  It now logs this message at the DEBUG level instead of the INFO level.  This change reduces the amount of logging output, potentially improving performance and filtering out less critical information",
            "avg_logprobs": -0.2510727882385254
        }
    },
    {
        "commit_hash": "168a5159b8ae176950c3ea5bfb7df98b3774a79b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\tlogger.debug(\"Non-matching event type for listener: \" + listener, ex);\n+\t\t\t\tif (logger.isTraceEnabled()) {\n+\t\t\t\t\tlogger.trace(\"Non-matching event type for listener: \" + listener, ex);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log ClassCastException from lambda-defined listener at trace level",
        "commit_body": "Closes gh-22834\n",
        "linked_issues": [
            {
                "issue_id": "22834",
                "issue_title": "Consider logging classcast exceptions caused by lambdas at trace level",
                "issue_body": "See https://github.com/spring-projects/spring-boot/issues/16631 for background.\r\n\r\nCurrently lambda based listeners get debug logging if they don't accept the argument type. For example:\r\n\r\n```\r\njava.lang.ClassCastException: class org.springframework.boot.context.event.ApplicationReadyEvent cannot be cast to class org.springframework.boot.devtools.classpath.ClassPathChangedEvent (org.springframework.boot.context.event.ApplicationReadyEvent and org.springframework.boot.devtools.classpath.ClassPathChangedEvent are in unnamed module of loader 'app')\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)\r\n```\r\n\r\nI wonder if trace level logging might be more appropriate.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a logging statement within a conditional block.  The original `isDebugEnabled()` check has been replaced with `isTraceEnabled()`.  This means the logging statement will now only execute if the logger's trace level is enabled, making the logging output more verbose (trace level is more detailed than debug)",
            "avg_logprobs": -0.24739158153533936
        }
    },
    {
        "commit_hash": "1694691b791d9f86e735a9d31fc6820bd8f3c55c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClientBuilder.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.http.client.reactive.JdkClientHttpConnector;\n-\t\tthrow new IllegalStateException(\"No suitable default ClientHttpConnector found\");\n+\t\telse {\n+\t\t\treturn new JdkClientHttpConnector();\n+\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Default to JDK HttpClient if no others present",
        "commit_body": "Closes gh-23432\n",
        "linked_issues": [
            {
                "issue_id": "23432",
                "issue_title": "JDK 11 HttpClient integration with WebClient",
                "issue_body": "This a simple implementation of ClientHttpResponse that levrage\r\nJDK 11 HttpClient.\r\n\r\nCloses gh-21014",
                "issue_state": "closed",
                "issue_comment": [
                    "@Julien-Eyraud Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=23432)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=23432) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@Julien-Eyraud Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=23432)!",
                    "Cross-linking to #17778 that this depends on.",
                    "@Julien-Eyraud amazing feature :) would be awesome to resolve conflicts and see this merged...",
                    "@rdsubhas I won't fix merge until https://github.com/spring-projects/spring-framework/issues/17778 is fixed",
                    "I've created a Spring Boot starter using the code from this PR: https://github.com/candrews/java-httpclient-webclient-spring-boot-starter.\r\n\r\nIt provides a really simple way to configure WebClient to use Java 11's HttpClient; just add the dependency (which I've published to [Maven Central](https://search.maven.org/artifact/com.integralblue/java-httpclient-webclient-spring-boot-starter)) to your project and you're done.\r\n\r\nHopefully, it helps those of us who really would like this feature hold out until it lands in Spring itself :)",
                    "So, is this still happening?",
                    "I don't know I can update the PR to fix conflict and change the target branch. It's up to the maintainer now.",
                    "The `main` branch is on JDK 17 now, so we can move forward with this.",
                    "I've rebase my branch on main. I've updated the JdkClientHttpResponse#getCookies with a duplicate from JettyClientHttpResponse#parseSameSite. I didn't know where to but it to use a common code. I also updated the documentation.",
                    "I just saw your JdkClientHttpConnector pullrequest. \r\nPlease add it here as default if no other is on the classpath org.springframework.web.reactive.function.client.DefaultWebClientBuilder.initConnector()\r\ninstead of throwing an Exception\r\n throw new IllegalStateException(\"No suitable default ClientHttpConnector found\");\r\n\r\nA problem is that child classes of AbstractWebClientReactiveOAuth2AccessTokenResponseClient\r\nAlways creates a new Webclient with: \r\nprivate WebClient webClient = WebClient.builder().build(); \r\nwhich invokes the DefaultWebClientBuilder.initConnector() leading to the IllegalStateException. \r\n\r\nOr at least add a Constructor to AbstractWebClientReactiveOAuth2AccessTokenResponseClient which takes a preinitialized WebClient instead of creating a new one.\r\n\r\nSincerely\r\nRolf\r\n\r\n\r\n\r\n",
                    "It's an interesting point @rk99d339. I'll wait for maintainer feedback. I hope I'll be able to merge soon.",
                    "Hi @rstoyanchev do you think I can have a review soon ? Or this will be discard ? What do you think about rk99d339's comment ?",
                    "Yes, I'm reviewing this and should have an update soon.",
                    "This is now in `main`. I've also made sure the JDK client is used by default when no others are present."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `throw` statement with a `return` statement.  Previously, if no suitable `ClientHttpConnector` was found, an `IllegalStateException` was thrown.  Now, a default `JdkClientHttpConnector` is returned instead.  This change effectively handles the case where no suitable connector is found by providing a default implementation",
            "avg_logprobs": -0.1694279239602285
        }
    },
    {
        "commit_hash": "1763bfbad04704f4a38290f371119a3544f7546b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/xml/XmlValidationModeDetector.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\treturn (content.indexOf(DOCTYPE) > -1);\n+\t\treturn content.contains(DOCTYPE);\n-\t\treturn (openTagIndex > -1 && content.length() > openTagIndex && Character.isLetter(content.charAt(openTagIndex + 1)));\n+\t\treturn (openTagIndex > -1 && (content.length() > openTagIndex + 1) &&\n+\t\t\t\tCharacter.isLetter(content.charAt(openTagIndex + 1)));\n-\t\tif (line.indexOf(START_COMMENT) == -1 && line.indexOf(END_COMMENT) == -1) {\n+\t\tif (!line.contains(START_COMMENT) && !line.contains(END_COMMENT)) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fixed content length check in XmlValidationModeDetector",
        "commit_body": "Issue: SPR-11477\n",
        "linked_issues": [
            {
                "issue_id": "16102",
                "issue_title": "XmlValidationModeDetector: length of a string is always greater than index of any of its characters [SPR-11477]",
                "issue_body": "**[Rajeev Bahuguna](https://jira.spring.io/secure/ViewProfile.jspa?name=rbahuguna)** opened **[SPR-11477](https://jira.spring.io/browse/SPR-11477?redirect=false)** and commented\n\nThe method org.springframework.util.xml.XmlValidationModeDetector::hasOpeningTag should have this:\nreturn (openTagIndex > -1 && content.length() > (openTagIndex+1) && Character.isLetter(content.charAt(openTagIndex + 1)));\n\nin place of the current:\nreturn (openTagIndex > -1 && content.length() > openTagIndex && Character.isLetter(content.charAt(openTagIndex + 1)));\n\n\n---\n\n**Affects:** 3.2.8, 4.0.2\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/1763bfbad04704f4a38290f371119a3544f7546b, https://github.com/spring-projects/spring-framework/commit/69c54a053cc2e2141e94b58923aec0f16151a842\n\n**Backported to:** [3.2.9](https://github.com/spring-projects/spring-framework/milestone/97?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `indexOf` with `contains` for checking the presence of strings within a `String` object.  This change is made in three places, improving readability and potentially performance.  Specifically:\\n\\n1. **`content.indexOf(DOCTYPE) > -1` changed to `content.contains(DOCTYPE)`:**  This directly replaces a check for the presence of `DOCTYPE` with a more concise and readable method.\\n\\n2",
            "avg_logprobs": -0.21672481536865235
        }
    },
    {
        "commit_hash": "17edbec0351f35aaea61f876fe617e6bbe40b58a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/env/AbstractEnvironment.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t\tfor (String profile : parentDefaultProfiles) {\n-\t\t\t\t\tthis.defaultProfiles.add(profile);\n-\t\t\t\t}\n+\t\t\t\tCollections.addAll(this.defaultProfiles, parentDefaultProfiles);",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `for` loop that iterated over `parentDefaultProfiles` and added each profile individually to `defaultProfiles` with a single `Collections.addAll` call.  This is a more concise and likely more efficient way to achieve the same result",
            "avg_logprobs": -0.08709538199684837
        }
    },
    {
        "commit_hash": "1815a6a7ebafb184b1f08de6245898b19de19c6a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\tprivate static final boolean completionStagePresent = ClassUtils.isPresent(\"java.util.concurrent.CompletionStage\",\n-\t\t\tRequestMappingHandlerAdapter.class.getClassLoader());\n+\tprivate static final boolean completionStagePresent = ClassUtils.isPresent(\n+\t\t\t\"java.util.concurrent.CompletionStage\", RequestMappingHandlerAdapter.class.getClassLoader());\n-\n-\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n+\t\telse {\n+\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n+\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "RequestMappingHandlerAdapter properly invokes handler method in synchronizeOnSession mode again",
        "commit_body": "Issue: SPR-13999\n",
        "linked_issues": [
            {
                "issue_id": "18572",
                "issue_title": "Regression: RequestMappingHandlerAdapter with synchronizeOnSession=true calls invokeHandlerMethod twice [SPR-13999]",
                "issue_body": "**[Isto Nikula](https://jira.spring.io/secure/ViewProfile.jspa?name=iston)** opened **[SPR-13999](https://jira.spring.io/browse/SPR-13999?redirect=false)** and commented\n\nFirst call on line 726, second 731.\n\nhttps://github.com/spring-projects/spring-framework/blob/4.2.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L723;L731\n\n---\n\n**Affects:** 4.2.5\n\n**Issue Links:**\n- #18555 Regression: `@ResponseBody` with Map result returns JSON array twice in case of synchronizeOnSession=true (_**\"is duplicated by\"**_)\n- #18708 Handler method is called twice when synchronizeOnSession is true in RequestMappingHandlerAdaptor (_**\"is duplicated by\"**_)\n- #18440 ResponseEntity CacheControl ignored / extended by RequestMappingHandlerAdapter\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out to be a regression caused by the revised HTTP header handling introduced in 4.2.5 (#18440). Fixed for 4.2.6 now.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes an unnecessary blank line and restructures the conditional logic around `invokeHandlerMethod`.  Critically, an `else` block has been added.  This suggests the original code likely had a missing `else` clause, potentially leading to a logic error.  The change now ensures `invokeHandlerMethod` is only called if the `completionStagePresent` condition is false.  The `completionStagePresent` check itself remains unchanged",
            "avg_logprobs": -0.3221607830213464
        }
    },
    {
        "commit_hash": "18c46713185744c477814959f1043d918300a0d8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-oxm/src/main/java/org/springframework/oxm/jaxb/ClassPathJaxb2TypeScanner.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (filter.match(reader, factory)) {\n+\t\t\tif (filter.match(reader, factory) && !reader.getClassMetadata().isInterface() ) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "JAXB scan skips annotated interfaces",
        "commit_body": "Issue: SPR-13221\n",
        "linked_issues": [
            {
                "issue_id": "17812",
                "issue_title": "JaxbMarshaller scan should skip annotated interfaces [SPR-13221]",
                "issue_body": "**[Kiril Nugmanov](https://jira.spring.io/secure/ViewProfile.jspa?name=cyniclt)** opened **[SPR-13221](https://jira.spring.io/browse/SPR-13221?redirect=false)** and commented\n\nSpring JAXB marshaller (`org.springframework.oxm.jaxb.Jaxb2Marshaller`)  incorrectly scans packages with JAXB annotations.\n\nProblems is when package is being scanned used `org.springframework.oxm.jaxb.ClassPathJaxb2TypeScanner` which checks if class has following annotations:\n* XmlRootElement\n* XmlType\n* XmlSeeAlso\n* XmlEnum\n* XmlRegistry\n\nSo if you generating client from WSDL - webservice interface will have an anotation `XmlSeeAlso.`\n\nWhis annotatio leads to the error\n\n```java\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'marshaller' defined in class path resource [application.xml]: Invocation of init method failed; nested exception is org.springframework.oxm.UncategorizedMappingException: Unknown JAXB exception; nested exception is com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions\norg.cynic.test.client.Service is an interface, and JAXB can't handle interfaces.\n\tthis problem is related to the following location:\n\t\tat org.cynic.test.client.Service\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"marshaller\" class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\">\n        <property name=\"packagesToScan\" value=\"org.cynic.test.client\"/>\n    </bean>\n</beans>\n```\n\nThe only dirty fix is to downgrade JAXB binding version from 2.1 to 2.0\nFor more details why this annotation is being generated on interfaces see this [post](http://stackoverflow.com/questions/7092390/omitting-xmlseealso-from-xjc-output)\n\nSolution  should be following: `org.springframework.oxm.jaxb.ClassPathJaxb2TypeScanner` must ignore annotated interfaces (even if there is default implementation for Java 8)\n\nI can create pull request (after discussion).\n\n\n---\n\n**Affects:** 4.1.7\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/18c46713185744c477814959f1043d918300a0d8\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `if` statement.  Previously, the code checked only if the `filter` matched the `reader` and `factory`.  The addition of `&& !reader.getClassMetadata().isInterface()` now ensures that the check only happens if the `reader` is not an interface.  This implies a change in the logic flow, potentially excluding interface types from further processing",
            "avg_logprobs": -0.1799522808619908
        }
    },
    {
        "commit_hash": "194b4cedfbf9f947797d97af851c8e718c2aa91e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/filter/UrlHandlerFilter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.http.server.PathContainer;\n-\t\t\t\tif (!entry.getKey().canHandle(request)) {\n+\t\t\t\tif (!entry.getKey().canHandle(request, path)) {\n-\t\tboolean canHandle(HttpServletRequest request);\n+\t\tboolean canHandle(HttpServletRequest request, RequestPath path);\n-\t\tpublic boolean canHandle(HttpServletRequest request) {\n-\t\t\treturn request.getRequestURI().endsWith(\"/\");\n+\t\tpublic boolean canHandle(HttpServletRequest request, RequestPath path) {\n+\t\t\tList<PathContainer.Element> elements = path.elements();\n+\t\t\treturn (!elements.isEmpty() && elements.get(elements.size() - 1).value().equals(\"/\"));",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use parsed path for checks in UrlHandlerFilter",
        "commit_body": "See gh-32830\n",
        "linked_issues": [
            {
                "issue_id": "32830",
                "issue_title": "Create WebFlux equivalent filter to handle URLs with trailing slashes ",
                "issue_body": "The `UrHandlerFilter` under #31366 is for use with Spring MVC and the Servlet API. This issue is to create the same for use with WebFlux, which will have the same functionality but for the WebFlux API. ",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `UrlHandlerFilter` modifies the `canHandle` method to accept an additional `RequestPath` parameter.  Previously, the method only checked if the request URI ended with a slash.  The updated method now uses the provided `RequestPath` to determine if the request can be handled, specifically checking if the last element of the path is a slash.  This suggests a more sophisticated routing logic, potentially handling more complex URL patterns",
            "avg_logprobs": -0.22495948791503906
        }
    },
    {
        "commit_hash": "1958ae3a625dbf7761cd4f6a530c9cd8543a19eb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\tlogger.trace(\"Message broker is not active. Ignoring: \" + message);\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Message broker is not active. Ignoring: \" + message);\n-\t\t\t\t\tif (logger.isTraceEnabled()) {\n-\t\t\t\t\t\tlogger.trace(\"Ignoring client message received \" + message +\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"Ignoring client message received \" + message +",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Update log level",
        "commit_body": "Issue: SPR-11673\n",
        "linked_issues": [
            {
                "issue_id": "16296",
                "issue_title": "no msg when cannot authorize against external queue [SPR-11673]",
                "issue_body": "**[Prashant Deva](https://jira.spring.io/secure/ViewProfile.jspa?name=pdeva)** opened **[SPR-11673](https://jira.spring.io/browse/SPR-11673?redirect=false)** and commented\n\nSo i tried putting in the following lines in my code to pass a fake password:\n\n```\n StompBrokerRelayRegistration registration = config.enableStompBrokerRelay(\"/topic\");\n        registration.setRelayHost(\"xxxx.com\");\n        registration.setSystemPasscode(\"hello\");\n        registration.setClientPasscode(\"hello\");\n\n```\n\nthe funny thing is the logs still just show this:\n\n```\n16:24:47,103  INFO reactor-tcp-io-2 netty.NettyTcpClient:304 - CONNECT: [id: 0x0db8042b, /192.168.1.15:49980 => xxxx.com/162.242.220.165:61613]\n```\n\nof course there is no data transfer cause the msg queue itself wont allow authentication with a non-existent password, but nothing in the logs by spring shows we had a bad authentication\n\n\n---\n\n**Affects:** 4.0.3\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI see this for the \"system\" connection at startup (DEBUG level):\n\n```\n10:21:58 [reactor-tcp-io-1] StompDecoder - Decoded [Payload byte[32]][Headers={stompCommand=ERROR, nativeHeaders={content-type=[text/plain], message=[Bad CONNECT], content-length=[32], version=[1.0,1.1,1.2]}, simpMessageType=OTHER, contentType=text/plain, id=31149240-3fb5-63b8-15fd-11166e51e9f2, timestamp=1398867718551}]\n```\n\nAnd then this for client connections later (TRACE level):\n\n```\n10:22:31 [clientInboundChannel-2] StompBrokerRelayMessageHandler - Message broker is not active. Ignoring message id=7ac7d601-e1a9-587b-5dbc-a78dd0ac73dd\n```\n\nI made changes so that:\n\n(a) any STOMP ERROR frame received from the broker is logged at **error** level\n(b) any client CONNECT frame ignored when the broker is inactive is logged at **error** level\n(c) any other client message ignored when the broker is inactive is logged at **debug** level\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI'm marking this resolved. The messages should now appear as expected.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the logging level for a message broker inactivity condition.  Originally, a `trace` level log was used to indicate the message was ignored when the broker was inactive.  The change now uses a `debug` level log instead.  This change likely reduces the amount of log output, as `debug` is less verbose than `trace`.  The nested `trace` log statement has also been changed to a `debug` log statement, maintaining consistency",
            "avg_logprobs": -0.27790608008702594
        }
    },
    {
        "commit_hash": "19a1477228b8ed75926a15358e3253eb7ffa492e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\telse if (nonSyntheticConstructors == 2 && primaryConstructor != null && defaultConstructor != null) {\n+\t\t\t\t\telse if (nonSyntheticConstructors == 2 && primaryConstructor != null\n+\t\t\t\t\t\t\t&& defaultConstructor != null && !primaryConstructor.equals(defaultConstructor)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix Kotlin bean w/ default + secondary ctors handling",
        "commit_body": "This commit polishes SPR-16022 fix in order to handle correctly\nthe case when primary and default constructors are the same when\na secondary constructor is defined.\n\nIssue: SPR-16289\n",
        "linked_issues": [
            {
                "issue_id": "20571",
                "issue_title": "Avoid implicit autowiring with Kotlin secondary constructors [SPR-16022]",
                "issue_body": "**[Alexander Chernikov](https://jira.spring.io/secure/ViewProfile.jspa?name=sashache)** opened **[SPR-16022](https://jira.spring.io/browse/SPR-16022?redirect=false)** and commented\n\nLooks similar to #20561, which is marked fixed in 5.0, but I observe this with 5.0.0.RELEASE, so creating new issue for a case.\n\nDummy Kotlin bean class:\n\n```kotlin\nclass KotlinCtor(val intVal: Int) {\n    constructor(p: String) : this(p.length)\n    constructor(p0: Int, p1: String) : this(p0 + p1.length)\n}\n```\n\nDummy beans in spring.xml:\n\n```xml\n...\n    <bean class=\"temp.KotlinCtor\" name=\"ctor0\">\n        <constructor-arg value=\"0\"/>\n    </bean>\n    <bean class=\"temp.KotlinCtor\" name=\"ctor1\">\n        <constructor-arg value=\"a\"/>\n    </bean>\n    <bean class=\"temp.KotlinCtor\" name=\"ctor2\">\n        <constructor-arg value=\"2\"/>\n        <constructor-arg value=\"b\"/>\n    </bean>\n...\n```\n\nAdd configuration:\n\n```kotlin\n@Configuration @ImportResource(\"spring.xml\")\nopen class KotlinAnnotator\n```\n\nDummy application, this time in Java:\n\n```java\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Main {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring.xml\");\n//        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(KotlinAnnotator.class);\n    }\n}\n```\n\nExecute this main() method: no problem.\nComment out XML context creation, uncomment annotation context creation, execute and fail:\n\n```\nWARNING: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'ctor1' defined in class path resource [spring.xml]: Unsatisfied dependency expressed through constructor parameter 0: Could not convert argument value of type [java.lang.String] to required type [int]: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"a\"\nException in thread \"main\" org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'ctor1' defined in class path resource [spring.xml]: Unsatisfied dependency expressed through constructor parameter 0: Could not convert argument value of type [java.lang.String] to required type [int]: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"a\"\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:691)\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:192)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1269)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1126)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:502)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)\n\tat org.springframework.context.annotation.AnnotationConfigApplicationContext.<init>(AnnotationConfigApplicationContext.java:88)\n\tat temp.Main.main(Main.java:9)\n```\n\n---\n\n**Affects:** 5.0 GA\n\n**Issue Links:**\n- #20561 AutowiredAnnotationBeanPostProcessor picks \"wrong\" constructor for Kotlin class\n- #20836 BeanCreationException when using c-namespace, Kotlin class with default constructor and annotation configuration\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/19a1477228b8ed75926a15358e3253eb7ffa492e, https://github.com/spring-projects/spring-framework/commit/edf82325557f05f482b0b9c0333d99908c8f1378\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Alexander Chernikov](https://jira.spring.io/secure/ViewProfile.jspa?name=sashache)** commented\n\nThank you, works for me in 5.0.3.\n"
                ]
            },
            {
                "issue_id": "20836",
                "issue_title": "BeanCreationException when using c-namespace, Kotlin class with default constructor and annotation configuration [SPR-16289]",
                "issue_body": "**[Alexander Chernikov](https://jira.spring.io/secure/ViewProfile.jspa?name=sashache)** opened **[SPR-16289](https://jira.spring.io/browse/SPR-16289?redirect=false)** and commented\n\n#20571 is fixed in Spring 5.0.2.\nHowever, I've found minor sub-case when using c-namespace.\n\nDummy Kotlin:\n\n```\npackage cr.spr16022\n\nimport org.springframework.context.annotation.Configuration\nimport org.springframework.context.annotation.ImportResource\nimport org.springframework.context.support.ClassPathXmlApplicationContext\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext\n\nclass KotlinCtor(val intVal: Int) {\n    constructor(p: String) : this(p.length)\n}\n\nclass KotlinQtor() {\n    constructor(p: String) : this()\n}\n\n@Configuration @ImportResource(\"cr.xml\") class KotlinAnnotator\n\nobject Main {\n    @JvmStatic fun main(args: Array<String>) {\n        val contextXml = ClassPathXmlApplicationContext(\"cr.xml\")\n//        val contextAnn = AnnotationConfigApplicationContext(KotlinAnnotator::class.java)\n    }\n}\n```\n\nBeans definition:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"cr.spr16022.KotlinCtor\" name=\"ctor0s\" c:p=\"a\"/>\n    <bean class=\"cr.spr16022.KotlinQtor\" name=\"qtor0s\" c:p=\"a\"/>\n</beans>\n```\n\nRun this dummy main(): no problems.\nUncomment contextAnn declaration and initialization, re-run: fail:\n\n```\nWARNING: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'qtor0s' defined in class path resource [cr.xml]: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'qtor0s' defined in class path resource [cr.xml]: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:243)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1270)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1127)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:502)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:312)\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:310)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:758)\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)\n\tat org.springframework.context.annotation.AnnotationConfigApplicationContext.<init>(AnnotationConfigApplicationContext.java:88)\n\tat cr.spr16022.Main.main(KotlinCtor.kt:22)\n\nProcess finished with exit code 1\n```\n\n---\n\n**Affects:** 5.0.2\n\n**Issue Links:**\n- #20571 Avoid implicit autowiring with Kotlin secondary constructors\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/19a1477228b8ed75926a15358e3253eb7ffa492e\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Alexander Chernikov](https://jira.spring.io/secure/ViewProfile.jspa?name=sashache)** commented\n\nThank you, works for me in 5.0.3.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `else if` statement.  Previously, the code checked if both a primary constructor and a default constructor existed.  The updated code now additionally requires that the primary and default constructors are *not* the same object.  This implies a check for *different* constructors, likely to prevent unintended behavior when both constructors are identical",
            "avg_logprobs": -0.3153211748277819
        }
    },
    {
        "commit_hash": "19a9bc4747028e68d0fc9ce71c302488cfbfa978",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/server/session/InMemoryWebSessionStore.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\n-\t\t\tif (InMemoryWebSessionStore.this.sessions.remove(currentId) == null) {\n-\t\t\t\treturn Mono.error(new IllegalStateException(\n-\t\t\t\t\t\t\"Failed to change session id: \" + currentId +\n-\t\t\t\t\t\t\t\t\" because the Session is no longer present in the store.\"));\n-\t\t\t}\n+\t\t\tInMemoryWebSessionStore.this.sessions.remove(currentId);",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary assertion",
        "commit_body": "Issue: SPR-16201\n",
        "linked_issues": [
            {
                "issue_id": "20749",
                "issue_title": "InMemoryWebSession.changeSessionId reports error if the session does not exist [SPR-16201]",
                "issue_body": "**[Rob Winch](https://jira.spring.io/secure/ViewProfile.jspa?name=rwinch)** opened **[SPR-16201](https://jira.spring.io/browse/SPR-16201?redirect=false)** and commented\n\nIf a user invokes `InMemoryWebSession.changeSessionId` before the session has been created, an error is reported stating:\n\n```\njava.lang.IllegalStateException: Failed to change session id: 4854375d-1713-468b-9e4c-61fe282de0bc because the Session is no longer present in the store.\n\t\tat org.springframework.web.server.session.InMemoryWebSessionStore$InMemoryWebSession.changeSessionId(InMemoryWebSessionStore.java:214)\n\t\tat org.springframework.security.web.server.csrf.WebSessionServerCsrfTokenRepository.lambda$saveToken$1(WebSessionServerCsrfTokenRepository.java:64)\n\t\tat reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:118)\n\t\t... 36 more\n```\n\nI think the method should support changing the id even if the session is new.\n\nAs it currently stands an additional problem is that it appears there is no way to determine if this operation is safe.\n\n\n---\n\n**Affects:** 5.0.1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/19a9bc4747028e68d0fc9ce71c302488cfbfa978\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a conditional check and error handling.  The original code checked if the session removal was successful (returned `null` indicating failure) and threw an `IllegalStateException` if it wasn't.  The updated code simply removes the session and doesn't explicitly handle the case where the session wasn't found.  This implies that the code now assumes the session will always exist before attempting to remove it",
            "avg_logprobs": -0.2081350282181141
        }
    },
    {
        "commit_hash": "1acf5a742436d2e8460a880c11dd4946d2ca3555",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/datasource/init/DatabasePopulatorUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "+\t\tcatch (ScriptException ex){\n+\t\t\tthrow ex;\n+\t\t}\n-\t\t\tif (ex instanceof ScriptException) {\n-\t\t\t\tthrow (ScriptException) ex;\n-\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use dedicated catch block for ScriptException",
        "commit_body": "Closes gh-24383",
        "linked_issues": [
            {
                "issue_id": "24383",
                "issue_title": "Use dedicated catch block for ScriptException",
                "issue_body": "It can be that.",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `if` statement.  Previously, if a `ScriptException` was caught, it was checked against its type and re-thrown.  The updated code directly re-throws the caught exception without the type check, improving efficiency and readability",
            "avg_logprobs": -0.17395213734019888
        }
    },
    {
        "commit_hash": "1b1682eacd9c8aabbb86f24dc9c54070f3dd18b4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/cglib/proxy/MethodProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!c1.isInterface() && c1 != Object.class) {\n-\t\t\t// Try early initialization for overridden methods on subclasses\n+\t\tif (!c1.isInterface() && c1 != Object.class && !Factory.class.isAssignableFrom(c2)) {\n+\t\t\t// Try early initialization for overridden methods on specifically purposed subclasses",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Narrow early initialization of CGLIB method proxies (for AOT processing)",
        "commit_body": "Do not trigger early initialization on Factory classes (e.g. AOP proxies)\n\nSee gh-29107\n",
        "linked_issues": [
            {
                "issue_id": "29107",
                "issue_title": "CGLIB proxies are not used at runtime on `@Configuration` classes in AOT mode",
                "issue_body": "Consider the following configuration class:\r\n\r\n```java\r\n@Configuration\r\npublic class MyConfiguration {\r\n\t@Bean\r\n\tA a() { return new A(); }\r\n\r\n\t@Bean\r\n\tB b() { return new B(this.a()); }\r\n\t\r\n\tstatic class A {\r\n\t\tpublic A() { System.out.println(\"A constructor\"); }\r\n\t}\r\n\r\n\tstatic class B {\r\n\t\tpublic B(A a) { System.out.println(\"B constructor\"); }\r\n\t}\r\n}\r\n```\r\n\r\nOn JVM in regular mode, it prints:\r\n\r\n```\r\nA constructor\r\nB constructor\r\n```\r\n\r\nOn JVM in AOT mode or native, while it seems CGLIB proxies are generated correctly at build time,  but they seems not used since it prints:\r\n\r\n```\r\nA constructor\r\nA constructor\r\nB constructor\r\n```\r\n\r\nThe code generated AOT maybe needs to be updated to leverage those CGLIB proxies.",
                "issue_state": "closed",
                "issue_comment": [
                    "We need to swap the creation of the raw class to the cglib proxy. I was hoping I could avoid having to change code generation for this but it turns out that there isn't a way to achieve this using an instance supplier. \r\n\r\nI've a proposal in [3b8bcdf](https://github.com/snicoll/spring-framework/commit/3b8bcdfe281b606a1ce8ee354b0cef56913ccfcd).\r\n\r\nThis is blocked by https://github.com/spring-projects/spring-boot/issues/32304 and, to some extent, https://github.com/spring-projects/spring-framework/issues/29141",
                    "I have it working but I think it needs a bit more work to test it correctly. "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `if` statement.  Originally, the code checked if `c1` was not an interface and not the `Object` class.  The updated code adds the additional check `!Factory.class.isAssignableFrom(c2)`.  This means early initialization for overridden methods on subclasses of `c1` will *only* occur if `c2` is not a subclass of `Factory`",
            "avg_logprobs": -0.13842766761779784
        }
    },
    {
        "commit_hash": "1b1ba479125ecd1051d14742d89f492376176130",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tfor (char ch: name.toCharArray()) {\n-\t\t\tif (!Character.isJavaIdentifierPart(ch)) {\n+\t\tfor (int i = 1; i < name.length(); i++) {\n+\t\t\tif (!Character.isJavaIdentifierPart(name.charAt(i))) {",
        "change_count": 4,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Avoid char array creation in AbstractAspectJAdvice.isVariableName()",
        "commit_body": "See gh-26100\n",
        "linked_issues": [
            {
                "issue_id": "26100",
                "issue_title": "Avoid char array creation in AbstractAspectJAdvice.isVariableName()",
                "issue_body": "This PR changes to avoid `char` array creation in `AbstractAspectJAdvice.isVariableName()`.",
                "issue_state": "closed",
                "issue_comment": [
                    "Well spotted, thanks again @izeye."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the iteration over the characters in the `name` string.  It replaces a `for-each` loop iterating over each character with an indexed `for` loop starting from the second character (index 1).  The core logic of checking if a character is a valid Java identifier part remains the same, but now operates on the characters using their index within the string.  This suggests a potential optimization or a change in the intended scope of the identifier validation",
            "avg_logprobs": -0.2582625579833984
        }
    },
    {
        "commit_hash": "1b93ea97ac4fb7011e4afb026bb32d0c589aa198",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\t// retrying in case of concurrent reads on the same key\n+\t\t\t\tif (this.queue.remove(key)) {\n+\t\t\t\t\tthis.queue.add(key);\n+\t\t\t\t\treturn this.cache.get(key);\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix concurrent reads issue in MimeTypeUtils cache",
        "commit_body": "As of gh-22340, `MimeTypeUtils` has a built-in LRU cache implementation\nfor caching parsed MIME types and avoiding excessive garbage creation at\nruntime.\nThis implementation, when hit with highly concurrent reads on the same\nmedia type (the cache key), can create multiple keys for the same MIME\ntype string. This duplication leads to the cache filling up and evicting\nentries. When the cache fetches a duplicate key, it is then not\nassociated with a value and the cache can return a `null` value, which\nis forbidden by the API contract.\n\nThis commit adds another cache check within the write lock: this avoids\ncreating duplicate entries in the cache and `null` return values.\n\nFixes gh-23211\n",
        "linked_issues": [
            {
                "issue_id": "23211",
                "issue_title": "MimeTypeUtils.parseMimeType returns null MIME type in case of high concurrency",
                "issue_body": "**Affects:** 5.5.0.M2 + (Problem observed in 5.5.0.M2, probably in any release after 2/5/2019)\r\n---\r\nI am getting an NPE on line MediaType.java:550 of spring-web-5.2.0.M2.jar (currently line 563 in master) because the cache is apparently returning a null type from MimeTypeUtils.parseMimeType().\r\n```\r\n\tpublic static MimeType parseMimeType(String mimeType) {\r\n\t\treturn cachedMimeTypes.get(mimeType);\r\n\t}\r\n```\r\nand the method below doesn't account for a null return from the LRU cache ```cachedMimeTypes```\r\n```\r\n\tpublic static MediaType parseMediaType(String mediaType) {\r\n\t\tMimeType type;\r\n\t\ttry {\r\n\t\t\ttype = MimeTypeUtils.parseMimeType(mediaType);\r\n\t\t}\r\n\t\tcatch (InvalidMimeTypeException ex) {\r\n\t\t\tthrow new InvalidMediaTypeException(ex);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn new MediaType(type.getType(), type.getSubtype(), type.getParameters()); //NPE\r\n\t\t}\r\n\t\tcatch (IllegalArgumentException ex) {\r\n\t\t\tthrow new InvalidMediaTypeException(mediaType, ex.getMessage());\r\n\t\t}\r\n\t}\r\n```\r\nThe ConcurrentLruCache in MimeTypeUtils must have a bug b/c that is the only way null type could be getting returned. The ConcurrentLruCache.get(key) method does returns in two places and one of them is returning a null. The return in the write lock block looks safe but the return in the read lock block could return null if the internal queue has the same key in it twice at which point the internal cache map wouldn't have the value anymore and then a null could be returned.\r\n```\r\n\t\tpublic V get(K key) {\r\n\t\t\tthis.lock.readLock().lock();\r\n\t\t\ttry {\r\n\t\t\t\tif (this.queue.remove(key)) {\r\n\t\t\t\t\tthis.queue.add(key);\r\n\t\t\t\t\treturn this.cache.get(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfinally {\r\n\t\t\t\tthis.lock.readLock().unlock();\r\n\t\t\t}\r\n\t\t\tthis.lock.writeLock().lock();\r\n\t\t\ttry {\r\n\t\t\t\tif (this.queue.size() == this.maxSize) {\r\n\t\t\t\t\tK leastUsed = this.queue.poll();\r\n\t\t\t\t\tif (leastUsed != null) {\r\n\t\t\t\t\t\tthis.cache.remove(leastUsed);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tV value = this.generator.apply(key);\r\n\t\t\t\tthis.queue.add(key);\r\n\t\t\t\tthis.cache.put(key, value);\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\tfinally {\r\n\t\t\t\tthis.lock.writeLock().unlock();\r\n\t\t\t}\r\n\t\t}\r\n```\r\nAssume two threads go through read lock block at same time, one of them will remove the key and add it back to front of queue, the other thread will fall through and wait for the write lock. Once the thread gets the write lock it will also add the key to the queue and now the key will be in the queue twice. Eventually the duplicate key might work its way to least used and get removed from the cache. At that point, all subsequent requests for that key will return null because the queue still has the key but the hash map doesn't have the value. \r\n\r\nThis is pretty serious b/c once it starts happening for a particular mime type, I think the application needs to be restarted. ",
                "issue_state": "closed",
                "issue_comment": []
            },
            {
                "issue_id": "22340",
                "issue_title": "Avoid MimeType garbage creation",
                "issue_body": "While profiling Spring web applications (MVC and WebFlux), it seems that `MimeType` (through `MediaType`) is creating a significant amount of garbage that could be avoided.\r\n\r\n- [x] Caching the `toString()` result of `MimeType` instances, since it cannot change and this method is called many times on hot paths\r\n- [x] `MediaType.parseMediaType` is called multiple times, for each request; this could be backed by a simple LRU cache implementation to avoid re-parsing known media types\r\n- [ ] `MimeTypeUtils.parseMimeType` parsing code can be improved; a draft implementation shows +40% throughput and -10% allocation.\r\n- [x] `MimeTypeUtils` and `MediaType` both have static sections where well-known types are parsed; changing those from `APPLICATION_JSON = MimeType.valueOf(APPLICATION_JSON_VALUE);` to `APPLICATION_JSON = new MimeType(\"application\", \"json\");` leads to a bit of duplication but consistently reduces garbage and CPU usage at startup time (approx. 10ms).",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a retry mechanism for retrieving a value from a cache (`this.cache`) associated with a key (`key`).  If the key is removed from a queue (`this.queue`), it's re-added, and the cached value is returned.  This suggests a scenario where concurrent access to the key might cause a race condition, and the retry attempts to resolve it",
            "avg_logprobs": -0.1712813317021237
        }
    },
    {
        "commit_hash": "1c01f575c2d3407e5c3c18a58d19ee00f5420249",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tmembers.add(asSourceClass(memberClassName));\n+\t\t\t\ttry {\n+\t\t\t\t\tmembers.add(asSourceClass(memberClassName));\n+\t\t\t\t}\n+\t\t\t\tcatch (IOException ex) {\n+\t\t\t\t\t// Let's skip it if it's not resolvable - we're just looking for candidates\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"Failed to resolve member class [\" + memberClassName +\n+\t\t\t\t\t\t\t\t\"] - not considering it as a configuration class candidate\");\n+\t\t\t\t\t}\n+\t\t\t\t}",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ConfigurationClassParser ignores unresolvable member classes",
        "commit_body": "Issue: SPR-13115\n",
        "linked_issues": [
            {
                "issue_id": "17706",
                "issue_title": "FileNotFoundException when implementing a nested interface with groovy closure in a @Component [SPR-13115]",
                "issue_body": "**[Tadas Krivickas](https://jira.spring.io/secure/ViewProfile.jspa?name=tadaskay)** opened **[SPR-13115](https://jira.spring.io/browse/SPR-13115?redirect=false)** and commented\n\n```java\norg.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [org.springframework.issues.DogService]; nested exception is java.io.FileNotFoundException: class path resource [org/springframework/issues/DogService$Wuffing$1.class] cannot be opened because it does not exist\n\tat org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:179)\n...\nCaused by: java.io.FileNotFoundException: class path resource [org/springframework/issues/DogService$Wuffing$1.class] cannot be opened because it does not exist\n\tat org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:172)\n\tat org.springframework.core.type.classreading.SimpleMetadataReader.<init>(SimpleMetadataReader.java:50)\n\tat org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:98)\n\tat org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:102)\n\tat org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:93)\n\tat org.springframework.context.annotation.ConfigurationClassParser.asSourceClass(ConfigurationClassParser.java:596)\n\tat org.springframework.context.annotation.ConfigurationClassParser$SourceClass.getMemberClasses(ConfigurationClassParser.java:758)\n\tat org.springframework.context.annotation.ConfigurationClassParser.processMemberClasses(ConfigurationClassParser.java:314)\n\tat org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:246)\n\tat org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:229)\n\tat org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:196)\n\tat org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:165)\n\tat org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:306)\n\tat org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:239)\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:254)\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:94)\n\tat org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:606)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:462)\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:686)\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:320)\n\tat org.springframework.boot.test.SpringApplicationContextLoader.loadContext(SpringApplicationContextLoader.java:103)\n\tat org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:68)\n\tat org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:86)\n\tat org.springframework.test.context.DefaultTestContext.getApplicationContext(DefaultTestContext.java:72)\n\tat org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:117)\n\tat org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83)\n\tat org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:212)\n\tat org.spockframework.spring.SpringTestContextManager.prepareTestInstance(SpringTestContextManager.java:49)\n\tat org.spockframework.spring.SpringInterceptor.interceptSetupMethod(SpringInterceptor.java:42)\n\tat org.spockframework.runtime.extension.AbstractMethodInterceptor.intercept(AbstractMethodInterceptor.java:28)\n\tat org.spockframework.runtime.extension.MethodInvocation.proceed(MethodInvocation.java:87)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)\n\tat org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128)\n\tat org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203)\n\tat org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155)\n\tat org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)\n```\n\nI've observed that this can be fixed in two ways:\n1. Moving the interface outside of class to package\n2. Replacing `@Component` with `@javax.inject.Named`\n\nOther notes:\n- Does not occur in an analogous situation using java, by implementing a private nested interface via lambda expression.\n\nPull request to reproduce: https://github.com/spring-projects/spring-framework-issues/pull/98\n\n\n---\n\n**Affects:** 4.1.6\n\n**Reference URL:** https://github.com/spring-projects/spring-framework-issues/pull/98\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework-issues/pull/98, and commits https://github.com/spring-projects/spring-framework/commit/1c01f575c2d3407e5c3c18a58d19ee00f5420249, https://github.com/spring-projects/spring-framework/commit/ef9910c3c48cc56b655f189a4362cbc8907b7e61\n\n3 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nCould you post the nested stacktrace please, for the actual point where the `FileNotFoundException` is being raised?\n\nJuergen\n",
                    "**[Tadas Krivickas](https://jira.spring.io/secure/ViewProfile.jspa?name=tadaskay)** commented\n\nAdded in description.\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) there is a sample project [available here](https://github.com/spring-projects/spring-framework-issues/tree/master/SPR-13115)\n",
                    "**[Tadas Krivickas](https://jira.spring.io/secure/ViewProfile.jspa?name=tadaskay)** commented\n\nChecked with 4.2.0-SNAPSHOT, the issue is fixed. Thanks!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a `try-catch` block around the `members.add(asSourceClass(memberClassName))` line.  This now handles potential `IOExceptions` during the resolution of `memberClassName` to a `SourceClass`.  If an `IOException` occurs, the problematic class is skipped, and a debug log message is printed, indicating that the class was not considered a configuration class candidate due to the resolution failure",
            "avg_logprobs": -0.10868984222412109
        }
    },
    {
        "commit_hash": "1c24dc1f27fda6736c5a7b123f0476a1bc124a94",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-test/src/main/java/org/springframework/mock/web/MockHttpServletResponse.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tStringBuilder sb = new StringBuilder(this.contentType);\n-\t\t\tif (!this.contentType.toLowerCase().contains(CHARSET_PREFIX) && this.charset) {\n-\t\t\t\tsb.append(\";\").append(CHARSET_PREFIX).append(this.characterEncoding);\n+\t\t\tString value = this.contentType;\n+\t\t\tif (this.charset && !this.contentType.toLowerCase().contains(CHARSET_PREFIX)) {\n+\t\t\t\tvalue = value + ';' + CHARSET_PREFIX + this.characterEncoding;\n-\t\t\tdoAddHeaderValue(HttpHeaders.CONTENT_TYPE, sb.toString(), true);\n+\t\t\tdoAddHeaderValue(HttpHeaders.CONTENT_TYPE, value, true);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify String concatenation",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change optimizes the construction of the `Content-Type` header.  Instead of using a `StringBuilder`, it now directly concatenates the `contentType` string, improving efficiency.  The conditional logic for appending the charset remains the same, but the string manipulation is now more concise and avoids unnecessary object creation.  This change likely results in a small performance improvement, especially for cases where the `contentType` is already long",
            "avg_logprobs": -0.20495116844605865
        }
    },
    {
        "commit_hash": "1cb2dfa45963321e530ff53d2d582642ed1d2294",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/AbstractErrors.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (nestedPath.length() > 0 && !nestedPath.endsWith(NESTED_PATH_SEPARATOR)) {\n+\t\tif (!nestedPath.isEmpty() && !nestedPath.endsWith(NESTED_PATH_SEPARATOR)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "enh: use isEmpty() instead of length()",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `if (nestedPath.length() > 0 && !nestedPath.endsWith(NESTED_PATH_SEPARATOR))` with `if (!nestedPath.isEmpty() && !nestedPath.endsWith(NESTED_PATH_SEPARATOR))`.\\n\\nThis is a stylistic change.  `nestedPath.isEmpty()` is generally considered more readable and idiomatic Java than checking the length",
            "avg_logprobs": -0.1073723316192627
        }
    },
    {
        "commit_hash": "1db9faf24838b5df83238e36312e9f721f11fa80",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\tif (bean instanceof SmartLifecycle) {\n+\t\t\t\t\tlatch.countDown();\n+\t\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid shutdown timeout in case of exception on stop",
        "commit_body": "Closes gh-33442\n",
        "linked_issues": [
            {
                "issue_id": "33442",
                "issue_title": "Errors thrown from SmartLifeycle#stop results in (unnecessary) waiting for the shutdown timeout",
                "issue_body": "When the stop method of a SmartLifecycle bean throws an error, the DefaultLifecycleProcessor always waits until the timeout is hit. Which is unnecessary as no cleanup is performed and delays the shutdown.\r\n\r\nImho when [calling the stop()](https://github.com/spring-projects/spring-framework/blob/main/spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java#L384) method the DefaultLifecycleProcessor should also do a `latch.countDown` in case an exception is thrown.\r\n\r\n(In our case we had a stop method which was interacting with the database. When we did some DB failover testing, this method has thrown some exception and the shutdown got delayed) ",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to see if a bean is an instance of `SmartLifecycle`.  If it is, a `countDown()` operation is performed on a `latch`.  This suggests the code is now handling `SmartLifecycle` beans differently, potentially for synchronization or lifecycle management purposes",
            "avg_logprobs": -0.12644286074880826
        }
    },
    {
        "commit_hash": "1dfe737d0e57e8634d3bf48a9e49b001bd106cc3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/ResolvableType.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\t\tif (forClass(clazz).hasGenerics()) {\n+\t\t\t\t\t\tif (clazz.getTypeParameters().length > 0) {\n-\t\t\treturn getSuperType().hasUnresolvableGenerics();\n+\t\t\tClass<?> superclass = resolved.getSuperclass();\n+\t\t\tif (superclass != null && superclass != Object.class) {\n+\t\t\t\treturn getSuperType().hasUnresolvableGenerics();\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid ResolvableType creation for interface/superclass check",
        "commit_body": "See gh-30713\n",
        "linked_issues": [
            {
                "issue_id": "30713",
                "issue_title": "`ResolvableType.hasUnresolvableGenerics()` should cache its result",
                "issue_body": "As part of restoring lenient matching for events with unresolvable generics in #30712, it turns out that we're calling `ResolvableType.hasUnresolvableGenerics()` on the given event type quite often. It seems sensible to cache it within `ResolvableType` itself, also to the benefit of our conditional type converter matching etc.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a check for generic types in a class (`forClass(clazz).hasGenerics()`) with a check for the presence of type parameters (`clazz.getTypeParameters().length > 0`).  Crucially, it also adds a check for the superclass (`superclass != null && superclass != Object.class`) before delegating to `getSuperType().hasUnresolvableGenerics()`",
            "avg_logprobs": -0.17895599365234374
        }
    },
    {
        "commit_hash": "1e003a1c90fe7f5aa91f99a34fa5be53a43ad6d8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/SimpleBrokerMessageHandler.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tSimpMessageHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, SimpMessageHeaderAccessor.class);\n-\t\tif (accessor == null) {\n-\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\"No header accessor (not using the SimpMessagingTemplate?): \" + message);\n-\t\t}\n-",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary assertion",
        "commit_body": "Issue: SPR-14279\n",
        "linked_issues": [
            {
                "issue_id": "18851",
                "issue_title": "SimpleBrokerMessageHandler makes an assertion about the type of the MessageHeaderAccessor, but doesn't seem to care [SPR-14279]",
                "issue_body": "**[Dave Syer](https://jira.spring.io/secure/ViewProfile.jspa?name=david_syer)** opened **[SPR-14279](https://jira.spring.io/browse/SPR-14279?redirect=false)** and commented\n\nThere's an assertion here: https://github.com/spring-projects/spring-framework/blob/master/spring-messaging/src/main/java/org/springframework/messaging/simp/broker/SimpleBrokerMessageHandler.java#L227. It says that the type of the accessor must be SimpMessageHeaderAccessor. But then the accessor is never actually used, so I'm wondering if the assertion is redundant.\n\nIt causes issues if anyone adds a ChannelInterceptor which manipulates headers, which seems like a perfectly valid thing to do, independent of whether you are a websocket client or not.\n\n---\n\n**Affects:** 4.2.6\n\n**Reference URL:** https://github.com/spring-cloud/spring-cloud-sleuth/issues/276\n\n**Issue Links:**\n- #19357 StompSubProtocolHandler makes the same assumption about header accessor as SimpleBrokerMessageHandler used to\n\n**Backported to:** [4.2.7](https://github.com/spring-projects/spring-framework/milestone/144?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis is probably a left-over from before the static accessor methods were added to the MessageHeaderAccessor hierarchy that we can probably remove.\n",
                    "**[Dave Syer](https://jira.spring.io/secure/ViewProfile.jspa?name=david_syer)** commented\n\nCould this be back ported to 4.2 please?\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The original code checked if a `SimpMessageHeaderAccessor` was present in the message.  If not, it threw an `IllegalStateException`.  This change appears to be a *no-op* (no change) in the summarization.  The code snippet provided only shows the exception handling, not the surrounding logic, so the context of the change is missing.  Without more context, it's impossible to determine if this was a deliberate change or a result of refactoring elsewhere.",
            "avg_logprobs": -0.48519298553466794
        }
    },
    {
        "commit_hash": "1e07468d20c49baeb441425c7d0df053cb5d3cd1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (!Modifier.isStatic(mod)) {\n+\t\t\t\tif (!Modifier.isStatic(mod) && !Modifier.isPrivate(mod)) {\n-\t\t\t\t\telse if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) && !Modifier.isPrivate(mod) &&\n+\t\t\t\t\telse if (!Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Prevent warning about final private methods in CglibAopProxy",
        "commit_body": "Issue: SPR-15820\n",
        "linked_issues": [
            {
                "issue_id": "20375",
                "issue_title": "[Kotlin] Warning message about private final methods. [SPR-15820]",
                "issue_body": "**[Dariusz Bacinski](https://jira.spring.io/secure/ViewProfile.jspa?name=dbacinski)** opened **[SPR-15820](https://jira.spring.io/browse/SPR-15820?redirect=false)** and commented\n\nRecently in Kotlin version 1.1.2 there was a change regarding opening (making not final) Koltin classes . Now private methods are not being opened. This is actual change:\n\nhttps://github.com/JetBrains/kotlin/commit/5d4cefcc30615284b1b28d0fe0653f738371c167\n\nUnfortunately Spring is very verbose regarding printing warning into logs about final methods. Which leads to a warning about private final methods like this:\n\n\"INFO  org.springframework.aop.framework.CglibAopProxy  - Final method [private final ...] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.\"\n\nhttps://github.com/spring-projects/spring-framework/blob/0d0b879a2313b73bf85abfe45ff0a59897aa6a3e/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L262\n\nAs discussed with Sebastien Deleuze `@koltinlang` Slack this should be checked only for public and protected methods.\n\n\n\n---\n\n**Affects:** 5.0 RC2\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/1e07468d20c49baeb441425c7d0df053cb5d3cd1\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the conditional logic in `CglibAopProxy.java` to add a check for `Modifier.isPrivate` within the `if` block.  Previously, the `else if` block checked for non-public, non-protected, and non-private modifiers.  The change combines this check with the initial `if (!Modifier.isStatic(mod))` condition, effectively requiring the method to be neither static *nor* private to proceed",
            "avg_logprobs": -0.29021032333374025
        }
    },
    {
        "commit_hash": "1e0e477833c90d13d60b4f8ed0649ab7bb3e1541",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (dataSource instanceof DataSource) {\n-\t\t\treturn (DataSource) dataSource;\n+\t\tif (dataSource instanceof DataSource result) {\n+\t\t\treturn result;\n-\t\telse if (dataSource instanceof String) {\n-\t\t\treturn this.dataSourceLookup.getDataSource((String) dataSource);\n+\t\telse if (dataSource instanceof String name) {\n+\t\t\treturn this.dataSourceLookup.getDataSource(name);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply \"instanceof pattern matching\" in AbstractRoutingDataSource",
        "commit_body": "Closes gh-28011\n",
        "linked_issues": [
            {
                "issue_id": "28011",
                "issue_title": "Apply \"instanceof pattern matching\" in AbstractRoutingDataSource",
                "issue_body": null,
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `main` in 1e0e477833c90d13d60b4f8ed0649ab7bb3e1541 and polished in 04fbfddb13e45a729a93d88c5aee8092bff2ca9c.\r\n\r\nThanks\r\n\r\n----\r\n\r\nIn the future, please refrain from submitting PRs for such small changes. \r\n\r\nWe prefer that people collect several related changes and submit a single PR for all of them. Otherwise, we end up spending a lot of time managing individual PRs.",
                    "> In the future, please refrain from submitting PRs for such small changes.\r\n> \r\n> We prefer that people collect several related changes and submit a single PR for all of them. Otherwise, we end up spending a lot of time managing individual PRs.\r\n\r\n\r\n\ud83d\udc4c\ud83c\udffb\r\nYesterday, I wrote a test about `AbstractRoutingDataSource`, reviewed the code, and submitted PRs for the changes. Sorry for the small changes.\r\n\r\nI will try to submit big revisions in the future."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a traditional `if-else if` structure with a more concise and type-safe approach using the Java 14 pattern matching feature.  Specifically, the `instanceof` checks are now combined with a variable declaration and type assertion (`result` and `name`).  This change improves readability and reduces the risk of `ClassCastException` by ensuring the correct type is handled at compile time",
            "avg_logprobs": -0.2979802404131208
        }
    },
    {
        "commit_hash": "1e9ab53095ed601850d2fd780bffd8bee5919487",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/propertyeditors/CharacterEditor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * <p>The \"allowEmpty\" parameter controls whether an empty String is\n-\t * to be allowed in parsing, i.e. be interpreted as the {@code null}\n-\t * value when {@link #setAsText(String) text is being converted}. If\n-\t * {@code false}, an {@link IllegalArgumentException} will be thrown\n-\t * at that time.\n+\t * <p>The \"allowEmpty\" parameter controls whether an empty String is to be\n+\t * allowed in parsing, i.e. be interpreted as the {@code null} value when\n+\t * {@link #setAsText(String) text is being converted}. If {@code false},\n+\t * an {@link IllegalArgumentException} will be thrown at that time.\n-\t\telse if (text.length() != 1) {\n-\t\t\tthrow new IllegalArgumentException(\"String [\" + text + \"] with length \" +\n-\t\t\t\t\ttext.length() + \" cannot be converted to char type\");\n+\t\telse if (text.length() == 1) {\n+\t\t\tsetValue(Character.valueOf(text.charAt(0)));\n-\t\t\tsetValue(new Character(text.charAt(0)));\n+\t\t\tthrow new IllegalArgumentException(\"String [\" + text + \"] with length \" +\n+\t\t\t\t\ttext.length() + \" cannot be converted to char type: neither Unicode nor single character\");\n-\t\tsetValue(new Character((char) code));\n+\t\tsetValue(Character.valueOf((char) code));",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "CharacterEditor uses Character.valueOf(char) and throws a more descriptive exception",
        "commit_body": "Issue: SPR-12386\n",
        "linked_issues": [
            {
                "issue_id": "16994",
                "issue_title": "Improvement of CharacterEditor.setAsText() and setAsUnicode() [SPR-12386]",
                "issue_body": "**[Kang Baek-Kyu](https://jira.spring.io/secure/ViewProfile.jspa?name=overmindx)** opened **[SPR-12386](https://jira.spring.io/browse/SPR-12386?redirect=false)** and commented\n\nThe java.lang.Character.valueOf(char c) returns a Character instance representing the specified char value. If a new Character instance is not required, this method should generally be used in preference to the constructor Character(char), as this method is likely to yield significantly better space and time performance by caching frequently requested values.\n\nThis method will always cache values in the range '\\u0000' to '\\u007F', inclusive, and may cache other values outside of this range.\n\nSo I changed source like this\n\nsetValue(new Character(text.charAt(0)));\n-> setValue(Character.valueOf(text.charAt(0)));\n\nsetValue(new Character((char)code));\n-> setValue(Character.valueOf((char) code));\n\n\n---\n\n**Affects:** 4.1.1\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/pull/683\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/1e9ab53095ed601850d2fd780bffd8bee5919487\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! I've applied this as part of a general `CharacterEditor` revision.\n\nJuergen\n",
                    "**[Kang Baek-Kyu](https://jira.spring.io/secure/ViewProfile.jspa?name=overmindx)** commented\n\nThanks Juergen!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `CharacterEditor` modifies the handling of empty and single-character strings during parsing.  The crucial change is in the conditional logic:\\n\\n* **Original:**  Throws `IllegalArgumentException` if the input string's length is not 1.\\n* **Modified:**  Throws `IllegalArgumentException` if the input string's length is *1* (previously it was checking for *not* 1)",
            "avg_logprobs": -0.3196414566040039
        }
    },
    {
        "commit_hash": "1ed1167153fe3717e72e3a064bcde934304416fe",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/connection/SingleConnectionFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tfor (ExceptionListener listener : this.delegates) {\n+\t\t\t\t// Iterate over temporary copy in order to avoid ConcurrentModificationException,\n+\t\t\t\t// since listener invocations may in turn trigger registration of listeners...\n+\t\t\t\tfor (ExceptionListener listener : new LinkedHashSet<ExceptionListener>(this.delegates)) {",
        "change_count": 2,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Avoid ConcurrentModificationException in SingleConnectionFactory's AggregatedExceptionListener",
        "commit_body": "Issue: SPR-13421\n",
        "linked_issues": [
            {
                "issue_id": "18000",
                "issue_title": "ConcurrentModificationException in SingleConnectionFactory$AggregatedExceptionListener [SPR-13421]",
                "issue_body": "**[Mike Noordermeer](https://jira.spring.io/secure/ViewProfile.jspa?name=miken)** opened **[SPR-13421](https://jira.spring.io/browse/SPR-13421?redirect=false)** and commented\n\nThe `SingleConnectionFactory$AggregatedExceptionListener` objects contains a list of delegates in a `LinkedHashSet`, protected by the `SingleConnectionFactory.connectionMonitor` lock object.\n\nIf you configure a `SingleConnectionFactory` with `reconnectOnException = true`, and use it in a `SimpleMessageListenerContainer`, the following will happen on a `JMSException`:\n\n1. `SingleConnectionFactory$AggregatedExceptionListener.onException()` is called, and starts looping over the `delegates Set`\n2. At a certain point in time, it will call `SimpleMessageListenerContainer.onException()`, which calls `refreshSharedConnection()`, `createSharedConnection()`, `prepareSharedConnection()`, `connection.setExceptionListener()`\n3. This modifies the `delegates` list (from the same thread, so the locking does not help)\n4. A `ConcurrentModificationException` will be thrown in `SingleConnectionFactory$AggregatedExceptionListener.onException()`\n\nFull exception message:\n\n```\nException in thread \"ActiveMQ Connection Executor: tcp://localhost/127.0.0.1:61616@52892\" java.util.ConcurrentModificationException\n\tat java.util.LinkedHashMap$LinkedHashIterator.nextNode(LinkedHashMap.java:711)\n\tat java.util.LinkedHashMap$LinkedKeyIterator.next(LinkedHashMap.java:734)\n\tat org.springframework.jms.connection.SingleConnectionFactory$AggregatedExceptionListener.onException(SingleConnectionFactory.java:670)\n\tat org.apache.activemq.ActiveMQConnection$5.run(ActiveMQConnection.java:2004)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n\nThe list of delegates should probably be copied before iteration, or the `SimpleMessageListenerContainer` should not re-add itself as listener.\n\n---\n\n**Affects:** 4.1.7, 4.2.1\n\n**Issue Links:**\n- #15030 Memory leak with SimpleMessageListenerContainer and ChainedExceptionListener on Single/CachingConnectionFactory\n- #20294 JMS Integration with Tibco causes deadlock while using DefaultMessageListenerContainer\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/f562eb5ff6e4b0d7408b23977104238d8970da20, https://github.com/spring-projects/spring-framework/commit/1ed1167153fe3717e72e3a064bcde934304416fe\n\n**Backported to:** [4.1.8](https://github.com/spring-projects/spring-framework/milestone/132?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! Fixed for 4.2.2 now, and to be backported to 4.1.8.\n\nFeel free to give the upcoming `4.2.2.BUILD-SNAPSHOT` an early try...\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the loop iterating over `this.delegates` (a list of `ExceptionListener` objects).  Instead of iterating directly over the original `this.delegates` list, it now creates a temporary copy using `LinkedHashSet`.  This is done to prevent a `ConcurrentModificationException`.  The original code was likely susceptible to this exception because listener invocations within the loop might have added or removed elements from `this.delegates`, leading to inconsistencies during iteration.",
            "avg_logprobs": -0.17537181854248046
        }
    },
    {
        "commit_hash": "1f13516528a5884a1182649566a33f6dd0cc4e68",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t// Optimize for Mono\n-\t\t\tif (Mono.class.isAssignableFrom(method.getReturnType())) {\n+\t\t\t// For Mono and suspending functions not returning kotlinx.coroutines.flow.Flow\n+\t\t\tif (Mono.class.isAssignableFrom(method.getReturnType()) || (KotlinDetector.isSuspendingFunction(method) && !COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName()))) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix @Transactional support on suspending function",
        "commit_body": "With this commit, @Transactional on suspending functions\nreturning a value now commits the transaction properly.\n\nCloses gh-25998\n",
        "linked_issues": [
            {
                "issue_id": "25998",
                "issue_title": "@Transactional on suspending function returning a value always rollbacks",
                "issue_body": "**Affects:** 5.3.0",
                "issue_state": "closed",
                "issue_comment": [
                    "Could you please provide a repro project ?",
                    "The Repro:https://github.com/lujijiang/app-demo.git \r\nMaster branch is ok with use transactionalOperator, you can checkout issue code from branch  @TransactionalTest",
                    "You can test with post to http://localhost:8080/savePerson ,and the data is \r\n```json\r\n{\r\n    \"name\":\"lily\",\r\n    \"age\":100\r\n}\r\n```",
                    "I have been able to reproduce it, it only happens when the suspending function returns a value. In that case the reactive transaction is always rollbacked because of a concellation. See https://github.com/sdeleuze/demo-coroutines-tx for a detailed repro.",
                    "Great, waiting to be fixed."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change expands the condition for optimizing for `Mono` return types.  The original check only considered methods returning `Mono`.  The updated code now also includes methods that are Kotlin suspending functions *and* do not return a `kotlinx.coroutines.flow.Flow`.  This suggests an effort to handle a wider range of asynchronous return types, potentially including other suspending functions that might benefit from similar optimization strategies",
            "avg_logprobs": -0.204050722576323
        }
    },
    {
        "commit_hash": "204a50ee6c9c77ec1f6be479af2e979991130da1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceHttpRequestHandler.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t// For backwards compatibility\n-\t\tMediaType mediaType = getMediaType(resource);\n-\t\tif (mediaType != null) {\n-\t\t\treturn mediaType;\n-\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix compile issue",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removed a backwards-compatible check for `mediaType`.  Previously, if `getMediaType(resource)` returned a non-null `MediaType`, that `MediaType` was immediately returned.  Now, this check is omitted, implying that the `mediaType` will be determined by some other mechanism or that the previous behavior is no longer needed",
            "avg_logprobs": -0.25021231515066966
        }
    },
    {
        "commit_hash": "21267e56b7b4645e145422ee918eb75fab250f56",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/method/ControllerAdviceBean.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t/**\n+\t * Declared as {@code Object} since this may be a reference to a\n+\t * {@code String} representing the bean name or a reference to the actual\n+\t * bean instance.\n+\t */\n+\t/**\n+\t * A reference to the resolved bean instance, potentially lazily retrieved\n+\t * via the {@code BeanFactory}.\n+\t */\n+\tprivate Object resolvedBean;\n+\n+\t\t\tthis.resolvedBean = bean;\n+\t * <p>As of Spring Framework 5.2, once the bean instance has been resolved it\n+\t * will be cached, thereby avoiding repeated lookups in the {@code BeanFactory}.\n-\t\treturn (this.bean instanceof String ? obtainBeanFactory().getBean((String) this.bean) : this.bean);\n+\t\tif (this.resolvedBean == null) {\n+\t\t\t// this.bean must be a String representing the bean name if\n+\t\t\t// this.resolvedBean is null.\n+\t\t\tthis.resolvedBean = obtainBeanFactory().getBean((String) this.bean);\n+\t\t}\n+\t\treturn this.resolvedBean;",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Cache resolved bean instance in ControllerAdviceBean",
        "commit_body": "Prior to this commit, the resolveBean() method in ControllerAdviceBean\nlooked up the @ControllerAdvice bean instance in the ApplicationContext\nby name for every web request that involved lookups for global methods\nannotated with @ExceptionHandler, @InitBinder, and @ModelAttribute.\n\nThis commit avoids the need for such repeated lookups in the\nApplicationContext by caching the resolved @ControllerAdvice bean\ninstance within ControllerAdviceBean once it has been resolved.\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ControllerAdviceBean` significantly improves the efficiency of retrieving the bean instance.  Previously, the bean was retrieved from the `BeanFactory` every time the `bean` property was accessed.  Now, the bean is resolved once and cached in the `resolvedBean` field.  A crucial `if` statement checks if `resolvedBean` is null, ensuring that the `BeanFactory` is only queried if the bean hasn't already been resolved",
            "avg_logprobs": -0.22022550582885742
        }
    },
    {
        "commit_hash": "215e5f5682cd9aaf9c95105f3d2069298a364a0e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tsqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex);\n+\t\t\t\ttry {\n+\t\t\t\t\tsqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex);\n+\t\t\t\t}\n+\t\t\t\tcatch (SQLException ex) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"JDBC getParameterType call failed - using fallback method instead: \" + ex);\n+\t\t\t\t\t}\n+\t\t\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensively call getParameterType (which might fail for certain statements)",
        "commit_body": "Issue: SPR-15977\n",
        "linked_issues": [
            {
                "issue_id": "20528",
                "issue_title": "\"Parameter metadata not available for the given statement\" SQL Exception after upgrading to Spring 5.0 RC4 [SPR-15977]",
                "issue_body": "**[Bogdan Dumitrescu](https://jira.spring.io/secure/ViewProfile.jspa?name=bogdanbux)** opened **[SPR-15977](https://jira.spring.io/browse/SPR-15977?redirect=false)** and commented\n\nScenario:\n\n- execute a prepared statement using JdbcTemplate inserting a row into MySQL 5.5:\n\njdbcTemplate.update(\"insert into users (id, name, description) values (?, ?, ?)\", id, name, description);\n\n- condition to reproduce: one of the arguments of the prepared statement is null. The column definition in MySQL corresponding to the null argument accepts null values.\n\nWhen trying to execute the above with Spring 5.0 RC4 we are getting a \"java.sql.SQLException: Parameter metadata not available for the given statement\".\n\nThe same code executes fine when using the 4.3.11.RELEASE of spring-jdbc.\n\nUsing version 5.1.44 of mysql-connector-java, we're seeing the same behaviour on the following MySQL versions:\n\nVer 14.14 Distrib 5.5.53\nVer 14.14 Distrib 5.7.18-15\n\n---\n\n**Affects:** 5.0 RC4\n\n**Attachments:**\n- [stacktrace.txt](https://jira.spring.io/secure/attachment/25108/stacktrace.txt) (_3.65 kB_)\n\n**Issue Links:**\n- #18399 Raise JDBC driver feature baseline to JDBC 4.0+\n- #20687 Doc: ParameterMetaData.getParameterType performance on Oracle 12c\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nCould you post the stacktrace for the underlying `SQLException` as well, please? I'm pretty sure this is a side effect of #18399 but it'd be great to know where exactly it originates... It's probably in `StatementCreatorUtils.setNull` but it'd be great to double-check.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've reintroduced a catch block around our `getParameterType` call in `StatementCreatorUtils.setNull` which I'm pretty sure is the root cause here. Spring Framework 4.x had a defensive catch block there against older JDBC drivers which implicitly covered this but got removed in the JDBC baseline upgrade for 5.0. Now it's not about general lack of support for `getParameterType` but rather just about failing for specific statements, so it should be sufficient to simply locally catch and log the `SQLException` and proceed with our fallback code path.\n\nTo be committed and backported tomorrow. It would nevertheless be great to verify that this matches your particular case...\n",
                    "**[Bogdan Dumitrescu](https://jira.spring.io/secure/ViewProfile.jspa?name=bogdanbux)** commented\n\nFirst of all, thank you for fixing this so quickly!\n\nI've added the stack trace from the underlying SQLException, just for completeness. We were using mysql-connector 5.1.36 for this stack trace, but we reproduced the error after upgrading to 5.1.44 as well.\n\nI'll test your fix as it's backported and let you know. Thanks again!\n",
                    "**[Bogdan Dumitrescu](https://jira.spring.io/secure/ViewProfile.jspa?name=bogdanbux)** commented\n\nI can confirm that with the latest 5.0 snapshot build our problem is solved - the row with null values is successfully saved to the database. Thank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a `try-catch` block around the `getParameterType` call.  If a `SQLException` occurs during the retrieval of the parameter type, a debug log message is printed, and the fallback method (presumably the one outside the `try-catch`) is used.  This significantly improves robustness by handling potential exceptions during parameter type retrieval",
            "avg_logprobs": -0.18316564168015573
        }
    },
    {
        "commit_hash": "2172b99fee345f0068e9d1851bf5ed6d0ba36633",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-import org.springframework.util.StringUtils;\n-\t\tif(!StringUtils.hasText(ex.getMessage())) {\n-\t\t\tclose(CloseStatus.SERVER_ERROR);\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(\"WebSocket session completed with error\", ex);\n-\t\telse {\n-\t\t\tclose(CloseStatus.SERVER_ERROR.withReason(ex.getMessage()));\n+\t\telse if (logger.isInfoEnabled()) {\n+\t\t\tlogger.info(\"WebSocket session completed with error: \" + ex.getMessage());\n+\t\tclose(CloseStatus.SERVER_ERROR);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing contribution",
        "commit_body": "Closes gh-28836\n",
        "linked_issues": [
            {
                "issue_id": "28836",
                "issue_title": "Avoid IllegalArgumentException when setting WebSocket error status",
                "issue_body": "Fixing internal error, when the message of an exception doesn't contain any text.\r\n\r\nIn my application, this probably caused a memory leak. (Which I will retest with a fork, but it will take some time because the issue happened very infrequently)\r\n\r\nThis is how it looks in the log:\r\n```\r\njava.lang.IllegalArgumentException: Reason must not be empty\r\n\tat org.springframework.util.Assert.hasText(Assert.java:289) ~[spring-core-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.CloseStatus.withReason(CloseStatus.java:184) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.onError(AbstractListenerWebSocketSession.java:250) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onError(FluxDoFinally.java:119) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onError(MonoIgnoreElements.java:84) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:842) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:608) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:588) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.innerError(FluxFlatMap.java:863) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapInner.onError(FluxFlatMap.java:990) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onError(FluxPeekFuseable.java:903) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.onError(MonoSubscribeOn.java:152) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.SinkEmptyMulticast$VoidInner.error(SinkEmptyMulticast.java:247) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.SinkEmptyMulticast.tryEmitError(SinkEmptyMulticast.java:88) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.SinkEmptySerialized.tryEmitError(SinkEmptySerialized.java:65) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.onError(AbstractListenerWebSocketSession.java:245) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat org.springframework.http.server.reactive.WriteResultPublisher$State.publishError(WriteResultPublisher.java:277) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.WriteResultPublisher.publishError(WriteResultPublisher.java:99) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.AbstractListenerWriteProcessor$State.onError(AbstractListenerWriteProcessor.java:479) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.AbstractListenerWriteProcessor.onError(AbstractListenerWriteProcessor.java:132) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher$State.onError(AbstractListenerReadPublisher.java:497) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.onError(AbstractListenerReadPublisher.java:145) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.handleError(AbstractListenerWebSocketSession.java:208) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.adapter.StandardWebSocketHandlerAdapter.onError(StandardWebSocketHandlerAdapter.java:120) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.onError(WsHttpUpgradeHandler.java:234) ~[tomcat-embed-websocket-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.upgradeDispatch(WsHttpUpgradeHandler.java:161) ~[tomcat-embed-websocket-9.0.64.jar!/:na]\r\n\tat org.apache.coyote.http11.upgrade.UpgradeProcessorInternal.dispatch(UpgradeProcessorInternal.java:60) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:890) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1787) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "I think we could switch to a very generic message instead.",
                    "Any suggestions? Then I will change the PR accordingly.",
                    "I've left it as a status-only response since the status code itself communicates the nature. I've also added logging with the exception message at INFO and the full stacktrace at DEBUG."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the error handling for WebSocket sessions.  Previously, if the exception message was empty, a `SERVER_ERROR` close was issued without logging.  Now, if the exception message is present, it logs the message at the INFO level, and if the message is empty, it logs the exception at the DEBUG level.  Crucially, the `close` method is called *regardless* of whether a message is logged, ensuring consistent error handling",
            "avg_logprobs": -0.3484695053100586
        }
    },
    {
        "commit_hash": "224e36948412b258a9e8f4336aa06e5f3645220b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\n+\t/**\n+\t * Common prefix that DispatcherServlet's default strategy attributes start with.\n+\t */\n+        private static final String DEFAULT_STRATEGIES_PREFIX = \"org.springframework.web.servlet\";\n+\t\n-\t\t\tthrow new IllegalStateException(\"Could not load 'DispatcherServlet.properties': \" + ex.getMessage());\n+\t\t\tthrow new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n-\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(\"org.springframework.web.servlet\")) {\n+\t\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reuse constant in DispatcherServlet",
        "commit_body": "See gh-1398\n",
        "linked_issues": [
            {
                "issue_id": "1398",
                "issue_title": "Do not use hard coded strings",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": [
                    "Merged, thanks!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the `DispatcherServlet` class, specifically how it handles loading configuration properties.  The most significant change is the introduction of a constant `DEFAULT_STRATEGIES_PREFIX` to store the prefix \"org.springframework.web.servlet\".  This change replaces hardcoded strings with a named constant, improving readability and maintainability",
            "avg_logprobs": -0.1967953300476074
        }
    },
    {
        "commit_hash": "2270df515b040d8612c691acc0102d1a224bcd82",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tString urlString = url.toString();\n+\t\t\tString cleanedPath = StringUtils.cleanPath(urlString);\n+\t\t\tif (!cleanedPath.equals(urlString)) {\n+\t\t\t\t// Prefer cleaned URL, aligned with UrlResource#createRelative(String)\n+\t\t\t\ttry {\n+\t\t\t\t\treturn new UrlResource(ResourceUtils.toURI(cleanedPath));\n+\t\t\t\t}\n+\t\t\t\tcatch (URISyntaxException | MalformedURLException ex) {\n+\t\t\t\t\t// Fallback to regular URL construction below...\n+\t\t\t\t}\n+\t\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Enforce cleaned URL for root resource from ClassLoader",
        "commit_body": "Closes gh-32828\n",
        "linked_issues": [
            {
                "issue_id": "32828",
                "issue_title": "Inconsistent use of cleaned URLs in PathMatchingResourcePatternResolver",
                "issue_body": "We have written our own plugin framework for Spring Boot where plugins (additional jar files) are loaded in their own PluginApplicationContext (derived from GenericApplicationContext) with their own PluginClassLoader (derived from URLClassLoader). Our plugin framework supports dynamic loading and unloading of plugins. \r\n\r\nWhen a plugin is loadded, the jar file is copied with a unique temporary name to our work directory before loading the it with our PluginCalssLoader and creating the PluginApplicationContext. \r\n\r\nWhen a plugin is unloaded, the PluginApplicationContext  is closed, the PluginClassLoader is closed and the temporary jar file is deleted.\r\n\r\nEverything works fine with Spring Boot 3.1 up to Spring Boot 3.1.11. But when we switch to Spring Boot 3.2 (even Spring Boot 3.2.5), the unloading does now work properly. The temporary jar file cannot be deleted anymore because the classloader is not freed. \r\n\r\nWhat can be the reason for this issue? What has changed between the releases?\r\n\r\nKind regards\r\nJ\u00f6rg",
                "issue_state": "closed",
                "issue_comment": [
                    "This may be due to https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.2-Release-Notes#nested-jar-support but that's only a guess. To be more specific, we'd need to know much more about what you're doing, how your running the application, and so on.\r\n\r\nIf you would like us to spend some more time investigating, please spend some time providing a complete yet minimal sample that reproduces the problem. You can share it with us by pushing it to a separate repository on GitHub or by zipping it up and attaching it to this issue. as we don't know enough about what you're doing and how you're running the Spring Boot application.\r\n\r\n",
                    "Hi Andy,\r\n\r\nI've put together a small sample which demonstrates the issue (attached zip). I've reduced our plugin framework to only the relevant parts and removed everything else like dependency management, resource loading and everything else. While assembling the demo, I've seen that there must have been something changed in the request mapping stuff of the Spring Framework. As long as I do not add @Controller classes to my plugins, they are unloaded sucessfully in Spring Boot 3.2. If I add @Controller classes to my plugins, they are unloaded successfully in Spring Boot 3.1.11 but not anymore in Spring Boot 3.2.5.\r\n\r\nIf you unzip the enclosed zip, you have 5 projects and a runtime folder:\r\n\r\n1. **demo**:  the main Spring Boot application, containing the plugin framework implementation\r\n2. **demo-layout**: the custom layout we use for packaging plugin jars\r\n3. **demo-plugin**: the parent BOM which is used by all plugin projects\r\n4. **demo-plugin1**: a simple demo plugin with one simple controller\r\n5. **demo-plugin2**: a simple demo plugin with one simple controller\r\n6. **runtime**: the runtime folder which contains everything to start the demo\r\n \r\nAfter you have extracted the zip, please execute the build-all.bat in the root folder. It builds everything and copies the targets to the correct folders. The plugin jars are copied to the plugins folder, everything else to the lib folder. Afterwards please execute the startServer.bat in runtime\\bin. It should start the small web application and you should be able to see that two plugins are activated when you open \"localhost:8081/list-plugins\" in a browser. When you now enter the url \"localhost:8081/deactivate-plugin?pluginId=demo-plugin1\" you should see a line \"Deleted file ..\\work\\demo-plugin1-1.0.0.0-<timestamp>.jar. That means the plugin class loader is completely unloaded and the jar could be deleted (the expected behaviour).\r\n\r\nNow please change the Spring Boot version to 3.2.5 in demo\\pom.xml, demo-layout\\pom.xml and demo-plugin\\pom.xml and recompile and restart everything. If you again deactivate the plugin, you will see that the output is now \"Unable to delete... \" allthough nothing has changed in our code. \r\n\r\nSo the problem must be in the Spring Framework and I need your help if I have to change something in our code.\r\n\r\nKind regards\r\nJ\u00f6rg\r\n[test-project.zip](https://github.com/spring-projects/spring-boot/files/15275106/test-project.zip)\r\n",
                    "Hi Andy,\r\n\r\nI have attached a demo zip and some instructions to reproduce the issue to the Github thread.\r\nAny help would be great because at some time we have to switch to Spring Boot 3.2.\r\n\r\nKind regards\r\nJ\u00f6rg\r\n",
                    "Thanks for the sample. I think I've managed to reproduce the behavior that you have described with a file handle being leaked but it is hard to be certain as the sample is Windows-specific and I use macOS for my day-to-day work. macOS (like Linux) also doesn't prevent a file from being deleted when it's open but I can see the leaked file handle using `lsof`.\r\n\r\nThe underlying cause of the problem is two URLs that are different but point to the same resource. They look something like this:\r\n\r\n- `file:/Users/awilkinson/Downloads/test-project/runtime/bin/../work/demo-plugin1-1.0.0.0-3486320809144453673.jar`\r\n- `file:/Users/awilkinson/Downloads/test-project/runtime/work/demo-plugin1-1.0.0.0-3486320809144453673.jar`\r\n\r\nThis difference results in the jar being opened twice but only closed once. As result there are two open file handles for the plugin jar when it is activated and one remains once it has been deactivated.\r\n\r\nI first suspected that this was due to the [new nested jar support](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.2-Release-Notes#nested-jar-support) but switching to the `CLASSIC` loader does not help. In fact, it makes things worse as there are three open file handles once the plugin has been activated and two remain once it has been deactivated. I also tried running `DemoApplication` in my IDE so that a Spring Boot's nested jar supported isn't used and the problem still occurs.\r\n\r\nGiven that the problem occurs without Spring Boot's nested jar support and only occurs when a component is found by classpath scanning of the plugin, I next suspected it was due to a change in Spring Framework and this appears to be the case. With the `demo` project updated to set the `spring-framework.version` property to 6.0.19 and rebuilt, the problem no longer occurs. Note that this downgrade requires running the app with `-Dspring.autoconfigure.exclude=org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration` as the task scheduling auto-configuration requires Spring Framework 6.2.x. We'll transfer this issue to the Framework team so that they can investigate.\r\n\r\nIn the meantime, the problem can be worked around by using a canonical directory for the `workDir` in `PluginLoader`:\r\n\r\n```\r\nFile workDir = new File(PluginConstants.WORK_DIR).getCanonicalFile();\r\n```\r\n\r\nThis removes the `bin/../` from the first URL so it's then matched by the second.\r\n\r\n",
                    "Some notes for the Framework team that may help. The TL;DR is that I think that https://github.com/spring-projects/spring-framework/commit/934231729123f57542f9bd974ec39a4222c7af22 is the cause of the regression as it calls `StringUtils.cleanPath` which 6.0 does not do.\r\n\r\nOther observations that led me to this conclusion follow:\r\n\r\nThe two different URLs are used in close proximity to each other within `scanCandidateComponents`. When the first with the `bin/../` is used, the stack is as follows:\r\n\r\n```\r\nUrlJarFiles.getOrCreate(boolean, URL) line: 72\t\r\nJarUrlConnection.connect() line: 289\t\r\nJarUrlConnection.getJarFile() line: 99\t\r\nPathMatchingResourcePatternResolver.doFindPathMatchingJarResources(Resource, URL, String) line: 683\t\r\nPathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 586\t\r\nPathMatchingResourcePatternResolver.getResources(String) line: 334\t\r\nPluginApplicationContext(AbstractApplicationContext).getResources(String) line: 1511\t\r\nPluginApplicationContext(GenericApplicationContext).getResources(String) line: 262\t\r\nClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).scanCandidateComponents(String) line: 457\t\r\nClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 351\t\r\nClassPathBeanDefinitionScanner.doScan(String...) line: 277\t\r\nClassPathBeanDefinitionScanner.scan(String...) line: 255\t\r\nPluginApplicationContext.scan(String...) line: 44\t\r\nStandardPluginRegistry.doLoadPlugin(StandardPlugin) line: 243\t\r\nStandardPluginRegistry.loadPlugin(StandardPlugin) line: 229\t\r\nStandardPluginRegistry.loadPlugins() line: 206\t\r\nStandardPluginRegistry.afterSingletonsInstantiated() line: 156\t\r\nDefaultListableBeanFactory.preInstantiateSingletons() line: 986\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 962\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).refresh() line: 624\t\r\nAnnotationConfigServletWebServerApplicationContext(ServletWebServerApplicationContext).refresh() line: 146\t\r\nSpringApplication.refresh(ConfigurableApplicationContext) line: 754\t\r\nSpringApplication.refreshContext(ConfigurableApplicationContext) line: 456\t\r\nSpringApplication.run(String...) line: 334\t\r\nSpringApplication.run(Class<?>[], String[]) line: 1354\t\r\nSpringApplication.run(Class<?>, String...) line: 1343\t\r\nDemoApplication.main(String[]) line: 49\t\r\n```\r\n\r\nWhen the second URL without the `bin/../` is used, the stack is as follows:\r\n\r\n```\r\nUrlJarFiles.getOrCreate(boolean, URL) line: 72\t\r\nJarUrlConnection.connect() line: 289\t\r\nJarUrlConnection.getInputStream() line: 195\t\r\nUrlResource.getInputStream() line: 232\t\t\r\nSimpleMetadataReader.getClassReader(Resource) line: 54\t\r\nSimpleMetadataReader.<init>(Resource, ClassLoader) line: 48\t\r\nCachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 103\t\r\nCachingMetadataReaderFactory.getMetadataReader(Resource) line: 122\t\r\nClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).scanCandidateComponents(String) line: 470\t\r\nClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 351\t\r\nClassPathBeanDefinitionScanner.doScan(String...) line: 277\t\r\nClassPathBeanDefinitionScanner.scan(String...) line: 255\t\r\nPluginApplicationContext.scan(String...) line: 44\t\r\nStandardPluginRegistry.doLoadPlugin(StandardPlugin) line: 243\t\r\nStandardPluginRegistry.loadPlugin(StandardPlugin) line: 229\t\r\nStandardPluginRegistry.loadPlugins() line: 206\t\r\nStandardPluginRegistry.afterSingletonsInstantiated() line: 156\t\r\nDefaultListableBeanFactory.preInstantiateSingletons() line: 986\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 962\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).refresh() line: 624\t\r\nAnnotationConfigServletWebServerApplicationContext(ServletWebServerApplicationContext).refresh() line: 146\t\r\nSpringApplication.refresh(ConfigurableApplicationContext) line: 754\t\r\nSpringApplication.refreshContext(ConfigurableApplicationContext) line: 456\t\r\nSpringApplication.run(String...) line: 334\t\r\nSpringApplication.run(Class<?>[], String[]) line: 1354\t\r\nSpringApplication.run(Class<?>, String...) line: 1343\t\r\nDemoApplication.main(String[]) line: 49\t\r\n```\r\n\r\nA URL in the second form can be seen in trace-level logging from `ClassPathBeanDefinitionScanner`:\r\n\r\n```\r\n2024-05-15T11:16:48.334+01:00 TRACE 33513 --- [           main] o.s.c.a.ClassPathBeanDefinitionScanner   : Scanning URL [jar:file:/Users/awilkinson/Downloads/test-project/runtime/work/demo-plugin1-1.0.0.0-16251652149578762890.jar!/com/example/demo/plugin1/DemoController.class]\r\n```\r\n\r\nUpon downgrading to Framework 6.0.19, this logging changes and the URL's in the first form with the `bin/../`:\r\n\r\n```\r\n2024-05-15T11:18:15.196+01:00 TRACE 33560 --- [           main] o.s.c.a.ClassPathBeanDefinitionScanner   : Scanning URL [jar:file:/Users/awilkinson/Downloads/test-project/runtime/bin/../work/demo-plugin1-1.0.0.0-14759968729258928182.jar!/com/example/demo/plugin1/DemoController.class]\r\n```\r\n\r\n6.1 is cleaning the path when going from a URL for a root dir resource to a URL for a specific resource that matches the sub-pattern. `createRelative` is called on a `UrlResource` with the URL `jar:file:/Users/awilkinson/Downloads/test-project/runtime/bin/../work/demo-plugin1-1.0.0.0-12436866063543419511.jar!/com/example/demo/plugin1/` with a `relativePath` of `DemoController.class`. This results in a `UrlResource` with the URL `jar:file:/Users/awilkinson/Downloads/test-project/runtime/work/demo-plugin1-1.0.0.0-12436866063543419511.jar!/com/example/demo/plugin1/DemoController.class` due to path cleaning that's now performed in `ResourceUtils.toURL(String)`.\r\n",
                    "It looks like `ClassLoader.getResources` itself returns a uncleaned path with a `../` segment there, and our `convertClassLoaderURL` method turns it into a `UrlResource(URL)` due to a jar location - whereas it would turn it into a `FileSystemResource` with a clean path in case of a file location. So we should consistently use cleaned URL paths even for the jar location case there, I suppose.",
                    "This should be resolved based on my understanding above, consistently cleaning URLs from the ClassLoader.\r\n@wilkinsona please give the upcoming 6.1.7 snapshot a try with Boot in such a scenario!",
                    "Unfortunately, the sample is broken as before when using 6.1.7-SNAPSHOT although the exact behavior has changed. Now, the first URL that's used does not contain `bin/../`. The stack at this point is as follows:\r\n\r\n```\r\nUrlJarFiles.getOrCreate(boolean, URL) line: 72\t\r\nJarUrlConnection.connect() line: 289\t\r\nJarUrlConnection.getJarFile() line: 99\t\r\nPathMatchingResourcePatternResolver.doFindPathMatchingJarResources(Resource, URL, String) line: 694\t\r\nPathMatchingResourcePatternResolver.findPathMatchingResources(String) line: 597\t\r\nPathMatchingResourcePatternResolver.getResources(String) line: 334\t\r\nPluginApplicationContext(AbstractApplicationContext).getResources(String) line: 1511\t\r\nPluginApplicationContext(GenericApplicationContext).getResources(String) line: 263\t\r\nClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).scanCandidateComponents(String) line: 457\t\r\nClassPathBeanDefinitionScanner(ClassPathScanningCandidateComponentProvider).findCandidateComponents(String) line: 351\t\r\nClassPathBeanDefinitionScanner.doScan(String...) line: 277\t\r\nClassPathBeanDefinitionScanner.scan(String...) line: 255\t\r\nPluginApplicationContext.scan(String...) line: 44\t\r\nStandardPluginRegistry.doLoadPlugin(StandardPlugin) line: 243\t\r\nStandardPluginRegistry.loadPlugin(StandardPlugin) line: 229\t\r\nStandardPluginRegistry.loadPlugins() line: 206\t\r\nStandardPluginRegistry.afterSingletonsInstantiated() line: 156\t\r\nDefaultListableBeanFactory.preInstantiateSingletons() line: 986\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 962\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).refresh() line: 624\t\r\nAnnotationConfigServletWebServerApplicationContext(ServletWebServerApplicationContext).refresh() line: 146\t\r\nSpringApplication.refresh(ConfigurableApplicationContext) line: 754\t\r\nSpringApplication.refreshContext(ConfigurableApplicationContext) line: 456\t\r\nSpringApplication.run(String...) line: 335\t\r\nSpringApplication.run(Class<?>[], String[]) line: 1363\t\r\nSpringApplication.run(Class<?>, String...) line: 1352\t\r\nDemoApplication.main(String[]) line: 49\t\r\n```\r\n\r\nThe second URL that's used now does contain `bin/../`. The stack at this point is as follows:\r\n\r\n```\r\nUrlJarFiles.getOrCreate(boolean, URL) line: 72\t\r\nJarUrlConnection.connect() line: 289\t\r\nJarUrlConnection.getInputStream() line: 195\t\r\nPluginClassLoader(URLClassLoader).getResourceAsStream(String) line: 296\t\r\nClassPathResource.getInputStream() line: 209\t\r\nSimpleMetadataReader.getClassReader(Resource) line: 54\t\r\nSimpleMetadataReader.<init>(Resource, ClassLoader) line: 48\t\r\nCachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(Resource) line: 103\t\r\nCachingMetadataReaderFactory.getMetadataReader(Resource) line: 122\t\r\nCachingMetadataReaderFactory(SimpleMetadataReaderFactory).getMetadataReader(String) line: 81\t\r\nConfigurationClassParser.asSourceClass(String, Predicate<String>) line: 630\t\r\nConfigurationClassParser.asSourceClass(ConfigurationClass, Predicate<String>) line: 579\t\r\nConfigurationClassParser.processConfigurationClass(ConfigurationClass, Predicate<String>) line: 244\t\r\nConfigurationClassParser.parse(AnnotationMetadata, String) line: 197\t\r\nConfigurationClassParser.parse(Set<BeanDefinitionHolder>) line: 165\t\r\nConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry) line: 417\t\r\nConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) line: 290\t\r\nPostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(Collection<BeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry, ApplicationStartup) line: 349\t\r\nPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List<BeanFactoryPostProcessor>) line: 118\t\r\nPluginApplicationContext(AbstractApplicationContext).invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) line: 788\t\r\nPluginApplicationContext(AbstractApplicationContext).refresh() line: 606\t\r\nStandardPluginRegistry.doLoadPlugin(StandardPlugin) line: 246\t\r\nStandardPluginRegistry.loadPlugin(StandardPlugin) line: 229\t\r\nStandardPluginRegistry.loadPlugins() line: 206\t\r\nStandardPluginRegistry.afterSingletonsInstantiated() line: 156\t\r\nDefaultListableBeanFactory.preInstantiateSingletons() line: 986\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 962\t\r\nAnnotationConfigServletWebServerApplicationContext(AbstractApplicationContext).refresh() line: 624\t\r\nAnnotationConfigServletWebServerApplicationContext(ServletWebServerApplicationContext).refresh() line: 146\t\r\nSpringApplication.refresh(ConfigurableApplicationContext) line: 754\t\r\nSpringApplication.refreshContext(ConfigurableApplicationContext) line: 456\t\r\nSpringApplication.run(String...) line: 335\t\r\nSpringApplication.run(Class<?>[], String[]) line: 1363\t\r\nSpringApplication.run(Class<?>, String...) line: 1352\t\r\nDemoApplication.main(String[]) line: 49\t\r\n```\r\n\r\nAn interesting change here is that, in the second use of the URL, it's now coming from a `ClassPathResource`. With 6.1.6, the second use of the URL was coming from a `UrlResource`.\r\n\r\nI think this explains why the sample continues to be broken as the class loader has the URL `file:/Users/awilkinson/Downloads/test-project/runtime/bin/../work/demo-plugin1-1.0.0.0-12470862329384363385.jar` on its path. The work around that I described above (using the canonical path when working with the files that populate the plugin's classpath) continues to work as both sides are then using the cleaned path. ",
                    "Thanks for the detailed analysis, @wilkinsona! Unfortunately it gets really involved from here since `ClassPathResource` delegates to `ClassLoader.getResourceAsStream(String)` which *internally* resolves a URL that it then obtains the stream for. We don't control those internal URLs at all unless we change the access path to `ClassLoader.getResource(String)`, cleaning the returned URL and then manually opening a stream for it. Since that might bypass optimizations in custom `ClassLoader` implementations, I'm not inclined to go there.\r\n\r\nSo for the time being, `PathMatchingResourcePatternResolver` exposes a consistent set of URLs in its results which is a sensible measure in general. Any subsequent direct class path access, be it from `ClassPathResource` or through direct `ClassLoader` usage, will still internally use the original URL though. From that perspective, it seems necessary to enforce clean URLs in the `PluginClassLoader` itself if it expects to have the same resource accessed in a uniform way (in order to be able to release each resource in a consistent fashion).",
                    "I really appreciate your help on this issue. I've changed our PluginClassLoader to use the getCanonicalFile() method and everything works fine now, even in our full blown plugin framework which supports a lot more than the simple demo project.\r\n\r\nThank you again for your help. We can now finally switch to the latest Spring Boot version and no longer have to worry about the end of the 3.1 version.\r\n\r\nKind regards\r\nJ\u00f6rg"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `PathMatchingResourcePatternResolver` adds a check to see if the cleaned path (`cleanedPath`) of a URL differs from the original URL string (`urlString`).  If they differ, it attempts to create a new `UrlResource` using the cleaned path.  This is a preference for the cleaned path, likely to resolve potential issues with inconsistent or incorrectly formatted paths",
            "avg_logprobs": -0.22184389114379882
        }
    },
    {
        "commit_hash": "22db1ac14635eb6599eff1708f02a4f7a2cb63eb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.core.CoroutinesUtils;\n+import org.springframework.core.KotlinDetector;\n+ * @author Sebastien Deleuze\n-\t\tint count = method.getParameterCount();\n+\t\tint count = (KotlinDetector.isSuspendingFunction(method) ? method.getParameterCount() - 1 : method.getParameterCount());\n+\t\t\tif (KotlinDetector.isSuspendingFunction(this.method)) {\n+\t\t\t\treturn CoroutinesUtils.invokeSuspendingFunction(this.method, bean, args);\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add Coroutines support for `@EventListener`",
        "commit_body": "Closes gh-28343\n",
        "linked_issues": [
            {
                "issue_id": "28343",
                "issue_title": "Add Coroutines support for `@EventListener`",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://spring.io/security-policy !!!\r\n-->\r\n**Affects:** Any\r\n\r\n---\r\n<!--\r\nThanks for taking the time to create an issue. Please read the following:\r\n\r\n- Questions should be asked on Stack Overflow.\r\n- For bugs, specify affected versions and explain what you are trying to do.\r\n- For enhancements, provide context and describe the problem.\r\n\r\nIssue or Pull Request? Create only one, not both. GitHub treats them as the same.\r\nIf unsure, start with an issue, and if you submit a pull request later, the\r\nissue will be closed as superseded.\r\n-->\r\nSpring introduced first-class support to kotlin and coroutines and while almost everything works flawlessly I really miss the support for coroutines in the `@EventListener`.\r\n\r\nI used in the past [spring-kotlin-coroutine ](https://github.com/konrad-kaminski/spring-kotlin-coroutine)however this project is not updated for 3 years so I wonder if such support could be added to core Spring.",
                "issue_state": "closed",
                "issue_comment": [
                    "It would be really helpful, do you have any working implementation that could replace it for now?",
                    "The original [Spring Kotlin Corutines](https://github.com/konrad-kaminski/spring-kotlin-coroutine) has great Kotlin Coroutines support, unfortunately it is discontinued. A lot of features are not support in current Spring framework although Spring has supported Kotlin for years.\r\n\r\nI used Kotlin Coroutines/Spring Boot in my project, and I found there are still some problems when using Coroutines in events, cache, schedule/async and Spring Security DSL config. I had to wrap the corourtines codes with a `runBlocking` to use it in the existing facilities of Spring.",
                    "Spring supports Coroutines where it support reactive types, and since #21831 supports that use case, we should indeed support this use case.",
                    "@sdeleuze I would like get the following cases working in a Spring/Kotlin Coroutines project.\r\n\r\n1. Allow a `suspend` `main` fun for the application entry.\r\n2. Coroutines version of `ApplicationEventListener`, `@EventListener` on a `suspend` fun or a fun returns a Kotlin `Flow`.\r\n3. Make cache annotations work on any `suspend` fun or `Flow` return type.\r\n4. Make it work in Spring Security Kotlin DSL `http{}`(similar to `route`, there is `coRoute` for coroutines)\r\n5. provides a coroutines versions of CommandLineRunner, ApplicationRunner, ReactiveAuditorAware, ReactiveEntityCallback, etc.",
                    "From my point of view, Spring should not support `suspend` everywhere, but I fully understand it is not always easy to draw the line between what should be supported and what should not. Notice that this question is not specific to Kotlin Coroutines, but is also true for our Reactive support.\r\n\r\nSpring should provides Coroutines support where Reactive types are supported. For example, we recently added support for Reactive/Coroutines to `@Scheduled` (see #29924).\r\n\r\nFor event listeners, we indeed support Reactive types on event listeners so it would make sense to support Coroutines as well (see https://github.com/spring-projects/spring-framework/issues/27515 related issue even if more focused on transactional support).\r\n\r\nSo let's try to make that happen early in 6.1.x release cycle (tentatively planned for RC2 but that may be postponed depending on my bandwidth).",
                    "Great to see schedule, cache, event listener to get Reactive/Coroutines support in Spring 6.1.",
                    "@sdeleuze awesome work! Super thanks!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ApplicationListenerMethodAdapter` addresses Kotlin coroutines.  It now differentiates between regular methods and suspending functions (Kotlin).  If the method is suspending, it decrements the parameter count by 1 and uses `CoroutinesUtils` to invoke the suspending function.  This change likely improves compatibility with Kotlin coroutines by correctly handling the extra parameter introduced by the coroutine context",
            "avg_logprobs": -0.2824334745053892
        }
    },
    {
        "commit_hash": "231433f5406453069aa125329be042d5e32ddff0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ReflectionUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tthrow new IllegalStateException(\"Unexpected reflection exception - \" + ex.getClass().getName() + \": \"\n-\t\t\t\t\t+ ex.getMessage());\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"Unexpected reflection exception - \" + ex.getClass().getName() + \": \" + ex.getMessage());\n-\t\t\t\tif (name.equals(method.getName())\n-\t\t\t\t\t\t&& (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {\n+\t\t\t\tif (name.equals(method.getName()) &&\n+\t\t\t\t\t\t(paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing (cherry picked from commit 6021822)",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes unnecessary line breaks and adds whitespace for better readability within the `if` statement.  No functional change to the conditional logic itself.  The `if` statement now uses a more concise style",
            "avg_logprobs": -0.31069991805336694
        }
    },
    {
        "commit_hash": "239b7086c676321b48b1b094704b4995417a188b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-        private static final String DEFAULT_STRATEGIES_PREFIX = \"org.springframework.web.servlet\";\n-\t\n+\tprivate static final String DEFAULT_STRATEGIES_PREFIX = \"org.springframework.web.servlet\";\n+\n-\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(\"org.springframework.web.servlet\")) {\n+\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish \"Reuse constant in DispatcherServlet\"",
        "commit_body": "Closes gh-1398\n",
        "linked_issues": [
            {
                "issue_id": "1398",
                "issue_title": "Do not use hard coded strings",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": [
                    "Merged, thanks!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement within `DispatcherServlet`.  Previously, the condition checked if the attribute name started with `\"org.springframework.web.servlet\"`.  The change now uses the constant `DEFAULT_STRATEGIES_PREFIX` for this check, improving code readability and maintainability.  This change is a simple refactoring, replacing a literal string with a named constant",
            "avg_logprobs": -0.17125365100329434
        }
    },
    {
        "commit_hash": "24aae2e104f9e8eb1f21e79959ab00cb7fdcc49f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/FactoryBeanRegistrySupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n+\t\t\t\t\t\tif (containsSingleton(beanName)) {\n+\t\t\t\t\t\t\tthis.factoryBeanObjectCache.put(beanName, object);\n+\t\t\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensive containsSingleton cache guard within getObjectFromFactoryBean",
        "commit_body": "Issue: SPR-16625\n",
        "linked_issues": [
            {
                "issue_id": "21166",
                "issue_title": "FactoryBeanRegistrySupport atomicity issues [SPR-16625]",
                "issue_body": "**[L\u00e1szl\u00f3 Magyar](https://jira.spring.io/secure/ViewProfile.jspa?name=magyarl)** opened **[SPR-16625](https://jira.spring.io/browse/SPR-16625?redirect=false)** and commented\n\nWithin org.springframework.beans.factory.support.FactoryBeanRegistrySupport found some issues with atomic operation.\nPlease check PR.\n\n---\n\n**Affects:** 4.3.14, 5.0.4\n\n**Issue Links:**\n- #21119 SimpleAliasRegistry registerAlias not atomic\n- #21161 Consistent thread-safe iteration in DefaultSingletonBeanRegistry\n- #21168 Address race condition within spring that causes about-to-be-created-bean exceptions\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1749\n\n**Backported to:** [4.3.15](https://github.com/spring-projects/spring-framework/milestone/164?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch, this may indeed lead to race conditions in on-the-fly removal during live operations. I've revised the code accordingly, inspired by your pull request but somewhat more extensively: including `factoryBeanInstanceCache` in `AbstractAutowireCapableBeanFactory`, and with a new `clearSingletonCache()` template method that reduces the scope of the singleton lock. Also, the extra `containsSingleton` check isn't actually necessary once all removal attempts happen consistently within the singleton lock since the `factoryBeanObjectCache` will always be in sync.\n",
                    "**[L\u00e1szl\u00f3 Magyar](https://jira.spring.io/secure/ViewProfile.jspa?name=magyarl)** commented\n\nJuergen, please check my other created ticket and it's PR, it is related to this maybe.\nIt's number #21161.\nPlease check the synchronized wrapper usage when adding elements to containedBeanMap and dependentBeanMap, also the synchronization when iterating over these collections.\nIn my opinion it is required.\n",
                    "**[L\u00e1szl\u00f3 Magyar](https://jira.spring.io/secure/ViewProfile.jspa?name=magyarl)** commented\n\nI've checked the code.\nThe extra containsSingleton check was because maybe between the returned true, and the synchronization some thread removed this bean from singletons.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI see, your concern there is effectively the singleton nature of the given `FactoryBean` instance: If it gets replaced by a non-singleton `FactoryBean` definition at runtime, we might accidentally decide to cache the instance in case of such a race condition... Even if the instance won't get reused later on when no singleton is found when reentering this code, we won't clean it up either since `removeSingleton` assumes it has cleaned it up already on singleton removal.\n\nInitially I only looked at it from the perspective of receiving an outdated instance there which is guaranteed to not happen with the synchronized removal from both data structures in `removeSingleton` now. I'll revisit it from the perspective of a hot replacement with a non-singleton, as outlined above. However, this is a very unusual scenario since replacements are expected to be of the same kind in quite a few spots across the core container.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've added another `containsSingleton` guard but only right before putting into the `factoryBeanObjectCache` where we need to make sure we're not adding to it when no singleton exists anymore at that point. All other conditions are being enforced through consistent synchronization in the meantime, and we keep the \"happy path\" free from an extra check here.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure that a singleton bean is present before adding it to the `factoryBeanObjectCache`.  Previously, the `put` operation was unconditional.  The new conditional logic prevents adding a non-singleton bean to the cache",
            "avg_logprobs": -0.1998455157646766
        }
    },
    {
        "commit_hash": "25e6a2da646c9a465fabf1c73796a1ae01886857",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\n-\t\t\t\tPrincipal user = getUser(session);\n-\t\t\t\tif (user != null) {\n-\t\t\t\t\theaderAccessor.setUser(user);\n-\t\t\t\t}\n-\n+\t\t\t\theaderAccessor.setUser(getUser(session));\n+\t\t\t\t\t\t\tPrincipal user = headerAccessor.getUser();\n+\t\t\t\t\t\t\tPrincipal user = getUser(session);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "StompSubProtocolHandler consistently accesses current user",
        "commit_body": "Issue: SPR-15822\n",
        "linked_issues": [
            {
                "issue_id": "20377",
                "issue_title": "Setting user header on CONNECT message stopped working [SPR-15822]",
                "issue_body": "**[Jeff](https://jira.spring.io/secure/ViewProfile.jspa?name=domain)** opened **[SPR-15822](https://jira.spring.io/browse/SPR-15822?redirect=false)** and commented\n\nWe followed instructions in Token-Based Authentication in Spring doc at http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/websocket.html#websocket-stomp-authentication-token-based, in order to set the user header on the CONNECT Message. In Spring framework 4.3.9, it works well. After migrating to 5.0.0 RC2, we found it stopped working. After some investigation, we tend to believe it is a bug in 5.0.0 RC2 as well as RC3.\n\n[5.0.0 RC2 behavior]   - bad\nIn method handleMessageFromClient() in StompSubProtocolHandler class, Principal is retrieved from session. Of course, at this point, the Principal is null. And then, Spring attempts to put Principal to stompAuthentications. Since it is null, nothing would be put into stompAuthentications.\n\n    \t\t\tPrincipal user = getUser(session);\n    \t\t\tif (user != null) {\n    \t\t\t\theaderAccessor.setUser(user);\n    \t\t\t}\n    \t\t\t...\n    \t\t\ttry {\n    \t\t\t\tSimpAttributesContextHolder.setAttributesFromMessage(message);\n    \t\t\t\tboolean sent = outputChannel.send(message);\n    \n    \t\t\t\tif (sent) {\n    \t\t\t\t\tif (isConnect) {\n    \t\t\t\t\t\tif (user != null && user != session.getPrincipal()) {\n    \t\t\t\t\t\t\tthis.stompAuthentications.put(session.getId(), user);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n[4.3.9 behavior]   - good\nSpring tries to retrieve Principal from STOMP header, and then put it into stompAuthentications.\n\n    if (sent) {\n             if (isConnect) {\n                      Principal user = headerAccessor.getUser();\n                      if (user != null && user != session.getPrincipal()) {\n                               this.stompAuthentications.put(session.getId(), user);\n                      }\n             }\n\nThis commit (https://github.com/spring-projects/spring-framework/commit/f813712f5b413b354560cd7cc006352e9defa9a3#diff-7bc1370febf168db39f9b3a608f68fe8) caused this regression. FYI.\n\n---\n\n**Affects:** 5.0 RC2, 5.0 RC3\n\n**Issue Links:**\n- #20099 Introduce null-safety of Spring Framework API\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/25e6a2da646c9a465fabf1c73796a1ae01886857\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch: We need to re-retrieve the user at that point, which got accidentally dropped during that nullability refactoring. Restored for 5.0 RC4 now.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the setting of the `Principal` user in the `StompSubProtocolHandler`.  It removes a redundant `if` statement and directly sets the user in the `headerAccessor` using the result of the `getUser(session)` method.  The added lines retrieve the user from the `headerAccessor` and then again from `getUser(session)`",
            "avg_logprobs": -0.3050958251953125
        }
    },
    {
        "commit_hash": "2624b909060e0967e16771de7a35261decd5a4a9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tif (method == null) {\n+\t\t\t\t// annotations like @Inject, @Value and @Resource don't have a method\n+\t\t\t\t// (attribute) named \"required\" -> default to required status\n+\t\t\t\treturn true;\n+\t\t\t}\n-\t\t\t// required by default\n+\t\t\t// an exception was thrown during reflective invocation of the required\n+\t\t\t// attribute -> default to required status",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid NPE in AutowiredAnnotationBeanPostProcessor",
        "commit_body": "Prior to this change, AABPP#determineRequiredStatus never checked the\nreturn value of ReflectionUtils#findMethod when searching for a\n'#required' attribute. This call returns null for annotations such as\n@Inject, @Value and @Resource, and subsequently causes a\nNullPointerException to be thrown when ReflectionUtils#invokeMethod is\ncalled. The NPE is caught immediately and #determineRequiredStatus\nreturns defaulting to true, but this this approach is inefficient. It\nis also problematic for users who have set breakpoints on NPE -- they\nend up debugging into Spring internals, which is a false positive.\n\nThis commit checks the return value of of ReflectionUtils#findMethod,\nand in the case of null, eagerly returns true.  There is no change to\nexternal behavior, simply a more efficient and debugging-friendly\nimplementation.\n\nExisting test cases already cover this change, given that it is purely\na refactoring.\n\nIssue: SPR-9316\n",
        "linked_issues": [
            {
                "issue_id": "13954",
                "issue_title": "caught NullPointerException in AutowiredAnnotationBeanPostProcessor.determineRequiredStatus [SPR-9316]",
                "issue_body": "**[Philippe Marschall](https://jira.spring.io/secure/ViewProfile.jspa?name=marschall)** opened **[SPR-9316](https://jira.spring.io/browse/SPR-9316?redirect=false)** and commented\n\nAutowiredAnnotationBeanPostProcessor.determineRequiredStatus uses ReflectionUtils.findMethod to look up a method named \"required\". If there is no such method then ReflectionUtils.findMethod returns null. However AutowiredAnnotationBeanPostProcessor.determineRequiredStatus never checks for null instead it directly passes the method to ReflectionUtils.invokeMethod which throws a NullPointerException which is then caught in a catch (Exception ex) block in AutowiredAnnotationBeanPostProcessor.determineRequiredStatus.\n\nAnnoations that don't have a method named \"required\" include `@Inject` `@Value` `@Resource`.\n\nThis is not so nice for several reasons:\n* when you debug one of your own NullPointerExceptions and set an exception breakpoint on NullPointerException you end up in Spring code\n* it uses NullPointerExceptions and catching them as part of normal control flow\n* filling in the stack trace of an exception is slow\n\n---\n\n**Affects:** 3.1.1\n\n**Issue Links:**\n- #14001 AutowiredAnnotationBeanPostProcessor.determineRequiredStatus(Annotation) throws NullPointerException if method wasnt found. (_**\"is duplicated by\"**_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/26ee0c4842ca83dec213b5422d0af18ba2e3ce6c, https://github.com/spring-projects/spring-framework/commit/2624b909060e0967e16771de7a35261decd5a4a9, https://github.com/spring-projects/spring-framework/commit/46bdb2de077063663f0daae85431ebe5c430edc8\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Philippe Marschall](https://jira.spring.io/secure/ViewProfile.jspa?name=marschall)** commented\n\nPull request is there https://github.com/SpringSource/spring-framework/pull/64\n",
                    "**[Chris Beams](https://jira.spring.io/secure/ViewProfile.jspa?name=cbeams)** commented\n\n> ```\n> commit 2624b909060e0967e16771de7a35261decd5a4a9 (SPR-9316)\n> Author: Philippe Marschall <philippe.marschall@gmail.com>\n> Date:   Mon Apr 9 13:00:32 2012 +0200\n> \n>     Avoid NPE in AutowiredAnnotationBeanPostProcessor\n>     \n>     Prior to this change, AABPP#determineRequiredStatus never checked the\n>     return value of ReflectionUtils#findMethod when searching for a\n>     '#required' attribute. This call returns null for annotations such as\n>     @Inject, @Value and @Resource, and subsequently causes a\n>     NullPointerException to be thrown when ReflectionUtils#invokeMethod is\n>     called. The NPE is caught immediately and #determineRequiredStatus\n>     returns defaulting to true, but this this approach is inefficient. It\n>     is also problematic for users who have set breakpoints on NPE -- they\n>     end up debugging into Spring internals, which is a false positive.\n>     \n>     This commit checks the return value of of ReflectionUtils#findMethod,\n>     and in the case of null, eagerly returns true.  There is no change to\n>     external behavior, simply a more efficient and debugging-friendly\n>     implementation.\n>     \n>     Existing test cases already cover this change, given that it is purely\n>     a refactoring.\n>     \n>     Issue: SPR-9316\n> ```\n\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of the `required` attribute in `AutowiredAnnotationBeanPostProcessor`.  Previously, the code assumed `required` was true by default.  Now, if the `method` is null (indicating annotations like `@Inject`, `@Value`, or `@Resource` which don't have a `required` attribute), it explicitly returns `true`",
            "avg_logprobs": -0.13959603309631347
        }
    },
    {
        "commit_hash": "262c702da4588e5f467fd24774357113379666b2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/type/classreading/CachingMetadataReaderFactory.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\telse if (this.metadataReaderCache != null) {\n+\t\t\t// Shared resource cache -> reset to local cache.\n+\t\t\tsetCacheLimit(DEFAULT_CACHE_LIMIT);\n+\t\t}\n+\t\t\tthis.cacheLimit = cacheLimit;",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "CachingMetadataReaderFactory releases shared cache Map on clearCache()",
        "commit_body": "LocalResourceCache properly initializes cacheLimit on construction.\n\nIssue: SPR-17527\n",
        "linked_issues": [
            {
                "issue_id": "22059",
                "issue_title": "CachingMetadataReaderFactory does not release shared resource cache after context refresh [SPR-17527]",
                "issue_body": "**[Philippe Julien](https://jira.spring.io/secure/ViewProfile.jspa?name=philjulien)** opened **[SPR-17527](https://jira.spring.io/browse/SPR-17527?redirect=false)** and commented\n\norg.springframework.core.type.classreading.CachingMetadataReaderFactory.clearCache() was modified in Spring 5 to only clear the metaDataReaderCache of the LocalResourceCache instance type. When created with the constructor that takes a ResourceLoader as an argument, CachingMetadataReaderFactory will keep a strong reference on the Map that it got from the DefaultResourceLoader. This would be fine if DefaultResourceLoader.clearResourceCaches(), that is called after a context refresh, cleared the resourceCaches and the inner map that it contains, but this is not the case. So CachingMetadataReaderFactory.metaDataReaderCache remain in memory after context refresh.\n\nIn our application this increased the memory footprint by about 100mb after we updated to Spring 5.\n\nA possible fix would be for CachingMetadataReaderFactory.clearCache() to set its metadataReaderCache to null if it's not an instance of LocalResourceCache.\n\n---\n\n**Affects:** 5.0.10, 5.1.2\n\n**Issue Links:**\n- #22058 CachingMetadataReaderFactory metadataReaderCache isn't cleaned up after context refresh when using the resource loader cache (_**\"is duplicated by\"**_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/23d104936390da07eedc832b5b64ecee1cdf8634, https://github.com/spring-projects/spring-framework/commit/262c702da4588e5f467fd24774357113379666b2\n\n**Backported to:** [5.0.11](https://github.com/spring-projects/spring-framework/milestone/192?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWell spotted! While `DefaultResourceLoader.clearResourceCaches()` could clear all the `Map` values individually, it seems sensible to let go of the shared cache reference in `CachingMetadataReaderFactory.clearCache()`. I'm considering to reset it to an empty local cache instead of `null` at that point, still being able to perform local caching in case of further use of the `CachingMetadataReaderFactory` instance.\r\n,\n",
                    "**[Philippe Julien](https://jira.spring.io/secure/ViewProfile.jspa?name=philjulien)** commented\n\nWhile you are looking at CachingMetadataReaderFactory. It seems odd that the constructor of LocalResourceCache isn't setting the object's cacheLimit field. I can open a new issue about this if you prefer.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, that constructor needs to set the `cacheLimit` field as well. I've addressed both issues in one pass for 5.1.3 and will also backport the changes to 5.0.11 ASAP. Thanks for raising this stuff!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds an `else if` condition to the existing conditional logic.  If `metadataReaderCache` is not null (indicating a shared resource cache), it resets the cache limit to the default value.  Finally, it sets the `cacheLimit` to the provided value.  This suggests a change in how the cache is managed when using a shared resource, potentially to avoid conflicts or optimize resource usage",
            "avg_logprobs": -0.2029039693433185
        }
    },
    {
        "commit_hash": "26acb4887d5e8521e4f7d1bb23994e1992904996",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/config/YamlProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import java.io.InputStream;\n+import java.io.Reader;\n+import org.yaml.snakeyaml.reader.UnicodeReader;\n-\t\t\tInputStream stream = resource.getInputStream();\n+\t\t\tReader reader = new UnicodeReader(resource.getInputStream());\n-\t\t\t\tfor (Object object : yaml.loadAll(stream)) {\n+\t\t\t\tfor (Object object : yaml.loadAll(reader)) {\n-\t\t\t\tstream.close();\n+\t\t\t\treader.close();",
        "change_count": 9,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "YamlProcessor explicitly closes UnicodeReader",
        "commit_body": "Issue: SPR-13173\n",
        "linked_issues": [
            {
                "issue_id": "17765",
                "issue_title": "YAML Processor leaves StreamDecoder open [SPR-13173]",
                "issue_body": "**[Erik Salter](https://jira.spring.io/secure/ViewProfile.jspa?name=an1310)** opened **[SPR-13173](https://jira.spring.io/browse/SPR-13173?redirect=false)** and commented\n\nWhen the YAMLProcessor is closed, it is still leaving a reference to a StreamDecoder instance open.  (See UnicodeReader::init())   While Spring\u2019s YamlProcessor closes the underlying input stream, the StreamDecoder (and thus the reference to the YAML and all its loaded references) remain open until the YAML reference is eventually GC\u2019d.\n\nThe issue comes in when these references are promoted from new to the old generation.  The references are then only collected on a FGC.  In the interim, the application can have many open handles (we counted 900+ on a production system that only had 2 FGC cycles)\n\nAttached is a snapshot after the YAMLProcessor closes the stream.\n\n---\n\n**Affects:** 4.1.3\n\n**Reference URL:** #17093\n\n**Attachments:**\n- [yaml.png](https://jira.spring.io/secure/attachment/22921/yaml.png) (_70.46 kB_)\n\n**Issue Links:**\n- #17093 Need a defensive close() in YamlProcessor\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/26acb4887d5e8521e4f7d1bb23994e1992904996, https://github.com/spring-projects/spring-framework/commit/3d131c9f3ceed70700dfe79eb7431708e74f7b0c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt looks like we'll have to avoid the `Yaml.load(InputStream)` method altogether, using a `loadFromReader` call with a custom `UnicodeReader` handle which we're able to close afterwards...\n\nThis is arguably a bug in that `Yaml` class itself. However, if we can work around so easily, let's try to do that.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `YamlProcessor` modifies how YAML data is read.  Instead of using an `InputStream`, it now uses a `Reader` (specifically, a `UnicodeReader`).  This change is crucial for handling YAML files correctly, as it ensures proper Unicode character decoding.  The `for` loop iterating over YAML objects now uses the `reader` instead of the `stream`.  Importantly, the code now closes the `reader` instead of the `stream`",
            "avg_logprobs": -0.22159910202026367
        }
    },
    {
        "commit_hash": "26d143868f912bcd8fe4b8cc66135928807526f8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\n-\n+\n-\tprivate ConverterRegistry converterRegistry;\n+\tprivate ConverterRegistry converterRegistry = (ConverterRegistry) this.converterLookup;\n+\t\tif (converterLookup instanceof ConverterRegistry) {\n+\t\t\tthis.converterRegistry = (ConverterRegistry) converterLookup;\n+\t\t}\n+\t@SuppressWarnings(\"deprecation\")\n+\t\t// The referenced XStream constructor has been deprecated as of 1.4.5.\n+\t\t// We're preserving this call for broader XStream 1.4.x compatibility.",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Compatibility with XStream 1.4.5",
        "commit_body": "XStream 1.4.5 doesn't check a given ConverterLookup for a ConverterRegistry implementation anymore, so we have to manually perform that check and assignment.\n\nIssue: SPR-11147\n",
        "linked_issues": [
            {
                "issue_id": "15774",
                "issue_title": "XStreamMarshaller doesn't set the converterRegistry field with XStream 1.4.5 [SPR-11147]",
                "issue_body": "**[Tomas Repel](https://jira.spring.io/secure/ViewProfile.jspa?name=trepel)** opened **[SPR-11147](https://jira.spring.io/browse/SPR-11147?redirect=false)** and commented\n\nWhen using XStreamMarshaller, I get following error\n\n```\nXStream marshalling ended with exception org.springframework.oxm.MarshallingFailureException: XStream marshalling exception;\nnested exception is com.thoughtworks.xstream.converters.ConversionException: No converter specified for class springtest.xmlmarshalling.Data\n```\n\nAfter some debugging, I think the problem is that XStreamMarshaller's converterRegistry field is not initialized (it remains NULL, unlike the converterLookup field just a line above) and when the XStream object is being created in constructXStream() method, the NULL value causes that no converter is registered.\n\nLet me know if you need more details or example war to reproduce this.\n\n\n---\n\n**Affects:** 4.0 RC2\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/26d143868f912bcd8fe4b8cc66135928807526f8\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nIs this a problem that you are also seeing in 3.2.x or is it a 4.0 regression?\n\nIf you could submit a [repro project](https://github.com/spring-projects/spring-framework-issues) for this, that would be very useful.\n",
                    "**[Tomas Repel](https://jira.spring.io/secure/ViewProfile.jspa?name=trepel)** commented\n\nI believe this is regression for Spring 4.0. PR for reproducer: https://github.com/spring-projects/spring-framework-issues/pull/63\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis seems to be an XStream 1.4.5 specific problem. Before, XStream checked the given ConverterLookup object whether it also implements ConverterRegistry...\n\nthis.converterRegistry = converterRegistry != null\n? converterRegistry\n: (converterLookup instanceof ConverterRegistry\n? (ConverterRegistry)converterLookup\n: null);\n\nBut as of 1.4.5, it just assigns the converterRegistry reference as provided. We'll fix this for Spring 4.0 GA, hopefully compatible with XStream 1.4.x and also 1.4.5 then.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check and initialization for `converterRegistry`.  Previously, `converterRegistry` was not initialized.  Now, if `converterLookup` is an instance of `ConverterRegistry`, it's used to initialize `converterRegistry`.  This change also includes a deprecation warning related to an XStream constructor, preserving compatibility with older XStream versions (1.4.x)",
            "avg_logprobs": -0.1633863091468811
        }
    },
    {
        "commit_hash": "27942644804732378806a6a560be6b321f74c0ce",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/JettyRequestUpgradeStrategy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tthis.running = true;\n+\t\t\t\t\tthis.running = true;\n-\t\t\t\tthis.running = false;\n+\t\t\t\t\t\tthis.running = false;\n-\t\tif (this.servletContext != null) {\n+\t\tif (isRunning()) {\n-\t\t\tif (this.servletContext == null) {\n+\t\t\tif (!isRunning()) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix JettyRequestUpgradeStrategy initialization bug",
        "commit_body": "Closes gh-23313\n",
        "linked_issues": [
            {
                "issue_id": "23313",
                "issue_title": "Reactive JettyRequestUpgradeStrategy returns 'No WebSocketServerFactory available' on startup with simultaneous handshakes",
                "issue_body": "After the server application has started the initial burst of WebSocket handshake requests some will fail with a 500 with the error 'No WebSocketServerFactory available', afterwards it's fine. \r\n\r\nThe problem is caused by the following code in class `org.springframework.web.reactive.socket.server.upgrade.JettyRequestUpgradeStrategy` in the `startLazily` method.\r\n \r\n```java\r\nif (this.servletContext != null) {\r\n\treturn;\r\n}\r\n\r\nsynchronized (this.lifecycleMonitor) {\r\n\tif (this.servletContext == null) {\r\n\t\tthis.servletContext = request.getServletContext();\r\n\t\tstart();\r\n\t}\r\n}\r\n```\r\n\r\nIf the above code is executed concurrently the code will early out when the servlet context is no longer null. But the `start()` method has not been (entirely) invoked causing exceptions for the requests already being executed untill the `start()` method has also been completed.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the `JettyRequestUpgradeStrategy` class, specifically focusing on the handling of the `running` flag.  The original code had a potential race condition where `running` was set to `true` and then immediately to `false` without proper synchronization.  The change introduces a conditional check (`isRunning()`) and a block (`if (!isRunning())`) to ensure the `running` flag is only set to `false` when it's currently `true`",
            "avg_logprobs": -0.2658565711975098
        }
    },
    {
        "commit_hash": "279777b2f3a43ed96eb8151f07b76f38672cc78f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * @return the mirrorSets the attribute mirror sets.\n+\t * @return the attribute mirror sets\n-\t\t\t\t\tif (lastValue != null &&\n-\t\t\t\t\t\t\t!ObjectUtils.nullSafeEquals(lastValue, value)) {\n+\t\t\t\t\tif (lastValue != null && !ObjectUtils.nullSafeEquals(lastValue, value)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the Javadoc for the `AnnotationTypeMapping` class, specifically the `mirrorSets` method.  The only change is a minor typo correction in the Javadoc comment, changing \"the mirrorSets the attribute mirror sets\" to \"the attribute mirror sets\".  No change was made to the underlying conditional logic",
            "avg_logprobs": -0.17189413042210822
        }
    },
    {
        "commit_hash": "27e9db8c8c30a941bbbc4ceae6a18bd2124ea527",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-oxm/src/main/java/org/springframework/oxm/jaxb/Jaxb2Marshaller.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\t\t\tboolean isJdk7 = (org.springframework.core.JdkVersion.getMajorJavaVersion() >= org.springframework.core.JdkVersion.JAVA_17);\n-\t\t\t\t\tif (isJdk6 && classArgument.isArray()) {\n-\t\t\t\t\t\treturn (isPrimitiveWrapper(classArgument) || isStandardClass(classArgument) ||\n-\t\t\t\t\t\t\t\tsupportsInternal(classArgument, false));\n+\t\t\t\t\tif (isJdk7 && classArgument.isArray()) {\n+\t\t\t\t\t\treturn (classArgument.getComponentType() == Byte.TYPE);\n-\t\t\t\t\t\treturn (classArgument.getComponentType() == Byte.TYPE);\n+\t\t\t\t\t\treturn (isPrimitiveWrapper(classArgument) || isStandardClass(classArgument) ||\n+\t\t\t\t\t\t\t\tsupportsInternal(classArgument, false));",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix regression in Jaxb2Marshaller regarding JdkVersion",
        "commit_body": "Issue: SPR-13312\n",
        "linked_issues": [
            {
                "issue_id": "17897",
                "issue_title": "Deprecate JdkVersion (for optimistic compatibility with newer JDK generations) [SPR-13312]",
                "issue_body": "**[Micha\u0142 Sobkiewicz](https://jira.spring.io/secure/ViewProfile.jspa?name=perceptron8)** opened **[SPR-13312](https://jira.spring.io/browse/SPR-13312?redirect=false)** and commented\n\nAfter hitting something similar to #16518 (with legacy code using Spring 2.5), I'd like to suggest some refactoring. There **will be** similar bugs in the future because of how org.springframework.core.JdkVersion is designed. It breaks when you use JVM which was not included in constants.\n\nIf full version information is needed at runtime (which I doubt), see\norg.apache.maven.artifact.versioning.ComparableVersion as an example of how to handle versioning properly. However, if checking runtime compatibility is the only thing needed (which is the case, I think), it can be done in a much simpler way.\n\nI attached my own helper, JvmVersion. It provides everything that is necessary \"to allow for automatically adapting to the present platform's capabilities\". I know that there were no enums before Java 5, but, well, Java 5 is over 10 years old, Spring 4 requires Java 6. As you can see, JvmVersion delegates to Package#isCompatibleWith(String) - so you don't have to handle system properties or dot notation manually - it just works. You could refactor existing code and deprecate JdkVersion to avoid new bugs. It would make me very proud of myself ;-)\n\nSorry for not creating pull request - it's just one file... Hope you will find it useful anyway.\n\nPS. See standardReflectionAvailable property in org.springframework.core.DefaultParameterNameDiscoverer (Spring 4.2) as an example of what can go wrong.\n\n---\n\n**Affects:** 4.2 GA\n\n**Attachments:**\n- [JvmVersion.java](https://jira.spring.io/secure/attachment/22966/JvmVersion.java) (_406 bytes_)\n\n**Issue Links:**\n- #18412 Upgrade to AspectJ 1.9 beta 3 (for build compatibility with JDK 9 build 95+)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/acb44f9d46fa80bfc69c69f107780f900c31a606, https://github.com/spring-projects/spring-framework/commit/e0f012f32d923b2e2c858c92075bf10d208ef89a, https://github.com/spring-projects/spring-framework/commit/27e9db8c8c30a941bbbc4ceae6a18bd2124ea527, https://github.com/spring-projects/spring-framework/commit/5e9a96817bf6f55f982746774c4c76671785f5cd, https://github.com/spring-projects/spring-framework/commit/bec3b0fa1a69e251340b9abe0a34ef3fafb67335\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Micha\u0142 Sobkiewicz](https://jira.spring.io/secure/ViewProfile.jspa?name=perceptron8)** commented\n\nI forgot about example usage. Here it is:\n\n```java\nif (JvmVersion.JAVA_1_8.isCompatibleWithRuntime()) {\n  // ...\n}\n```\n\n",
                    "**[Micha\u0142 Sobkiewicz](https://jira.spring.io/secure/ViewProfile.jspa?name=perceptron8)** commented\n\nLinks to mentioned classes / methods:\n\n* https://maven.apache.org/ref/3.1.0/maven-artifact/apidocs/org/apache/maven/artifact/versioning/ComparableVersion.html\n* https://docs.oracle.com/javase/8/docs/api/java/lang/Package.html#isCompatibleWith-java.lang.String-\n* https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/DefaultParameterNameDiscoverer.java\n* https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/JdkVersion.java\n\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nI am not sure I understand the link between your issue and #16518. You're not expecting us to recognize a JDK version that a) did not exist when we released that version of the framework and b) does not work at all with said version.\n\nWhat's a point of being able to recognize Java 8 using Spring 2.5 if you can't effectively run a Spring 2.5-based app with Java 8?\n",
                    "**[Micha\u0142 Sobkiewicz](https://jira.spring.io/secure/ViewProfile.jspa?name=perceptron8)** commented\n\nMy point is that nothing should prevent you from running Spring 2.5 with Java 8 or using Spring 4.2 optional features designed for Java 8 with Java 10.\nThe link between my issue and #16518 is as follows: JdkVersion was buggy, #16518 appeared because of that, nothing changed, there was no conclusions, JdkVersion is still buggy.\n\na) I'm not expecting you to recognize JDK versions that didn't exist when framework was released. It's rather what you are trying to do. Obviously, you can't create constant for versions that are not yet known (let them be static, enums, whatever). I'm trying to show you that code based on JdkVersion won't work properly on future JVMs, just because it has no constant for future JVMs - it can't - and that's the point! Instead of comparing constants, you should test if one of _known_ versions is compatible with the _current_ runtime - but without creating constant for _current_. That's all you need - I suppose - and JvmVersion does exactly and only that (it has just one method, it can't be simpler). If you really need more, please try to develop something similar to ComparableVersion from maven.\n\nb) If it doesn't work because you use language features that was not present at the time of releasing framework in that framework (enums, try-withresources, lambdas, modules, value-based classes, ...), it's ok. I don't mind. You can't do anything with that. But if it breaks because something like bug or bad design, that's another story.\n\nSuppose Spring 4.2 is binary compatible with Java 10. It's likely to be true as Java versions are expected to be binary backwards-compatible. Now look at:\n1) https://github.com/spring-projects/spring-framework/blob/v4.2.0.RELEASE/spring-core/src/main/java/org/springframework/core/DefaultParameterNameDiscoverer.java#L35 and\n2) https://github.com/spring-projects/spring-framework/blob/v4.2.0.RELEASE/spring-core/src/main/java/org/springframework/core/JdkVersion.java#L87\n   It **will** break, without a doubt. At least one Spring 4.2 feature will not work with Java 10, even if it could, because of a simple bug. Maybe other. This is the only one I'm aware of. You can prevent similar bugs in the future easily.\n\nBy the way, another source of potential bugs is following assumption:\n3) https://github.com/spring-projects/spring-framework/blob/v4.2.0.RELEASE/spring-core/src/main/java/org/springframework/core/JdkVersion.java#L75\nHow about \"1.10.1.7-r25\"? Is it 1.6? 1.7? 1.10? Or maybe it depends?\n\nIt's not about Spring 2.5 really. We are switching to String 3.2.9 or Spring 4.2 anyway. It's about reliable, error-free code.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIn the end, `JdkVersion` is an outdated class which we should get rid of. In addition to your points (which I generally agree with), JDK 9 is likely to have a different version scheme (\"9.x.x\" instead of \"1.9.x), so this whole version string parsing is even more fragile. We need to avoid this completely.\n\nAs a consequence, let me repurpose this issue towards deprecating `JdkVersion`, getting rid of remaining use of `JdkVersion` in our codebase. We generally try to detect the specific API that we're trying to use, so `DefaultParameterNameDiscoverer` can simply check for the presence of `java.lang.reflect.Executable` (which is only there on JDK 8+). We're doing that in most places already; `DefaultParameterNameDiscoverer` is just one of three remaining `JdkVersion` checks in the entire framework codebase. The goal is for there to be no such checks anymore as of 4.2.1.\n\nJuergen\n",
                    "**[Micha\u0142 Sobkiewicz](https://jira.spring.io/secure/ViewProfile.jspa?name=perceptron8)** commented\n\nMakes sense. I'll check 4.2.1 then, just to sleep well, as soon as it's released.\nThank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the conditional logic within `Jaxb2Marshaller.java` to handle array types differently based on the Java version.\\n\\nPreviously, if the Java version was JDK 6 and the `classArgument` was an array, it checked for primitive wrappers, standard classes, and internal support.  Now, if the Java version is JDK 7 or higher and the `classArgument` is an array, it only checks if the component type of the array is `Byte.TYPE`.",
            "avg_logprobs": -0.1302746295928955
        }
    },
    {
        "commit_hash": "289d378aebd4782f422b880702fbd098122a389c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core-test/src/main/java/org/springframework/aot/agent/InstrumentedBridgeMethods.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t!Modifier.isPublic(constructor.getDeclaringClass().getModifiers()) || !constructor.canAccess(null)) {\n+\t\t\t\t\t!Modifier.isPublic(constructor.getDeclaringClass().getModifiers())) {\n-\t\t\tif (!Modifier.isPublic(method.getModifiers())) {\n+\t\t\tif (!Modifier.isPublic(method.getModifiers())\n+\t\t\t\t|| !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish",
        "commit_body": "This fixes an additional case where invoked methods are public but the\ndeclaring class is package private.\n\nFixes gh-29046\n",
        "linked_issues": [
            {
                "issue_id": "29046",
                "issue_title": "IllegalAccessException while instrumenting invocation of non-public method with RuntimeHintsAgent",
                "issue_body": "The `RuntimeHintsAgent` agent fails at instrumenting the following case:\r\n\r\n```java\r\n@EnabledIfRuntimeHintsAgent\r\nclass RuntimeHintsAgentTests {\r\n\r\n\t@Test\r\n\tvoid invokePrivateMethod() {\r\n\t\tMethod greet = ReflectionUtils.findMethod(PrivateClass.class, \"greet\");\r\n\t\tRuntimeHintsInvocations invocations = RuntimeHintsRecorder.record(() -> {\r\n\t\t\tgreet.invoke(new PrivateClass());\r\n\t\t});\r\n\t}\r\n\r\n\tclass MyClass {\r\n\r\n\t\tprivate String greet() {\r\n\t\t\treturn \"hello\";\r\n\t\t}\r\n\t\t\r\n\t}\r\n}\r\n``` \r\n\r\nWith this code snippet, the agent fails during the method invocation with an exception like:\r\n\r\n```\r\njava.lang.IllegalAccessException: class org.springframework.aot.agent.InstrumentedBridgeMethods cannot access a member of class org.springframework.sample.RuntimeHintsAgentTests$MyClass with modifiers \"private\"\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "Reopening for cases where methods are public but declaring class is not."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional logic around constructor and method accessibility checks.  Specifically, it removes the `|| !constructor.canAccess(null)` check from the first conditional statement.  The second conditional statement now also checks the accessibility of the method's declaring class, in addition to the method itself.  This implies a change in the criteria for determining if a method or constructor is considered accessible",
            "avg_logprobs": -0.33513225555419923
        }
    },
    {
        "commit_hash": "28e206a9469b603c40bb023c69592570374bc8bb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/codec/EncoderHttpMessageWriter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\treturn (isStreamingMediaType(contentType) ?\n-\t\t\t\tmessage.writeAndFlushWith(body.map(Flux::just)) : message.writeWith(body));\n+\t\tif (isStreamingMediaType(contentType)) {\n+\t\t\treturn message.writeAndFlushWith(body.map(buffer ->\n+\t\t\t\t\tMono.fromCallable(() -> buffer)\n+\t\t\t\t\t\t\t.doOnDiscard(PooledDataBuffer.class, PooledDataBuffer::release)));\n+\t\t}\n+\n+\t\treturn message.writeWith(body);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply doOnDiscard for streaming mode",
        "commit_body": "Use of Flux.just is problematic in that if the Flux is cancelled before\ndemand, the item may never be read, nor freed. Flux#just does not\neven delegate cancellation signals.\n\nCloses gh-22731\n",
        "linked_issues": [
            {
                "issue_id": "22731",
                "issue_title": "ProtobufEncoder and ProtobufDecoder buffer leaks",
                "issue_body": "**Affects:** Spring Framework 5.1.5\r\n---\r\n## Issue\r\nAfter upgrading from **2.0.6.RELEASE** version to **2.1.3.RELEASE** I started seeing a lot of memory leaks related to `org.springframework.http.codec.protobuf.ProtobufEncoder#encodeMessage` in logs (see below).\r\n\r\n### Technical details:\r\n* OS: \r\n```\r\nLinux version 2.6.32-573.7.1.el6.x86_64 (mockbuild@c6b8.bsys.dev.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) ) #1 SMP Tue Sep 22 22:00:00 UTC 2015\r\n```\r\n* Java:\r\n```\r\njava version \"1.8.0_181\"\r\nJava(TM) SE Runtime Environment (build 1.8.0_181-b13)\r\nJava HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)\r\n```\r\n* Protobuf: 3.4.0\r\n* Java system properties:\r\n```\r\n-Dspring.profiles.active=default\r\n-XX:+UseG1GC\r\n-Xmx6G\r\n-Xms6G\r\n-XX:MaxGCPauseMillis=15\r\n-XX:MaxTenuringThreshold=1\r\n-XX:+UnlockExperimentalVMOptions\r\n-XX:G1NewSizePercent=60\r\n-XX:G1MaxNewSizePercent=70\r\n-XX:+UseGCLogFileRotation\r\n-XX:NumberOfGCLogFiles=5\r\n-XX:GCLogFileSize=100M\r\n-XX:+PrintGCApplicationStoppedTime\r\n-XX:+PrintTenuringDistribution\r\n-XX:+PrintGCCause\r\n-XX:+PrintGCDetails\r\n-XX:+PrintGCTimeStamps\r\n-XX:+PrintGC\r\n-XX:+PrintGCDateStamps\r\n-XX:+PrintAdaptiveSizePolicy\r\n```\r\n\r\n### Log example [own classes are hidden with ...]\r\n```\r\n2019-04-03 07:23:43.445 ERROR [reactor-http-epoll-1] ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for mo\r\nre information.\r\nRecent access records: \r\n#1:\r\n        io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:616)\r\n        io.netty.buffer.ByteBufOutputStream.write(ByteBufOutputStream.java:68)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.doFlush(CodedOutputStream.java:2985)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.flush(CodedOutputStream.java:2896)\r\n        com.google.protobuf.AbstractMessageLite.writeTo(AbstractMessageLite.java:87)\r\n        org.springframework.http.codec.protobuf.ProtobufEncoder.encodeMessage(ProtobufEncoder.java:89)\r\n        org.springframework.http.codec.protobuf.ProtobufEncoder.lambda$encode$1(ProtobufEncoder.java:78)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107)\r\n        reactor.core.publisher.FluxJust$WeakScalarSubscription.request(FluxJust.java:99)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.MonoNext$NextSubscriber.request(MonoNext.java:102)\r\n        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1878)\r\n        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1752)\r\n        reactor.core.publisher.MonoNext$NextSubscriber.onSubscribe(MonoNext.java:64)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)\r\n        reactor.core.publisher.FluxJust.subscribe(FluxJust.java:70)\r\n        reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40)\r\n        reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44)\r\n        reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60)\r\n        reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:185)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onNext(FluxDoFinally.java:123)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onSubscribe(MonoFlatMap.java:230)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)\r\n        reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n        reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoReduceSeed$ReduceSeedSubscriber.onComplete(MonoReduceSeed.java:156)\r\n        reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.innerComplete(FluxFlatMap.java:863)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapInner.onComplete(FluxFlatMap.java:957)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:271)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:271)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:321)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableConditionalSubscriber.onComplete(FluxPeekFuseable.java:578)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:321)\r\n        reactor.core.publisher.FluxSubscribeOnCallable$CallableSubscribeOnSubscription.run(FluxSubscribeOnCallable.java:251)\r\n        reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:50)\r\n        reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:27)\r\n        java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n        java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n        java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        java.lang.Thread.run(Thread.java:748)\r\n#2:\r\n        io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:616)\r\n        io.netty.buffer.ByteBufOutputStream.write(ByteBufOutputStream.java:68)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.doFlush(CodedOutputStream.java:2985)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.flushIfNotAvailable(CodedOutputStream.java:2980)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.writeInt32(CodedOutputStream.java:2659)\r\n        com.google.protobuf.CodedOutputStream.writeEnum(CodedOutputStream.java:301)\r\n        com....Result.writeTo(...Result.java:312)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.writeMessageNoTag(CodedOutputStream.java:2783)\r\n        com.google.protobuf.CodedOutputStream$OutputStreamEncoder.writeMessage(CodedOutputStream.java:2759)\r\n        com....Response.writeTo(...Response.java:134)\r\n        com.google.protobuf.AbstractMessageLite.writeTo(AbstractMessageLite.java:86)\r\n        org.springframework.http.codec.protobuf.ProtobufEncoder.encodeMessage(ProtobufEncoder.java:89)\r\n        org.springframework.http.codec.protobuf.ProtobufEncoder.lambda$encode$1(ProtobufEncoder.java:78)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107)\r\n        reactor.core.publisher.FluxJust$WeakScalarSubscription.request(FluxJust.java:99)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.MonoNext$NextSubscriber.request(MonoNext.java:102)\r\n        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1878)\r\n        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1752)\r\n        reactor.core.publisher.MonoNext$NextSubscriber.onSubscribe(MonoNext.java:64)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)\r\n        reactor.core.publisher.FluxJust.subscribe(FluxJust.java:70)\r\n        reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40)\r\n        reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44)\r\n        reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60)\r\n        reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:185)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onNext(FluxDoFinally.java:123)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onSubscribe(MonoFlatMap.java:230)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)\r\n        reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n        reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoReduceSeed$ReduceSeedSubscriber.onComplete(MonoReduceSeed.java:156)\r\n        reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.innerComplete(FluxFlatMap.java:863)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapInner.onComplete(FluxFlatMap.java:957)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:271)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:271)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:321)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableConditionalSubscriber.onComplete(FluxPeekFuseable.java:578)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:321)\r\n        reactor.core.publisher.FluxSubscribeOnCallable$CallableSubscribeOnSubscription.run(FluxSubscribeOnCallable.java:251)\r\n        reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:50)\r\n        reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:27)\r\n        java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n        java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n        java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        java.lang.Thread.run(Thread.java:748)\r\nCreated at:\r\n        io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(PooledByteBufAllocator.java:339)\r\n        io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:185)\r\n        io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:171)\r\n        io.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:105)\r\n        org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:65)\r\n        org.springframework.core.io.buffer.NettyDataBufferFactory.allocateBuffer(NettyDataBufferFactory.java:39)\r\n        org.springframework.http.codec.protobuf.ProtobufEncoder.encodeMessage(ProtobufEncoder.java:82)\r\n        org.springframework.http.codec.protobuf.ProtobufEncoder.lambda$encode$1(ProtobufEncoder.java:78)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:107)\r\n        reactor.core.publisher.FluxJust$WeakScalarSubscription.request(FluxJust.java:99)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.request(FluxPeekFuseable.java:138)\r\n        reactor.core.publisher.MonoNext$NextSubscriber.request(MonoNext.java:102)\r\n        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1878)\r\n        reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1752)\r\n        reactor.core.publisher.MonoNext$NextSubscriber.onSubscribe(MonoNext.java:64)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onSubscribe(FluxPeekFuseable.java:172)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)\r\n        reactor.core.publisher.FluxJust.subscribe(FluxJust.java:70)\r\n        reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.FluxPeekFuseable.subscribe(FluxPeekFuseable.java:86)\r\n        reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40)\r\n        reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44)\r\n        reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60)\r\n        reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onNext(MonoPeekTerminal.java:185)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:73)\r\n        reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onNext(FluxDoFinally.java:123)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onSubscribe(MonoFlatMap.java:230)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)\r\n        reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n        reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:241)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onNext(FluxPeekFuseable.java:204)\r\n        reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)\r\n        reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505)\r\n        reactor.core.publisher.MonoReduceSeed$ReduceSeedSubscriber.onComplete(MonoReduceSeed.java:156)\r\n        reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:794)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:560)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapMain.innerComplete(FluxFlatMap.java:863)\r\n        reactor.core.publisher.FluxFlatMap$FlatMapInner.onComplete(FluxFlatMap.java:957)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:271)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:271)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:321)\r\n        reactor.core.publisher.FluxPeekFuseable$PeekFuseableConditionalSubscriber.onComplete(FluxPeekFuseable.java:578)\r\n        reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:321)\r\n        reactor.core.publisher.FluxSubscribeOnCallable$CallableSubscribeOnSubscription.run(FluxSubscribeOnCallable.java:251)\r\n        reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:50)\r\n        reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:27)\r\n        java.util.concurrent.FutureTask.run(FutureTask.java:266)\r\n        java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\r\n        java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\r\n        java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\r\n        java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\r\n        java.lang.Thread.run(Thread.java:748)\r\n```\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "@rstoyanchev Hi. Why you added this fix only to 5.1.7? Would be great to get it asap",
                    "Not sure I understand. 5.1.7 is available. What else could we have done?",
                    "@rstoyanchev yeap, thank you. I was confused about the spring boot version(2.1.7)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the conditional logic for handling streaming media types in `EncoderHttpMessageWriter`.  The original code used a ternary operator to conditionally choose between `writeAndFlushWith` and `writeWith`.  The revised code uses an `if` statement, making the conditional logic more explicit and readable.  Critically, it now includes a `Mono.fromCallable` wrapper around the `buffer` to ensure proper resource management (releasing pooled buffers)",
            "avg_logprobs": -0.22917505264282226
        }
    },
    {
        "commit_hash": "2950958f35de1a6d5a265017c5111f640b9887aa",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/function/DefaultServerRequest.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-import java.util.Enumeration;\n-\t\t\tEnumeration<String> attributeNames = this.servletRequest.getAttributeNames();\n-\t\t\twhile (attributeNames.hasMoreElements()) {\n-\t\t\t\tString name = attributeNames.nextElement();\n-\t\t\t\tthis.servletRequest.removeAttribute(name);\n-\t\t\t}\n+\t\t\tList<String> attributeNames = Collections.list(this.servletRequest.getAttributeNames());\n+\t\t\tattributeNames.forEach(this.servletRequest::removeAttribute);",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Fix ConcurrentModificationException on Undertow",
        "commit_body": "This commit fixes a ConcurrentModificationException that occurs when\nrequesting a nonexistant route.\n\nCloses gh-22698\n",
        "linked_issues": [
            {
                "issue_id": "22698",
                "issue_title": "ConcurrentModificationException when serving Servlet.fn request and Undertow",
                "issue_body": "I get this with Undertow (but not Tomcat):\r\n\r\n```\r\nCaused by: java.util.ConcurrentModificationException\r\n\tat java.util.HashMap$HashIterator.nextNode(HashMap.java:1437)\r\n\tat java.util.HashMap$KeyIterator.next(HashMap.java:1461)\r\n\tat io.undertow.servlet.util.IteratorEnumeration.nextElement(IteratorEnumeration.java:44)\r\n\tat org.springframework.web.servlet.function.DefaultServerRequest$ServletAttributesMap.clear(DefaultServerRequest.java:377)\r\n\tat org.springframework.web.servlet.function.RequestPredicates.restoreAttributes(RequestPredicates.java:292)\r\n\tat org.springframework.web.servlet.function.RequestPredicates.access$300(RequestPredicates.java:67)\r\n```\r\n\r\nBasic app:\r\n\r\n```\r\n@SpringBootApplication\r\npublic class ServletApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(ServletApplication.class, args);\r\n\t}\r\n\r\n\t@Bean\r\n\tpublic RouterFunction<?> userEndpoints() {\r\n\t\treturn route().GET(\"/hello\", request -> ok().body(\"Hello\")).build();\r\n\t}\r\n\r\n}\r\n```\r\n\r\nThe error shows up when you try to visit a non-existent endpoint (e.g. http://localhost:8080/).",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `while` loop iterating over attribute names to remove them from the `servletRequest` with a stream-based approach using `Collections.list` and `forEach`.  This change leverages the `forEach` method on a `List` to remove all attributes in a more concise and potentially more efficient manner.  The original `Enumeration`-based loop is replaced with a more modern, functional-style approach",
            "avg_logprobs": -0.19230851162685436
        }
    },
    {
        "commit_hash": "2a19b8f7a5f9dcc43831b2f674b76c9bd1fa6d31",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (ClassUtils.isPresent(\"kotlinx.coroutines.Deferred\", classLoader)) {\n+\t\tif (reactorPresent && ClassUtils.isPresent(\"kotlinx.coroutines.Deferred\", classLoader)) {\n-\t\tif (ClassUtils.isPresent(\"kotlinx.coroutines.flow.Flow\", classLoader)) {\n+\t\tif (reactorPresent && ClassUtils.isPresent(\"kotlinx.coroutines.flow.Flow\", classLoader)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine Coroutines adapter registration activation",
        "commit_body": "Closes gh-23087\n",
        "linked_issues": [
            {
                "issue_id": "23087",
                "issue_title": "Refine Coroutines adapter registration activation",
                "issue_body": "Coroutines adapter should be registered only when Reactor is available, otherwise it can trigger error when using Spring MVC with Coroutines in the classpath. This issue is a refinement of #19975.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change introduces a new boolean variable `reactorPresent` (presumably defined elsewhere) and now conditions the checks for `kotlinx.coroutines.Deferred` and `kotlinx.coroutines.flow.Flow` presence on this variable.  This suggests the code is now conditionally checking for these classes only if a Reactor-related condition is met.  The original checks were unconditional",
            "avg_logprobs": -0.27675883800952467
        }
    },
    {
        "commit_hash": "2ac4355ec075fec77a8fbafd635fb4fefba81d4e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/asm/ClassReader.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+    // SPRING PATCH: leniently handle offset mismatch\n+    if (bytecodeOffset >= labels.length) {\n+      return new Label();\n+    }\n+    // END OF PATCH",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ASM ClassReader leniently handles label offset mismatch (again)",
        "commit_body": "Issue: SPR-17467\n",
        "linked_issues": [
            {
                "issue_id": "21999",
                "issue_title": "Type annotations and generic types causing ArrayIndexOutOfBoundsException [SPR-17467]",
                "issue_body": "**[aprantl](https://jira.spring.io/secure/ViewProfile.jspa?name=aprantl1)** opened **[SPR-17467](https://jira.spring.io/browse/SPR-17467?redirect=false)** and commented\n\nWe just tried upgrading our project to from Spring Framework 5.0.8 to 5.1.2 but unfortunately we hit a blocker which seems to be some kind of regression. At least my Google search yielded [a two year old ASM bug report](https://gitlab.ow2.org/asm/asm/issues/317615) which also have been fixed shortly after .\n\nWe are getting an `ArrayIndexOutOfBoundException` when initialising the ApplicationContext or when calling certain methods that make use of type annotations in the method body. Additionally, it seem to be necessary that the affected class inherits from a generic type.\n\nI've attached a small test project that should help reproducing the bug. If you execute the test you should see the error. Downgrading the dependency to Spring Framework 5.0.8 solves the issue.\n\nOur test systems use MacOs und CentOs with JDK 1.8.0_181.\n\n---\n\n**Affects:** 5.1.2\n\n**Attachments:**\n- [project.zip](https://jira.spring.io/secure/attachment/26084/project.zip) (_18.27 kB_)\n\n**Issue Links:**\n- #22029 ArrayIndexOutOfBoundsException when reading metadata for a class that uses javax.validation.NotNull on a local variable (_**\"is duplicated by\"**_)\n- #18661 Type annotations cause ArrayIndexOutOfBoundsException in ASM ClassReader\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/2ac4355ec075fec77a8fbafd635fb4fefba81d4e\n\n1 votes, 3 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis seems to be #18661 coming back indeed since we upgraded to ASM 7.0 for Spring Framework 5.1, with a heavily refactored `ClassReader` where we did not re-apply that old patch of ours. Since ASM refused to fix this itself (which I unfortunately haven't noticed), I've reintroduced a defensive patch to our ASM 7.0 fork for the Spring Framework 5.1.3 release.\n\nThis will be available in the upcoming `5.1.3.BUILD-SNAPSHOT`. Feel free to give it an early try...\n",
                    "**[aprantl](https://jira.spring.io/secure/ViewProfile.jspa?name=aprantl1)** commented\n\nThanks, that was quick. I successfully tested the fix with the `5.1.3.BUILD-SNAPSHOT`. Looking forward to using the `5.1.3.RELEASE` with Java 11.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood to hear! FYI, Spring Framework 5.1.3 is scheduled for release on Nov 26, with the Spring Boot 2.1.1 release following a day later.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure `bytecodeOffset` is within the bounds of the `labels` array.  If it's out of bounds, a new `Label` object is returned, likely to handle an unexpected or invalid offset in the bytecode. This suggests a potential fix for a previous issue where an invalid offset could cause an exception.  The patch aims for more robust error handling by preventing an array index out-of-bounds exception",
            "avg_logprobs": -0.23920018185851394
        }
    },
    {
        "commit_hash": "2bfff7fc376c4c747cc9811c54c0ba320787db11",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\treturn new UrlResource(ResourceUtils.toURI(cleanedPath));\n+\t\t\t\t\t// Cannot test for URLStreamHandler directly: URL equality for same String\n+\t\t\t\t\t// in order to find out whether original URL uses default URLStreamHandler.\n+\t\t\t\t\tif (ResourceUtils.toURL(urlString).equals(url)) {\n+\t\t\t\t\t\t// Plain URL with default URLStreamHandler -> replace with cleaned path.\n+\t\t\t\t\t\treturn new UrlResource(ResourceUtils.toURI(cleanedPath));\n+\t\t\t\t\t}\n+\t\t\t// Retain original URL instance, potentially including custom URLStreamHandler.",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Retain original URL instance in case of custom URLStreamHandler",
        "commit_body": "Closes gh-33199\n",
        "linked_issues": [
            {
                "issue_id": "33199",
                "issue_title": "PathMatchingResourcePatternResolver#convertClassLoaderURL drops URLStreamHandler in version 6.1.x",
                "issue_body": "I'm trying to upgrade to spring version **6.1.x**. Due to the specific nature of a project, we use a custom class loader and custom java.net.URLStreamHandler which handles the opening of the JAR files.\r\n\r\nUp to version `6.0.x` the URL object remains as is in `PathMatchingResourcePatternResolver#convertClassLoaderURL` but since version `6.1.x` the whole URL object is replaced by a new one keeping only the URL string. \r\n\r\nCurrently, there is no method how to keep the `URLStreamHandler` as the framework constructs a new URL. It would be beneficial to have the possibility to turn off this behaviour or somehow pass the handler of the original URL to the new one constructed.  ",
                "issue_state": "closed",
                "issue_comment": [
                    "This is actually a regression as of 6.1.7 where we enforce the use of cleaned URLs: #32828\r\n\r\nWe'll see what we can do to retain the original URL in case of a custom `URLStreamHandler`. Do those URLs look like regular jar URLs in every other respect, or is there some indication of being a custom URL (other than internally storing a custom handler)?",
                    "The URLs look like regular jar URLs.\r\nWe are required to utilize a custom URLStreamHandler because the JAR file is encrypted and cannot be accessed using the standard method.",
                    "For the time being, the only way to prevent this URL replacement is for the original URL to expose a pre-cleaned path so that the `StringUtils.cleanPath(urlString).equals(urlString)` condition is met, in which case the original URL is being retained already. Maybe that's something you could revise your custom ClassLoader towards.\r\n\r\nFor 6.1.12, we can try to retain the original URL based on some extra indication that it has a custom handler. However, `URLStreamHandler` usage is pretty opaque, so it is not obvious how we can check for the original URL having such a custom handler. We might be able to do `new URL(originalUrl.toString()).equals(originalUrl)` and see whether this returns `false`, assuming that the associated handler differs then. Would that work in your scenario?\r\n\r\nFWIW our revision in 6.1 is driven by the deprecation of all `URL` constructors in JDK 20: https://docs.oracle.com/en%2Fjava%2Fjavase%2F22%2Fdocs%2Fapi%2F%2F/java.base/java/net/URL.html#constructor-deprecation",
                    "The condition `StringUtils.cleanPath(urlString).equals(urlString)` is not met only due to path separators in our case. We will revise the ClassLoader if it is feasible to return the cleaned path.\r\n\r\nHowever, the approach of checking equals seems ok (as it is probably the only option, how to check if the `URL` has a custom `URLStreamHandler`). "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a check to determine if the original URL uses the default URLStreamHandler.  If it does, the code now returns a `UrlResource` constructed from the cleaned path.  Otherwise, the original URL instance is retained, likely to preserve any custom URLStreamHandler.  The core change is the addition of a conditional check based on URL equality to handle cases where a custom URLStreamHandler might be in use",
            "avg_logprobs": -0.22320846031452046
        }
    },
    {
        "commit_hash": "2c1afca9c556b63c1645630b1db8d2934d1f2033",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.util.CollectionUtils;\n-\t\tformData.forEach((name, values) ->\n+\t\tformData.forEach((name, values) -> {\n+\t\t\t\tif (name == null) {\n+\t\t\t\t\tAssert.isTrue(CollectionUtils.isEmpty(values), \"Null name in form data: \" + formData);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n-\t\t\t\t}));\n+\t\t\t\t});\n+\t\t});",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reject null form data names",
        "commit_body": "...or skip if there are no values either.\n\nCloses gh-22372\n",
        "linked_issues": [
            {
                "issue_id": "22372",
                "issue_title": "Keys for form data in FormHttpMessageConverter must not be null",
                "issue_body": "Fix for java.lang.IllegalArgumentException",
                "issue_state": "closed",
                "issue_comment": [
                    "@GWhiskas Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22372)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22372) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@GWhiskas Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22372)!",
                    "I've addressed this slightly differently, thanks."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for the `name` key in the `formData` map.  Previously, the code iterated through the map without checking for null `name` values.  Now, if a `name` is null, it asserts that the corresponding `values` list is empty.  If not empty, an assertion error is thrown, preventing potential issues.  This is a defensive programming improvement to handle potential null input",
            "avg_logprobs": -0.21787327660454645
        }
    },
    {
        "commit_hash": "2c5a1af236e6c90460b2279fd0a871d0fc6c9d6e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/KotlinReflectionParameterNameDiscoverer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\n+\t\tif (ctor.getDeclaringClass().isEnum() || !KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Leverage Java reflection for Kotlin enums",
        "commit_body": "As discussed in KT-25165, from a Kotlin POV enum constructors\nhave no parameter, this is an \"implementation detail\"\nrequired for running on the JVM, so it seems relevant to skip\nKotlin reflection in that case and just delegate to Java\nreflection.\n\nIssue: SPR-16931\n",
        "linked_issues": [
            {
                "issue_id": "21470",
                "issue_title": "Unable to use Kotlin enums with @Validated beans [SPR-16931]",
                "issue_body": "**[Daniel Jones](https://jira.spring.io/secure/ViewProfile.jspa?name=jonesd9)** opened **[SPR-16931](https://jira.spring.io/browse/SPR-16931?redirect=false)** and commented\n\nI have a configuration properties kotlin class with a kotlin enum property. If the class is annotated with `@Validated`\u00a0an exception occurs in hibernate-validator's `ParameterMetadata`\u00a0class due to an `IndexOutOfBoundsException`.\n\nThis seems to happen due to the underlying `ParameterNameDiscoverer`, `KotlinReflectionParameterNameDiscoverer`.\n\nI think this is due to the validator class expecting a 2-parameter constructor (name, ordinal) but `KotlinReflectionParameterNameDiscoverer` returns an empty array.\n\nExample configuration properties class:\n\n```java\n@ConfigurationProperties(\"my.prefix\")\n@Validated\ndata class MyProperties(        \n        var enumProp: MyEnum = MyEnum.ONE\n\n) {\n    enum class MyEnum {\n        ONE, TWO\n    }\n} \n```\n\n\n\n---\n\n**Affects:** 5.0.6\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/2c5a1af236e6c90460b2279fd0a871d0fc6c9d6e, https://github.com/spring-projects/spring-framework/commit/73db2081cd734ae6f26b84b10e8a5049631f7b53\n\n**Backported to:** [5.0.11](https://github.com/spring-projects/spring-framework/milestone/192?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nIndeed, I have been able to reproduce this issue. Not sure what we do wrong here, it could be a Kotlin reflection bug or a conceptual difference between Java and Kotlin. Any thoughts [Daniel Jones](https://jira.spring.io/secure/ViewProfile.jspa?name=jonesd9)?\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nI have created\u00a0[KT-25165.](https://youtrack.jetbrains.net/issue/KT-25165)\n",
                    "**[Daniel Jones](https://jira.spring.io/secure/ViewProfile.jspa?name=jonesd9)** commented\n\nSorry, missed the notification from 6 days ago. I'm not really sure other than I remembering getting different results in the debugger if I used Kotlin's reflection API over Java's.\n\nA quick go on the Kotlin REPL in IntelliJ gives me the following differences:\n\nUsing the Kotlin API, this returns an empty array\n\n```java\n// toTypeArray().size == 1\nMyEnum::class.constructors.toTypedArray()[0].parameters\n>> []\n```\n\nUsing the Java API, I get the expected 2-arg constructor\n\n```java\n// declaredConstructors.size == 1\nMyEnum::class.java.declaredConstructors[0]\n>> protected my.package.MyEnum(java.lang.String,int)\n```\n\nSo I think you're on the right track that the issue is with Kotlin.\n",
                    "**[ruslanys](https://jira.spring.io/secure/ViewProfile.jspa?name=ruslanys)** commented\n\n[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze),\u00a0\n\nI'm sorry for disturbing you, but I have the same issue and tried to solve it.\n\nSo, can we tweak `KotlinReflectionParameterNameDiscoverer` to solve this issue?\n\nIn my perspective, looks that all in our hands and we don't need to wait for something from Kotlin.\n\nLooks, like if we add checking for enums, it will solve the issue.\r\nI changed the method with the following and it works for me.\n\n```java\n@Override\r\n@Nullable\r\npublic String[] getParameterNames(Constructor<?> ctor) {\r\n\tif (ctor.getDeclaringClass().isEnum() || !KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\ttry {\r\n\t\tKFunction<?> function = ReflectJvmMapping.getKotlinFunction(ctor);\r\n\t\treturn (function != null ? getParameterNames(function.getParameters()) : null);\r\n\t}\r\n\tcatch (UnsupportedOperationException ex) {\r\n\t\treturn null;\r\n\t}\r\n}\r\n```\n\nAccording to `PrioritizedParameterNameDiscoverer.getParameterNames(Constructor<?> ctor)` method, `ParameterNameDiscoverer` s will be applied until one of them won't return null.\n\nSo, when `KotlinReflectionParameterNameDiscoverer` returns null, then the following `StandardReflectionParameterNameDiscoverer` will be applied and return `\"$enum$name\", \"$enum$oridnal\"` parameters for default enum and this won't cause an error.\n\nAnd looks like Alexander Udalov from JetBrains [had clear clarification](https://youtrack.jetbrains.net/issue/KT-25165#focus=streamItem-27-2939479-0-0): for Kotlin language, Enum doesn't have undeclared parameters.\n\nSo, because of this, don't you think that for Kotlin Enums we should delegate parameters discovering to Java?\r\nCan we use the suggested approach?\n",
                    "**[ruslanys](https://jira.spring.io/secure/ViewProfile.jspa?name=ruslanys)** commented\n\nI've added a [PR-1985](https://github.com/spring-projects/spring-framework/pull/1985), please take a look.\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nThanks I will have a look asap.\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nFix in `master` and `5.0.x` branches, I think indeed this is the correct approach. Thanks for your feedback and help on that issue.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `ctor.getDeclaringClass().isEnum()`.  Previously, the code only checked if the type was not Kotlin.  The updated code now also excludes enum types.  This suggests a specific handling for enum constructors might be implemented or planned, or that enum constructors were causing issues that needed to be excluded from the original Kotlin-specific logic",
            "avg_logprobs": -0.3010809482672276
        }
    },
    {
        "commit_hash": "2c7d2f70636691bdbaadcf1eccb87a29fe171b78",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/context/support/ServletContextResource.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tURL url = getURL();\n-\t\tif (ResourceUtils.isFileURL(url)) {\n+\t\tURL url = this.servletContext.getResource(this.path);\n+\t\tif (url != null && ResourceUtils.isFileURL(url)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Handle non-existent files in ServletContextResource",
        "commit_body": "ServletContextResource#getFile now falls back to #getRealPath for\nnon-existent files\n\nIssue: SPR-8461\n",
        "linked_issues": [
            {
                "issue_id": "13107",
                "issue_title": "ServletContextResource getFile should not rely on getRealPath (for WebLogic 10 compatibility) [SPR-8461]",
                "issue_body": "**[Jason Arndt](https://jira.spring.io/secure/ViewProfile.jspa?name=jarndt196)** opened **[SPR-8461](https://jira.spring.io/browse/SPR-8461?redirect=false)** and commented\n\nWhen using the ResourceHttpRequestHandler to serve static resources the ServletContextResource's getFile() method that is used doesn't work when not deploying exploded.\n\nHere is the scenario:\n\n* wire up in spring config\n  <mvc:resources mapping=\"/resources/**\" location=\"/resources/\" />\n\n* access http://localhost:7001/myapp/resources/images/img.gif\n\n* DispatcherServlet gets the request and delegates to the ResourceHttpRequestHandler.getResource()\n\n* ResourceHttpRequestHandler uses the ServletContextResource from it's list of locations to check \"exists\" and \"readable\"\n\n* ServletContextResource says yes it exists\n\n* isReadable() hops to AbstractFileResolvingResource, which determines that is is a \"file system resolution\" and calls getFile() on ServletContextResource.  NOTE: the url that is returned by Weblogic is file:c:/weblogic/tmp/blah/blah/blah/resources/images/img.gif\n\n* The ServletContextResource.getFile() uses WebUtils.getRealPath(), which is returning /resources/images/img.gif and it tries to then create a File object.\n\nI was able to work around this issue by creating and plugging in a custom ServletContextResource class that overrides the getFile() method and does this:\n\n`@Override`\npublic File getFile() throws IOException {\n////////////////////////////////////////////////////\n//TODO: this fixes a Bug in spring...they are using file path resolution, so use it here too...\n//   `@see` AbstractFileResolvingResource.isReadable()\n//String realPath = WebUtils.getRealPath(this.servletContext, this.path);\n//return new File(realPath);\n////////////////////////////////////////////////////////\nURL url = getServletContext().getResource(getPath());\nString realPath = url.getPath();\nreturn new File(realPath);\n}\n\nI have tested this using Weblogic 10.3 deployed exploded, not exploded, and using the eclipse plugin which is basically exploded.\n\n\n---\n\n**Affects:** 3.0.5, 3.1 M1, 3.1 M2\n\n4 votes, 6 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Jonathan](https://jira.spring.io/secure/ViewProfile.jspa?name=jisajs9)** commented\n\nJason,\n\nI have a subclass of ServletContextResource that overrides the getFile method as described, but I'm not sure how to register it to be used.  Can you provide advice on how to wire it up.\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe fixed this for tomorrow's 3.1 RC2 and also for the upcoming 3.0.7 release which will go out in late December. The fix is a bit different but will have the same effect: We check for \"file:\" URLs and simply call super.getFile() in that case since AbstractFileResolvingResource has proper code for that purpose already.\n\nFor overriding the default ServletContextResource implementation, you'd have to override your ApplicationContext's getResourceByPath implementation accordingly, returning a custom Resource class instead. Hopefully 3.1 RC2 (or 3.0.7) will be out early enough for your purposes.\n\nJuergen\n",
                    "**[Jonathan](https://jira.spring.io/secure/ViewProfile.jspa?name=jisajs9)** commented\n\nJuergen,  thanks for the updates\n",
                    "**[Piotr Findeisen](https://jira.spring.io/secure/ViewProfile.jspa?name=pofin)** commented\n\nWe recently upgraded from Spring 3.0.5 to Spring 3.1 and...  is there any way to get the legacy behavior in `ServletContextResource`?\n\nI'm running on JBoss 4.2.3 and have `ServletContextResource` with `path = \"/../some.jar\"`. In Spring 3.0.5 i could call `ServletContextResource.getFile()` to get a file handle to the jar and later open it. In Spring 3.1 calling `ServletContextResource.getFile()` throws\n\n```\njava.io.FileNotFoundException: ServletContext resource [/../some.jar] cannot be resolved to URL because it does not exist\n\tat org.springframework.web.context.support.ServletContextResource.getURL(ServletContextResource.java:132)\n\tat org.springframework.web.context.support.ServletContextResource.getFile(ServletContextResource.java:147)\n```\n\nThe `getFile()` methods never makes to the legacy part:\n\n```\n...\nelse {\n     String realPath = WebUtils.getRealPath(this.servletContext, this.path);\n     return new File(realPath);\n}\n```\n\n",
                    "**[Piotr Findeisen](https://jira.spring.io/secure/ViewProfile.jspa?name=pofin)** commented\n\nIt may be that the improvement of #9715 no longer works -- correct me if i'm wrong.\n",
                    "**[Michael Wyraz](https://jira.spring.io/secure/ViewProfile.jspa?name=micw)** commented\n\nThe fix is invalid since it breaks functionality. If the File does not exist, it fails with an exception (in getURL()) instead of returning the path of the non-existent File.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nFixed for 3.2 M1 and 3.1.2, falling back to getRealPath for non-existent files.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how the `ServletContextResource` retrieves the URL.  Instead of first getting the URL using `getURL()`, it now directly retrieves it using `this.servletContext.getResource(this.path)`.  Crucially, it adds a null check (`if (url != null ...`) before checking if the URL is a file URL.  This likely addresses a potential `NullPointerException` that could occur if `this.servletContext.getResource(this",
            "avg_logprobs": -0.12813132286071777
        }
    },
    {
        "commit_hash": "2c98c1b81a2bfb6d0d13415a2fd222b642106146",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/jmx/export/MBeanExporter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tObject managedResource, ModelMBean modelMBean, ObjectName objectName) {\n+\t\t\tObject managedResource, @Nullable ModelMBean modelMBean, @Nullable ObjectName objectName) {\n-\t\tif (managedResource instanceof NotificationPublisherAware) {\n+\t\tif (managedResource instanceof NotificationPublisherAware && modelMBean != null && objectName != null) {\n-\t\t\tAssert.state(this.modelMBean != null && this.objectName != null, \"Not initialized\");",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Relaxed assertion in NotificationPublisherAwareLazyTargetSource",
        "commit_body": "Issue: SPR-17592\n",
        "linked_issues": [
            {
                "issue_id": "22124",
                "issue_title": "Exporting a lazily initialized bean (which implements SelfNaming and is annotated with ManagedResource annotation) gives IllegalStateException [SPR-17592]",
                "issue_body": "**[Lavish Kothari](https://jira.spring.io/secure/ViewProfile.jspa?name=lavishkothari)** opened **[SPR-17592](https://jira.spring.io/browse/SPR-17592?redirect=false)** and commented\n\nI'm having a bean that is\n* annotated with `ManagedResource`\n* lazily initialized\n* implements `SelfNaming`\n\nI'm exporting it using spring's `AnnotationMBeanExporter`.\n\nAll this works good when I'm using spring version `4.3.16.RELEASE`, but when I upgraded my spring version to `5.0.5.RELEASE` or `5.1.3.RELEASE` this code started giving me `IllegalStateException`.\n\nMy Bean definition and the spring's context.xml looks like this:\n\n\u00a0SampleBean.java\n\n```java\npackage com.jmx.trial.dummybeans;\r\n\r\nimport org.springframework.jmx.export.annotation.ManagedResource;\r\nimport org.springframework.jmx.export.naming.SelfNaming;\r\n\r\nimport javax.management.MalformedObjectNameException;\r\nimport javax.management.ObjectName;\r\n\r\n@ManagedResource\r\npublic class SampleBean implements SelfNaming {\r\n    @Override\r\n    public ObjectName getObjectName() throws MalformedObjectNameException {\r\n        return new ObjectName(\"com.jmx.trial:name=sampleBean\");\r\n    }\r\n}\r\n```\n\n\u00a0\n\napplication-context.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <bean id=\"server\" class=\"org.springframework.jmx.support.MBeanServerFactoryBean\"/>\r\n\r\n    <bean id=\"exporter\" class=\"org.springframework.jmx.export.annotation.AnnotationMBeanExporter\">\r\n        <property name=\"server\" ref=\"server\"/>\r\n    </bean>\r\n\r\n    <bean id=\"sampleBean\" class=\"com.jmx.trial.dummybeans.SampleBean\" lazy-init=\"true\"/>\r\n\r\n</beans>\r\n```\n\nI understand that an extra validation was added [here](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/jmx/export/MBeanExporter.java#L1115), and this is causing `IllegalStateException` but I'm not completely sure why that was added.\n\n\u00a0\n\nThe stack-trace looks like this:\n\n```java\norg.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean [sampleBean] with key 'sampleBean'; nested exception is java.lang.IllegalStateException: Not initialized\r\n\r\n    at org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:625)\r\n    at org.springframework.jmx.export.MBeanExporter.lambda$registerBeans$2(MBeanExporter.java:551)\r\n    at java.base/java.util.HashMap.forEach(HashMap.java:1336)\r\n    at org.springframework.jmx.export.MBeanExporter.registerBeans(MBeanExporter.java:551)\r\n    at org.springframework.jmx.export.MBeanExporter.afterSingletonsInstantiated(MBeanExporter.java:434)\r\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:863)\r\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:863)\r\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)\r\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:144)\r\n    at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:85)\r\n    at com.jmx.trial.MBeanExporterTest.testBeanExportedWithXml(MBeanExporterTest.java:79)\r\n    at com.jmx.trial.MBeanExporterTest.testForLazyAutoDetectWithSelfNaming(MBeanExporterTest.java:44)\r\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n    at java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\r\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\r\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\r\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\r\n    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\r\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\r\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\r\nCaused by: java.lang.IllegalStateException: Not initialized\r\n    at org.springframework.util.Assert.state(Assert.java:73)\r\n    at org.springframework.jmx.export.MBeanExporter$NotificationPublisherAwareLazyTargetSource.postProcessTargetObject(MBeanExporter.java:1115)\r\n    at org.springframework.aop.target.LazyInitTargetSource.getTarget(LazyInitTargetSource.java:72)\r\n    at org.springframework.jmx.export.MBeanExporter$NotificationPublisherAwareLazyTargetSource.getTarget(MBeanExporter.java:1103)\r\n    at org.springframework.aop.framework.CglibAopProxy$DynamicUnadvisedInterceptor.intercept(CglibAopProxy.java:475)\r\n    at com.jmx.trial.dummybeans.SampleBean$$EnhancerBySpringCGLIB$$9cd1c95b.getObjectName(<generated>)\r\n    at org.springframework.jmx.export.MBeanExporter.getObjectName(MBeanExporter.java:752)\r\n    at org.springframework.jmx.export.MBeanExporter.registerLazyInit(MBeanExporter.java:726)\r\n    at org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:596)\r\n    ... 33 more\r\n```\n\n\u00a0\n\nMy experiments:\n* When I don't lazily initialize the `SampleBean`, I don't get this `IllegalStateException`.\n* When I annotate SampleBean with `ManagedResource(objectName = \"com.jmx.trial:name=sampleBean\")` and make `SampleBean` _not_ implement `SelfNaming` interface, again I don't get `IllegalStateException`\n* When I debug this and place a lot of breakpoints in `MBeanExporter` and `CGLibAopProxy` I don't get this exception. (This is specifically interesting that in debug-mode the tests run successfully but in normal run mode the tests fails.)\n\nThough not very sure, but I think implementing `SelfNaming` interface is not a very good idea as the javadocs of `SelfNaming` interface says that:\n\n> This interface is mainly intended for internal usage.\n\nI'm not sure if it is the problem with using `SelfNaming` interface or I'm doing something fundamentally wrong. Can you please explain this behavior and point me to the fundamentals that I'm missing.\n\nPS: some of my findings: (might be unrelated) From [here](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html) I found this caution point:\n\n> Do not use interface-based AOP proxies in combination with autodetection of JMX annotations in your bean classes.\n\nI don't completely understand this, but is this the rule that I'm violating?\n\n\u00a0\n\nI feel that the `Assert.state` that is getting called in `postProcessTargetObject` should be moved into the method `injectNotificationPublisherIfNecessary` and should be called only if `managedResource instanceof NotificationPublisherAware` is `true`.\n\n---\n\n**Affects:** 5.0.5, 5.1.3\n\n**Reference URL:** https://stackoverflow.com/questions/53711613/exporting-a-lazily-initialized-bean-which-implements-selfnaming-and-is-annotate\n\n**Attachments:**\n- [lazy-autodetect-with-selfNaming.xml](https://jira.spring.io/secure/attachment/26151/lazy-autodetect-with-selfNaming.xml) (_661 bytes_)\n- [LazyBeanExportingTest.java](https://jira.spring.io/secure/attachment/26153/LazyBeanExportingTest.java) (_1.16 kB_)\n- [SampleBean.java](https://jira.spring.io/secure/attachment/26152/SampleBean.java) (_496 bytes_)\n\n**Issue Links:**\n- #20276 Extend null-safety to field level\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/e95c1b3153bfa0318d0bbf440bf257ea38e792e5, https://github.com/spring-projects/spring-framework/commit/2c98c1b81a2bfb6d0d13415a2fd222b642106146\n\n**Backported to:** [5.0.12](https://github.com/spring-projects/spring-framework/milestone/193?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out to be a side effect of our nullability efforts in 5.0. I've effectively relaxed it in `injectNotificationPublisherIfNecessary` itself, simply skipping the callback if there is no state to pass in.\n\nThanks for raising this! Please give the upcoming `5.1.4.BUILD-SNAPSHOT` / `5.0.12.BUILD-SNAPSHOT` a try and let me know whether it works for you now...\n",
                    "**[Lavish Kothari](https://jira.spring.io/secure/ViewProfile.jspa?name=lavishkothari)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) Thanks for a quick response.\n\nI confirm that `5.1.4.BUILD-SNAPSHOT` works good for me.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds nullability annotations (`@Nullable`) to the `modelMBean` and `objectName` parameters.  Critically, it also introduces a conditional check (`if (managedResource instanceof NotificationPublisherAware && modelMBean != null && objectName != null)`) within the method.  This means the previous `Assert",
            "avg_logprobs": -0.13461874961853026
        }
    },
    {
        "commit_hash": "2d86f221ce9e4df99aec801ae226ed228f5b64ac",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/codec/json/Jackson2Tokenizer.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tif (!this.parser.hasCurrentToken()) {\n-\t\t\t\tSystem.out.println(\"NO CURRENT TOKEN: \" + token);\n-\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove println",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removed a debugging print statement.  Specifically, it removed a check for `parser.hasCurrentToken()` and the subsequent print statement if the condition was false.  This suggests the original code was likely used for debugging and is now no longer needed",
            "avg_logprobs": -0.17944296351018943
        }
    },
    {
        "commit_hash": "2daa0745611f4989a5dc99619dd4aef541288503",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/ParamsRequestCondition.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tlong count = 0;\n-\t\tfor (ParamExpression e : expressions) {\n-\t\t\tif (e.getValue() != null && !e.isNegated()) {\n-\t\t\t\tcount++;\n-\t\t\t}\n-\t\t}\n-\t\treturn count;\n+\t\treturn expressions.stream()\n+\t\t\t\t.filter(e -> e.getValue() != null && !e.isNegated())\n+\t\t\t\t.count();",
        "change_count": 10,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Use count in ParamsRequestCondition#getValueMatchCount",
        "commit_body": "See gh-32088\n",
        "linked_issues": [
            {
                "issue_id": "32088",
                "issue_title": "Use count in ParamsRequestCondition#getValueMatchCount",
                "issue_body": "\r\nThe `getValueMatchCount` method was refactored to use a `Stream` instead of a `for-each loop`, eliminating the need for the unnecessary local variable `count`. This change was made to reduce the risk of accidental modifications during future maintenance, as the implementation is possible without using a local variable. Additionally, the refactoring was done for enhanced stability and maintainability, especially since there was no need to interrupt the loop under specific conditions.\r\n\r\n\r\n\r\n- [x]  The test code was executed and passed successfully.",
                "issue_state": "closed",
                "issue_comment": [
                    "@Ryan-Dia congratulations for making your first contribution to Spring Framework.",
                    "@Ryan-Dia the team has discussed this change today and we've decided to revert it. I had missed that the method you've changed is in a hot code path and we explicitly avoid using the Stream API in such places. ",
                    "Thank you for reviewing the changes I proposed. I understand the decision to revert them, recognizing that the modified method is in a hot code path. I appreciate the feedback and will ensure my future contributions are more closely aligned with these best practices\r\n\r\n\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `for` loop counting `ParamExpression` objects with a Java Stream's `filter` and `count` operation.  The original code iterated through the `expressions` list and incremented a counter if a condition was met. The new code achieves the same result more concisely and functionally by using streams.  This change improves readability and potentially efficiency (though the difference is likely negligible in this specific case)",
            "avg_logprobs": -0.19454739602764
        }
    },
    {
        "commit_hash": "2e5d0470dc0c9766d98d144d5b6bd56248112e46",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tSet<String> ignoreSet = (ignoreProperties != null ? new HashSet<>(Arrays.asList(ignoreProperties)) : null);\n+\t\tSet<String> ignoredProps = (ignoreProperties != null ? new HashSet<>(Arrays.asList(ignoreProperties)) : null);\n-\t\t\tif (writeMethod != null && (ignoreSet == null || !ignoreSet.contains(targetPd.getName()))) {\n+\t\t\tif (writeMethod != null && (ignoredProps == null || !ignoredProps.contains(targetPd.getName()))) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change renames the `ignoreSet` variable to `ignoredProps`.  This is a simple renaming of a variable used in a conditional statement, which checks if a property should be ignored during a bean copy operation.  The logic of the conditional remains the same",
            "avg_logprobs": -0.19609031677246094
        }
    },
    {
        "commit_hash": "2e5d752e15164b331ad48bcdcb61c174f880498c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tfor (String beanName : candidateBeans.keySet()) {\n+\t\tfor (Map.Entry<String, T> entry : candidateBeans.entrySet()) {\n+\t\t\tString beanName = entry.getKey();\n-\t\t\t\tmatchingBean = candidateBeans.get(beanName);\n+\t\t\t\tmatchingBean = entry.getValue();",
        "change_count": 5,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Better use of key iterator",
        "commit_body": "This commit uses an EntrySet instead of looping over the keys and\nretrieving the value in a separate call.\n\nIssue: SPR-12356\n",
        "linked_issues": [
            {
                "issue_id": "16961",
                "issue_title": "BeanFactoryAnnotationUtils,qualifiedBeanOfType, Inefficient use of keySet iterator. [SPR-12356]",
                "issue_body": "**[Min Ho Pak](https://jira.spring.io/secure/ViewProfile.jspa?name=luckybomb)** opened **[SPR-12356](https://jira.spring.io/browse/SPR-12356?redirect=false)** and commented\n\nBeanFactoryAnnotationUtils,qualifiedBeanOfType method use KeySet Iterator.\n\nIt is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.\n\npull request:\nhttps://github.com/spring-projects/spring-framework/pull/667\n\n---\n\n**Affects:** 4.1.1\n\n**Issue Links:**\n- #17037 MessageHeaderAccessor copyHeaders... tuning\n- #16968 org.springframework.ui.ModelMap.mergeAttributes(Map) makes inefficient use of keySet iterator\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/667, and commits https://github.com/spring-projects/spring-framework/commit/2e5d752e15164b331ad48bcdcb61c174f880498c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nThanks for the PR. You get a point that in that particular case this is more efficient, especially because we are building a map ourselves and we can guarantee its nature.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change iterates over a `Map` (`candidateBeans`) instead of using `keySet()` and then retrieving the value.  This change uses a `Map.Entry` to directly access the value associated with each key, eliminating an extra `get()` operation.  This improves efficiency by avoiding an extra lookup",
            "avg_logprobs": -0.2675534174992488
        }
    },
    {
        "commit_hash": "2f0970b18401426846b38388927f182b3327bb98",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/support/AllEncompassingFormHttpMessageConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (jaxb2Present) {\n+\t\t\tif (jaxb2Present && !jackson2XmlPresent) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix an AllEncompassingFormHttpMessageConverter regression",
        "commit_body": "Restore previous behavior to configure\nJaxb2RootElementHttpMessageConverter when JAXB but not Jackson are present.\n\nCloses gh-25291\n",
        "linked_issues": [
            {
                "issue_id": "25291",
                "issue_title": "AllEncompassingFormHttpMessageConverter now uses both JAXB and Jackson by default",
                "issue_body": "**Affects:** 5.3 snapshots\r\n\r\nWhen both JAX-B and Jackson are on the classpath, `AllEncompassingFormHttpMessageConverter` will now configure both `Jaxb2RootElementHttpMessageConverter` and `MappingJackson2XmlHttpMessageConverter`. Previously, the latter was preferred. This change in behaviour was introduced in https://github.com/spring-projects/spring-framework/commit/1e501f2583efd7521fe457453e5f866bcb8c509a as the `jackson2XmlPresent` flag is no longer being checked when deciding if `Jaxb2RootElementHttpMessageConverter` should be configured.",
                "issue_state": "closed",
                "issue_comment": [
                    "Fixed, sorry for the glitch, I missed it. Thanks for your report."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional check in `AllEncompassingFormHttpMessageConverter`.  Originally, the code checked only if JAXB 2 was present (`jaxb2Present`).  The updated code adds a further condition:  it only proceeds if JAXB 2 is present *and* Jackson 2 XML is *not* present (`!jackson2XmlPresent`).  This suggests a preference for using JAXB 2 only when Jackson 2 XML is unavailable",
            "avg_logprobs": -0.14468562126159668
        }
    },
    {
        "commit_hash": "2f920e8fb3bf3f45754ebe64a33bf8c0ed84cfa6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/json/JacksonModulesRuntimeHints.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (ClassUtils.isPresent(className, classLoader)) {\n-\t\t\treflectionHints.registerType(TypeReference.of(className),\n-\t\t\t\t\tbuilder -> builder.onReachableType(TypeReference.of(Jackson2ObjectMapperBuilder.class))\n-\t\t\t\t\t\t\t.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));\n-\t\t}\n+\t\treflectionHints.registerTypeIfPresent(classLoader, className,\n+\t\t\t\tbuilder -> builder.onReachableType(TypeReference.of(Jackson2ObjectMapperBuilder.class))\n+\t\t\t\t\t\t.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish JacksonModulesRuntimeHints",
        "commit_body": "Closes gh-29001\n",
        "linked_issues": [
            {
                "issue_id": "29001",
                "issue_title": "Refine `JacksonModulesRuntimeHints`",
                "issue_body": null,
                "issue_state": "closed",
                "issue_comment": [
                    "Shouldn't the condition be on a Jackson class? Or the module as it's probably optional. ",
                    "Good point, I will update accordingly.",
                    "In fact, maybe the condition is ok with the builder but we should add a classpath check on the related modules since those are instantiated reflectively."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a conditional check (`if (ClassUtils.isPresent(...))`) with a `registerTypeIfPresent` method.  This change likely improves efficiency by avoiding the unnecessary `ClassUtils.isPresent` check if the class is not present, potentially reducing overhead.  The core logic for registering the type and its members remains the same",
            "avg_logprobs": -0.17775765271253988
        }
    },
    {
        "commit_hash": "2f9d0a7de8e2f1247dd4a34811220106f7359aa5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\twhile (j < statement.length && !('}' == statement[j])) {\n+\t\t\t\t\twhile (j < statement.length && '}' != statement[j]) {\n-\t\t\t\t\tif (!(statement[position + j] == START_SKIP[i].charAt(j))) {\n+\t\t\t\t\tif (statement[position + j] != START_SKIP[i].charAt(j)) {\n-\t\t\t\t\t\t\t\tif (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {\n+\t\t\t\t\t\t\t\tif (statement[m + n] != STOP_SKIP[i].charAt(n)) {",
        "change_count": 6,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "simplify boolean NOT operation",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `NamedParameterUtils` modifies the `while` and `if` statements used to parse SQL statements containing skip markers.  The change replaces `!('}' == statement[j])` with `'}' != statement[j]` and `!(statement[x] == char)` with `statement[x] != char`.  This is a stylistic change, converting from a negation of equality to a direct inequality check",
            "avg_logprobs": -0.22603736877441405
        }
    },
    {
        "commit_hash": "2ff22510d92986ebabd0f7f4667d7ede3f83e01d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.util.CollectionUtils;\n-\t\tif (earlyEventsToProcess != null) {\n+\t\tif (!CollectionUtils.isEmpty(earlyEventsToProcess)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid earlyApplicationEvents iteration in case of empty Set",
        "commit_body": "Closes gh-25161\n",
        "linked_issues": [
            {
                "issue_id": "25161",
                "issue_title": "Suggest making a Set.size() > 0 judgement for AbstractApplicationContext.earlyApplicationEvents",
                "issue_body": "https://github.com/spring-projects/spring-framework/blob/7e2b81729eefe31e9e8b2872b0de0adc1bad2162/spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java#L839",
                "issue_state": "closed",
                "issue_comment": [
                    "Well spotted! Since we have such emptiness checks in other places already, in particular in hotspot code paths and for collections that tend to be empty at runtime, I've applied our common `CollectionUtils.isEmpty` check here as well now. While it won't make much difference performance-wise, it does avoid allocation of an `Iterator` which is generally worthwhile in such scenarios."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a null check (`if (earlyEventsToProcess != null)`) with a check for emptiness using `CollectionUtils.isEmpty()`.  This change is more robust, as it handles both null and empty collections, preventing potential `NullPointerExceptions`",
            "avg_logprobs": -0.13062055155916033
        }
    },
    {
        "commit_hash": "30ebc3b8e2185c56791531507e0f430972f82b51",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationAttributes.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t/**\n-\t * Store the supplied {@code value} in this map under the specified\n-\t * {@code key}, unless a value is already stored under the key.\n-\t * @param key the key under which to store the value\n-\t * @param value the value to store\n-\t * @return the current value stored in this map, or {@code null} if no\n-\t * value was previously stored in this map\n-\t * @see #get\n-\t * @see #put\n-\t * @since 4.2\n-\t */\n-\t@Override\n-\tpublic Object putIfAbsent(String key, Object value) {\n-\t\tObject obj = get(key);\n-\t\tif (obj == null) {\n-\t\t\tobj = put(key, value);\n-\t\t}\n-\t\treturn obj;\n-\t}\n-",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove superfluous AnnotationAttributes#putIfAbsent implementation",
        "commit_body": "Since Java 8, putIfAbsent() is a standard method in java.util.Map. We\ntherefore no longer need the custom implementation that overrides the\nstandard implementation in HashMap.\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a `putIfAbsent` method to the `AnnotationAttributes` class.  This method checks if a value already exists for a given key in the internal map. If not, it stores the provided `value` and returns `null`. If a value already exists, it returns the existing value without modifying the map.  This method effectively implements a thread-safe way to add a value only if it's not already present, mirroring the functionality of `java.util",
            "avg_logprobs": -0.16410226821899415
        }
    },
    {
        "commit_hash": "311b3338145038ea92c693bb2a8babec9580deda",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/ResourceBundleMessageSource.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t * Return a ResourceBundle for the given basename and code,\n-\t * fetching already generated MessageFormats from the cache.\n+\t * Return a ResourceBundle for the given basename and Locale,\n+\t * fetching already generated ResourceBundle from the cache.\n-\t\t\t\t\tlocaleMap = new ConcurrentHashMap<>();\n-\t\t\t\t\tMap<Locale, ResourceBundle> existing = this.cachedResourceBundles.putIfAbsent(basename, localeMap);\n-\t\t\t\t\tif (existing != null) {\n-\t\t\t\t\t\tlocaleMap = existing;\n-\t\t\t\t\t}\n+\t\t\t\t\tlocaleMap = this.cachedResourceBundles.computeIfAbsent(basename, bn -> new ConcurrentHashMap<>());",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use computeIfAbsent in ResourceBundleMessageSource",
        "commit_body": "This commit optimizes code in ResourceBundleMessageSource\nby using computeIfAbsent instead of putIfAbsent.\n\nIn addition, the content of some Javadoc has been adjusted.\n\nCloses gh-25054",
        "linked_issues": [
            {
                "issue_id": "25054",
                "issue_title": "Use computeIfAbsent in ResourceBundleMessageSource",
                "issue_body": "This PR is to optimize code by using `computeIfAbsent` instead of `putIfAbsent`, in addition, the content of some Javadoc has been adjusted.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ResourceBundleMessageSource` modifies how ResourceBundles are cached.  The original code cached `MessageFormats` based on a `basename` and `code`.  The updated code now caches `ResourceBundles` based on a `basename` and `Locale`.  Critically, the change eliminates the redundant `putIfAbsent` and subsequent `if` check, replacing it with a more concise and efficient `computeIfAbsent` method",
            "avg_logprobs": -0.19139774322509764
        }
    },
    {
        "commit_hash": "321d7b0b061b552aa10e7af099d0610663fab1ef",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/config/ResourcesBeanDefinitionParser.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tCacheControl cacheControl = CacheControl.empty();\n+\t\tCacheControl cacheControl;\n+\t\telse {\n+\t\t\tcacheControl = CacheControl.empty();\n+\t\t}\n+",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Put CacheControl.empty() in else part.",
        "commit_body": "Make sure the constructor of `CacheControl` being invoked only once.",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `CacheControl cacheControl = CacheControl.empty();` statement.  It now initializes `cacheControl` only if necessary, potentially avoiding an unnecessary object creation.  The original code unconditionally created an empty `CacheControl` object.  The change likely aims for efficiency, especially if the `else` block is frequently executed",
            "avg_logprobs": -0.3034200933244493
        }
    },
    {
        "commit_hash": "325fb5d97e309a9eb94cfb42a12b136fc7aada16",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/DeferredResultMethodReturnValueHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import java.util.concurrent.CompletionException;\n+\t\t\t\tif (ex instanceof CompletionException && ex.getCause() != null) {\n+\t\t\t\t\tex = ex.getCause();\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Unwrap CompletionException in return value handler",
        "commit_body": "See gh-22476\n",
        "linked_issues": [
            {
                "issue_id": "22476",
                "issue_title": "Fix CompletableFuture exception handling",
                "issue_body": "CompletableFuture exceptions are always wrapped into CompletionException.\r\nWe need to unwrap CompletionException to properly handle exceptions in MVC handlers that return CompletableFuture.\r\nSee https://stackoverflow.com/questions/49676889/spring-controller-advice-does-not-correctly-handle-a-completablefuture-completed\r\n\r\n#22475",
                "issue_state": "closed",
                "issue_comment": [
                    "@sviperll Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22476)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22476) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@sviperll Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22476)!",
                    "Can we get this merged? FWIW, it looks good to me.",
                    "I've resolved this in a separate commit also adding a check to ensure the cause is not null. Thanks for submitting a PR and for pointing this out!",
                    "Is this fix already part of a release?",
                    "Yes, Spring Framework 5.1.7",
                    "@bclozel weird, I am using Spring Boot v2.1.9.RELEASE but still have this error (dependency of spring is 5.1.10)",
                    "I have the same problem, when returning e.g. `CompletableFuture<ResponseEntity<Void>>`from a controller method. The debugger revealed, that the `DeferredResultMethodReturnValueHandler`isn't used in that case, since `ResponseBodyEmitterReturnValueHandler`is kicking in instead.",
                    "@maverick1601, `ResponseBodyEmitterReturnValueHandleris` delegates to `ReactiveTypeHandler` which handles adapts the future via a Reactor-based adapter registered through the `ReactiveAdapterRegistry`. So this comes from Project Rector and I see a fix there https://github.com/reactor/reactor-core/issues/1652 related to this for version 3.3. Spring Framework 5.2 is based on that version of Reactor but you can try independently upgrading Reactor first.\r\n",
                    "Never mind, I figured, that it works as expected, just not via the `DeferredResultMethodReturnValueHandler`, as you've mentioned. The problem was on my side, testing with a mis-configured `ExceptionHandler`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to handle `CompletionException` in the `DeferredResultMethodReturnValueHandler`.  If a `CompletionException` is encountered and it has a cause, the original exception is replaced with the cause. This likely improves error handling by exposing the underlying exception instead of the `CompletionException` wrapper",
            "avg_logprobs": -0.16466999053955078
        }
    },
    {
        "commit_hash": "327e761536eb23c9db90e93c18a549b6bccca2f8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/codec/multipart/PartGenerator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import java.nio.charset.Charset;\n- * {@link MultipartParser#parse(Flux, byte[], int)}, and produces a flux of {@link Part} objects.\n+ * {@link MultipartParser#parse(Flux, byte[], int, Charset)}, and produces a flux of {@link Part} objects.\n+\t\t\t\tif (!Files.exists(directory)) {\n+\t\t\t\t\tFiles.createDirectory(directory);\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Recreate file storage directory when removed in DefaultPartHttpMessageReader",
        "commit_body": "Some operating systems delete temp files not just when booting up, but\nalso during operation. This commit makes sure that the\nDefaultPartHttpMessageReader recreates the directory used to store\nfiles in, if it's not there.\n\nCloses gh-26790\n",
        "linked_issues": [
            {
                "issue_id": "26790",
                "issue_title": "Make sure file storage directory exists before usage in DefaultPartHttpMessageReader",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://spring.io/security-policy !!!\r\n-->\r\n**Affects:** \\<Spring Framework version>\r\n5.3.4\r\n---\r\n\r\nwhen i upload a file, it throw an exception\r\n\r\n```\r\njava.io.UncheckedIOException: Could not create temp file in /tmp/spring-multipart\r\n\tat org.springframework.http.codec.multipart.PartGenerator$CreateFileState.createFileState(PartGenerator.java:588)\r\n\tSuppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: \r\nError has been observed at the following site(s):\r\n\t|_ checkpoint \u21e2 com.nxin.passport.application.support.filter.FormDataParserFilter [DefaultWebFilterChain]\r\n\t|_ checkpoint \u21e2 com.nxin.passport.application.support.filter.UrlRewriteFilter [DefaultWebFilterChain]\r\n\t|_ checkpoint \u21e2 HTTP POST \"/user/uploadPhoto\" [ExceptionHandlingWebHandler]\r\nStack trace:\r\n\t\tat org.springframework.http.codec.multipart.PartGenerator$CreateFileState.createFileState(PartGenerator.java:588)\r\n\t\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)\r\n\t\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1789)\r\n\t\tat reactor.core.publisher.MonoCacheTime.subscribeOrReturn(MonoCacheTime.java:142)\r\n\t\tat reactor.core.publisher.Mono.subscribe(Mono.java:4031)\r\n\t\tat reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:126)\r\n\t\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)\r\n\t\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)\r\n\t\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\r\n\t\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)\r\n\t\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\t\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\t\tat java.base/java.lang.Thread.run(Thread.java:834)\r\nCaused by: java.nio.file.NoSuchFileException: /tmp/spring-multipart/8497015949572241043.multipart\r\n\tat java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)\r\n\tat java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)\r\n\tat java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)\r\n\tat java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)\r\n\tat java.base/java.nio.file.Files.newByteChannel(Files.java:370)\r\n\tat java.base/java.nio.file.Files.createFile(Files.java:647)\r\n\tat java.base/java.nio.file.TempFileHelper.create(TempFileHelper.java:137)\r\n\tat java.base/java.nio.file.TempFileHelper.createTempFile(TempFileHelper.java:160)\r\n\tat java.base/java.nio.file.Files.createTempFile(Files.java:867)\r\n\tat org.springframework.http.codec.multipart.PartGenerator$CreateFileState.createFileState(PartGenerator.java:580)\r\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)\r\n\tat reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1789)\r\n\tat reactor.core.publisher.MonoCacheTime.subscribeOrReturn(MonoCacheTime.java:142)\r\n\tat reactor.core.publisher.Mono.subscribe(Mono.java:4031)\r\n\tat reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.run(MonoSubscribeOn.java:126)\r\n\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:84)\r\n\tat reactor.core.scheduler.WorkerTask.call(WorkerTask.java:37)\r\n\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\r\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\n```\r\n\r\ni found DefaultPartHttpMessageReader has a fileStorageDirectory property control the upload temp directory, it init as system temp dir, in linux, it is /tmp/spring-multipart, but os may sometimes remove the files in /tmp, when the spring-multipart is remove, then the upload action will fail, because the directory only init once at startup, \r\n\r\n![image](https://user-images.githubusercontent.com/5616997/114377903-be5db780-9bb9-11eb-9819-e9d286cc2553.png)\r\n\r\ni have found the way to customize the path,\r\n![image](https://user-images.githubusercontent.com/5616997/114378082-eea55600-9bb9-11eb-8897-c8acd652ce4a.png)\r\n\r\nbut it did not invoke in any place\r\n\r\n![image](https://user-images.githubusercontent.com/5616997/114378217-14325f80-9bba-11eb-8a03-82a24c9b6cee.png)\r\n\r\nplease provide some way to config the path, so i can set a other place to store the tepm data to avoid the issure, the spring mvc config way is below\r\n\r\n![image](https://user-images.githubusercontent.com/5616997/114378476-5360b080-9bba-11eb-89ea-b3f9cd63454e.png)\r\n\r\ncan you provide a similarity one in webflux?",
                "issue_state": "closed",
                "issue_comment": [
                    "The field changed by `setFileStorageDirectory` is definitely used, even though the setter is not called anywhere. So could you please try again and see if it works for you?\r\n\r\nYou are correct that some operating systems are quite aggressive when deleting files in the temporary directory. So I did make some changes to make sure that we re-create the file storage directory if it ends up was deleted  by the operating system."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `PartGenerator` adds a `Charset` parameter to the `MultipartParser.parse` method and includes a check and creation of a directory if it doesn't exist.  Specifically, the `parse` method now accepts a `Charset` argument, and the code now handles the potential non-existence of a temporary directory by creating it if needed.  This likely improves handling of different character encodings in multipart data and ensures the directory for temporary files is available",
            "avg_logprobs": -0.2660860774492977
        }
    },
    {
        "commit_hash": "32df079b05d2b1b755c6c84ef4d2bf5238186b71",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/StringUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\tprivate static final char WINDOWS_FOLDER_SEPARATOR_CHAR = '\\\\';\n+\n-\t\tif (path.indexOf('\\\\') != -1) {\n+\t\tif (path.indexOf(WINDOWS_FOLDER_SEPARATOR_CHAR) != -1) {\n-\t\tif (pathToUse.indexOf('.') == -1) {\n+\t\tif (pathToUse.indexOf(EXTENSION_SEPARATOR) == -1) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish use of constants in StringUtils",
        "commit_body": "The hardcoded '.' and '\\\\' literals have been replaced by the use of\nEXTENSION_SEPARATOR and WINDOWS_FOLDER_SEPARATOR_CHAR.\n\nCloses gh-33654\n",
        "linked_issues": [
            {
                "issue_id": "33654",
                "issue_title": "Polish use of constants in `StringUtils`",
                "issue_body": "I modified the hardcoded '.' and '\\\\' parts to \r\nEXTENSION_SEPARATOR,\r\nWINDOWS_FOLDER_SEPARATOR_CHAR.\r\n\r\nThe '\\\\' part can be maintained by adding WINDOWS_FOLDER_SEPARATOR_CHAR\r\nto maintain the overall consistency of the code base.\r\n\r\nps. This is my first Spring Framework PR, so even if there are some shortcomings, I will improve it to a good code through future activities.",
                "issue_state": "closed",
                "issue_comment": [
                    "@J-unStiN Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=33654)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=33654) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@J-unStiN Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=33654)!",
                    "Hi @J-unStiN,\r\n\r\nCongratulations on submitting your first PR for the Spring Framework! \ud83d\udc4d \r\n\r\nAlthough we generally prefer to make such minor changes ourselves, I will accept this since it's your first PR.\r\n\r\nAlso, please note that we do not add `@author` tags for such minor changes.\r\n\r\nRegards,\r\n\r\nSam",
                    "This has been merged into `main`.\r\n\r\nThanks",
                    "Thank you very very much.\r\n\r\nI will never forget this moment.\r\n\r\nI have another question.\r\n\r\nI don't see any methods in Spring's StirngUtils that check for empty and null values \u200b\u200bvia isBlank, isEmpty. I wonder if it would be okay to create one and post a PR."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `path.indexOf('\\\\\\\\')` with `path.indexOf(WINDOWS_FOLDER_SEPARATOR_CHAR)`, and `pathToUse.indexOf('.')` with `pathToUse.indexOf(EXTENSION_SEPARATOR)`.  This suggests a refactoring to use a constant (`WINDOWS_FOLDER_SEPARATOR_CHAR`) for the Windows folder separator character, and likely a similar constant (`EXTENSION_SEPARATOR`) for the file extension separator",
            "avg_logprobs": -0.12659725189208984
        }
    },
    {
        "commit_hash": "33642345a4bebadb6226a8497037e9b8c13af0e1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfinal boolean infoEnabled = logger.isInfoEnabled();\n-\t\t\tfinal boolean debugEnabled = logger.isDebugEnabled();\n-\t\t\t\t\t\tif (infoEnabled && implementsInterface(method, ifcs)) {\n+\t\t\t\t\t\tif (logger.isInfoEnabled() && implementsInterface(method, ifcs)) {\n-\t\t\t\t\t\tif (debugEnabled) {\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\telse if (debugEnabled && !Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&\n+\t\t\t\t\telse if (logger.isDebugEnabled() && !Modifier.isPublic(mod) && !Modifier.isProtected(mod) &&",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Lazily check log level within validation conditions",
        "commit_body": "See gh-24672\n",
        "linked_issues": [
            {
                "issue_id": "24672",
                "issue_title": "Reduce String garbage in CglibAopProxy.doValidateClass()",
                "issue_body": "Subj + some tiny improvements",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional logging logic by directly using `logger.isInfoEnabled()` and `logger.isDebugEnabled()` within the `if` statements, instead of first assigning these values to variables.  This eliminates redundant variable declarations and improves readability.  The core change is a refactoring of the conditional checks, making the code more concise and efficient",
            "avg_logprobs": -0.310266203350491
        }
    },
    {
        "commit_hash": "33ef9107e068223b53b9f19cf9b7906aabf769e0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/handler/annotation/support/PayloadMethodArgumentResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (ClassUtils.isAssignable(targetClass, payloadClass)) {\n-\t\t\tvalidate(message, parameter, payload);\n-\t\t\treturn (isOptionalTargetClass ? Optional.of(payload) : payload);\n-\t\t}\n-\t\telse {\n+\t\tif (!ClassUtils.isAssignable(targetClass, payloadClass)) {\n-\t\t\tvalidate(message, parameter, payload);\n-\t\t\treturn (isOptionalTargetClass ? Optional.of(payload) : payload);\n+\t\tvalidate(message, parameter, payload);\n+\t\treturn (isOptionalTargetClass ? Optional.of(payload) : payload);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Minor refactoring in PayloadMethodArgumentResolver",
        "commit_body": "Closes gh-30168\n",
        "linked_issues": [
            {
                "issue_id": "30168",
                "issue_title": "Minor refactoring in PayloadMethodArgumentResolver",
                "issue_body": "remove duplicate logic",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change inverts the conditional logic within the `PayloadMethodArgumentResolver`.  Originally, if `targetClass` was assignable from `payloadClass`, validation and return occurred.  Now, if `targetClass` is *not* assignable from `payloadClass`, the validation and return are performed unconditionally.  This means the original `else` block is removed, and the validation and return logic is now executed regardless of the result of the `ClassUtils.isAssignable` check",
            "avg_logprobs": -0.20927753448486328
        }
    },
    {
        "commit_hash": "341ac76209a0a5ad34cb80385179040d47636974",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/BeanPropertyRowMapper.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "+\t * @see #setMappedClass\n+\t * @see BeanUtils#getPropertyDescriptors\n+\t * @see #mappedNames(PropertyDescriptor)\n+\t * @see #initialize\n-\t\tString lowerCaseName = lowerCaseName(pd.getName());\n-\t\tmappedNames.add(lowerCaseName);\n-\t\tString underscoreName = underscoreName(pd.getName());\n-\t\tif (!lowerCaseName.equals(underscoreName)) {\n-\t\t\tmappedNames.add(underscoreName);\n-\t\t}\n+\t\tmappedNames.add(lowerCaseName(pd.getName()));\n+\t\tmappedNames.add(underscoreName(pd.getName()));",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Rely on HashSet for uniqueness of mapped names",
        "commit_body": "See gh-32199\n",
        "linked_issues": [
            {
                "issue_id": "32199",
                "issue_title": "Let `BeanPropertyRowMapper` subclasses customize mapped names",
                "issue_body": "`BeanPropertyRowMapper` traditionally maps lower-case and underscore-based names for each discovered property.\r\n\r\nWhile it allows for customizing those specific names, it does not allow for totally custom mapped names, e.g. derived from a custom annotation.\r\n\r\nSee the use case described in the tests for #30180.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the logic for adding property names to the `mappedNames` list.  It removes the conditional check (`if (!lowerCaseName.equals(underscoreName))`) and directly adds both the lower-case and underscore-cased versions of the property name to the list using a single call to `add`.  This results in a more concise and potentially slightly faster implementation",
            "avg_logprobs": -0.16590922391867335
        }
    },
    {
        "commit_hash": "3477738bed64f0cda2952eee787a267e89b0569d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\telse if (replace) {\n+\t\t\t\telse if (replace && replacingClass == null) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Consistently pick lowest superclass level to replace",
        "commit_body": "See gh-28676\n",
        "linked_issues": [
            {
                "issue_id": "28676",
                "issue_title": "A configuration class superclass that is skipped due to register bean phase conditions is ignored when another configuration class that extends it is processed",
                "issue_body": "**Affects:** 6.0.x. I expect 5.3.x to also be affected.\r\n\r\nI think @mbhave and I have found a bug in configuration class processing related to condition evaluation. It's hopefully illustrated by the following tests:\r\n\r\n```java\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.ConditionContext;\r\nimport org.springframework.context.annotation.Conditional;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.ConfigurationCondition;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.core.type.AnnotatedTypeMetadata;\r\n\r\nimport static org.assertj.core.api.Assertions.assertThat;\r\n\r\nclass ConfigurationPhasesKnownSuperclassesTests {\r\n\r\n\t@Test\r\n\tvoid superclassSkippedInParseConfigurationPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass() {\r\n\t\ttry (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\r\n\t\t\t\tParseConfigurationPhase.class)) {\r\n\t\t\tassertThat(context.getBean(\"subclassBean\")).isEqualTo(\"bravo\");\r\n\t\t\tassertThat(context.getBean(\"superclassBean\")).isEqualTo(\"superclass\");\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tvoid superclassSkippedInRegisterBeanPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass() {\r\n\t\ttry (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(\r\n\t\t\t\tRegisterBeanPhase.class)) {\r\n\t\t\tassertThat(context.getBean(\"subclassBean\")).isEqualTo(\"bravo\");\r\n\t\t\tassertThat(context.getBean(\"superclassBean\")).isEqualTo(\"superclass\");\r\n\t\t}\r\n\t}\r\n\r\n\t@Configuration(proxyBeanMethods = false)\r\n\tstatic class Example {\r\n\r\n\t\t@Bean\r\n\t\tString superclassBean() {\r\n\t\t\treturn \"superclass\";\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Configuration(proxyBeanMethods = false)\r\n\t@Import({ RegisterBeanPhaseExample.class, BravoExample.class })\r\n\tstatic class RegisterBeanPhase {\r\n\r\n\t}\r\n\r\n\t@Conditional(NonMatchingRegisterBeanPhaseCondition.class)\r\n\t@Configuration(proxyBeanMethods = false)\r\n\tstatic class RegisterBeanPhaseExample extends Example {\r\n\r\n\t\t@Bean\r\n\t\tString subclassBean() {\r\n\t\t\treturn \"alpha\";\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Configuration(proxyBeanMethods = false)\r\n\t@Import({ ParseConfigurationPhaseExample.class, BravoExample.class })\r\n\tstatic class ParseConfigurationPhase {\r\n\r\n\t}\r\n\r\n\t@Conditional(NonMatchingParseConfigurationPhaseCondition.class)\r\n\t@Configuration(proxyBeanMethods = false)\r\n\tstatic class ParseConfigurationPhaseExample extends Example {\r\n\r\n\t\t@Bean\r\n\t\tString subclassBean() {\r\n\t\t\treturn \"alpha\";\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Configuration(proxyBeanMethods = false)\r\n\tstatic class BravoExample extends Example {\r\n\r\n\t\t@Bean\r\n\t\tString subclassBean() {\r\n\t\t\treturn \"bravo\";\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class NonMatchingRegisterBeanPhaseCondition implements ConfigurationCondition {\r\n\r\n\t\t@Override\r\n\t\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic ConfigurationPhase getConfigurationPhase() {\r\n\t\t\treturn ConfigurationPhase.REGISTER_BEAN;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic class NonMatchingParseConfigurationPhaseCondition implements ConfigurationCondition {\r\n\r\n\t\t@Override\r\n\t\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic ConfigurationPhase getConfigurationPhase() {\r\n\t\t\treturn ConfigurationPhase.PARSE_CONFIGURATION;\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n```\r\n\r\n`superclassSkippedInParseConfigurationPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass` passes but `superclassSkippedInRegisterBeanPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass` fails.\r\n\r\nThe register bean phase test fails due to the `knownSuperclasses` map in `ConfigurationClassParser` being polluted. Due to the parse configuration phase conditions matching an entry is added to the map for `Example -> RegisterBeanPhaseExample`. Subsequently, the register bean phase condition on `RegisterBeanPhaseExample` does not match, so neither it nor `Example` are processed. When `BravoExample` is then parsed, `ConfigurationClassParser` considers its superclass `Example`. It's skipped due to the existing entry in the `knownSuperclasses` map, despite the fact that `Example` was never actually processed due to the conditions on `RegisterBeanPhaseExample`. The end result is that the context is left without a bean named `superclassBean`.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition `replacingClass == null` to the `else if` block.  Previously, the code would execute the `replace` block regardless of whether `replacingClass` was null.  Now, it only executes if `replace` is true *and* `replacingClass` is not null",
            "avg_logprobs": -0.2127447509765625
        }
    },
    {
        "commit_hash": "34ab818dfa795bd67fa44061f71e68bc665fa0bf",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/hibernate5/HibernateExceptionTranslator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tif (ex instanceof PersistenceException && ex.getCause() instanceof HibernateException) {\n-\t\t\treturn convertHibernateAccessException((HibernateException) ex.getCause());\n+\t\tif (ex instanceof PersistenceException) {\n+\t\t\tif (ex.getCause() instanceof HibernateException) {\n+\t\t\t\treturn convertHibernateAccessException((HibernateException) ex.getCause());\n+\t\t\t}\n+\t\t\treturn EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex);\n-\t\treturn EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex);\n+\t\treturn null;",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "HibernateExceptionTranslator avoids JPA IllegalState/ArgumentException translation",
        "commit_body": "Issue: SPR-14681\n",
        "linked_issues": [
            {
                "issue_id": "19245",
                "issue_title": "HibernateExceptionTranslator translating to InvalidDataAccessApiUsageException when using vanilla Hibernate [SPR-14681]",
                "issue_body": "**[Koen Serneels](https://jira.spring.io/secure/ViewProfile.jspa?name=koen.serneels)** opened **[SPR-14681](https://jira.spring.io/browse/SPR-14681?redirect=false)** and commented\n\nThe new org.springframework.orm.hibernate5.HibernateExceptionTranslator uses a fallthrough in the sense that it first tries to map the exception using vanilla Hibernate (SessionFactoryUtils). If no translation could be done it tries JPA via EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible().\n\nThe latter troubles us as it is translating IllegalStateException to InvalidDataAccessApiUsageException. I'm not really sure why IllegalStateException and IllegalArgumentException get this special treatment, but ok. So now we suddenly end up with translated exceptions that weren't translated before. Since these extra translations are in context of JPA (as it is called 'convertJpaAccessExceptionIfPossible') this also makes no sense as we are not using JPA but vanilla Hibernate.\n\nSo, what is the correct way to make sure that we only get Hibernate exceptions translated? Afaic the HibernateExceptionTranslator has no options to turn off JPA translation and the LocalSessionFactoryBean extends HibernateExceptionTranslator without the option to inject another implementation. Wouldn't it make more sense to have the HibernateExceptionTranslator JPA unaware and add another translator in case JPA is actually used?\n\n---\n\n**Affects:** 4.3.2\n\n**Reference URL:** https://stackoverflow.com/questions/39393116/how-to-deactivate-spring-data-exception-translation\n\n**Issue Links:**\n- #19225 TypeConverterSupport does not propagate custom exceptions anymore\n- #19024 Hibernate5 LocalSessionFactoryBean does not translate javax.persistence exceptions\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/4b445531f56ccb106c935bcbdee27c55cb867b83, https://github.com/spring-projects/spring-framework/commit/34ab818dfa795bd67fa44061f71e68bc665fa0bf\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThe translation of `IllegalStateException` to `InvalidDataAccessApiUsageException` arguably wasn't intended in this native Hibernate case and is therefore a regression in 4.3.2. I've re-labelled this issue accordingly.\n\nHowever, the general feature was intentional (see #19024): As of Hibernate 5.2, a Hibernate `Session` **is** a JPA `EntityManager`, and `HibernateException` actually extends `PersistenceException` now. It mostly throws `HibernateException` still but sometimes also plain JPA exceptions now, even when used \"natively\".\n",
                    "**[Koen Serneels](https://jira.spring.io/secure/ViewProfile.jspa?name=koen.serneels)** commented\n\nThanks J\u00fcrgen. So, to be sure, the fix will imply that both IllegalStateException and IllegalArgumentException are no longer translated?\n\nNote: for completeness, the javadoc does mention this:\n// Following the JPA specification, a persistence provider can also\n// throw these two exceptions, besides PersistenceException.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nYes, that's what I'm trying to balance out for this modern-day \"native\" use of Hibernate: just translating plain `PersistenceException` next to `HibernateException` but leaving other exceptions as-is, like before when doing native Hibernate.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAre you actually relying on Hibernate-originating `IllegalStateException` / `IllegalArgumentException` to get rethrown there, or is it primarily about custom exceptions that you throw within your callbacks? Do you have some specific handling for those exceptions?\n",
                    "**[Koen Serneels](https://jira.spring.io/secure/ViewProfile.jspa?name=koen.serneels)** commented\n\nThe second: we are throwing  `IllegalStateException` / `IllegalArgumentException` from repositories and are not expecting them to be wrapped/translated. While this is mostly important for our tests, it is imho arguable that  such general purpose exceptions would be translated when they did not originate from JPA. So, in that case I believe the best solution is to translate if they originated from Hibernate/JPA (if that is doable) and leave them as-is otherwise\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt would be great if you could give the latest `4.3.3.BUILD-SNAPSHOT` a try to check whether it works for you again...\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the exception handling logic for `HibernateExceptionTranslator`.  The original code checked if the exception was a `PersistenceException` *and* its cause was a `HibernateException`, then handled the `HibernateException`.  Now, it first checks if the exception is a `PersistenceException`.  If so, it checks if the cause is a `HibernateException`.  If it is, it handles the `HibernateException`; otherwise, it delegates to `EntityManagerFactoryUtils",
            "avg_logprobs": -0.1552036476135254
        }
    },
    {
        "commit_hash": "34e5ce9360ed6c0fe83678a904d5e70064765db6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/jta/JtaTransactionManager.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (transactionManager instanceof UserTransaction userTransaction) {\n-\t\t\treturn userTransaction;\n+\t\tif (transactionManager instanceof UserTransaction ut) {\n+\t\t\treturn ut;\n-\t\tif (ut instanceof TransactionManager transactionManager) {\n+\t\tif (ut instanceof TransactionManager tm) {\n-\t\t\treturn transactionManager;\n+\t\t\treturn tm;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix Checkstyle violations",
        "commit_body": "See gh-30019\n",
        "linked_issues": [
            {
                "issue_id": "30019",
                "issue_title": "Apply \"instanceof pattern matching\" in `spring-tx`",
                "issue_body": null,
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `main` in 375114defa711b33babc0aef9b4f918f232e315f and revised in 34e5ce9360ed6c0fe83678a904d5e70064765db6 and b1cf832c28473518240a91afed17bd51f95fbf9a.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional check for `UserTransaction` and `TransactionManager` by using more concise variable names (`ut` and `tm`).  The original `if` statements were checking if the `transactionManager` object was an instance of `UserTransaction` and then, if true, checking if that same object was an instance of `TransactionManager`.  The change now directly assigns the type to a more concise variable name, improving readability and eliminating redundant checks",
            "avg_logprobs": -0.3537288506825765
        }
    },
    {
        "commit_hash": "35055fd866baadefeec2e2f47d1d94454763b452",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/env/PropertySourcesPropertyResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (propertySource.getProperty(key) != null) {\n+\t\t\tif (propertySource.containsProperty(key)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refactor PropertyResolver impl for consistency",
        "commit_body": "PropertySourcesPropertyResolver#containsProperty now\ncalls #containsProperty on each underlying PropertySource instead of\ncalling #getProperty and checking for null.\n\nIssue: SPR-9529\n",
        "linked_issues": [
            {
                "issue_id": "14163",
                "issue_title": "Refactor PropertySourcesPropertyResolver#containsString for consistency [SPR-9529]",
                "issue_body": "**[Mauro Molinari](https://jira.spring.io/secure/ViewProfile.jspa?name=mauromol)** opened **[SPR-9529](https://jira.spring.io/browse/SPR-9529?redirect=false)** and commented\n\nTo ensure maximum performance and consistency, shouldn't `org.springframework.core.env.PropertySourcesPropertyResolver.containsProperty(String)` be implemented as such?\n\n```\npublic boolean containsProperty(String key) {\n  for (PropertySource<?> propertySource : this.propertySources) {\n    if (propertySource.containsProperty(key)) {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n\n\n---\n\n**Affects:** 3.1 GA, 3.1.1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/35055fd866baadefeec2e2f47d1d94454763b452\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Chris Beams](https://jira.spring.io/secure/ViewProfile.jspa?name=cbeams)** commented\n\nGood call, Mauro.  This is complete.\n\n> ```\n> \n> commit 35055fd866baadefeec2e2f47d1d94454763b452\n> Author: Chris Beams <cbeams@vmware.com>\n> Date:   Thu Jun 21 12:28:12 2012 +0200\n> \n>     Refactor PropertyResolver impl for consistency\n>     \n>     PropertySourcesPropertyResolver#containsProperty now\n>     calls #containsProperty on each underlying PropertySource instead of\n>     calling #getProperty and checking for null.\n>     \n>     Issue: SPR-9529\n> ```\n\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a check for a non-null result from `propertySource.getProperty(key)` with a check for the existence of a property using `propertySource.containsProperty(key)`.  This change likely improves efficiency and robustness by avoiding the potentially expensive `getProperty()` call if the property doesn't exist.  It's a more direct way to determine if a property is present",
            "avg_logprobs": -0.1361502205453268
        }
    },
    {
        "commit_hash": "3576ff051cf13ccc97d8b0fea8d961d204c15f0d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tSet<ScheduledTask> tasks =\n-\t\t\t\t\tnew LinkedHashSet<ScheduledTask>(4);\n+\t\t\tSet<ScheduledTask> tasks = this.scheduledTasks.get(bean);\n+\t\t\tif (tasks == null) {\n+\t\t\t\ttasks = new LinkedHashSet<ScheduledTask>(4);\n+\t\t\t\tthis.scheduledTasks.put(bean, tasks);\n+\t\t\t}\n-\t\t\tthis.scheduledTasks.put(bean, tasks);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ScheduledAnnotationBeanPostProcessor properly registers multiple tasks per bean",
        "commit_body": "Issue: SPR-14286\n",
        "linked_issues": [
            {
                "issue_id": "18858",
                "issue_title": "Scheduled tasks aren't cancelled on ScheduledTaskRegistrar destruction anymore [SPR-14286]",
                "issue_body": "**[Romain Moreau](https://jira.spring.io/secure/ViewProfile.jspa?name=romainmoreau)** opened **[SPR-14286](https://jira.spring.io/browse/SPR-14286?redirect=false)** and commented\n\nWith Spring 4.3.0.RC1, when ScheduledTaskRegistrar was destroyed, scheduled futures were cancelled correctly.\n\nNow, with Spring 4.3.0.RC2, when ScheduledTaskRegistrar is destroyed, scheduled tasks aren't cancelled because the [scheduledTasks collection used to iterate the tasks to cancel](https://github.com/spring-projects/spring-framework/blob/v4.3.0.RC2/spring-context/src/main/java/org/springframework/scheduling/config/ScheduledTaskRegistrar.java#L485) is empty.\n\nHere's below the code for a quick and dirty reproduction case.\nTo run with Spring 4.3.0.RC1, replace the spring-boot-starter-parent version with 1.4.0.M2.\nWith Spring 4.3.0.RC1, you'll see in the log \"1 scheduled found\" as expected.\nWith Spring 4.3.0.RC2, you'll see in the log \"0 scheduled found\" (scheduledTasks set is empty).\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.4.0.M3</version>\n  </parent>\n  <artifactId>scheduled-repro</artifactId>\n  <properties>\n    <!-- Needed because of a Maven issue on my side, not affecting reproduction case -->\n    <spring-integration.version>4.2.6.RELEASE</spring-integration.version>\n  </properties>\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n  </dependencies>\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n  <repositories>\n    <repository>\n      <id>spring-milestones</id>\n      <url>http://repo.spring.io/milestone</url>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <pluginRepositories>\n    <pluginRepository>\n      <id>spring-milestones</id>\n      <url>http://repo.spring.io/milestone</url>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </pluginRepository>\n  </pluginRepositories>\n</project>\n```\n\n```java\npackage scheduledrepro;\n\nimport org.springframework.beans.factory.annotation.*;\nimport org.springframework.boot.*;\nimport org.springframework.boot.autoconfigure.*;\nimport org.springframework.scheduling.annotation.*;\nimport org.springframework.scheduling.config.*;\nimport org.springframework.scheduling.concurrent.*;\nimport org.springframework.context.annotation.*;\nimport org.springframework.boot.context.event.*;\nimport org.springframework.context.event.*;\nimport org.springframework.util.*;\nimport java.lang.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport org.slf4j.*;\n\n@EnableScheduling\n@SpringBootApplication\npublic class ScheduledReproApplication implements SchedulingConfigurer {\n private static final Logger LOGGER = LoggerFactory.getLogger(ScheduledReproApplication.class);\n\n private ScheduledTaskRegistrar taskRegistrar;\n\n @Override\n public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\n  this.taskRegistrar = taskRegistrar;\n  taskRegistrar.setScheduler(threadPoolTaskScheduler());\n }\n\n @Bean\n public ThreadPoolTaskScheduler threadPoolTaskScheduler() {\n  return new ThreadPoolTaskScheduler();\n }\n\n @org.springframework.context.event.EventListener\n public void applicationReadyEvent(ApplicationReadyEvent applicationReadyEvent) throws Exception {\n  Field field = ReflectionUtils.findField(ScheduledTaskRegistrar.class, \"scheduledTasks\"); // Spring 4.3.0.RC2\n  if (field == null) {\n   field = ReflectionUtils.findField(ScheduledTaskRegistrar.class, \"scheduledFutures\"); // Spring 4.3.0.RC1\n  }\n  field.setAccessible(true);\n  Set < ? > scheduledTasks = (Set < ? > ) field.get(taskRegistrar);\n  LOGGER.info(\"{} scheduled found\", scheduledTasks.size());\n }\n\n @Scheduled(cron = \"* * * * * *\")\n public void scheduled() {\n  LOGGER.info(\"Scheduled\");\n }\n\n public static void main(String[] args) throws Exception {\n  SpringApplication.run(ScheduledReproApplication.class, args);\n }\n}\n```\n\n---\n\n**Affects:** 4.3 RC2\n\n**Issue Links:**\n- #16830 ScheduledAnnotationBeanPostProcessor should unregister tasks on destruction of individual beans\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/3576ff051cf13ccc97d8b0fea8d961d204c15f0d\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, as of 4.3 RC2, `ScheduledAnnotationBeanPostProcessor` tracks its scheduled tasks internally, with `ScheduledTaskRegistrar.destroy()` not affecting those anymore. However, tasks should still get destroyed on shutdown through `ScheduledAnnotationBeanPostProcessor`'s destruction callbacks. So are your beans not getting destroyed at all, or are you simply not seeing the expected effect on `ScheduledTaskRegistrar.destroy()` now (which is by design)?\n",
                    "**[Romain Moreau](https://jira.spring.io/secure/ViewProfile.jspa?name=romainmoreau)** commented\n\nI looked at ScheduledAnnotationBeanPostProcessor and any Set that is a value of the scheduledTasks map will only contain one task associated to the last `@Scheduled` annotated method of a bean because when there is a previous Set already created, it is always overwritten on [line 400](https://github.com/spring-projects/spring-framework/blob/v4.3.0.RC2/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java#L400).\n\nFor instance, given the following class, Spring 4.3.RC2 will only cancel the task associated to the scheduled3 method, the tasks associated to the scheduled1 and the scheduled2 methods won't be cancelled.\n\n```java\n@Component\npublic class Scheduler {\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(Scheduler.class);\n\t\n\t@Scheduled(cron = \"*/30 * * * * *\")\n\tpublic void scheduled1() {\n\t\tLOGGER.info(\"1\");\n\t}\n\n\t@Scheduled(cron = \"0 0 0 * * *\")\n\tpublic void scheduled2() {\n\t\tLOGGER.info(\"2\");\n\t}\n\n\t@Scheduled(cron = \"15 * * * * *\")\n\tpublic void scheduled3() {\n\t\tLOGGER.info(\"3\");\n\t}\n}\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! Addressed in master now; please give the upcoming `4.3.0.BUILD-SNAPSHOT` a try if you have the chance...\n",
                    "**[Romain Moreau](https://jira.spring.io/secure/ViewProfile.jspa?name=romainmoreau)** commented\n\nI tried the latest SNAPSHOT build with your changes and it works for me, thanks!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change optimizes the creation of `ScheduledTask` sets.  Instead of always creating a new `LinkedHashSet` for each bean, it now checks if a `Set` already exists for that bean in the `scheduledTasks` map.  If it does, that existing `Set` is reused; otherwise, a new `Set` is created and put into the map. This avoids unnecessary object creation, potentially improving performance, especially if the same bean is processed multiple times",
            "avg_logprobs": -0.09600339617047991
        }
    },
    {
        "commit_hash": "358555929d4ff7d33dc1a5895a324e550cfa993e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/ParamsRequestCondition.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\treturn expressions.stream()\n-\t\t\t\t.filter(e -> e.getValue() != null && !e.isNegated())\n-\t\t\t\t.count();\n+\t\tlong count = 0;\n+\t\tfor (ParamExpression e : expressions) {\n+\t\t\tif (e.getValue() != null && !e.isNegated()) {\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t}\n+\t\treturn count;",
        "change_count": 10,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Revert \"Merge pull request #32088 from Ryan-Dia\"",
        "commit_body": "This reverts commit 484aee069e7edaf0cf904d0135ab10b6b8162e70, reversing\nchanges made to 6bd7f0231dcc47e8099000dea301157788fd5b15.\n\nSee gh-32088\n",
        "linked_issues": [
            {
                "issue_id": "32088",
                "issue_title": "Use count in ParamsRequestCondition#getValueMatchCount",
                "issue_body": "\r\nThe `getValueMatchCount` method was refactored to use a `Stream` instead of a `for-each loop`, eliminating the need for the unnecessary local variable `count`. This change was made to reduce the risk of accidental modifications during future maintenance, as the implementation is possible without using a local variable. Additionally, the refactoring was done for enhanced stability and maintainability, especially since there was no need to interrupt the loop under specific conditions.\r\n\r\n\r\n\r\n- [x]  The test code was executed and passed successfully.",
                "issue_state": "closed",
                "issue_comment": [
                    "@Ryan-Dia congratulations for making your first contribution to Spring Framework.",
                    "@Ryan-Dia the team has discussed this change today and we've decided to revert it. I had missed that the method you've changed is in a hot code path and we explicitly avoid using the Stream API in such places. ",
                    "Thank you for reviewing the changes I proposed. I understand the decision to revert them, recognizing that the modified method is in a hot code path. I appreciate the feedback and will ensure my future contributions are more closely aligned with these best practices\r\n\r\n\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a stream-based `count()` operation on `ParamExpression` objects with a traditional `for` loop.  The `for` loop iterates through the `expressions` list, incrementing a counter (`count`) whenever a `ParamExpression` has a non-null value and is not negated.  This results in a more explicit and potentially more performant (though likely negligible in this case) implementation",
            "avg_logprobs": -0.17127485708756882
        }
    },
    {
        "commit_hash": "35bd00beaf25943521b5650ef6e004291b19eff7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/datasource/init/ScriptUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tchar[] content = script.toCharArray();\n-\t\t\tchar c = content[i];\n+\t\t\tchar c = script.charAt(i);\n-\t\tchar[] content = script.toCharArray();\n-\t\t\tif (content[i] == '\\'') {\n+\t\t\tif (script.charAt(i) == '\\'') {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove String#toCharArray from ScriptUtils",
        "commit_body": "ScriptUtils contains two calls to String#toCharArray for the sole\npurpose to iterating over all chars in a String. Not only is this\nunnecessary and can be replaced with String#charAt it also causes\nadditional allocator and heap pressure because String#toCharArray\nrather than returning the backing array (which is gone in Java 9)\ncreates a copy.\n\nThis commit contains the following changes:\n\n - remove String#toCharArray from ScriptUtils and replace with\n   String#charAt\n\nIssue: SPR-15075\n",
        "linked_issues": [
            {
                "issue_id": "19641",
                "issue_title": "Remove String#toCharArray from ScriptUtils [SPR-15075]",
                "issue_body": "**[Philippe Marschall](https://jira.spring.io/secure/ViewProfile.jspa?name=marschall)** opened **[SPR-15075](https://jira.spring.io/browse/SPR-15075?redirect=false)** and commented\n\nScriptUtils contains two calls to String#toCharArray for the sole purpose to iterating over all chars in a String. Not only is this unnecessary and can be replaced with String#charAt it also causes additional allocator and heap pressure because String#toCharArray rather than returning the backing array (which is gone in Java 9) creates a copy.\n\n\n---\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1280, and commits https://github.com/spring-projects/spring-framework/commit/d912f77a31e34156d55c149d8b322ab274269cd6, https://github.com/spring-projects/spring-framework/commit/35bd00beaf25943521b5650ef6e004291b19eff7, https://github.com/spring-projects/spring-framework/commit/131d2c2051f7bf9f54d6a9cb89da79cdd67fa3a6\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nLet's backport this to 4.3.6 as well.\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nPR merged and backported to `4.3.x`. Thanks!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `script.toCharArray()` and `content[i]` with `script.charAt(i)`.  This avoids creating an unnecessary character array copy, improving efficiency, especially for large script strings.  The core change is in the handling of single quotes (`'`) within the script, which now directly accesses the character at the current index of the original `script` string",
            "avg_logprobs": -0.28596274460418314
        }
    },
    {
        "commit_hash": "37c04bd9c8d7a1269d1088af935a5571cb6887bc",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tParameter[] parameters = this.method.getParameters();\n-\t\tif (parameters.length != 1) {\n+\t\tint count = this.method.getParameterTypes().length;\n+\t\tif (count != 1) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix usage of Java8 API",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `parameters.length` with `this.method.getParameterTypes().length` to determine if the method has exactly one parameter.  This change is likely a performance optimization, as `getParameterTypes()` returns an array of types, which may be cached, while `getParameters()` returns an array of `Parameter` objects, which may involve more object creation/access",
            "avg_logprobs": -0.25994570843585124
        }
    },
    {
        "commit_hash": "37f9c8675804d4282bed9d2d1fb9da9761aee86a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (reactiveType == null) {\n+\t\tif (clazz == null) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix failing tests due to last commit",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a check for `reactiveType` being null with a check for `clazz` being null.  This suggests a refactoring where `clazz` is now the primary determinant for whether the `reactiveType` is needed or not.  The original `reactiveType` check has been replaced with a check for a potentially more fundamental null condition",
            "avg_logprobs": -0.25162630610995823
        }
    },
    {
        "commit_hash": "3809d885b6e5825368705d00a3d63f0ab7cd0128",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/ContentDisposition.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t} else {\n+\t\t\t}\n+\t\t\telse {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix Checkstyle violation",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an `else` block.  This suggests the code block previously handled by the `else` statement is now handled by the preceding `if` statement or is no longer needed.  Without context, the exact impact is unknown, but the code is now potentially simpler and more concise",
            "avg_logprobs": -0.3165579936543449
        }
    },
    {
        "commit_hash": "38525ceff609e4ae5c3d1c06a35c0e96e7da748d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/DatabaseStartupValidator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t\t\tif (logger.isInfoEnabled()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix log level guard in DatabaseStartupValidator.afterPropertiesSet()",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging level for a warning message to an informational message.  Specifically, the code now checks if the logger is at the INFO level instead of the WARN level before logging",
            "avg_logprobs": -0.15670349659063879
        }
    },
    {
        "commit_hash": "38dcd179d5c2ad7630310cba292e80471b000d5f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/support/SimpleEvaluationContext.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "- * of essential SpEL features and configuration options.\n+ * of essential SpEL features and customization options, targeting simple\n+ * condition evaluation and in particular data binding scenarios.\n- * <p>When creating {@code SimpleEvaluationContext} you need to choose the level\n- * of support you need to deal with properties and methods in SpEL expressions:\n+ * <p>When creating a {@code SimpleEvaluationContext} you need to choose the\n+ * level of support that you need for property access in SpEL expressions:\n- * <li>Custom {@code PropertyAccessor} only (no reflection)</li>\n+ * <li>A custom {@code PropertyAccessor} (typically not reflection-based),\n+ * potentially combined with a {@link DataBindingPropertyAccessor}</li>\n- * <p>For more flexibility, consider {@link StandardEvaluationContext} instead.\n+ * <p>For more flexibility, in particular for internal configuration\n+ * scenarios, consider using {@link StandardEvaluationContext} instead.\n+ * @see #forPropertyAccessors\n-\t * Create a {@code SimpleEvaluationContext} for the specified\n-\t * {@link PropertyAccessor} delegates.\n-\t * @see ReflectivePropertyAccessor\n-\t * @see DataBindingPropertyAccessor\n+\t * Create a {@code SimpleEvaluationContext} for the specified {@link PropertyAccessor}\n+\t * delegates: typically a custom {@code PropertyAccessor} specific to a use case\n+\t * (e.g. attribute resolution in a custom data structure), potentially combined with\n+\t * a {@link DataBindingPropertyAccessor} if property dereferences are needed as well.\n+\t * @see DataBindingPropertyAccessor#forReadOnlyAccess()\n+\t * @see DataBindingPropertyAccessor#forReadWriteAccess()\n+\t\tfor (PropertyAccessor accessor : accessors) {\n+\t\t\tif (accessor.getClass() == ReflectivePropertyAccessor.class) {\n+\t\t\t\tthrow new IllegalArgumentException(\"SimpleEvaluationContext is not designed for use with a plain \" +\n+\t\t\t\t\t\t\"ReflectivePropertyAccessor. Consider using DataBindingPropertyAccessor or a custom subclass.\");\n+\t\t\t}\n+\t\t}\n+\t * @see #forPropertyAccessors\n-\t * @see DataBindingPropertyAccessor#forReadOnlyAccess()\n+\t * @see DataBindingPropertyAccessor#forReadWriteAccess()\n+\t * @see #forPropertyAccessors\n-\t\t * {@link org.springframework.core.convert.support.DefaultConversionService}\n-\t\t * is used.\n+\t\t * {@link org.springframework.core.convert.support.DefaultConversionService} is used.\n-\t\t * {@link org.springframework.core.convert.support.DefaultConversionService}\n-\t\t * is used.\n+\t\t * {@link org.springframework.core.convert.support.DefaultConversionService} is used.",
        "change_count": 6,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Guidance of which PropertyAccessors to use with SimpleEvaluationContext",
        "commit_body": "Issue: SPR-16588\n",
        "linked_issues": [
            {
                "issue_id": "21130",
                "issue_title": "Support for SimpleEvaluationContext in SpEL [SPR-16588]",
                "issue_body": "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** opened **[SPR-16588](https://jira.spring.io/browse/SPR-16588?redirect=false)** and commented\n\n`StandardEvaluationContext` provides more options than are actually required for many common uses cases (e.g. data binding expressions, property based filters, etc) where the goal is to provide a little extra flexibility but not necessarily expose the full extent of the SpEL language. Arguably there should be a more basic `EvaluationContext` that meaningfully restricts the SpEL language and the set of relevant configuration options to what is relevant for those scenarios, optimizing guidance and SpEL resolution performance for the particular scenario.\n\n---\n\n**Affects:** 4.3.14, 5.0.4\n\n**Issue Links:**\n- [DATACMNS-1282](https://jira.spring.io/browse/DATACMNS-1282) Use SimpleEvaluationContext in MapDataBinder (_**\"is depended on by\"**_)\n- #21481 Performance degradation in SPEL expression evaluation\n- [SWF-1722](https://jira.spring.io/browse/SWF-1722) Use SimpleEvaluationContext in AbstractMvcView\n- #21244 Incomplete backport of DefaultSubscriptionRegistry changes for SPR-16588\n\n**Backported to:** [4.3.15](https://github.com/spring-projects/spring-framework/milestone/164?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nReopened for considering the new `DataBindingPropertyAccessor` as well as a builder API.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refines the `SimpleEvaluationContext` in Spring Expression Language (SpEL).  The primary change is a shift in focus and intended usage.\\n\\n**Original:**  `SimpleEvaluationContext` was presented as a general-purpose SpEL context, allowing users to specify their own `PropertyAccessor`s.  This implied a broader range of use cases, including potentially using `ReflectivePropertyAccessor`",
            "avg_logprobs": -0.2700981330871582
        }
    },
    {
        "commit_hash": "3910350b0a21b3f24750b26d22ce158b732b028b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/asm/ClassReader.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+        // SPRING PATCH: leniently handle offset mismatch\n+        if (offset >= labels.length) {\n+            return new Label();\n+        }\n+        // END OF PATCH",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ASM ClassReader leniently handles label offset mismatch",
        "commit_body": "Issue: SPR-14089\n",
        "linked_issues": [
            {
                "issue_id": "18661",
                "issue_title": "Type annotations cause ArrayIndexOutOfBoundsException in ASM ClassReader [SPR-14089]",
                "issue_body": "**[Tom van den Berge](https://jira.spring.io/secure/ViewProfile.jspa?name=tomvandenberge)** opened **[SPR-14089](https://jira.spring.io/browse/SPR-14089?redirect=false)** and commented\n\nI'm getting an exception when starting up my Spring Boot application:\n\n```java\njava.lang.ArrayIndexOutOfBoundsException: 193\n\tat org.springframework.asm.ClassReader.readLabel(ClassReader.java:2185)\n\tat org.springframework.asm.ClassReader.readTypeAnnotations(ClassReader.java:1614)\n\t...\n```\n\nIt seems that when my classes are inspected for annotations, ClassReader (Spring 4.2.5) chokes on one of my classes containing Java-8 type annotations. This is extremely unfortunate, because it means that I can't use Spring annotations in combination with type annotations.\n\nI've attached a very small (maven) project that reproduces the problem. All you need to do is run \"mvn test\". The included unit test attempts to read the problematic class file using org.springframework.asm.ClassReader, and gives the same exception as above.\n\nThe class that can't be read is\n\n```java\npublic class Problem implements Interface<String> {\n\tpublic void serialize(String request) {\n\t\tMap<String, @Nullable Object> values = new HashMap<>();\n\t\tvalues.clear();\n\t}\n}\n```\n\nThe `@Nullable` type annotation is from org.eclipse.jdt.annotation 2.0.0. I've included the source code in the attached project.\n\nAnd the interface:\n\n```java\npublic interface Interface<T> {\n\tvoid serialize(T request);\n}\n```\n\nWithout the interface, the problem doesn't occur. Also the type parameter is essential to reproduce the problem.\nWhat is also surprising, is that when the class is not compiled by maven (javac), but by Eclipse, the problem does not occur.\n\nIt would be great to know if there is a workaround for this problem, e.g. compiler settings that can be included in the pom file.\n\n---\n\n**Affects:** 4.2.5\n\n**Attachments:**\n- [project.tar](https://jira.spring.io/secure/attachment/23355/project.tar) (_8.50 kB_)\n\n**Issue Links:**\n- #21999 Type annotations and generic types causing ArrayIndexOutOfBoundsException\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nTechnically, this is an issue in ASM which we're forking there, currently at ASM 5.0.4 level. As of Spring Framework 4.3, this is based on ASM 5.1... However, your issue doesn't seem to be addressed there either yet, and I'm not aware of a workaround either.\n\nSo we can certainly address this in a custom fashion within our ASM fork, through a defensive catch block around type annotation parsing (and possibly similar metadata that Spring does not actually need for its component introspection, which is the only purpose of our repackaged ASM ClassReader). We'll do this for 4.3 RC1 as well as 4.2.6.\n\nHowever, please also report this issue to the ASM project itself at the ObjectWeb tracker: http://forge.ow2.org/tracker/?group_id=23\n",
                    "**[Tom van den Berge](https://jira.spring.io/secure/ViewProfile.jspa?name=tomvandenberge)** commented\n\nGreat! I just filed the bug there, too:\n\nhttp://forge.ow2.org/tracker/index.php?func=detail&aid=317615&group_id=23&atid=100023\n\nI was able to reproduce the bug against ASM 5.0.4 and ASM 5.1 directly as well.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're leniently handling any label offset mismatch now. Please give it a try against the upcoming `4.3.0.BUILD-SNAPSHOT`; to be backported to 4.2.6 in a bit.\n\nOnce ASM published an official fix for the actual cause of the mismatch, we'll roll it in as well.\n",
                    "**[Tom van den Berge](https://jira.spring.io/secure/ViewProfile.jspa?name=tomvandenberge)** commented\n\nIt works fine in 4.3.0.BUILD-SNAPSHOT.\n\nThanks a lot for the incredibly fast fix!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure the `offset` value is within the bounds of the `labels` array.  If `offset` is out of bounds, it now returns a new `Label` object, instead of potentially throwing an exception due to an array index out-of-bounds error.  This is a defensive programming measure to handle potential issues with invalid input",
            "avg_logprobs": -0.14461092515425247
        }
    },
    {
        "commit_hash": "39de64bafc234a3db9210f05b38174e878a69489",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/persistenceunit/DefaultPersistenceUnitManager.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\tlogger.debug(\"Found explicit default unit with name '\" + defaultName + \"' in persistence.xml - \" +\n-\t\t\t\t\t\t\t\"overriding local default unit settings ('packagesToScan'/'mappingResources')\");\n+\t\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t\t\tlogger.warn(\"Found explicit default persistence unit with name '\" + defaultName + \"' in persistence.xml - \" +\n+\t\t\t\t\t\t\t\"overriding local default persistence unit settings ('packagesToScan'/'mappingResources')\");",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log at WARN level in case of contradicting PersistenceUnitManager setup",
        "commit_body": "Closes gh-23257\n",
        "linked_issues": [
            {
                "issue_id": "23257",
                "issue_title": "Log at WARN level in case of contradicting PersistenceUnitManager setup",
                "issue_body": "If users configure a `LocalContainerEntityManagerFactoryBean` and accidentally set both a persistence unit name *and* packages to scan, the latter are ignored but the message pointing to the invalidity of this setup is only logged at debug level. The observable misbehavior is that apparently the entity scanning silently does not work.\r\n\r\nHere's an [example StackOverflow question](https://stackoverflow.com/questions/26583015/no-managedtype-was-found-for-the-key-class).",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging level for a message indicating the overriding of default persistence unit settings.  It now logs a warning instead of a debug message",
            "avg_logprobs": -0.15676649155155306
        }
    },
    {
        "commit_hash": "3b1d46b3bac74802d264cd57c4a7e685f377c91e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/function/BodyExtractors.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\tprivate static final ResolvableType VOID_TYPE = ResolvableType.forClass(Void.class);\n-\t\tif (elementType.equals(ResolvableType.forClass(Void.class))) {\n+\t\tif (VOID_TYPE.equals(elementType)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a direct comparison of `elementType` with `ResolvableType.forClass(Void.class)` to a comparison with a pre-defined constant `VOID_TYPE`.  This improves code readability and potentially performance by avoiding repeated object creation",
            "avg_logprobs": -0.05031791558632484
        }
    },
    {
        "commit_hash": "3b3798977408c25ec38ef1f7fe65bafc3712f7d9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/SortedProperties.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (!this.omitComments || !line.startsWith(\"#\")) {\n+\t\t\tif (!(this.omitComments && line.startsWith(\"#\"))) {\n-\t\t\tif (!this.omitComments || !line.startsWith(\"#\")) {\n+\t\t\tif (!(this.omitComments && line.startsWith(\"#\"))) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply De Morgan's law for greater clarity of purpose",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional logic.  The original code had two negated conditions (`!this.omitComments || !line.startsWith(\"#\")`).  The revised code uses a single, more concise condition (`!(this.omitComments && line.startsWith(\"#\"))`).  This is logically equivalent but more readable and potentially slightly more efficient.  The change effectively checks if *both* `omitComments` is true *and* the line starts with \\'#\\' before excluding the line",
            "avg_logprobs": -0.21972490816700216
        }
    },
    {
        "commit_hash": "3baacedfd9c8d908ac95be00ee745d938033cd67",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CoroutinesUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-public final class CoroutinesUtils {\n-\n-\tprivate CoroutinesUtils() {\n-\t}\n+public abstract class CoroutinesUtils {\n-\t\tif (classifier.equals(JvmClassMappingKt.getKotlinClass(Flow.class))) {\n+\t\tif (classifier != null && classifier.equals(JvmClassMappingKt.getKotlinClass(Flow.class))) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Alignment with other abstract utils classes",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies `CoroutinesUtils` from a `final` class to an `abstract` class.  Critically, it adds a null check (`classifier != null`) before the `equals` comparison.  This prevents a `NullPointerException` if the `classifier` variable is null",
            "avg_logprobs": -0.07316483656565348
        }
    },
    {
        "commit_hash": "3bc1121b9d6f73f601776a20e6ec5b0e1ea0f4b2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (!this.isStompConnected) {\n+\t\t\tif (!this.isStompConnected || conn == null) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Check both connection and connected flag",
        "commit_body": "Issue: SPR-14703\n",
        "linked_issues": [
            {
                "issue_id": "19268",
                "issue_title": "NPE during websocket disconnect [SPR-14703]",
                "issue_body": "**[Prashant Deva](https://jira.spring.io/secure/ViewProfile.jspa?name=pdeva)** opened **[SPR-14703](https://jira.spring.io/browse/SPR-14703?redirect=false)** and commented\n\nThis is the exception on server\n\n```\n\nException in thread \"clientInboundChannel-97\" org.springframework.messaging.MessageDeliveryException: Failed to handle GenericMessage [payload=byte[0], headers={simpMessageType=DISCONNECT, stompCommand=DISCONNECT, simpSessionAttributes={org.springframework.messaging.simp.SimpAttributes.COMPLETED=true}, simpSessionId=e4fb909754d849a08526503c2afa7584}] to org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask@329d23a5 in StompBrokerRelay[127.0.0.1:61613]; nested exception is java.lang.NullPointerException\n\tat org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:144)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.lang.NullPointerException\n\tat org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler$StompConnectionHandler.forward(StompBrokerRelayMessageHandler.java:783)\n\tat org.springframework.messaging.simp.stomp.StompBrokerRelayMessageHandler.handleMessageInternal(StompBrokerRelayMessageHandler.java:511)\n\tat org.springframework.messaging.simp.broker.AbstractBrokerMessageHandler.handleMessage(AbstractBrokerMessageHandler.java:238)\n\tat org.springframework.messaging.support.ExecutorSubscribableChannel$SendTask.run(ExecutorSubscribableChannel.java:135)\n\t... 3 more\n```\n\nHere is the client side code:\n\n```java\n    void setup() throws ExecutionException, InterruptedException\n    {\n\n        JettyWebSocketClient webSocketClient = new JettyWebSocketClient();\n        List<Transport> transports = new ArrayList<Transport>(1);\n        transports.add(new WebSocketTransport(webSocketClient));\n\n        SockJsClient sockJsClient = new SockJsClient(transports);\n        sockJsClient.setMessageCodec(new StringMessageCodec());\n\n        stompClient = new WebSocketStompClient(sockJsClient);\n        stompClient.setMessageConverter(new StringMessageConverter());\n        stompClient.start();\n\n        sessionHandler = new MyStompSessionHandler();\n        stompClient.connect(WS_URL, sessionHandler);\n    }\n\n    void stop()\n    {\n        stompSession.disconnect();\n        stompClient.stop();\n    }\n```\n\nAs you can see the client closes the connection gracefully.\nIt first disconnects the session and then calls stop() on the stompClient.\n\nDoing so should not result in an exception on the server.\n\n---\n\n**Affects:** 4.2.6\n\n**Issue Links:**\n- #19281 exception during websocket server shutdown\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/3bc1121b9d6f73f601776a20e6ec5b0e1ea0f4b2, https://github.com/spring-projects/spring-framework/commit/07d5f8b12300fe8559a034031143a1e598ace059, https://github.com/spring-projects/spring-framework/commit/114b2b63b1bf04a2d8743203578797387cd1527f\n\n**Backported to:** [4.2.8](https://github.com/spring-projects/spring-framework/milestone/145?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nLine number based on 4.2.6 should [match to here](https://github.com/spring-projects/spring-framework/blob/74c025052541e70d61d3569a59f80d612fb08272/spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java#L783).\n\nMost likely the DISCONNECT frame and the closing of the websocket connection are competing with each other on the server-side. There is actually a way to wait for the DISONNECT to complete through a receipt header before shutting down completely. That said we should be more defensive around this scenario to avoid the NPE. I'll see if I can reproduce it easily. Either way I can add some checks.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should now be fixed in snapshots of all 3 target versions.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `conn == null` to the `if` statement.  Previously, the code only checked if `isStompConnected` was false.  The addition ensures that if the `conn` object is null, the code block within the `if` statement is executed, preventing a potential `NullPointerException`",
            "avg_logprobs": -0.10525401433308919
        }
    },
    {
        "commit_hash": "3d57425dcb67bc9f403a412555afeb6ba962ff9f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/SimpleErrors.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tFieldError fieldError = getFieldError(field);\n+\t\tif (fieldError != null) {\n+\t\t\treturn fieldError.getRejectedValue();\n+\t\t}\n+\n+\n+",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Return rejected value from getFieldValue in case of error",
        "commit_body": "See gh-19877\n",
        "linked_issues": [
            {
                "issue_id": "19877",
                "issue_title": "Increase reusability of `Validator` [SPR-15314]",
                "issue_body": "**[Daniel Gulyas](https://jira.spring.io/secure/ViewProfile.jspa?name=danigu)** opened **[SPR-15314](https://jira.spring.io/browse/SPR-15314?redirect=false)** and commented\n\n### Quick summary\n\nHi!\n\nIt would be really cool if the Validator implementations could be reused at the Service level hassle-free.\n\nIt would be cool because:\n* It's a common scenario that there's a second request source using the same dto (think webmvc / rest and mq), adding the second source involves extra work if it doesn't provide the binding in an other way, without using implementations of the Errors interface\n* Increases code reuse, since we use the same Validator on both Service-level and Controller-level\n* Would promote validation at the service-level a bit\n\nExample scenario when that happens:\n1. There's a web-mvc project, `controller <-dto-> service`, at the controller-side the dto is validated with the Validator\n2. There's a business need to implement a secondary source of requests (let's say an mq)\n\nNow there's a possibility to reuse the Validator created for the controller at the service level, but for me it seems to involves quite a hassle, it would be nice to make that convenient.\n\n### Proposal\n\n* Create an interface which implements the simplified Errors interface\n  * Can be instantiated with the target object only\n  * Doesn't necessary have to store all the rejected properties, tracking if there was any errors might be enough\n* Create an abstract class which implements Validator\n  * Boolean validate(Object target) is implemented here\n\nThe namings for me seem to be a bit weak, they could handle suggestions I'm pretty sure.\n\nFor existing Validator implementations there's only need to extend this abstract class and it'll turn into a validator which is convenient to use at the service level, please see the attached java files, this might be a bit invasive although.\n\n### Follow-up\n\nThis is just an idea and i'm kinda new to Spring and to Java in general so the proposal will probably include foolish design mistakes, i looked it up and so far i haven't seen anything which would make reusing of these easy, please point it out if there's already some.\n\nIf that's cool to do and there's a consensus i could make a pr for this in the coming days.\n\nLet me know what you think!\n\n\n---\n\n**Attachments:**\n- [ExampleValidator.java](https://jira.spring.io/secure/attachment/23795/ExampleValidator.java) (_553 bytes_)\n- [ServiceLevelValidator.java](https://jira.spring.io/secure/attachment/23794/ServiceLevelValidator.java) (_350 bytes_)\n- [SimplifiedErrors.java](https://jira.spring.io/secure/attachment/23793/SimplifiedErrors.java) (_488 bytes_)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "We are considering a default method on the `Validator` interface for such a purpose in 6.1, for simplified assertion-style invocations. We are not sure whether to reduce this to a `boolean` return value or rather throw an `IllegalArgumentException` with a rich message, but either way, we're going to make it easier to invoke a `Validator` without an `Errors` instance having to be manually built/provided.",
                    "After a bit of back and forth, I'm introducing a `Validator.validateObject(Object)` method with an `Errors` return value now which can easily be used for a `Validator.validateObject(Object).hasErrors()` check but also with a new failOnError method on the `Errors` interface: `Validator.validateObject(Object).failOnError(IllegalStateException::new))`. Underneath the covers, this is using a new `SimpleErrors` implementation which tracks registered errors in a lean fashion and flexibly accesses field values via getter methods or raw field access (while not providing any binding support)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check for a `FieldError` object (`fieldError`).  If the `fieldError` is not null, it returns the `rejectedValue` from that `FieldError`.  This suggests a change to handle cases where a `FieldError` might be missing, potentially preventing a `NullPointerException`",
            "avg_logprobs": -0.15977959405808223
        }
    },
    {
        "commit_hash": "3dd817585b6258fe51d3279262234dc41f34009b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/jmx/support/MBeanRegistrationSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import java.util.Collections;\n-\tprotected final Set<ObjectName> registeredBeans = new LinkedHashSet<ObjectName>();\n+\tprivate final Set<ObjectName> registeredBeans = Collections.synchronizedSet(new LinkedHashSet<ObjectName>());\n-\t\tfor (ObjectName objectName : this.registeredBeans) {\n+\t\tfor (ObjectName objectName : new LinkedHashSet<ObjectName>(this.registeredBeans)) {\n-\t\tthis.registeredBeans.clear();\n+\t\tthis.registeredBeans.remove(objectName);",
        "change_count": 7,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "MBeanExporter does not log warnings for manually unregistered MBeans",
        "commit_body": "Issue: SPR-9451\n",
        "linked_issues": [
            {
                "issue_id": "14086",
                "issue_title": "MBeanExporter#destroy logs warnings about explicitly unregistered mbeans [SPR-9451]",
                "issue_body": "**[Andreas Hubold](https://jira.spring.io/secure/ViewProfile.jspa?name=ahubold)** opened **[SPR-9451](https://jira.spring.io/browse/SPR-9451?redirect=false)** and commented\n\nMethod #destroy of org.springframework.jmx.export.MBeanExporter unregisters all beans that have been registered before. It however also tries to unregister beans that have already been unregistered via org.springframework.jmx.export.MBeanExporter#unregisterManagedResource. The MBeanExporter logs a warning for each such bean:\n\n```\nWARN  o.s.jmx.export.MBeanExporter - Could not unregister MBean [...] as said MBean is not registered (perhaps already unregistered by an external process)\n```\n\nThe bean was not unregistered by an external process but by the MBeanExporter itself when #unregisterManagedResource was called.\n\nPlease do not log this as warning. Administrators get nervous and keep asking what this message means.\n\n---\n\n**Affects:** 3.1.1\n\n**Issue Links:**\n- #15585 MBeanExporter/MBeanRegistrationSupport leaks ObjectNames in registeredBeans\n\n**Backported to:** [3.1.4](https://github.com/spring-projects/spring-framework/milestone/83?closed=1)\n\n10 votes, 3 watchers\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `MBeanRegistrationSupport` modifies how the `registeredBeans` set is handled.  Previously, a `LinkedHashSet` was used directly.  Now, a `LinkedHashSet` is wrapped within a `Collections.synchronizedSet`.  Critically, the code now iterates over a *copy* of the `registeredBeans` set using `new LinkedHashSet<ObjectName>(this.registeredBeans)`",
            "avg_logprobs": -0.14605401039123536
        }
    },
    {
        "commit_hash": "40822746306f5d0e5d553504275046ec4906309b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLStateSQLExceptionTranslator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.dao.QueryTimeoutException;\n+\t\t// First, the getSQLState check...\n+\n+\t\t// For MySQL: exception class name indicating a timeout?\n+\t\t// (since MySQL doesn't throw the JDBC 4 SQLTimeoutException)\n+\t\tif (ex.getClass().getName().contains(\"Timeout\")) {\n+\t\t\treturn new QueryTimeoutException(buildMessage(task, sql, ex), ex);\n+\t\t}\n+\n+\t\t// Couldn't resolve anything proper - resort to UncategorizedSQLException.",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SQLStateSQLExceptionTranslator checks exception class name for timeout indication before resorting to UncategorizedSQLException",
        "commit_body": "Issue: SPR-11959\n",
        "linked_issues": [
            {
                "issue_id": "16575",
                "issue_title": "SQLExceptionTranslators do not reliably translate QueryTimeoutException [SPR-11959]",
                "issue_body": "**[Francisco Lozano](https://jira.spring.io/secure/ViewProfile.jspa?name=flozano)** opened **[SPR-11959](https://jira.spring.io/browse/SPR-11959?redirect=false)** and commented\n\nWith SQLErrorCodeSQLExceptionTranslator, my code can catch both DuplicateKeyException and DataIntegrityViolationException. This helps to distinguish between a FK constraint violation and a duplicate key, directly and without having to dig more onto the database to find out.\n\nI had to change my use of JdbcTemplate to force SQLExceptionSubclassTranslator, in order to gracefully handle query timeouts. Unfortunately, this had the effect of rendering all my catches of DuplicateKeyException unreachable.\n\nSo, by default and without coding anything, as a user of Spring JDBC wrappers I'm stuck between a rock and a hard place.\n\nI guess the workaround is to make a custom SQLExceptionTranslator, but this use-case is not so strange and it would be great if Spring could come with a \"smart\" SQL exception translator that uses whatever it needs to provide the most accurate exception possible.\n\nI'm not sure now this should be reported a \"bug\" or as something else... I initially considered SQLErrorCodeSQLExceptionTranslator \"buggy\" because it is not translating exceptions onto  DuplicateKeyException, but I can see in this case it's not straightforward to do it right for everyone.\n\n---\n\n**Affects:** 4.0.5\n\n**Issue Links:**\n- #14012 java.sql.SQLTimeoutException not translated to org.springframework.dao.QueryTimeoutException\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/40822746306f5d0e5d553504275046ec4906309b\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Francisco Lozano](https://jira.spring.io/secure/ViewProfile.jspa?name=flozano)** commented\n\nWorkaround for now:\n\n```\npublic class SmarterSQLExceptionTranslator extends\n\t\tSQLErrorCodeSQLExceptionTranslator {\n\n\t@Override\n\tprotected DataAccessException customTranslate(String task, String sql,\n\t\t\tSQLException sqlEx) {\n\t\tif (sqlEx instanceof SQLTimeoutException) {\n\t\t\treturn new QueryTimeoutException(buildMessage(task, sql, sqlEx),\n\t\t\t\t\tsqlEx);\n\t\t}\n\t\treturn super.customTranslate(task, sql, sqlEx);\n\t}\n}\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nBased on your workaround, let's turn this around: SQLErrorCodeSQLExceptionTranslator should be able to handle QueryTimeoutException, even if not indicated by a specific error code.\n\nAs for SQLExceptionSubclassTranslator, that one is intended to be constrained to the JDBC 4.0 exception hierarchy's capabilities. It's also used as the fallback translator within SQLErrorCodeSQLExceptionTranslator, but for some reason it's not kicking in for query timeouts - probably because those end up being misidentified based on some error code match in SQLErrorCodeSQLExceptionTranslator itself?\n\nJuergen\n",
                    "**[Francisco Lozano](https://jira.spring.io/secure/ViewProfile.jspa?name=flozano)** commented\n\nFirst of all, an update: for me it's still failing even with workaround, because I'm using MySQL and this issue happens: http://bugs.mysql.com/bug.php?id=73216. In short: MySQL has two MySQLTimeoutException - one jdbc4 and other plain SQLException - and the one being thrown is the one which doesn't inherit from SQLTimeoutException.\n\nDuring my tests I threw manually the right exception (the jdbc4 one), whereas the driver never throws that one (it's there but I think it's never used).\n\nIf the thrown MySQLTimeoutException was the correct one of the two that they have in the driver, SQLErrorCodeSQLExceptionTranslator would probably work OK as it is now, right? delegating to subclass-based.\n\nSo, unless there's another way to detect a timeout other than subclass-approach, and given that SQLExceptionSubclassTranslator is on-spec and OK as it is (it already does as much as it can with subclass strategy), I think this issue may be fixed as a won't fix.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, SQLErrorCodeSQLExceptionTranslator is supposed to fall back to the subclass-based approach in such a case. The only problem could be that it accidentally detects an known error code in a timeout-related exception and decides to translate it to one of its resource failure exceptions first.\n\nThat said, in your case, it seems that it does fall through to the subclass-based approach but just doesn't detect it that way either since it's not the expected subclass. So you end up getting an UncategorizedSQLException? Or do you get a more specific but still not timeout-indicating exception thrown?\n\nWe could have a fallback check that detects known keywords such as \"Timeout\" in an exception's class name before resorting to an UncategorizedSQLException. I suppose that would actually work for this MySQL case here... In principle, we'd even be willing to add such a workaround just for MySQL.\n\nJuergen\n",
                    "**[Francisco Lozano](https://jira.spring.io/secure/ViewProfile.jspa?name=flozano)** commented\n\nIn my case, I get UncategorizedSQLException wrapping the non-jdbc4 MySQLTimeoutException.\n\nI like the idea of having a list of (vendor-specific?) exception names or patterns handling fallbacks. I think I will try that for my workaround actually... I didn't want to catch the specific exception and couple my code to MySQL's driver because of GPL, but I can for sure put the name of the exception in a Set.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'm not too keen on turning this into a full-fledged extensible mechanism at this point, since we only have one use case and everything else is known to be covered by the existing (and extensible) error code and SQLState based mechanisms. So from that perspective, all I'm considering to add is this...\n\n```\n// For MySQL: exception class name indicating a timeout?\n// (since MySQL doesn't throw the JDBC 4 SQLTimeoutException)\nif (ex.getClass().getName().contains(\"Timeout\")) {\n     return new QueryTimeoutException(buildMessage(task, sql, ex), ex);\n}\n```\n\nat the end of SQLStateSQLExceptionTranslator which is the last-resort fallback in all of our translation chains, right before we end up with an UncategorizedSQLException.\n\nJuergen\n",
                    "**[Francisco Lozano](https://jira.spring.io/secure/ViewProfile.jspa?name=flozano)** commented\n\nIf this is the only case found, maybe that's enough :) but the .contains(\"\") is not very roubst, why not the class name? if it's just for MySQL's specific case...\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nFair enough, we could check for the specific class name there... It just might be beneficial to cover similar exceptions for other JDBC drivers as well; in some sense, that's actually more robust. We have a few such cases where we detect naming patterns for the purposes of specific exception messages etc, for cases where there are no formal indications. Note that we are checking the **exception class name** here, not the exception message.\n\nSince the specific check above is right before giving up completely (with a bland UncategorizedSQLException), a general check for timeout-related exceptions doesn't seem to hurt. It will even cover plain SQLStateSQLExceptionTranslator use with the standard JDBC 4 SQLTimeoutException, without the SQLExceptionSubclassTranslator involved, adding a timeout capability that otherwise isn't possible based on the pure SQLState arrangement.\n\nJuergen\n",
                    "**[Francisco Lozano](https://jira.spring.io/secure/ViewProfile.jspa?name=flozano)** commented\n\nThank you as always!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a check for `QueryTimeoutException` in the `SQLStateSQLExceptionTranslator`.  Specifically, it now handles exceptions from MySQL that indicate a timeout, but don\\'t use the standard JDBC 4 `SQLTimeoutException`.  If the exception class name contains \"Timeout\", a `QueryTimeoutException` is created, wrapping the original exception.  Otherwise, the original exception is handled as an `UncategorizedSQLException`.  This change improves handling of MySQL timeout errors",
            "avg_logprobs": -0.24770294992547287
        }
    },
    {
        "commit_hash": "40bf83c9e585bcca99dc321f071f69f4e7cdffa9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataContext.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t\tsetFunctionReturnName(paramName);\n+\t\t\t\t\t\tthis.actualFunctionReturnName = paramName;\n-\t\t\t\t\telse if (paramName != null) {\n-\t\t\t\t\t\tsetFunctionReturnName(paramName);\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tthis.actualFunctionReturnName = param.getName();\n-\t\t\t\t\t\t\tsetFunctionReturnName(returnNameToUse);\n+\t\t\t\t\t\t\tthis.actualFunctionReturnName = returnNameToUse;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Restore original 4.x behavior for initialization of function return name",
        "commit_body": "Closes gh-25707\n",
        "linked_issues": [
            {
                "issue_id": "25707",
                "issue_title": "CallMetaDataContext.reconcileParameters overwrites cursor name",
                "issue_body": "\r\n**Affects:** \\SB2\r\norg.springframework:spring-jdbc:5.1.9.RELEASE\r\nExplanation. Existing code is using a named cursor.\r\nWhen the Resultset comes back, it is always empty, even though when I debug through the spring-jdbc I see it getting created with correct results. The issue is with the named cursor.\r\n\r\nExample:\r\n\r\n> this.simpleJdbcCall = new SimpleJdbcCall(jdbcTemplate)\r\n>                 .withSchemaName(\"schema\")\r\n>                 .withFunctionName(\"functionName\")\r\n>                 .returningResultSet(\"myCursorName\", mapperInstance);\r\n\r\nif I name the cursor 'returnValue' then it works. Searching through the code, I saw that it is over writing 'myCursorName' with 'returnValue'. 'returnValue' seems to be the default name used internally.\r\nIn SimpleJdbcCall:\r\n\r\n> \tpublic <T> T executeFunction(Class<T> returnType, SqlParameterSource args) {\r\n> \t\treturn (T) doExecute(args).get(getScalarOutParameterName());\r\n> \t}\r\n\r\n'getScalarOutParameterName()' is returning 'returnValue' even though I named it as '.returningResultSet(\"myCursorName\",'\r\n\r\nBut I also traced this to `CallMetaDataContext.reconcileParameters` around line 396:\r\n\r\n> \tparam = declaredParams.get(getFunctionReturnName());\r\n> \tif (param == null && !getOutParameterNames().isEmpty()) {\r\n> \t\tparam = declaredParams.get(getOutParameterNames().get(0).toLowerCase());\r\n> \t}\r\n> \tif (param == null) {\r\n> \t\tthrow new InvalidDataAccessApiUsageException(\r\n> \t\t\t\t\"Unable to locate declared parameter for function return value - \" +\r\n> \t\t\t\t\" add an SqlOutParameter with name '\" + getFunctionReturnName() + \"'\");\r\n> \t}\r\n> \telse if (paramName != null) {\r\n> \t\tsetFunctionReturnName(paramName);\r\n> \t}\r\n\r\nIn older version it used to have (the last 3 lines):\r\n\r\n> \telse {\r\n> \t\tsetFunctionReturnName(param.getName());\r\n> \t}\r\n\r\nparamName is 'returnValue', but it should be using what I supplied which is 'param.getName()'.\r\nThen this would return the correct ruleset: return (T) doExecute(args).get(getScalarOutParameterName());\r\n\r\nPlease advise. Thanks.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "This seems to be an accidental regression introduced by our nullability efforts in 5.0. I'll fix this for 5.2.9, with a backport to 5.1.18 and 5.0.19 at the same time (for release on Sep 15).",
                    "Thanks for the quick response."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes a redundant `else if` block and simplifies the logic for setting the `actualFunctionReturnName` field.  Previously, if `paramName` was not null, it would set the `functionReturnName`.  Now, if `paramName` is null, it sets `actualFunctionReturnName` to the value of `param.getName()`. Otherwise, it sets `actualFunctionReturnName` to `returnNameToUse`",
            "avg_logprobs": -0.18369998931884765
        }
    },
    {
        "commit_hash": "40cd277b7e26e135de71b80bec757b2022641815",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/ReloadableResourceBundleMessageSource.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tlong originalTimestamp = -1;\n+\t\tlong originalTimestamp = -2;\n-\t\t\tif (originalTimestamp < 0 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis) {\n+\t\t\tif (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ReloadableResourceBundleMessageSource prevents accidental exposure of incomplete holder",
        "commit_body": "Issue: SPR-12177\n",
        "linked_issues": [
            {
                "issue_id": "16791",
                "issue_title": "Race condition in ReloadableResourceBundleMessageSource since 4.1.0 [SPR-12177]",
                "issue_body": "**[Janning Vygen](https://jira.spring.io/secure/ViewProfile.jspa?name=janning)** opened **[SPR-12177](https://jira.spring.io/browse/SPR-12177?redirect=false)** and commented\n\nThis bug is not in 4.1.0.RC2 but in 4.1.0.RELEASE\n\nI think it is a blocker as this class is at the core of spring, widely used and produces unexpected results which crashes the application completely:\n\nWe are using ReloadableResourceBundleMessageSource with cacheMillis = -1 in production. We use this class to have a reloadable instance in development mode.\n\nThere is a race condition when getMergedProperties(Locale locale) is called.\n\nIt results in an empty but cached propertiesHolder. Imagine two threads calling getMergedProperties(Locale locale). The first thread is running into getProperties(filename) Line 354. it then runs into line 464:\n\npropHolder = new PropertiesHolder();\nPropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder);\n\nso thread 1 is setting an empty PropertiesHolder into the cache. Imagine thread 1 is waiting here for a long time and a second thread is running into this method. It will find the empty propHolder in line 453 and it get returned in line 460. Now thread 2 goes on with this empty propHolder but it does not put it into mergedProperties (line  355).\n\nBut in line 360 the second thread is putting his mergedholder into the cache. Now thread 1 continues but will not update the cache as an entry already exists. Subsequent threads  will get the mergedHolder from the cache which is partially empty (depending on how often this race condition occurs).\n\nI was able to reproduce this bug on my development engine with breakpoints. I think you need to fix line 464-465.\n\nThis else thread is only running on start up. A fix would be to add this line after line 464:\n\npropHolder = refreshProperties(filename, propHolder);\n\nI hope I explained it good enough.\n\n---\n\n**Affects:** 4.1 GA\n\n**Issue Links:**\n- #19152 Method getMergedProperties in ReloadableResourceBundleMessageSource does not set fileTimestamp\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/40cd277b7e26e135de71b80bec757b2022641815\n\n0 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs far as my analysis goes, the actual root of the problem is the `originalTimestamp < 0` in line 458 which may prematurely return a half-initialized holder to concurrent callers. Changing this to `originalTimestamp == -1`, i.e. just the case of a pre-cached 'eternal' holder, should do the job... In the case of a yet incomplete holder (-2), we should then skip the early return and proceed to the regular refresh code path that follows below.\n\nThis will be available in the upcoming 4.1.1 snapshot. Try to break it again please, and let me know whether I've been missing something!\n\nJuergen\n",
                    "**[Janning Vygen](https://jira.spring.io/secure/ViewProfile.jspa?name=janning)** commented\n\nlooks good. Thanks you so much!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the initialization of `originalTimestamp` from `-1` to `-2`.  More importantly, it alters the conditional logic checking `originalTimestamp`.  The original check `if (originalTimestamp < 0 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis)` is now `if (originalTimestamp == -1 || originalTimestamp > System.currentTimeMillis() - this.cacheMillis)`",
            "avg_logprobs": -0.12463619232177735
        }
    },
    {
        "commit_hash": "42a4f2896222959d85ba4642542cfe05aff91f2c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfor (Annotation annotation : getAnnotations()) {\n+\t\t\tfor (Annotation annotation : this.annotations) {\n-\t\t\tfor (Annotation annotation : getAnnotations()) {\n+\t\t\tfor (Annotation annotation : this.annotations) {",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Avoid unnecessary Annotation array cloning in TypeDescriptor",
        "commit_body": "Closes gh-32476\n",
        "linked_issues": [
            {
                "issue_id": "32476",
                "issue_title": "Avoid additional unnecessary `Annotation` array cloning in `TypeDescriptor`",
                "issue_body": "As a follow-up to #32405, we should also avoid cloning the annotation array unnecessarily in `isAnnotationPresent()` and `getAnnotation()`.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `getAnnotations()` with `this.annotations`.  This suggests a field `annotations` now holds the annotation list directly within the `TypeDescriptor` class, rather than relying on a method to retrieve it.  This likely improves performance by avoiding the method call overhead",
            "avg_logprobs": -0.12965044482000943
        }
    },
    {
        "commit_hash": "42b16591ec9978f9e317035bad998e617e79bb7e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/persistenceunit/SpringPersistenceUnitInfo.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.apache.commons.logging.LogFactory;\n-\t\tif (this.loadTimeWeaver == null) {\n-\t\t\tthrow new IllegalStateException(\"Cannot apply class transformer without LoadTimeWeaver specified\");\n+\t\tif (this.loadTimeWeaver != null) {\n+\t\t\tthis.loadTimeWeaver.addTransformer(new ClassFileTransformerAdapter(classTransformer));\n+\t\t}\n+\t\telse {\n+\t\t\tLogFactory.getLog(getClass()).info(\"No LoadTimeWeaver setup: ignoring JPA class transformer\");\n-\t\tthis.loadTimeWeaver.addTransformer(new ClassFileTransformerAdapter(classTransformer));",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SpringPersistenceUnitInfo leniently ignores transformer if no LoadTimeWeaver is present",
        "commit_body": "Closes gh-29736\n",
        "linked_issues": [
            {
                "issue_id": "29736",
                "issue_title": "Compatibility with Hibernate ORM 6.2",
                "issue_body": "I've just tried to run a build of Spring Data JPA on [Hibernate 6.2 CR1](https://in.relation.to/2022/12/22/orm-62-cr1/). It apparently [changes a couple of default settings](https://docs.jboss.org/hibernate/orm/6.2/migration-guide/migration-guide.html#enhancement), which now cause `SpringPersistenceUnitInfo.addTransformer(\u2026)` being called, which blows up with an `IllegalStateException` if no `LoadTimeWeaver` is set.\r\n\r\nI am not certain how we want to handle this, but as it looks like the current default bootstrap settings will either have to handle that call more leniently or we will have to change our default settings. Unfortunately, the tickets linked to from the migration guide indicate that the flags are deprecated for removal without replacement.\r\n\r\nThe comments in `EntityManagerFactoryBuilderImpl` seem to indicate that they only assume the call to `\u2026.addTransformer(\u2026)` to have an effect in EE environments anyway. I could get this working with a local copy of `SpringPersistenceUnitInfo` tweaked to drop the invocation if no load time weaver was specified instead of throwing the exception. SD JPA builds fine then.",
                "issue_state": "closed",
                "issue_comment": [
                    "Following that advice, `SpringPersistenceUnitInfo` just logs a warning in case of no `LoadTimeWeaver` setup now, leniently ignoring the given transformer in such a case.\r\n\r\nIf anything else can be addressed for Hibernate ORM 6.2 RC1 or a follow-up RC, there's still a chance for the 6.0.4 release. Otherwise we'll address any remainders in 6.0.5."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of `LoadTimeWeaver` and class transformers in `SpringPersistenceUnitInfo`.  Previously, an `IllegalStateException` was thrown if `loadTimeWeaver` was null.  Now, if `loadTimeWeaver` is not null, a class transformer is added.  If `loadTimeWeaver` is null, a log message is printed indicating that the JPA class transformer will be ignored",
            "avg_logprobs": -0.17152313232421876
        }
    },
    {
        "commit_hash": "437ffa6067266eafca6fa7c5200b7375618e1970",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\n+\t\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n+\t\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n+\t\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n+\t\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n+\t\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n+\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Detect LoadTimeWeaver bean when declared through @Bean method as well",
        "commit_body": "Issue: SPR-10856\n",
        "linked_issues": [
            {
                "issue_id": "15483",
                "issue_title": "Detect LoadTimeWeaver bean when declared through @Bean method as well [SPR-10856]",
                "issue_body": "**[Nick Williams](https://jira.spring.io/secure/ViewProfile.jspa?name=guitarking117)** opened **[SPR-10856](https://jira.spring.io/browse/SPR-10856?redirect=false)** and commented\n\nThis may be a Java-config problem only. I haven't tried it with XML config.\n\nI'm configuring a `LocalContainerEntityManagerFactoryBean`, and I want to enable load time weaving. `@EnableLoadTimeWeaving` works (I see in the log that it found `addTransformer` on the `ClassLoader` and created a load time weaver), but `setLoadTimeWeaver` is never called on the `LocalContainerEntityManagerFactoryBean`.\n\n`LocalContainerEntityManagerFactoryBean` implements `LoadTimeWeaverAware`, so my (possibly incorrect) assumption was that Spring should set the `LoadTimeWeaver` property, but it does not. If my assumption was incorrect, the documentation should be updated to indicate that you must call this method manually. If my assumption was correct, there is a bug here, because Spring is not calling this method.\n\nInstead, I have to do this in my configuration:\n\n```java\n@Configuration\n...\n@EnableLoadTimeWeaving\n...\npublic class RootContextConfiguration\n{\n    ...\n    @Inject LoadTimeWeaver loadTimeWeaver;\n    ...\n\n    @Bean\n    public LocalContainerEntityManagerFactoryBean entityManagerFactoryBean()\n    {\n        ...\n        LocalContainerEntityManagerFactoryBean factory =\n                new LocalContainerEntityManagerFactoryBean();\n        ...\n        factory.setLoadTimeWeaver(this.loadTimeWeaver);\n        ...\n        return factory;\n    }\n    ...\n}\n```\n\nThat code works. The `LoadTimeWeaver` is injected and I successfully add it to my factory, then the JPA provider starts instrumenting my classes. However, without this the `LoadTimeWeaver` is never added to the `LocalContainerEntityManagerFactoryBean` and the JPA provider cannot instrument my classes.\n\n---\n\n**Affects:** 3.2.4, 4.0 M2\n\n**Issue Links:**\n- #15365 LoadTimeWeaving is working with XML config and not with Java Config (_**\"is duplicated by\"**_)\n- #19498 NPE in LoadTimeWeavingConfiguration: loadTimeWeaver() called too early\n- #18459 Proper load-time weaving support for Hibernate 5\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/437ffa6067266eafca6fa7c5200b7375618e1970\n\n9 votes, 14 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Nick Williams](https://jira.spring.io/secure/ViewProfile.jspa?name=guitarking117)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller), are you not going to be able to get this fixed for 4.0.0? That's disappointing. :-(\n",
                    "**[Nick Williams](https://jira.spring.io/secure/ViewProfile.jspa?name=guitarking117)** commented\n\nAny possibility this gets fixed in 4.0.1 or 4.0.2?\n",
                    "**[Steve McKay](https://jira.spring.io/secure/ViewProfile.jspa?name=smckay)** commented\n\nI encountered this issue with Spring 4.1.1, and it's caused by the way the ApplicationContext registers LoadTimeWeaverAwareProcessor. LoadTimeWeaver definition is checked for in AbstractApplicationContext.prepareBeanFactory(), which runs **before** BeanFactoryPostProcessors. Because `@Configuration` classes are handled by a BeanFactoryPostProcessor, the LoadTimeWeaver registered by `@EnableLoadTimeWeaving` is added to late too trigger registration of LoadTimeWeaverAwareProcessor.\n\nBecause I'm using Spring Boot, I used a SpringApplicationRunListener to register a LoadTimeWeaver in the contextLoaded() callback. Of course that only works with Spring Boot so anyone not using it will have to find some other workaround. The important thing is to have a LoadTimeWeaver definition available **before** calling ApplicationContext.refresh().\n",
                    "**[Michael Simons](https://jira.spring.io/secure/ViewProfile.jspa?name=michael.simons)** commented\n\nHere's a snippet that works with Spring Boot in case anybody lands here:\n\n```java\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.context.event.ApplicationPreparedEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver;\n \n@SpringBootApplication\npublic class Application {    \n    public static void main(final String... args) {\n        final SpringApplication springApplication = new SpringApplication(Application.class);\n        springApplication.addListeners(new ApplicationListener<ApplicationPreparedEvent>() {\n            @Override\n            public void onApplicationEvent(final ApplicationPreparedEvent event) {\n                event.getApplicationContext().getBeanFactory().registerSingleton(ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, new InstrumentationLoadTimeWeaver());\n            }\n        });\n        springApplication.run(args);\n    }\n}\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThanks for the pointers! It seems that we need to detect a `LoadTimeWeaver` bean when declared through an `@Bean` method as well, after we registered all `BeanFactoryPostProcessors`. We did not support that at all before but we are doing it in `AbstractApplicationContext` as of 4.3 now.\n\nThat said, it might make sense for Spring Boot to go a step further and have first-class support for `LoadTimeWeaver` setup, registering an externally declared `LoadTimeWeaver` class at the earliest possible point.\n",
                    "**[Andrei Ivanov](https://jira.spring.io/secure/ViewProfile.jspa?name=shadow)** commented\n\nSorry to hijack this issue, but maybe I can draw attention to my related issue too, #18466 :)\n\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a check for a `LoadTimeWeaver` bean.  If a `LoadTimeWeaver` bean exists and a temporary class loader is not yet set, it registers a `LoadTimeWeaverAwareProcessor` bean post-processor and sets a `ContextTypeMatchClassLoader` as the temporary class loader.  This suggests a mechanism for dynamically applying weaving to beans during application context initialization, likely for aspects or other bytecode manipulation",
            "avg_logprobs": -0.19754300492533136
        }
    },
    {
        "commit_hash": "43dd813ee64e7c62aeeaf24cdd52230457336d5b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/xml/DomContentHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (node instanceof Document document) {\n-\t\t\tthis.document = document;\n+\t\tif (node instanceof Document doc) {\n+\t\t\tthis.document = doc;",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Temporary workaround for Checkstyle bug",
        "commit_body": "Attempting to name a variable in an \"instanceof pattern\" the same as\na field results in a Checkstyle violation similar to the following if\nthe \"instanceof pattern matching\" is located within a constructor.\n\nReference to instance variable 'document' needs \"this.\". [RequireThis]\n\nSee gh-28188\n",
        "linked_issues": [
            {
                "issue_id": "28188",
                "issue_title": "Apply \"instanceof pattern matching\" in spring-core",
                "issue_body": null,
                "issue_state": "closed",
                "issue_comment": [
                    "I'm not convinced this needs to be applied throughout. Especially where variables are used once.",
                    "> Please rebase your changes on `main`.\r\n> \r\n> Also, for checks like `value instanceof Class clazz` you'll need to add the generic wildcard like `value instanceof Class<?> clazz`. So please make the appropriate changes. In other words, we don't want to have to suppress \"raw types\" warnings in such cases.\r\n\r\nOK , let me update the codes.",
                    "This has been merged into `main` in bbaf7578b2ca66ec1a4cff114c3e2bc4d7d3b462 and revised in 43dd813ee64e7c62aeeaf24cdd52230457336d5b and 16f65e59b49ebdc7813819c137203fccccf8f4f2.\r\n\r\nThanks! \ud83d\udc4d ",
                    "It turns out that the Checkstyle issue is a known limitation.\r\n\r\n- https://github.com/checkstyle/checkstyle/issues/10969"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `Document document` with `Document doc` in a conditional statement.  This is a simple renaming of a variable within the `if` statement, likely a stylistic change to use a shorter variable name.  No functional change to the conditional logic or the program's behavior is introduced",
            "avg_logprobs": -0.1805294406029486
        }
    },
    {
        "commit_hash": "43e315f10c6021ef46f403f17b473ffd98c8474a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\treturn;\n-\t\t\t\tif (inValue instanceof DisposableSqlTypeValue) {\n-\t\t\t\t\t((DisposableSqlTypeValue) inValue).cleanup();\n+\t\t\t\t// Unwrap SqlParameterValue first...\n+\t\t\t\tif (inValue instanceof SqlParameterValue) {\n+\t\t\t\t\tinValue = ((SqlParameterValue) inValue).getValue();\n-\t\t\t\telse if (inValue instanceof SqlValue) {\n+\t\t\t\t// Check for disposable value types\n+\t\t\t\tif (inValue instanceof SqlValue) {\n+\t\t\t\telse if (inValue instanceof DisposableSqlTypeValue) {\n+\t\t\t\t\t((DisposableSqlTypeValue) inValue).cleanup();\n+\t\t\t\t}",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Unwrap SqlParameterValue for disposable value detection in cleanupParameters",
        "commit_body": "Closes gh-22972\n",
        "linked_issues": [
            {
                "issue_id": "22972",
                "issue_title": "Oracle LOB segments holding TEMP space after executing SP using SimpleJdbcCall with SqlParameterSource",
                "issue_body": "https://github.com/spring-projects/spring-framework/blob/e0654a5b3dcf55a7840cd29d25c55854a071202c/spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java#L460\r\n\r\nWhen using SimpleJdbcCall with MapSqlParameterSource but without initial parameters declaration - all parameters became as SqlParameterValue.\r\n\r\nBut cleanup method doesn't expect such type of parameters and therefore is not executing freetemporary for LOBs.\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `StatementCreatorUtils` modifies the cleanup logic for input values (`inValue`).  The original code unconditionally returned.  The updated code now first unwraps `SqlParameterValue` if present, then checks for `DisposableSqlTypeValue` and `SqlValue` types.  Crucially, the order of the `if` statements has been changed to prioritize unwrapping `SqlParameterValue` before checking for `DisposableSqlTypeValue`",
            "avg_logprobs": -0.22256229400634767
        }
    },
    {
        "commit_hash": "4453102e852f4693222d103264c9a62b421f3d2a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ExceptionHandlerExceptionResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType);\n-\t\t\tif (resolver == null) {\n-\t\t\t\tresolver = new ExceptionHandlerMethodResolver(handlerType);\n-\t\t\t\tthis.exceptionHandlerCache.put(handlerType, resolver);\n-\t\t\t}\n+\t\t\tExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.computeIfAbsent(handlerType, ExceptionHandlerMethodResolver::new);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish ExceptionHandlerMethodResolver mapping",
        "commit_body": "See gh-27801\n",
        "linked_issues": [
            {
                "issue_id": "27801",
                "issue_title": " Polish ExceptionHandlerMethodResolver mapping",
                "issue_body": "Refactor exception resolver cache get/null/put opration into single call.",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for making your first contribution to Spring Framework."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a conditional check and potentially redundant object creation with a `computeIfAbsent` operation.  The original code checked if an `ExceptionHandlerMethodResolver` existed for a given `handlerType` in the cache. If not, it created a new one and added it to the cache.  The updated code uses `computeIfAbsent` to create and store the resolver only if it's not already present, avoiding the redundant check and creation. This is more concise and potentially more efficient.",
            "avg_logprobs": -0.20667198181152344
        }
    },
    {
        "commit_hash": "449174c7d4c5925ff54cc4390d33d0d0bd8ad377",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DisposableBeanAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tfor (int i = 0; i < destroyMethodNames.length; i++) {\n-\t\t\t\t\tString destroyMethodName = destroyMethodNames[i];\n+\t\t\t\tfor (String destroyMethodName : destroyMethodNames) {",
        "change_count": 3,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `for` loop iterating over an array of `String`s (`destroyMethodNames`) using an index with an enhanced `for` loop (for-each loop).  This change improves readability and removes the need to manage the index `i`.  The code now directly iterates over the elements of the `destroyMethodNames` array",
            "avg_logprobs": -0.1516766611735026
        }
    },
    {
        "commit_hash": "449f704650fa02750a807e7f060515128dc888f3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(\"Resolved classpath location [\" + location + \"] to resources \" + result);\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "PathMatchingResourcePatternResolver consistently logs retrieval results",
        "commit_body": "Issue: SPR-13923\n",
        "linked_issues": [
            {
                "issue_id": "18495",
                "issue_title": "PathMatchingResourcePatternResolver should provide consistent logging [SPR-13923]",
                "issue_body": "**[Paul](https://jira.spring.io/secure/ViewProfile.jspa?name=pmv)** opened **[SPR-13923](https://jira.spring.io/browse/SPR-13923?redirect=false)** and commented\n\nIf you provide a pattern such as \"classpath:com/some/company/**/*.xml\", and have the logger set to debug, you get nice output with the list of resources Spring finds:\nhttps://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java#L424\n\nHowever, if you have a pattern such as \"classpath*:someResource.xml\", you get no output of what Spring found - you have to set a breakpoint.\n\nEither a similar log statement should be added here:\nhttps://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java#L311\n\nOr the logging should be moved to somewhere in the parent method that calls each of them: https://github.com/spring-projects/spring-framework/blob/v4.2.4.RELEASE/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java#L268\n\nWe have an issue where different servers are returning elements in different order.  Obviously our code needs to be fixed so order doesn't matter, however, the issue would have been easier to track down if the list of resolved artifacts would have been displayed with DEBUG or TRACE logging enabled.\n\n\n---\n\n**Affects:** 4.2.4\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Paul](https://jira.spring.io/secure/ViewProfile.jspa?name=pmv)** commented\n\nThanks!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a debug log statement to print the resolved classpath location and the resulting resources.  This is a logging enhancement, specifically for debugging purposes, providing more context about the resource resolution process",
            "avg_logprobs": -0.16168131479402867
        }
    },
    {
        "commit_hash": "44c31a6aad26ce2a4e7225e93e6fb26612f07b2c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\t\tsubs.add(sessionId, subsId);\n-\t\t\t\t\t\tthis.accessCache.put(cachedDestination, subs.deepCopy());\n+\t\t\t\t\t\t// Subscription id's may also be populated via getSubscriptions()\n+\t\t\t\t\t\tif (!subs.containsKey(sessionId) || !subs.get(sessionId).contains(subsId)) {\n+\t\t\t\t\t\t\tsubs.add(sessionId, subsId);\n+\t\t\t\t\t\t\tthis.accessCache.put(cachedDestination, subs.deepCopy());\n+\t\t\t\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix duplicate STOMP subscription id issue",
        "commit_body": "Issue: SPR-15543\n",
        "linked_issues": [
            {
                "issue_id": "20102",
                "issue_title": "DefaultSubscriptionRegistry should prevent duplicate subscription id in accessCache [SPR-15543]",
                "issue_body": "**[Bao Tran](https://jira.spring.io/secure/ViewProfile.jspa?name=tran.bao51093)** opened **[SPR-15543](https://jira.spring.io/browse/SPR-15543?redirect=false)** and commented\n\nIn DefaultSubscriptionRegistry, multiple subscriptions on the same session should have unique subscription id's.\nIn DefaultSubscriptionRegistry.addSubscriptionInternal method, there are calls to:\n\n```java\nthis.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);\nthis.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);\n```\n\n* Assume that registerSubscription is called with a message argument.\n* If findSubscriptions method is called with destination argument after addSubscription and before updateAfterNewSubscription, accessCache will contain duplicate subscriptionId for destination - sessionId key.\n* This will lead to a subscriber receives a message twice due to loop in SimpleBrokerMessageHandler.sendMessageToSubscribers\n\n---\n\n**Affects:** 4.3.8\n\n**Issue Links:**\n- #19848 Cannot receive message sometimes with SimpleBrokerMessageHandler\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1427, and commits https://github.com/spring-projects/spring-framework/commit/4fc41eeeb90f9c5cd01f96ec46a1438ce2fbdc0e, https://github.com/spring-projects/spring-framework/commit/b6e252495a70d716179db1e91397190ac2a0aee9, https://github.com/spring-projects/spring-framework/commit/44c31a6aad26ce2a4e7225e93e6fb26612f07b2c, https://github.com/spring-projects/spring-framework/commit/8deec9569c2741c2fc5a78e375765dfb93586f49\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThanks for finding this and identifying the fix!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure that a subscription (`subsId`) for a session (`sessionId`) is not already present before adding it.  Previously, the subscription was always added.  The new `if` statement prevents duplicate entries, potentially improving data integrity and efficiency.  The core change is the addition of a crucial check to avoid redundant entries in the `subs` map, which is likely a set of subscriptions.  This is a defensive programming improvement",
            "avg_logprobs": -0.31941600556069233
        }
    },
    {
        "commit_hash": "44da77513444f8388397f93d057ad1b6187516d3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.web.context.request.async.WebAsyncManager;\n+import org.springframework.web.context.request.async.WebAsyncUtils;\n+\t\t\t// Consistent with CorsFilter, ignore ASYNC dispatches\n+\t\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n+\t\t\tif (asyncManager.hasConcurrentResult()) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "CorsInterceptor skips async dispatch",
        "commit_body": "Closes gh-24223\n",
        "linked_issues": [
            {
                "issue_id": "24223",
                "issue_title": "Ensure CORS processing does not add Vary header twice on async requests",
                "issue_body": "## spring boot version `2.2.2`\r\n## example \r\n\r\n`WebMvcConfigurer`\r\n```\r\nCorsRegistration corsRegistration = registry.addMapping(\"/**\")\r\n                .allowCredentials(true);\r\ncorsRegistration.allowedHeaders(\"*\")\r\n                .maxAge(1800L)\r\n                .allowedMethods(HttpMethod.GET.name(),\r\n                        HttpMethod.POST.name(),\r\n                        HttpMethod.PUT.name(),\r\n                        HttpMethod.OPTIONS.name(),\r\n                        HttpMethod.DELETE.name())\r\n                .exposedHeaders(\"Content-Length\");\r\n```\r\n`controller`\r\n```\r\n@RequestMapping(\"/test)\r\n@RestController\r\npublic class ExampleController {\r\n    @GetMapping\r\n    public CompletableFuture<T> test() {\r\n        // do something\r\n    }\r\n}\r\n```\r\n\r\n`reponse headers`\r\n```\r\nVary | Origin\r\nVary | Access-Control-Request-Method\r\nVary | Access-Control-Request-Headers\r\nVary | Origin\r\nVary | Access-Control-Request-Method\r\nVary | Access-Control-Request-Headers\r\n```\r\n\r\nRef #24222 ",
                "issue_state": "closed",
                "issue_comment": [
                    "@blackstorm Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=24223)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=24223) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@blackstorm Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=24223)!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check to determine if the current request is part of an asynchronous operation.  If a concurrent result exists in the `WebAsyncManager`, the method immediately returns `true`.  This change likely avoids unnecessary processing for asynchronous requests, mirroring the behavior of the `CorsFilter`",
            "avg_logprobs": -0.1897420398259567
        }
    },
    {
        "commit_hash": "45a629e20a4f184769808d2958b6ca17f9333334",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/adapter/standard/ConvertingEncoderDecoderSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (applicationContext != null && applicationContext instanceof ConfigurableApplicationContext) {\n+\t\tif (applicationContext instanceof ConfigurableApplicationContext) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary check in ConvertingEncoderDecoderSupport",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant null check.  The original code checked if `applicationContext` was not null *and* if it was an instance of `ConfigurableApplicationContext`.  The updated code simplifies this to just checking if `applicationContext` is an instance of `ConfigurableApplicationContext`.  This assumes that `applicationContext` will never be null if it's going to be cast to `ConfigurableApplicationContext`",
            "avg_logprobs": -0.14513016869040096
        }
    },
    {
        "commit_hash": "460947651ae4c58d31386a0a14396c273b287119",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/DefaultPathContainer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tString value = input.substring(index + 1);\n-\t\t\t\tfor (String v : StringUtils.commaDelimitedListToStringArray(value)) {\n-\t\t\t\t\tname = StringUtils.uriDecode(name, charset);\n-\t\t\t\t\tif (StringUtils.hasText(name)) {\n+\t\t\t\tname = StringUtils.uriDecode(name, charset);\n+\t\t\t\tif (StringUtils.hasText(name)) {\n+\t\t\t\t\tString value = input.substring(index + 1);\n+\t\t\t\t\tfor (String v : StringUtils.commaDelimitedListToStringArray(value)) {",
        "change_count": 8,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Minor refactoring in DefaultPathContainer",
        "commit_body": "Closes gh-27204\n",
        "linked_issues": [
            {
                "issue_id": "27204",
                "issue_title": "DefaultPathContainer#parsePathParamValues should decode and test name once in outer loop",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://spring.io/security-policy !!!\r\n-->\r\n**Affects:** 5.3.8\r\n\r\n---\r\n<!--\r\nThanks for taking the time to create an issue. Please read the following:\r\n\r\n- Questions should be asked on Stack Overflow.\r\n- For bugs, specify affected versions and explain what you are trying to do.\r\n- For enhancements, provide context and describe the problem.\r\n\r\nIssue or Pull Request? Create only one, not both. GitHub treats them as the same.\r\nIf unsure, start with an issue, and if you submit a pull request later, the\r\nissue will be closed as superseded.\r\n-->\r\nIn method parsePathParamValues, line 164: should  name be decoded and tested once in outer loop?\r\n```\r\nprivate static void parsePathParamValues(String input, Charset charset, MultiValueMap<String, String> output) {\r\n  if (StringUtils.hasText(input)) {\r\n  \tint index = input.indexOf('=');\r\n  \tif (index != -1) {\r\n  \t  String name = input.substring(0, index);\r\n  \t  String value = input.substring(index + 1);\r\n  \t  for (String v : StringUtils.commaDelimitedListToStringArray(value)) {\r\n  \t  \r\n  \t  \t// should `name` be decoded and tested once in outer loop?\r\n  \t  \tname = StringUtils.uriDecode(name, charset);\r\n  \t  \tif (StringUtils.hasText(name)) {\r\n  \t  \t  output.add(name, StringUtils.uriDecode(v, charset));\r\n  \t  \t}\r\n  \t  }\r\n  \t}\r\n  \telse {\r\n  \t  String name = StringUtils.uriDecode(input, charset);\r\n  \t  if (StringUtils.hasText(name)) {\r\n  \t  \toutput.add(input, \"\");\r\n  \t  }\r\n  \t}\r\n  }\r\n}\r\n```",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change reorders the `String value` initialization and the loop.  Originally, `value` was extracted *before* the `if` statement, and the loop iterated over it.  Now, `value` is extracted *inside* the `if` block, after the `name` is decoded.  This change likely improves efficiency by avoiding unnecessary decoding and string splitting if `name` is empty or invalid",
            "avg_logprobs": -0.35227474212646487
        }
    },
    {
        "commit_hash": "46b7cd54a154df16d4c93d1e6c2e44bbc8c74399",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/context/support/SpringBeanAutowiringSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\tlogger.debug(\"Current WebApplicationContext is not available for processing of \" +\n+\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t\tlogger.warn(\"Current WebApplicationContext is not available for processing of \" +\n-\t\t\t\t\t\t\"Make sure this class gets constructed in a Spring web application. Proceeding without injection.\");\n+\t\t\t\t\t\t\"Make sure this class gets constructed in a Spring web application after the\" +\n+\t\t\t\t\t\t\"Spring WebApplicationContext has been initialized. Proceeding without injection.\");",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log missing web application context at warn level (instead of debug)",
        "commit_body": "Closes gh-26925\n",
        "linked_issues": [
            {
                "issue_id": "26925",
                "issue_title": "SpringBeanAutowiringSupport should log at warn level when autowiring fails",
                "issue_body": "I recently upgraded to a newer wildfly version (20-->23) and wildfly now init's webservices very early, before spring initilization is kicked off, so the autowiring in SpringBeanAutowiringSupport fails.\r\n\r\nObviously, that is not a spring issue, but these issues would be WAY easier to find if the failure to wire was at least a Warn level log statement.  It appears that the logging in the processInjectionBasedOnCurrentContext method is debug, as it is designed to be called from other places than the constructor itself, but I think there should be a warn or error level log of the failure to wire in the constructor, to lead people to this class when their are external factors that cause this autowire to work differently.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code changed the logging level from `debug` to `warn` when the `WebApplicationContext` is unavailable.  It also improved the log message to include a more specific explanation about the expected initialization order of the `WebApplicationContext`",
            "avg_logprobs": -0.2767903804779053
        }
    },
    {
        "commit_hash": "4751769a7c984f9bce6dd095e6c9324c8fce150e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tMethod[] methods = getMethods(type);\n-\t\t\tfor (Method method : methods) {\n+\t\t\tfor (Method method : getMethods(type)) {\n-\t\t\t\tMethod[] methods = getMethods(ifc);\n-\t\t\t\tfor (Method method : methods) {\n+\t\t\t\tfor (Method method : getMethods(ifc)) {\n-\t\t\tMethod[] methods = getMethods(type);\n-\t\t\tfor (Method method : methods) {\n+\t\t\tfor (Method method : getMethods(type)) {\n-\t * static methods sand non-user-declared methods on the {@link Object} base class.\n+\t * static methods and non-user-declared methods on the {@link Object} base class.",
        "change_count": 9,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes redundant method declarations and initialization.  The original code had multiple `Method[] methods = getMethods(...)` and nested loops.  The revised code uses the `getMethods` call directly within the loop, eliminating the redundant variable assignments and improving code efficiency and readability.  The comment clarifying the exclusion of static methods and non-user-declared methods on `Object` is also present in the revised code",
            "avg_logprobs": -0.3085351322972497
        }
    },
    {
        "commit_hash": "475c4d4425b2170c4a0f19d5bd39b70e752e38a1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\twhile (j < statement.length && '}' != statement[j]) {\n+\t\t\t\t\twhile (j < statement.length && statement[j] != '}') {\n-\t\t\t\t\t\tif (':' == statement[j] || '{' == statement[j]) {\n+\t\t\t\t\t\tif (statement[j] == ':' || statement[j] == '{') {\n-\t\t\t\t\t\ttotalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter);\n+\t\t\t\t\t\ttotalParameterCount = addNamedParameter(\n+\t\t\t\t\t\t\t\tparameterList, totalParameterCount, escapes, i, j + 1, parameter);\n-\t\t\t\t\t\ttotalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter);\n+\t\t\t\t\t\ttotalParameterCount = addNamedParameter(\n+\t\t\t\t\t\t\t\tparameterList, totalParameterCount, escapes, i, j, parameter);",
        "change_count": 10,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `'{' != statement[j]` and `':' == statement[j]` with `statement[j] != '}'` and `statement[j] == ':'`, respectively.  This change uses the more concise and idiomatic Java comparison operator `!=` and `==` for character comparisons within the `while` loop and `if` statement.  It also adds extra line breaks and indentation for improved readability",
            "avg_logprobs": -0.20939836502075196
        }
    },
    {
        "commit_hash": "47a3a5c97011a4e147db9a4cab3e85c8486fcec7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t// 0 - not subscribed, 1 - subscribed, 2 - cancelled, 3 - cancelled via connector (before subscribe)\n+\t// 0 - not subscribed, 1 - subscribed, 2 - cancelled via connector (before subscribe)\n-\t\t\t\t\t// https://github.com/reactor/reactor-netty/issues/503\n-\t\t\t\t\t// FluxReceive rejects multiple subscribers, but not after a cancel().\n-\t\t\t\t\t// Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n-\t\t\t\t\t// So we need to reject once in cancelled state.\n-\t\t\t\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\t\t\t\"The client response body can only be consumed once.\");\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (this.state.get() == 3) {\n-\t\t\t\t.doOnCancel(() -> this.state.compareAndSet(1, 2))\n-\t\tif (mayHaveBody(method) && this.state.compareAndSet(0, 3)) {\n+\t\tif (mayHaveBody(method) && this.state.compareAndSet(0, 2)) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Switch to Reactor 2020.0.0 snapshots",
        "commit_body": "See gh-25373\n",
        "linked_issues": [
            {
                "issue_id": "25373",
                "issue_title": "Upgrade to Reactor 2020.0.0-M2",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes the `state` value `3` (cancelled via connector *before* subscribe) and the associated `IllegalStateException` check.  Previously, if the response was cancelled before subscription, a subsequent attempt to subscribe would throw an exception.  Now, the code only checks for cancellation *before* subscription, and if it's in that state, it sets the state to `2` (cancelled via connector)",
            "avg_logprobs": -0.423290901184082
        }
    },
    {
        "commit_hash": "47ff92873bc35345a0e0a743be4939527a27f896",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!message.contains(parameter.getExecutable().toGenericString())) {\n+\t\tif (message != null && !message.contains(parameter.getExecutable().toGenericString())) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add null check",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for the `message` variable before checking if it contains the `parameter.getExecutable().toGenericString()`.  Previously, attempting to call `message.contains(...)` on a null `message` would have thrown a `NullPointerException`.  The addition of `message != null` prevents this exception",
            "avg_logprobs": -0.06801585874695709
        }
    },
    {
        "commit_hash": "49356b2c0f498ae6580c1ef7d7ac0787629de7c8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/SimpleIdGenerator.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "- * A simple {@link IdGenerator} that starts at 1 and increments by 1 with each call.\n+ * A simple {@link IdGenerator} that starts at 1, increments up to\n+ * {@link Long#MAX_VALUE}, and then rolls over.\n-\tprivate final AtomicLong mostSigBits = new AtomicLong(0);\n-\n-\t\tlong leastSigBits = this.leastSigBits.incrementAndGet();\n-\t\tif (leastSigBits == 0) {\n-\t\t\tthis.mostSigBits.incrementAndGet();\n-\t\t}\n-\t\treturn new UUID(this.mostSigBits.get(), leastSigBits);\n+\t\treturn new UUID(0, this.leastSigBits.incrementAndGet());",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SimpleIdGenerator rolls over at Long.MAX_VALUE",
        "commit_body": "Closes gh-25485\n",
        "linked_issues": [
            {
                "issue_id": "25485",
                "issue_title": "SimpleIdGenerator is not thread safe, neither it is documented to be",
                "issue_body": "I have a small miss-understanding about `SimpleIdGenerator`, that is a fairly trivial class:\r\n\r\n```\r\npublic class SimpleIdGenerator implements IdGenerator {\r\n\r\n\tprivate final AtomicLong mostSigBits = new AtomicLong(0);\r\n\r\n\tprivate final AtomicLong leastSigBits = new AtomicLong(0);\r\n\r\n\r\n\t@Override\r\n\tpublic UUID generateId() {\r\n\t\tlong leastSigBits = this.leastSigBits.incrementAndGet();\r\n\t\tif (leastSigBits == 0) {\r\n\t\t\tthis.mostSigBits.incrementAndGet();\r\n\t\t}\r\n\t\treturn new UUID(this.mostSigBits.get(), leastSigBits);\r\n\t}\r\n\r\n}\r\n```\r\n\r\nThe presence of `AtomicLong` hints into the fact that this is a thread-safe continuous incremented UUID, but it's not the case:\r\n\r\n```\r\nlong leastSigBits = this.leastSigBits.incrementAndGet();\r\nif (leastSigBits == 0) {\r\n```\r\n\r\nFor the sake of the discussion let's suppose that currently `leastSigBits` holds a `-1` (it has been incremented quite a lot, yes). \r\n\r\n\r\n`ThreadA` does `long leastSigBits = this.leastSigBits.incrementAndGet();`, so it puts the value into `0` (`-1 + 1 = 0`); but _before_ it does the check `if (leastSigBits == 0)`, `ThreadB` did `long leastSigBits = this.leastSigBits.incrementAndGet();` too, now on a value that is `0`, so it put the value in `1`. `ThreadA` does the check and sees a value of `1`, that `if` statement is not entered and a such a duplicate `UUID`.\r\n\r\nThis is very far stretched and I have doubts it has ever impacted any users as for this to happen they would need to generate all the `long` range of IDs, which is highly highly improbable. Still, this code is wrong.\r\n\r\nIf this is suppose to provide _thread-safe_ variant : \r\n\r\n   - document it as such\r\n  - fix the code\r\n\r\nif this isn't supposed to be thread safe, simply dropping the un-necessary `AtomicLong` (with it's `volatile` overhead) is going to be a big performance gain.\r\n\r\nEither way, I would be more than glad to fix this, if someone tells me the path I should be taking. Thank you. ",
                "issue_state": "closed",
                "issue_comment": [
                    "Can I fix this .",
                    "> ThreadA does the check and sees a value of 1\r\n\r\nWhy would that be? The value of incrementAndGet is saved in a local variable. ",
                    "@rstoyanchev I should have had my coffee before posting this. you're right and I am wrong.\r\n\r\nEither way there is a race here.\r\n\r\n`ThreadA` does this:\r\n\r\n```\r\nlong leastSigBits = this.leastSigBits.incrementAndGet();\r\n\t\tif (leastSigBits == 0) {\r\n\t\t\tthis.mostSigBits.incrementAndGet();\r\n\t\t}\r\n```\r\n\r\nit sets `long leastSigBits` as `0`, enters the `if` statement, but does not do `this.mostSigBits.incrementAndGet();` just yet. `ThreadB` acts at the same time; it sets its local `long leastSigBits` to `1`, does not enter the `if statement` and does `return new UUID(this.mostSigBits.get(), leastSigBits);`. `this.mostSigBits.get() == 0` and  `leastSigBits == 1`; as such it returns an UUID that was already returned. \r\n\r\n",
                    "> > ThreadA does the check and sees a value of 1\r\n> \r\n> Why would that be? The value of incrementAndGet is saved in a local variable.\r\n\r\nThe result of `this.mostSigBits.incrementAndGet()` should be saved in a local variable too and instead of `this.mostSigBits.get()` later.",
                    "> @rstoyanchev I should have had my coffee before posting this. you're right and I am wrong.\r\n> \r\n> Either way there is a race here.\r\n> \r\n> `ThreadA` does this:\r\n> \r\n> ```\r\n> long leastSigBits = this.leastSigBits.incrementAndGet();\r\n> \t\tif (leastSigBits == 0) {\r\n> \t\t\tthis.mostSigBits.incrementAndGet();\r\n> \t\t}\r\n> ```\r\n> \r\n> it sets `long leastSigBits` as `0`, enters the `if` statement, but does not do `this.mostSigBits.incrementAndGet();` just yet. `ThreadB` acts at the same time; it sets its local `long leastSigBits` to `1`, does not enter the `if statement` and does `return new UUID(this.mostSigBits.get(), leastSigBits);`. `this.mostSigBits.get() == 0` and `leastSigBits == 1`; as such it returns an UUID that was already returned.\r\n\r\n@wind57  I agree.",
                    "> > @rstoyanchev I should have had my coffee before posting this. you're right and I am wrong.\r\n> > Either way there is a race here.\r\n> > `ThreadA` does this:\r\n> > ```\r\n> > long leastSigBits = this.leastSigBits.incrementAndGet();\r\n> > \t\tif (leastSigBits == 0) {\r\n> > \t\t\tthis.mostSigBits.incrementAndGet();\r\n> > \t\t}\r\n> > ```\r\n> > \r\n> > \r\n> > it sets `long leastSigBits` as `0`, enters the `if` statement, but does not do `this.mostSigBits.incrementAndGet();` just yet. `ThreadB` acts at the same time; it sets its local `long leastSigBits` to `1`, does not enter the `if statement` and does `return new UUID(this.mostSigBits.get(), leastSigBits);`. `this.mostSigBits.get() == 0` and `leastSigBits == 1`; as such it returns an UUID that was already returned.\r\n> \r\n> @wind57 I agree.\r\n\r\nI prepared a unit test to show the issue:\r\n\r\n```java\r\nclass SimpleIdGeneratorTest {\r\n\r\n\tprivate final AtomicLong mostSigBits = new AtomicLong(0);\r\n\tprivate final AtomicLong leastSigBits = new AtomicLong(-1);\r\n\r\n\tSet<UUID> ids = new HashSet<>();\r\n\r\n\t@Test\r\n\tvoid generateIdTest() throws InterruptedException {\r\n\r\n\t\tids.add(new UUID(0, 1));\r\n\t\tExecutorService executorService = Executors.newFixedThreadPool(2);\r\n\t\texecutorService.execute(() -> ids.add(generateId()));\r\n\t\texecutorService.execute(() -> ids.add(generateId()));\r\n\r\n\t\tThread.sleep(200);\r\n\t\tassertTrue(ids.contains(new UUID(0, 1)));\r\n\t\tassertTrue(ids.contains(new UUID(1, 0)));\r\n\r\n                 // This UUID is missing, instead UUID(mostSigBits = 0, leastSigBits = 1) got created twice\r\n\t\tassertFalse(ids.contains(new UUID(1, 1)));\r\n\t}\r\n\r\n\tpublic UUID generateId() {\r\n\t\tlong leastSigBits = this.leastSigBits.incrementAndGet();\r\n\t\tif (leastSigBits == 0) {\r\n\t\t\ttry {\r\n\t\t\t\tThread.sleep(100);\r\n\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\tthis.mostSigBits.incrementAndGet();\r\n\t\t}\r\n\t\treturn new UUID(this.mostSigBits.get(), leastSigBits);\r\n\t}\r\n}\r\n```\r\n\r\nI guess, to be truly thread safe, we would need to introduce a synchronized block as shown below. Please correct me if I'm wrong.\r\n\r\n\r\n```java\r\nclass SimpleIdGeneratorTest {\r\n\r\n\tprivate final AtomicLong mostSigBits = new AtomicLong(0);\r\n\tprivate final AtomicLong leastSigBits = new AtomicLong(-1);\r\n\r\n\tSet<UUID> ids = new HashSet<>();\r\n\r\n\t@Test\r\n\tvoid generateIdTest() throws InterruptedException {\r\n\r\n\t\tids.add(new UUID(0, 1));\r\n\t\tExecutorService executorService = Executors.newFixedThreadPool(2);\r\n\t\texecutorService.execute(() -> ids.add(generateId()));\r\n\t\texecutorService.execute(() -> ids.add(generateId()));\r\n\r\n\t\tThread.sleep(200);\r\n\t\tassertTrue(ids.contains(new UUID(0, 1)));\r\n\t\tassertTrue(ids.contains(new UUID(1, 0)));\r\n\t\tassertTrue(ids.contains(new UUID(1, 1)));\r\n\t}\r\n\r\n\tpublic UUID generateId() {\r\n\t\tlong leastSigBits = this.leastSigBits.incrementAndGet();\r\n\t\tsynchronized (this) {\r\n\t\t\tif (leastSigBits == 0) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tThread.sleep(100);\r\n\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t\tthis.mostSigBits.incrementAndGet();\r\n\t\t\t}\r\n\t\t\treturn new UUID(this.mostSigBits.get(), leastSigBits);\r\n\t\t}\r\n\t}\r\n}\r\n``` ",
                    "@puhlerblet usually a unit test proves very little in case of thread safety, though, I admit, in this case it is fairly trivial to prove the point. Otherwise, you could also look into [this](https://openjdk.java.net/projects/code-tools/jcstress/) tool, that I usually use. It does instruction re-ordering that can prove things, see more [here](https://stackoverflow.com/questions/56273136/xxstresslcm-xxstressgcm-options-for-jvm) for example.\r\n\r\nAlso _both_ `synchronized` _and_ `AtomicLong`? Under contention, an intrinsic lock is \"inflated\" and when a GC needs to happen - it needs to deflate that, which is a process that takes time (and easily provable with `JMH`). I would suggest a `ReentrantLock`, instead.\r\n\r\nBut the problem is a bit more subtle, it seems to me. Keep in mind that for this problem to be observed, we need to go through the entire range of positive and negative values of a long. Let's take the easy case:\r\n\r\n```\r\n Long.MAX_VALUE == 9223372036854775807\r\n```\r\n\r\nSo there are `9223372036854775807` positive possibilities in a long. We now look of how big is an `UUID`:\r\n\r\n```\r\njava.util.UUID object internals:\r\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\r\n      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)\r\n      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\r\n      8     4        (object header)                           2c 19 17 00 (00101100 00011001 00010111 00000000) (1513772)\r\n     12     4        (alignment/padding gap)\r\n     16     8   long UUID.mostSigBits                          0\r\n     24     8   long UUID.leastSigBits                          0\r\nInstance size: 32 bytes\r\nSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total\r\n```\r\n\r\ntake `32 bytes` multiply by `9223372036854775807` and you will need that much space, just for the `UUID`, just for positive part of the least significant bits, if you want to cover the entire range.\r\n\r\nAnd if I now look at the documentation of the class itself:\r\n\r\n> A simple IdGenerator that starts at 1 and increments by 1 with each call.\r\n\r\nI could say that there is no need for two `AtomicLong` as, realistically, no one will ever hit so many IDs.",
                    "@wind57 since i am quite inexperienced in dealing with concurrency I really appreciate your input. Your assumption, that no one will ever hit so many IDs sounds reasonable. ",
                    "@rstoyanchev what do you think about this one? ",
                    "@wind57 indeed every time `leastSigBits` rolls over, some id's may be based on the current rather than on the next `mostSigBits` value which in practice means that some id's may be issued more than once, but that would only happen once in a very long while and the duplicates would have been last issued a very long time ago\r\n\r\nI think it's simply not worth optimizing and we can just update the docs to say that uniqueness is not fully guaranteed and that on occasion, after every `Long.MAX_VALUE` number of id's are issued, there may be repeated ones for a short period. If that's an issue for some reason then don't use this generator.\r\n\r\nThoughts? /cc @garyrussell @artembilan\r\n\r\n",
                    "This is by the way one alternative I thought of but again I'm not sure it's necessary:\r\n```java\r\npublic class SimpleIdGenerator implements IdGenerator {\r\n\r\n\tprivate final AtomicLong mostSigBits = new AtomicLong(0);\r\n\r\n\tprivate final AtomicLong leastSigBits = new AtomicLong(0);\r\n\r\n\tprivate final AtomicLong lastMostSigBits = new AtomicLong(-1);\r\n\r\n\r\n\t@Override\r\n\tpublic UUID generateId() {\r\n\t\tlong leastSigBits = this.leastSigBits.incrementAndGet();\r\n\t\tif (leastSigBits == 0) {\r\n\t\t\tthis.mostSigBits.incrementAndGet();\r\n\t\t}\r\n\t\telse if (leastSigBits == Long.MAX_VALUE - 10000) {\r\n\t\t\tthis.lastMostSigBits.incrementAndGet();\r\n\t\t}\r\n\t\telse if (leastSigBits < 10000) {\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (!this.mostSigBits.equals(this.lastMostSigBits)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new UUID(this.mostSigBits.get(), leastSigBits);\r\n\t}\r\n\r\n}\r\n```",
                    "Bear in mind that this generator is pretty much useless in any environment that persists the ID in a DB and/or a multi-instance application.\r\n\r\nNot only does the problem (potentially) occur after `Long.MAX_VALUE` allocations, but those allocations must have occurred in the same JVM.\r\n\r\nThis generator was provided long ago for a very specific use case where the IDs were not persisted and `UUID.randomUUID()` was found to be too expensive for the ID allocation rate.\r\n\r\nSo, I would say documentation should be enough.\r\n\r\nIf performance is really an issue, consider using the `AlternativeJdkIdGenerator` instead.",
                    "Thanks @garyrussell those will be good clarifications. For same JVM, not persisted, and reasonably close to unique. If those trade-offs are okay you'll probably get better performance than `AlternativeJDkIdGenerator`.",
                    " - I agree on the part about documentation.\r\n\r\n - I disagree on the implementation prototype, though. Why not simply use a _single_ `AtomicLong` and specify in the documentation that it supports unique values up to `Long.MAX_VALUE` and then it will simply overflow? ",
                    ">  and specify in the documentation that it supports unique values up to Long.MAX_VALUE and then it will simply overflow\r\n\r\nThat's an option I guess, make it more official that after Long.MAX_VALUE it won't be fully unique. If that is an issue to begin with then it's the wrong generator to use one way or another. @garyrussell you agree with that?",
                    "Yes, I agree; users are always able to define their own implementation if they are not happy with this one."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change in `SimpleIdGenerator` modifies the way IDs are generated.  The original implementation used a `AtomicLong` to track the most and least significant bits of a UUID, incrementing both sequentially.  The new implementation simplifies this by only incrementing the least significant bits.  Crucially, it now wraps around to 0 after reaching `Long.MAX_VALUE`, ensuring that the generator doesn't overflow",
            "avg_logprobs": -0.2567129135131836
        }
    },
    {
        "commit_hash": "49c4d310b51ac0552e036348fc1c1dbbc2b0589f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/PropertyEditorRegistrySupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\tif (editor != null) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n+\t\t\t\t\t\tif (editor != null) {\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish",
        "commit_body": "See gh-27799\n",
        "linked_issues": [
            {
                "issue_id": "27799",
                "issue_title": "Polish",
                "issue_body": "This PR polishes a bit.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes unnecessary indentation.  The `if` statement's block was previously indented, but the change removes that indentation, making the code more concise and readable without changing its functionality.  No change to the conditional logic itself",
            "avg_logprobs": -0.28831084569295246
        }
    },
    {
        "commit_hash": "4a81f2c904ef72ec80a043cb9f9b1d9ab2a390c5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/multipart/support/StandardServletMultipartResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t// To be on the safe side: explicitly delete the parts,\n-\t\t\t// but only actual file parts (for Resin compatibility)\n+\n-\t\t\t\t\tif (request.getFile(part.getName()) != null) {\n-\t\t\t\t\t\tpart.delete();\n-\t\t\t\t\t}\n+\t\t\t\t\tpart.delete();",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove HTTP parts workaround for Resin",
        "commit_body": "A workaround was added for the Resin Servlet container in gh-13937.\nThis avoids attempting to delete parts that are not named, because the\n`part.delete()` call would fail for non-file entries. This can be\nproblematic for files that are unnamed as they might not be removed by\nthe Framework.\n\nThis commit removes this workaround as Resin is not supported anymore.\n\nFixes gh-33511\n",
        "linked_issues": [
            {
                "issue_id": "33511",
                "issue_title": "parts w/o filename in `Content-Disposition` header are not cleaned from temp folder (skipped by `StandardServletMultipartResolver`)",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://spring.io/security-policy !!!\r\n-->\r\n**Affects:** 6.1.12 (but can not say since when exactly, older versions are probably also affected) + Jetty 12.0.12\r\n\r\nParts w/o filename in content disposition header are missing in `AbstractMultipartHttpServletRequest.getMultiFileMap()`. Because of this `part.delete()` is skipped in the resolver. \r\nThe relevant logic to filter out such parts is in https://github.com/spring-projects/spring-framework/blob/eff19ec9721381344f0eeacdebfda9da8d8bef07/spring-web/src/main/java/org/springframework/web/multipart/support/StandardMultipartHttpServletRequest.java#L101\r\n\r\nthe logic to ignore parts which are not part of the filemap is here: https://github.com/spring-projects/spring-framework/blob/eff19ec9721381344f0eeacdebfda9da8d8bef07/spring-web/src/main/java/org/springframework/web/multipart/support/StandardServletMultipartResolver.java#L123\r\n\r\nShould we cleanup those parts by ourself? Not sure whether there are other dependencies (why it should not be part of filemap e.g.) but our fix is currently to overwrite the `StandardServletMultipartResolver` and delete the part nevertheless its contained or not in the filemap)",
                "issue_state": "closed",
                "issue_comment": []
            },
            {
                "issue_id": "13937",
                "issue_title": "org.springframework.web.multipart.support.StandardServletMultipartResolver.cleanupMultipart causes an IOException on Resin [SPR-9299]",
                "issue_body": "**[Ralph Schaer](https://jira.spring.io/secure/ViewProfile.jspa?name=ralsa)** opened **[SPR-9299](https://jira.spring.io/browse/SPR-9299?redirect=false)** and commented\n\nTesting the StandardServletMultipartResolver on Resin 4.0.27 with this form.\n\n\\<form action=\"uploadTest\" method=\"post\" enctype=\"multipart/form-data\">\n\\<input type=\"hidden\" name=\"hiddenParameter\" value=\"theHiddenValue\" />\n...\n\\</form>\n\nThe resolver tries to cleanup the parts with the cleanupMultipart method\nby calling part.delete();\n\nResin throws this exception\n\n8:08:25.093 [resin-port-8080-19] WARN  o.s.w.m.s.StandardServletMultipartResolver - Failed to perform cleanup of multipart items\nava.io.IOException: Part.delete() is not applicable to part 'hiddenParameter':'theHiddenValue'\nat com.caucho.server.http.AbstractCauchoRequest$PartImpl.delete(AbstractauchoRequest.java:1086) ~[resin.jar:4.0.27]       \nat org.springframework.web.multipart.support.StandardServletMultipartResolver.cleanupMultipart(StandardServletMultipartResolver.java:65) ~[spring-web-3.1.1.RELEASE.jar:3.1.1.RELEASE]\n\nNot sure why Resin not simply ignores the call to delete() for this kind of parts, as all the other servers (Tomcat, Jetty) do.\n\n\n\n---\n\n**Affects:** 3.1.1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9fcb5781873417e3e9ce8f2a932d3de4649a26c4, https://github.com/spring-projects/spring-framework/commit/7ea85a959c810c1689fc04b8d0c2bd17e5fe6e08\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant check for whether a file part exists before deleting it.  Previously, the code checked if a file part existed using `request.getFile(part.getName())`, and only deleted the part if it did.  The updated code directly deletes the part (`part.delete()`) without the existence check.  This simplifies the logic and likely improves performance by avoiding the extra method call",
            "avg_logprobs": -0.21273116605827608
        }
    },
    {
        "commit_hash": "4c964473b19590780b9ddad34c832f0b2b4f47d8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tboolean newJarFile = false;\n+\t\tboolean closeJarFile;\n+\t\t\tcloseJarFile = !jarCon.getUseCaches();\n-\t\t\t\tnewJarFile = true;\n+\t\t\t\tcloseJarFile = true;\n-\t\t\t// Close jar file, but only if freshly obtained -\n-\t\t\t// not from JarURLConnection, which might cache the file reference.\n-\t\t\tif (newJarFile) {\n+\t\t\tif (closeJarFile) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensively close jar files from non-cached JarURLConnections",
        "commit_body": "Issue: SPR-6295\n",
        "linked_issues": [
            {
                "issue_id": "10961",
                "issue_title": "PathMatchingResourcePatternResolver should close jar file from JarURLConnection if not cached [SPR-6295]",
                "issue_body": "**[Stoehr Sukachevin](https://jira.spring.io/secure/ViewProfile.jspa?name=stoehr)** opened **[SPR-6295](https://jira.spring.io/browse/SPR-6295?redirect=false)** and commented\n\nThe \"org.springframework.core.io.support.PathMatchingResourcePatternResolver#doFindPathMatchingJarResources(Resource, String)\" method does not close a Jar file that it opens if it gets it from a JarURLConnection directly.  The reason that is given in the code as to why the Jar file is not closed from a JarURLConnection is because the JarURLConnection \"might cache the file reference\".  However, \"setUseCaches(false)\" is called on the JarURLConnection instance when it is first obtained presumably because we do not want any caching done.  (And internally, at least for the Sun JVM version of the JarURLConnection subclass [sun.net.www.protocol.jar.JarURLConnection], if \"useCaches\" is \"false\", then the Jar file is closed after it is no longer needed [e.g., when the input stream from the JarURLConnection instance is closed].)\n\nThe net result of this is that the Jar file will NOT be closed for an undetermined\nlength of time (until the Jar file's \"finalize()\" method is called by the GC), and in Windows, the Jar file will most likely have an open-file lock on it unnecessarily after this method completes.\n\nThe solution is to simply close the Jar file unconditionally at the end of the method.  (Curently, it is only closed when the \"newJarFile\" flag is set, which is not the case when the Jar file is retrieved from a JarURLConnection directly.)\n\n---\n\n**Affects:** 2.5.6\n\n**Issue Links:**\n- #17521 Regression: DLL handled as classpath resource\n- #16711 PathMatchingResourcePatternResolver cannot search for \"classpath*\" patterns in a jar file roots\n- #18260 PathMatchingResourcePatternResolver does not consider manifest based classpaths\n- #18657 PathMatchingResourcePatternResolver should enforce consistent alphabetical sorting of directory content\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/4c964473b19590780b9ddad34c832f0b2b4f47d8\n\n1 votes, 4 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis issue has been resolved through a selective bulk update, as part of a larger effort to better manage unresolved issues. To qualify for the update, the issue was either created before Spring 3.0 or affects a version older than Spring 3.0 and is not a bug.\n\nThere is a good chance the request was made obsolete, or at least partly outdated, by changes in later versions of Spring including deprecations. It is also possible it didn't get enough traction or we didn't have enough time to address it. One way or another, we didn't get to it.\n\nIf you believe the issue, or some aspects of it, are still relevant and worth pursuing at present you may re-open this issue or create a new one with a more up-to-date description.\n\nWe thank you for your contributions and encourage you to become familiar with the [current process](https://github.com/SpringSource/spring-framework/wiki/The-Lifecycle-of-an-Issue) of managing Spring Framework JIRA issues that has been in use for over a year.\n",
                    "**[Shabin S](https://jira.spring.io/secure/ViewProfile.jspa?name=shabin.s.8780@gmail.com)** commented\n\nThe \"org.springframework.core.io.support.PathMatchingResourcePatternResolver#doFindPathMatchingJarResources(Resource, String)\" method still(4.2.4-RELEASE) does not close a Jar file that it opens if it gets it from a JarURLConnection directly. As mentioned in the main description, the reason that is given in the code as to why the Jar file is not closed from a JarURLConnection is because the JarURLConnection \"might cache the file reference\". However, \"setUseCaches(true)\" is called on the JarURLConnection instance only if  con.getClass().getSimpleName().startsWith(\"JNLP\") written inside ResourceUtils.useCachesIfNecessary(jarCon) method. So if the file is not cached in other cases, why is it not closed?\nThe newJarFile flag(which is used for checking whether to close the file or not) can be modified to set to true if jarCon.getUseCaches() is false so that the file will be closed if no caching is to be done.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs of 4.3, we defensively close jar files from non-cached JarURLConnections. We'll see during the 4.3 release candidate whether that causes a regression in any common environment...\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how a JAR file is handled when obtaining resources.  The original code had a `newJarFile` flag to determine if the file was freshly opened.  The change removes this flag and introduces a `closeJarFile` flag.  Crucially, the `closeJarFile` flag is now directly set based on whether the `JarURLConnection` caches the file reference (`!jarCon.getUseCaches()`)",
            "avg_logprobs": -0.2766938018798828
        }
    },
    {
        "commit_hash": "4d3c3056edc983c1afe13d055aeb443bd96bd473",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceHttpRequestHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-import org.springframework.web.HttpMediaTypeNotAcceptableException;\n-import org.springframework.web.accept.ContentNegotiationManagerFactoryBean;\n-\t * Configure a {@code ContentNegotiationManager} to determine the media types\n-\t * for resources being served. If the manager contains a path\n-\t * extension strategy it will be used to look up the file extension\n-\t * of resources being served via\n-\t * {@link PathExtensionContentNegotiationStrategy#getMediaTypeForResource\n-\t * getMediaTypeForResource}. If that fails the check is then expanded\n-\t * to use any configured content negotiation strategy against the request.\n-\t * <p>By default a {@link ContentNegotiationManagerFactoryBean} with default\n-\t * settings is used to create the manager. See the Javadoc of\n-\t * {@code ContentNegotiationManagerFactoryBean} for details\n-\t * @param contentNegotiationManager the manager to use\n+\t * Configure a {@code ContentNegotiationManager} to help determine the\n+\t * media types for resources being served. If the manager contains a path\n+\t * extension strategy it will be checked for registered file extension.\n+\t * @param contentNegotiationManager the manager in use\n-\t * Return the specified content negotiation manager.\n+\t * Return the configured content negotiation manager.\n-\t * to it. This implementation first tries to determine the MediaType based\n-\t * strictly on the file extension of the Resource via\n-\t * {@link PathExtensionContentNegotiationStrategy#getMediaTypeForResource}\n-\t * and then expands to check against the request via\n-\t * {@link ContentNegotiationManager#resolveMediaTypes}.\n+\t * to it. This implementation tries to determine the MediaType based on the\n+\t * file extension of the Resource via\n+\t * {@link ServletPathExtensionContentNegotiationStrategy#getMediaTypeForResource}.\n+\t\t// For backwards compatibility\n+\t\tMediaType mediaType = getMediaType(resource);\n+\t\tif (mediaType != null) {\n+\t\t\treturn mediaType;\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish media type change in ResourceHttpRequestHandler",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the logic for determining the media type of a resource served by `ResourceHttpRequestHandler`.\\n\\n**Before:**\\n\\nThe code first attempted to determine the media type based on the file extension using `PathExtensionContentNegotiationStrategy`.  If that failed, it then checked against the request using the `ContentNegotiationManager`.\\n\\n**After:**\\n\\nThe code now prioritizes checking the `ServletPathExtensionContentNegotiationStrategy` for the media type based on the file extension.",
            "avg_logprobs": -0.12584256172180175
        }
    },
    {
        "commit_hash": "4dab35205dbbde83b219352c0567cb1e7f1f4062",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/FrameworkServlet.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tsuper.doTrace(request, response);\n+\t\t// Work around until https://github.com/jakartaee/servlet/pull/545 is fixed and in use\n+\t\tif (request.getDispatcherType() != DispatcherType.ERROR) {\n+\t\t\tsuper.doTrace(request, response);\n+\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid super.doTrace for ERROR dispatches",
        "commit_body": "Closes gh-31457\n",
        "linked_issues": [
            {
                "issue_id": "31457",
                "issue_title": "Do not delegate TRACE to HttpServlet on ERROR dispatch",
                "issue_body": "Based on https://github.com/spring-projects/spring-boot/issues/33623. \r\n\r\nTomcat disables TRACE requests by default, which results in a 405. Spring Boot handles the resulting ERROR dispatch, and `FrameworkServlet` delegates to its parent for `doTrace` handling as usual. The result is in an error response with HTTP TRACE (instead of error) details in the body.\r\n\r\nThe issue will be fixed at the Servlet level with https://github.com/jakartaee/servlet/pull/545, possibly for Servlet 6.1, but meanwhile we can apply a temporary fix in `FrameworkServlet`.\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a conditional check on the `request.getDispatcherType()`.  Previously, `super.doTrace(request, response)` was unconditionally called.  Now, it's only called if the `DispatcherType` is not `ERROR`.  This suggests a workaround for an issue in the Jakarta Servlet library (likely related to tracing or logging) that's expected to be fixed in a future release",
            "avg_logprobs": -0.16401626897412677
        }
    },
    {
        "commit_hash": "4eaee1e7381d5f3d8cd6e3ab77c8cfcf7ef2d716",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AttributeMethods.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+ * @author Sam Brannen\n-\t\t\tif (method.getDefaultValue() != null) {\n+\t\t\tif (!foundDefaultValueMethod && (method.getDefaultValue() != null)) {\n-\t\t\tif (type.isAnnotation() || (type.isArray() && type.getComponentType().isAnnotation())) {\n+\t\t\tif (!foundNestedAnnotation && (type.isAnnotation() || (type.isArray() && type.getComponentType().isAnnotation()))) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Short circuit if-conditions in AttributeMethods",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change introduces a new conditional check (`!foundDefaultValueMethod`) before checking if a method's default value is null.  Similarly, it introduces a new conditional check (`!foundNestedAnnotation`) before checking if a type is an annotation or an array of annotations.  This suggests the original code might have had a potential issue where the checks were performed unnecessarily in certain cases, and the new checks are intended to prevent that",
            "avg_logprobs": -0.2581588172912598
        }
    },
    {
        "commit_hash": "4edc7196fb172cabe454dfc0377d322678b7ea7f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t// Request handling error (e.g. remote call), if we manage to set the status..\n+\t\t\tif (response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR)) {\n+\t\t\t\tlogger.error(logPrefix + \"500 Server Error for \" + formatRequest(request), ex);\n+\t\t\t\treturn Mono.empty();\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine disconnected client handling in WebFlux",
        "commit_body": "If an error looks like a \"disconnected client\" but the response is not\nyet committed then it can't be an I/O error from writing to the server\nresponse. It is most likely as a result of a remote call as part of\nrequest handling.\n\nNot setting the response to 500 in this case results in a 200 response\nstatus despite the error. Even if it was an I/O error from the server\nresponse, setting the status won't impact a failed response.\n\nCloses gh-23319\n",
        "linked_issues": [
            {
                "issue_id": "23319",
                "issue_title": "Errors.NativeIoException from WebClient on WebFlux server does not set the response status",
                "issue_body": "If `Errors.NativeIoException` is raised from controller while handling service logic it is not properly handled by Spring Framework / WebFlux.\r\n\r\nI'm observing the issue in one of my services that runs on Linux, it uses `WebClient` to access another web-service and, if idled for a while in connection pool, it generates `Errors.NativeIoException` with error code indication \"Connection reset by peer\" (I have mentioned it here: https://github.com/reactor/reactor-netty/issues/641#issuecomment-512865171).\r\n\r\nDisregarding the fact that this connection is not taken out from the pool automatically the behavior of the Spring WebFlux is odd: the service returns **HTTP 200 with empty content**, where as I have expected at least HTTP 500.\r\n\r\nIt can be easy reproduced by raising this Exception manually using latest versions of Spring-Boot, Netty and Java.\r\nSpring-Boot version (maven):\r\n```xml\r\n<parent>\r\n\t<groupId>org.springframework.boot</groupId>\r\n\t<artifactId>spring-boot-starter-parent</artifactId>\r\n\t<version>2.1.6.RELEASE</version>\r\n\t<relativePath/>\r\n</parent>\r\n<dependencies>\r\n\t<dependency>\r\n\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t<artifactId>spring-boot-starter-webflux</artifactId>\r\n\t</dependency>\r\n\t...\r\n```\r\n\r\nLinux version (in Docker):\r\n```\r\nroot@59a09bf2408a:/demo# uname -a\r\nLinux 59a09bf2408a 4.9.125-linuxkit #1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 GNU/Linux\r\n```\r\n\r\nJava version:\r\n```\r\nroot@59a09bf2408a:/demo# mvn -version\r\nApache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-04T19:00:29Z)\r\nMaven home: /usr/share/maven\r\nJava version: 11.0.4, vendor: Oracle Corporation, runtime: /usr/local/openjdk-11\r\nDefault locale: en, platform encoding: UTF-8\r\nOS name: \"linux\", version: \"4.9.125-linuxkit\", arch: \"amd64\", family: \"unix\"\r\n```\r\n\r\nExample of controller to cause the issue:\r\n```java\r\n@RestController\r\n@EnableWebFlux\r\npublic class DemoController {\r\n\t@GetMapping(\"/objects/{id}\")\r\n\tpublic Mono<DemoObject> getObjects(final @PathVariable String id) {\r\n\t\tswitch (id) {\r\n\t\t\tcase \"1\":\r\n\t\t\t\treturn Mono.error(new IOException(\"Failed to read object: \" + id));\r\n\t\t\tcase \"2\":\r\n\t\t\t\t// -104 Connection reset by peer\r\n\t\t\t\treturn Mono.error(new Errors.NativeIoException(\"Failed to read object: \" + id, -104));\r\n\t\t\tdefault:\r\n\t\t\t\tDemoObject data = new DemoObject();\r\n\t\t\t\tdata.id = id;\r\n\t\t\t\treturn Mono.just(data);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static final class DemoObject {\r\n\t\tpublic String id;\r\n\t}\r\n}\r\n```\r\n\r\n`-104` is a [Connection reset by peer](https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/errno.h#L87) code on Linux generated in my service by underlying communication to the external service using `WebClient`\r\n\r\nStandard `IOException` are handled as expected:\r\n```\r\n$ curl -v http://localhost:8080/objects/1\r\n*   Trying ::1...\r\n* TCP_NODELAY set\r\n* Connected to localhost (::1) port 8080 (#0)\r\n> GET /objects/1 HTTP/1.1\r\n> Host: localhost:8080\r\n> User-Agent: curl/7.54.0\r\n> Accept: */*\r\n>\r\n< HTTP/1.1 500 Internal Server Error\r\n< Content-Type: application/json;charset=UTF-8\r\n< Content-Length: 129\r\n<\r\n* Connection #0 to host localhost left intact\r\n{\"timestamp\":1563573616713,\"path\":\"/objects/1\",\"status\":500,\"error\":\"Internal Server Error\",\"message\":\"Failed to read object: 1\"}\r\n```\r\n\r\nBut the `Errors.NativeIoException` have weird handling:\r\n```\r\n~ $ curl -v http://localhost:8080/objects/2\r\n*   Trying ::1...\r\n* TCP_NODELAY set\r\n* Connected to localhost (::1) port 8080 (#0)\r\n> GET /objects/2 HTTP/1.1\r\n> Host: localhost:8080\r\n> User-Agent: curl/7.54.0\r\n> Accept: */*\r\n>\r\n< HTTP/1.1 200 OK\r\n< content-length: 0\r\n<\r\n* Connection #0 to host localhost left intact\r\n```\r\n\r\nI believe `Errors.NativeIoException` is misinterpret by Netty as an error of incoming HTTP connection and not the underlying business / service logic. But should not this be a part of WebFlux to take care of any Exception that is raised from inside controllers and deliver them as HTTP 500 to outside clients?\r\n\r\nWorkaround: at the moment I am using `Mono.onErrorMap` to map any `Errors.NativeIoException` into `ResponseStatusException` before it leaves the controller to avoid **HTTP 200** response in case of internal issues. But this feels very wrong to me.\r\n\r\nI'll be happy about any guidance and/or explanation about current behavior of WebFlux.\r\nThank you!",
                "issue_state": "closed",
                "issue_comment": [
                    "It looks like the \"Connection reset by peer\" triggers this [error handling](https://github.com/spring-projects/spring-framework/blob/957f0fac7a0dd1f0a7a5742fbeb8c40b7da439f0/spring-web/src/main/java/org/springframework/web/server/adapter/HttpWebHandlerAdapter.java#L270-L279) where the assumption is that the client is gone and we don't event set the response status.\r\n\r\nWe can at least try and set the status to 500, so if the error is a result of request handling, then the response would correctly reflect that.\r\n\r\nWe considered differentiating between IO errors on the server response vs request handling in #21875. However it was determined Reactor Netty already uses different exceptions. @violetagg is this case where the above `Errors.NativeIoException` somehow slips through and isn't getting translated to `PrematureCloseException`?"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a conditional check (`if (response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR))`) to handle potential errors during request processing.  If `response.setStatusCode` successfully sets the status to 500 Internal Server Error, it logs the error and returns an empty Mono, indicating that the request processing should be terminated.  This suggests a more robust error handling mechanism for situations where the response status can be set",
            "avg_logprobs": -0.23644170656309024
        }
    },
    {
        "commit_hash": "502997d8e986dcfde1f49b2b2f443a32b5488b13",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (dependentBeans == null) {\n+\t\tif (dependentBeans == null || dependentBeans.isEmpty()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Further simplify DefaultSingletonBeanRegistry.isDependent()",
        "commit_body": "See gh-30839\n",
        "linked_issues": [
            {
                "issue_id": "30839",
                "issue_title": "Simplify `DefaultSingletonBeanRegistry.isDependent()`",
                "issue_body": "Move `alreadySeen` out of for-loop.",
                "issue_state": "closed",
                "issue_comment": [
                    "@bnbakp0582 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30839)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30839) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@bnbakp0582 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30839)!",
                    "Hi @bnbakp0582,\r\n\r\nThis has been merged into `6.0.x` and `main` in fb4ad2f3ba0bf0d968a49a05efd8fd41f3e2509d and revised in 502997d8e986dcfde1f49b2b2f443a32b5488b13.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for an empty `dependentBeans` list before proceeding with the existing `if (dependentBeans == null)` block.  This prevents a potential `NullPointerException` if `dependentBeans` is a null but empty list.  In essence, it now handles the case where the list is empty as well as when it's null",
            "avg_logprobs": -0.19241916970030903
        }
    },
    {
        "commit_hash": "5068eb2e01a5f534b6ceaefe9d1034446b674164",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/AbstractErrors.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\treturn (field.equals(fieldError.getField()) ||\n-\t\t\t\t(field.endsWith(\"*\") && fieldError.getField().startsWith(field.substring(0, field.length() - 1))));\n+\t\tif (field.equals(fieldError.getField())) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t// Optimization: use chatAt instead of endsWith (SPR-11304, VESC-165)\n+\t\tint endIndex = field.length() - 1;\n+\t\treturn (field.charAt(endIndex) == '*' && fieldError.getField().startsWith(field.substring(0, endIndex)));",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add minor optimization to AbstractErrors",
        "commit_body": "Issue: SPR-11304\n",
        "linked_issues": [
            {
                "issue_id": "15928",
                "issue_title": "Optimize lookup of field errors in AbstractBindingResult [SPR-11304]",
                "issue_body": "**[Daniel Mikusa](https://jira.spring.io/secure/ViewProfile.jspa?name=dmikusa)** opened **[SPR-11304](https://jira.spring.io/browse/SPR-11304?redirect=false)** and commented\n\nThere is a performance issue when Spring MVC validates a large object graph using JSR 303 Bean Validation API & Hibernated Validator.\n\nHere is the object structure for the [sample project](https://github.com/spring-projects/spring-framework-issues/tree/master/SPR-11304) in spring-framework-issues...\n\n```\n- Address\n  - propA (string)\n  - propB (string)\n  - propC (List) // has around 100 elements\n       - Object1\n           - propA (string)\n           - propB (List)  // has around 30 elements\n               - Object 2\n                    - propA\n                    - propB\n                    - propC\n```\n\nWorst case it takes about 2.5 seconds to process a request that fails validation.  Without validation, processing is very fast.\n\n---\n\n**Affects:** 3.2.6, 4.0 GA\n\n**Issue Links:**\n- #16001 StringIndexOutOfBoundsException in AbstractErrors for class-level JSR-303 validator\n\n**Backported to:** [3.2.7](https://github.com/spring-projects/spring-framework/milestone/95?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI've made a small optimization in AbstractErrors that improves performance by ~ 30%. The overall request time is still not ideal but the number of errors (~12K) is unusually large. Given some additional details on the specific scenario that leads to this, we could make further optimzations.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `AbstractErrors.java` optimizes the logic for matching a field name against a field error.  The original code used a conditional expression involving `equals` and `endsWith/startsWith`.  The revised code uses an `if` statement for the exact match case, followed by a more efficient `charAt`-based check for the wildcard `*` suffix",
            "avg_logprobs": -0.3041254615783691
        }
    },
    {
        "commit_hash": "50829c9fdce91309118a2dfa2ebd8cd9bcf43437",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/SharedEntityManagerCreator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (target == null || !TransactionSynchronizationManager.isActualTransactionActive()) {\n+\t\t\t\tif (target == null || (!TransactionSynchronizationManager.isActualTransactionActive() &&\n+\t\t\t\t\t\t!target.getTransaction().isActive())) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Shared EntityManager does not insist on actualTransactionActive flag anymore",
        "commit_body": "Issue: SPR-13838\n",
        "linked_issues": [
            {
                "issue_id": "18411",
                "issue_title": "Regression: Shared EntityManager proxy insists on actualTransactiveActive flag even with SYNCHRONIZATION_NEVER [SPR-13838]",
                "issue_body": "**[Krzysztof Lewandowski](https://jira.spring.io/secure/ViewProfile.jspa?name=bikeholik)** opened **[SPR-13838](https://jira.spring.io/browse/SPR-13838?redirect=false)** and commented\n\nIf set the transaction synchronization to be SYNCHRONIZATION_NEVER, e.g.:\n\n```\n@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    if(bean instanceof AbstractPlatformTransactionManager){\n        AbstractPlatformTransactionManager transactionManager = (AbstractPlatformTransactionManager)bean;\n        transactionManager.setTransactionSynchronization(SYNCHRONIZATION_NEVER);\n    }\n    return bean;\n}\n```\n\nI get a following exception when trying to save an object using jpa repository:\n\n```\nCaused by: javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call\n\tat org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:277)\n\tat com.sun.proxy.$Proxy126.persist(Unknown Source)\n\tat org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:439)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:483)\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:483)\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:468)\n\tat org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:440)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)\n```\n\nWith that setup `TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());` is not called and now SharedEntityManagerCreator requires actual transaction to be active:\n\n```\n            if (target == null || !TransactionSynchronizationManager.isActualTransactionActive()) {\n         throw new TransactionRequiredException(\"No EntityManager with actual transaction available \" +\n                           \"for current thread - cannot reliably process '\" + method.getName() + \"' call\");\n}\n```\n\n---\n\n**Affects:** 4.2.4\n\n**Attachments:**\n- [screenshot-1.png](https://jira.spring.io/secure/attachment/23256/screenshot-1.png) (_119.53 kB_)\n- [screenshot-2.png](https://jira.spring.io/secure/attachment/23257/screenshot-2.png) (_222.84 kB_)\n\n**Issue Links:**\n- #16541 Shared EntityManager should immediately throw TransactionRequiredException if no transaction in progress\n- #17833 Transaction propagation SUPPORTS leads to \u201cHHH000326: Cannot join transaction\u201d warning\n- #17834 Inconsistent JPA behavior using no transaction, propagation SUPPORTS and OpenEntityManager pattern\n- #18944 Shared EntityManager's target lookup doesn't work with Spring Data's ChainedTransactionManager\n\n1 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI suppose you are using `JpaTransactionManager`, so an `EntityManager` is bound to the thread... with just the `actualTransactionActive` flag not set? We should definitely relax that `EntityManager` status check then. Looking at it for 4.2.5.\n\nJuergen\n",
                    "**[Krzysztof Lewandowski](https://jira.spring.io/secure/ViewProfile.jspa?name=bikeholik)** commented\n\nYes, exactly. JpaTransactionManager is used. i can work around it like:\n\n```\n    @Bean\n    @Primary\n    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {\n        return new JpaTransactionManager(entityManagerFactory) {\n            @Override\n            protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) {\n                if (status.isNewSynchronization()) {\n                    super.prepareSynchronization(status, definition);\n                } else {\n                    TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());\n                }\n            }\n\n\n        };\n    }\n```\n\nBut it doesn't seem to be a cleanest solution. Moreover thread locals won't get cleaned unless I add some transaction event listeners.\n",
                    "**[Sathishkumar Murugesan](https://jira.spring.io/secure/ViewProfile.jspa?name=sathish.murugesan)** commented\n\nHi,\n\nI am also facing similar issue. I have upgraded to latest Spring version from 4.1.6.Release to 4.2.4.Release and suddenly all what has functioned smoothly before, now throws the following exception. Exception occurs in SharedEntityManagerCreator.java. In the same method reported by other user.\n\n```java\njavax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call\nat org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:277) ~[na:4.2.4.RELEASE]\nat com.sun.proxy.$Proxy51.persist(Unknown Source) ~[na:na]\n```\n\n```java\nelse if (transactionRequiringMethods.contains(method.getName())) {\n                    // We need a transactional target now, according to the JPA spec.\n                    // Otherwise, the operation would get accepted but remain unflushed...\n                    if (target == null || !TransactionSynchronizationManager.isActualTransactionActive()) {\n                        throw new TransactionRequiredException(\"No EntityManager with actual transaction available \" +\n                                \"for current thread - cannot reliably process '\" + method.getName() + \"' call\");\n                    }\n                }\n```\n\nDo you have work around for now?\n\nI also created issue in Stackoverflow : http://stackoverflow.com/questions/34494754/upgraded-from-spring-4-1-6-to-4-2-4-and-suddenly-getting-transactionrequiredexce with more explanation and code samples\n",
                    "**[Krzysztof Lewandowski](https://jira.spring.io/secure/ViewProfile.jspa?name=bikeholik)** commented\n\nThe most dirty one is to manually call\n\n```\nTransactionSynchronizationManager.setActualTransactionActive(true);\n```\n\nsomewhere before you invoke operation that force those checks\n",
                    "**[Sathishkumar Murugesan](https://jira.spring.io/secure/ViewProfile.jspa?name=sathish.murugesan)** commented\n\nThanks for workaround. For me target == null, so it fails in the first condition not with ActualTransactionActive.\n\nEntityManagerFactoryUtils.java\n\n```java\nelse if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t// Indicate that we can't obtain a transactional EntityManager.\n\t\t\treturn null;\n\t\t}\n```\n\nI dont know why it couldn't find the targetEntityManager. But when i switch 4.1.6 it works like charm\n\nIf I set this in code.. then it works\n\n```java\nif(!TransactionSynchronizationManager.isSynchronizationActive()){\n            TransactionSynchronizationManager.initSynchronization();\n            TransactionSynchronizationManager.setActualTransactionActive(true);\n        }\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIf the first condition fails for you there, I assume you're not using `JpaTransactionManager`? Which transaction manager are you using then? You do set transaction synchronization to 'never' though?\n\nLet's sort out any variant of this issue for 4.2.5 in February. Providing an immediate upgrade path from 4.1.x is a key requirement for us.\n\nJuergen\n",
                    "**[Sathishkumar Murugesan](https://jira.spring.io/secure/ViewProfile.jspa?name=sathish.murugesan)** commented\n\nI use JPA transaction manager and attached code snippet of my configuration.\n\n```java\n<bean id=\"xxxTxManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\"\n          p:entityManagerFactory-ref=\"xxxEntityManagerFactory\" p:dataSource-ref=\"xxxDataSource\"/>\n\n<tx:annotation-driven transaction-manager=\"xxxTxManager\"/>\n\n<bean id=\"xxxEntityManagerFactory\"\n          class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"\n          p:persistenceUnitName=\"xxxHibernatePersistenceUnit\"\n          p:packagesToScan=\"com.opensolutions\"\n          p:dataSource-ref=\"xxxDataSource\" p:jpaVendorAdapter-ref=\"hibernateVendor\"\n          p:jpaPropertyMap-ref=\"jpaPropertyMap\" p:persistenceXmlLocation=\"classpath*:META-INF/xxx-jpa-persistence.xml\"/>\n\n    <bean id=\"hibernateVendor\"\n          class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"\n          p:showSql=\"false\"/>\n\n    <util:map id=\"jpaPropertyMap\">\n        <entry key=\"hibernate.dialect\" value=\"org.hibernate.dialect.Oracle10gDialect\"/>\n        <entry key=\"jadira.usertype.databaseZone\" value=\"jvm\"/>\n        <entry key=\"jadira.usertype.javaZone\" value=\"jvm\"/>\n    </util:map>\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'm not sure how `target` can be `null` there with a `JpaTransactionManager` driving the transaction. Could you please double-check what's happening there, in particular within the `EntityManagerFactoryUtils.doGetTransactionalEntityManager` call?\n\nJuergen\n",
                    "**[Sathishkumar Murugesan](https://jira.spring.io/secure/ViewProfile.jspa?name=sathish.murugesan)** commented\n\nI checked it..,\n\n```java\nEntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(emf);\n```\n\nreturns null, so\n\n```java\nelse if (!TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t// Indicate that we can't obtain a transactional EntityManager.\n\t\t\treturn null;\n\t\t}\n```\n\n!!\nWhen i check the method doGetResource it has only JMS datasource not my database datasource. Attached screenshot for more reference. Please let me know if you need more details.\n\n!screenshot-1.png|thumbnail!\nJust giving back ground about my scenario, i am trying to persist the data in the database before i post the message in the queue while posting queue it works fine. Its async process i used to save the data when they post reply back its fails only in the reply section when i listener picks up the call.  While posting the message to the queue, it still works fine without any issues.\n\nBefore i post the message in the queue, when i inspect getResources, I see all the resources. Attached screenshot of the same for reference. It fails only during reply\n!screenshot-2.png|thumbnail!\n\nRegards,\nSathish\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis looks like your `JpaTransactionManager` isn't even kicking in though; otherwise an `EntityManagerHolder` would be bound for your `EntityManagerFactory` at that point. You could put corresponding breakpoints in `JpaTransactionManager`...\n\nAs far as my current analysis goes, #17834 seems to have caused the regression for `SYNCHRONIZATION_NEVER` in that it insists on the `actualTransactiveActive` flag; we can easily fix this for 4.2.5. The regression with no `EntityManagerHolder` bound at all seems to be different and not caused by #17834; it'd be my pleasure to address it for 4.2.5 as well but have yet to find its root cause.\n\nJuergen\n",
                    "**[Sathishkumar Murugesan](https://jira.spring.io/secure/ViewProfile.jspa?name=sathish.murugesan)** commented\n\nI tried to put break point in JpaTransactionManager. But code doesnt even go to JpaTransactionManager. JpaTransactionManger class is never invoked.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've resolved the original issue here through an extra `EntityManager.getTransaction().isActive()` check: so either the `actualTransactiveFlag` or that `EntityManager` state needs to be set in order to proceed with a transaction-requiring operation. This should cover the `SYNCHRONIZATION_NEVER` case.\n\nAs for the `target` suddenly being `null` in some scenarios on 4.x, this seems to be a separate issue not caused by the changes behind #17834. Let's create a separate JIRA issue for that scenario if it remains to be a problem.\n\nJuergen\n",
                    "**[Murali Mohan Rath](https://jira.spring.io/secure/ViewProfile.jspa?name=mmrath)** commented\n\nI have raised a related bug at https://jira.spring.io/browse/DATACMNS-803\nThis is not resolved even with 4.2.5 SNAPSHOT build\n",
                    "**[Murali Mohan Rath](https://jira.spring.io/secure/ViewProfile.jspa?name=mmrath)** commented\n\nI had another go by building 4.3.0-BUILD-SNAPSHOT locally and it resolves the issue. I guess the snapshots on spring repo are not updated.\n\n`@Juergen` , Is it possible to release 4.2.5 soon? if not would you know when will be the next release?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI haven't got around to the 4.2.5 backport yet; I'll make sure to commit it later this week. So the fix simply isn't available in that branch yet.\n\nAs for the release dates, we always reflect the current plan here: https://jira.spring.io/browse/SPR/?selectedTab=com.atlassian.jira.jira-projects-plugin:roadmap-panel - 4.2.5 is currently scheduled for Feb 18.\n\nJuergen\n",
                    "**[Paul Zhang](https://jira.spring.io/secure/ViewProfile.jspa?name=paulzhang)** commented\n\nhello Juergen,\n\njust fellow up with \"As for the target suddenly being null in some scenarios on 4.x, this seems to be a separate issue not caused by the changes behind #17834. Let's create a separate JIRA issue for that scenario if it remains to be a problem.\" did you created separate JIRA issue for this one.\n",
                    "**[Sathishkumar Murugesan](https://jira.spring.io/secure/ViewProfile.jspa?name=sathish.murugesan)** commented\n\nAs for the target suddenly being null in some scenarios on 4.x, this seems to be a separate issue not caused by the changes behind #17834. Let's create a separate JIRA issue for that scenario if it remains to be a problem.\n\nThis issue is not still resolved in Spring 4.3.0 also. Exact Scenario is explained  by Murali Mohan Rath : I have raised a related bug at https://jira.spring.io/browse/DATACMNS-803\n\nIf we invoke JmsTransactionManager first, followed by JPATransactionManager then JPATransactionManager is coming as null. which eventually breaks code. Because of this issue we were not able to migrate from Spring 4.1.6 to any higher Spring Version.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for the `target.getTransaction().isActive()` condition within the existing `if` statement.  Previously, the code only checked if a transaction was active in the `TransactionSynchronizationManager`.  The modification now ensures that the `target` entity manager's transaction is also active, effectively tightening the condition under which the code proceeds.  This likely prevents a scenario where the transaction manager indicates an active transaction, but the target entity manager's transaction is not",
            "avg_logprobs": -0.21956272514498965
        }
    },
    {
        "commit_hash": "511dab1ade9c8b45d35e3bca005b631f0c40af89",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\tif (mm instanceof IntroductionAwareMethodMatcher) {\n+\t\t\t\t\tif (mm instanceof IntroductionAwareMethodMatcher iamm) {\n-\t\t\t\t\t\tmatch = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);\n+\t\t\t\t\t\tmatch = iamm.matches(method, actualClass, hasIntroductions);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply \"instanceof pattern matching\" (#29710)",
        "commit_body": NaN,
        "linked_issues": [
            {
                "issue_id": "29710",
                "issue_title": "Apply \"instanceof pattern matching\"",
                "issue_body": null,
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `main`.\r\n\r\nIn the future, please include larger change sets in your PRs.\r\n\r\nThere are certainly other places in the code base that can benefit from \"instance of pattern matching\", and we would prefer to address them on a per-module basis (for example, the entire `spring-aop` module).\r\n\r\nThanks",
                    "OK. Thank you for the tips.\r\n\r\nI had checked all the codes of `spring-aop`, and only this one needed to be modified.",
                    "> I had checked all the codes of `spring-aop`, and only this one needed to be modified.\r\n\r\nI'm not sure how you checked, because I found several other places that needed to be modified in `spring-aop`. See commit b71db12c43a1a09fa2fb49bf88ce8f00e017511b."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a cast with a more concise cast and variable declaration.  It now uses a variable `iamm` to hold the `IntroductionAwareMethodMatcher` instance, avoiding the redundant cast in the subsequent `matches` call.  This improves readability and slightly reduces the amount of code.  The core functionality of checking if `mm` is an `IntroductionAwareMethodMatcher` and then calling `matches` remains the same",
            "avg_logprobs": -0.22706848924810236
        }
    },
    {
        "commit_hash": "51875cdf5fa1ee0fafad85876cd14e0ea422f003",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/cglib/proxy/MethodProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t// SPRING PATCH BEGIN: early initialization for overridden methods on subclasses\n-\t\tif (!c1.isInterface()) {\n-\t\t\tproxy.init();\n+\t\t// SPRING PATCH BEGIN\n+\t\tif (!c1.isInterface() && c1 != Object.class) {\n+\t\t\t// Try early initialization for overridden methods on subclasses\n+\t\t\ttry {\n+\t\t\t\tproxy.init();\n+\t\t\t}\n+\t\t\tcatch (CodeGenerationException ex) {\n+\t\t\t\t// Ignore - to be retried when actually needed later on (possibly not at all)\n+\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensive early initialization of CGLIB method proxies (for AOT processing)",
        "commit_body": "Method proxies might not actually be used later on, so failure is not fatal.\n\nSee gh-29107\n",
        "linked_issues": [
            {
                "issue_id": "29107",
                "issue_title": "CGLIB proxies are not used at runtime on `@Configuration` classes in AOT mode",
                "issue_body": "Consider the following configuration class:\r\n\r\n```java\r\n@Configuration\r\npublic class MyConfiguration {\r\n\t@Bean\r\n\tA a() { return new A(); }\r\n\r\n\t@Bean\r\n\tB b() { return new B(this.a()); }\r\n\t\r\n\tstatic class A {\r\n\t\tpublic A() { System.out.println(\"A constructor\"); }\r\n\t}\r\n\r\n\tstatic class B {\r\n\t\tpublic B(A a) { System.out.println(\"B constructor\"); }\r\n\t}\r\n}\r\n```\r\n\r\nOn JVM in regular mode, it prints:\r\n\r\n```\r\nA constructor\r\nB constructor\r\n```\r\n\r\nOn JVM in AOT mode or native, while it seems CGLIB proxies are generated correctly at build time,  but they seems not used since it prints:\r\n\r\n```\r\nA constructor\r\nA constructor\r\nB constructor\r\n```\r\n\r\nThe code generated AOT maybe needs to be updated to leverage those CGLIB proxies.",
                "issue_state": "closed",
                "issue_comment": [
                    "We need to swap the creation of the raw class to the cglib proxy. I was hoping I could avoid having to change code generation for this but it turns out that there isn't a way to achieve this using an instance supplier. \r\n\r\nI've a proposal in [3b8bcdf](https://github.com/snicoll/spring-framework/commit/3b8bcdfe281b606a1ce8ee354b0cef56913ccfcd).\r\n\r\nThis is blocked by https://github.com/spring-projects/spring-boot/issues/32304 and, to some extent, https://github.com/spring-projects/spring-framework/issues/29141",
                    "I have it working but I think it needs a bit more work to test it correctly. "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the initialization of `proxy` objects, specifically when dealing with non-interface subclasses.  The original `if (!c1.isInterface())` check has been enhanced to `if (!c1.isInterface() && c1 != Object.class)`.  This addition prevents the initialization attempt on `Object` class, which is unnecessary.  Crucially, a `try-catch` block now surrounds the `proxy.init()` call",
            "avg_logprobs": -0.2263511085510254
        }
    },
    {
        "commit_hash": "51e30dd2211d635703359e907529a1ec871b91fa",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/MimeType.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import java.util.Map.Entry;\n-\t\tfor (Entry<String, String> entry : this.parameters.entrySet()) {\n-\t\t\tString key = entry.getKey();\n+\t\tfor (String key : this.parameters.keySet()) {",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polish MimeType",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces an enhanced `for` loop iterating over `Entry<String, String>` objects with a `for` loop iterating directly over the keys of the `parameters` map.  This change simplifies the loop by avoiding the need to access the `Entry`'s value.  It effectively removes unnecessary object creation and dereferencing",
            "avg_logprobs": -0.2201481388039785
        }
    },
    {
        "commit_hash": "53597f90e9e7da2739da9b874d16a4b1c5c50c10",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/SortedProperties.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import org.springframework.util.StringUtils;\n-\n-\t\tfor (String line : StringUtils.tokenizeToStringArray(contents, EOL)) {\n+\t\tfor (String line : contents.split(EOL)) {\n-\t\tfor (String line : StringUtils.tokenizeToStringArray(contents, EOL)) {\n+\t\tfor (String line : contents.split(EOL)) {",
        "change_count": 6,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Remove dependency on StringUtils in SortedProperties",
        "commit_body": "See gh-23018, gh-22383\n",
        "linked_issues": [
            {
                "issue_id": "22383",
                "issue_title": "Ensure indexer output is deterministic and repeatable",
                "issue_body": "The output file that `spring-context-indexer` produces is currently written using `Properties#store`. This prevents the build of a project that uses indexer from being repeatable, due to current timestamp being included in comment inside output file, and also entries possibly not being ordered deterministically.\r\n\r\nThis PR ensures that indexer output is written in deterministic and repeatable manner by filtering out comments and ordering entries.",
                "issue_state": "closed",
                "issue_comment": [
                    "As @jhoeller mentioned elsewhere, Spring already has a `PropertiesPersister` interface and `DefaultPropertiesPersister` implementation.\r\n\r\nSo, we'll look into providing support to filter out comment lines from the output (likely enabled via a new `boolean` flag in `DefaultPropertiesPersister`), which should take care of the timestamp comment.\r\n\r\n@vpavic, would that meet your needs?",
                    "I'm not sure that filtering comments alone is sufficient. To be guaranteed to be repeatable I believe it's also necessary to order the keys. Without ordering the keys, you are reliant on repeatable hashing of the keys which may not hold true under all circumstances.\r\n\r\nGradle contains [some code](https://github.com/gradle/gradle/blob/d40d48a02932cd12936e1c4829c0f1143c82aa5e/subprojects/base-services/src/main/java/org/gradle/internal/util/PropertiesUtils.java#L81-L119) for writing properties in a repeatable manner which could serve as inspiration.",
                    "Thanks for the feedback @sbrannen, I wasn't aware of `PropertiesPersister` - a custom implementation would probably do.\r\n\r\nThanks @wilkinsona, I forgot to mention there's also an ordering aspect to this.",
                    "> I'm not sure that filtering comments alone is sufficient. To be guaranteed to be repeatable I believe it's also necessary to order the keys. Without ordering the keys, you are reliant on repeatable hashing of the keys which may not hold true under all circumstances.\r\n\r\nOK. Thanks for bringing that up. We'll then have to take the order into account as well.\r\n",
                    "### Design Notes\r\n\r\nIt will likely be easiest to support consistent ordering by extending `Properties` and overriding the implementation of `keys()`.\r\n\r\nTo remove the comments, we will likely need to override `store(OutputStream, String)` and `store(Writer, String)` to _filter_ out all comments.\r\n\r\n### Open Issues\r\n\r\n@vpavic, @dsyer, @wilkinsona:\r\n\r\n* Can you please confirm that you do not need this support for the `storeToXML(...)` variants?\r\n* Is it acceptable to ignore (i.e., filter out) any user-supplied comments (provided via the `String comment` argument to `store(OutputStream, String)` or `store(Writer, String)`)?",
                    "I believe XML variants aren't needed.\r\n\r\nRegarding `PropertiesPersister` itself, it seems a bit obscure as code search doesn't reveal any (production) uses even in Framework's codebase - `Properties#store` is actually used in all places that write `Properties` instances.\r\n\r\nTo me `PropertiesPersister` looks like an overhead for this, as simple property writing helper with two variants (one accepting `OutputStream` the other `Writer`) of static `store` method would be much simpler to consume across the Spring portfolio. Both load and XML related parts of the API don't seem particularly relevant to the core problem being discussed here.",
                    "Thanks for the feedback, @vpavic.\r\n\r\nI am actually considering only a custom subclass of `Properties`. If I get that to work, I don't think there will be a need to implement a custom `PropertiesPersister`, modify `DefaultPropertiesPersister`, or introduce a new helper class.",
                    "OK, this feature is basically done, but I'd like to share it with you here first to see if it meets your needs.\r\n\r\nNew method in `org.springframework.core.CollectionFactory` (per recommendation by @jhoeller):\r\n\r\n```java\r\n/**\r\n * Create a variant of {@code java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n *\r\n * <p>This can be useful when storing the {@link Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n *\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n */\r\npublic static Properties createSortedProperties(boolean omitComments) {\r\n\treturn new SortedProperties(omitComments);\r\n}\r\n```\r\n\r\nImplementation of `SortedProperties`:\r\n\r\n```java\r\n/**\r\n * Specialization of {@link Properties} that sorts properties alphanumerically\r\n * based on their keys.\r\n *\r\n * <p>This can be useful when storing the {@link Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties.\r\n *\r\n * <p>Comments in generated properties files can also be optionally omitted\r\n * (see {@link SortedProperties#SortedProperties(boolean)}).\r\n *\r\n * @author Sam Brannen\r\n * @since 5.2\r\n * @see java.util.Properties\r\n */\r\nclass SortedProperties extends Properties {\r\n\r\n\tprivate static final String EOL = System.getProperty(\"line.separator\");\r\n\r\n\tprivate static final Comparator<Entry<Object, Object>> entryComparator = //\r\n\t\t(entry1, entry2) -> String.valueOf(entry1.getKey()).compareTo(String.valueOf(entry2.getKey()));\r\n\r\n\tprivate final boolean omitComments;\r\n\r\n\r\n\t/**\r\n\t * Construct a new {@code SortedProperties} instance that honors the supplied\r\n\t * {@code omitComments} flag.\r\n\t *\r\n\t * @param omitComments {@code true} if comments should be omitted when\r\n\t * storing properties in a file\r\n\t */\r\n\tSortedProperties(boolean omitComments) {\r\n\t\tthis.omitComments = omitComments;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void store(OutputStream out, String comments) throws IOException {\r\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\t\tsuper.store(baos, (this.omitComments ? null : comments));\r\n\t\tString contents = new String(baos.toByteArray(), StandardCharsets.ISO_8859_1);\r\n\t\tfor (String line : StringUtils.tokenizeToStringArray(contents, EOL)) {\r\n\t\t\tif (!omitComments || !line.startsWith(\"#\")) {\r\n\t\t\t\tout.write((line + EOL).getBytes(StandardCharsets.ISO_8859_1));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void store(Writer writer, String comments) throws IOException {\r\n\t\tStringWriter stringWriter = new StringWriter();\r\n\t\tsuper.store(stringWriter, (this.omitComments ? null : comments));\r\n\t\tString contents = stringWriter.toString();\r\n\t\tfor (String line : StringUtils.tokenizeToStringArray(contents, EOL)) {\r\n\t\t\tif (!omitComments || !line.startsWith(\"#\")) {\r\n\t\t\t\twriter.write(line + EOL);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void storeToXML(OutputStream out, String comments) throws IOException {\r\n\t\tsuper.storeToXML(out, (this.omitComments ? null : comments));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void storeToXML(OutputStream out, String comments, String encoding) throws IOException {\r\n\t\tsuper.storeToXML(out, (this.omitComments ? null : comments), encoding);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a sorted enumeration of the keys in this {@link Properties} object.\r\n\t * <p>The keys will be converted to strings if necessary using\r\n\t * {@link String#valueOf(Object)} and sorted alphanumerically according to\r\n\t * the natural order of strings.\r\n\t */\r\n\t@Override\r\n\tpublic synchronized Enumeration<Object> keys() {\r\n\t\tSet<Object> sortedKeys = new TreeSet<>();\r\n\t\tfor (Object key : super.keySet()) {\r\n\t\t\tsortedKeys.add(String.valueOf(key));\r\n\t\t}\r\n\t\treturn Collections.enumeration(sortedKeys);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a sorted set of the entries in this {@link Properties} object.\r\n\t * <p>The entries will be sorted based on their keys, and the keys will be\r\n\t * converted to strings if necessary using {@link String#valueOf(Object)}\r\n\t * and compared alphanumerically according to the natural order of strings.\r\n\t */\r\n\t@Override\r\n\tpublic Set<Entry<Object, Object>> entrySet() {\r\n\t\tSet<Entry<Object, Object>> sortedEntries = new TreeSet<>(entryComparator);\r\n\t\tsortedEntries.addAll(super.entrySet());\r\n\t\treturn Collections.synchronizedSet(sortedEntries);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n@vpavic, @dsyer, @wilkinsona, please let me know your thoughts.\r\n\r\nCheers,\r\n\r\nSam",
                    "Thanks @sbrannen, looks good at first glance.\r\n\r\nMy only concern is that this basically limits the use to `SortedProperties` instances, meaning you'd have to be control of both creation and persistence of properties. It would be nice if `SortedProperties` could wrap regular `Properies` instance so that we're be able to write it repeatable manner even when we're not in control of creation.",
                    "> It would be nice if `SortedProperties` could wrap regular `Properies` instance so that we're be able to write it repeatable manner even when we're not in control of creation.\r\n\r\nOK. I just added that locally. The additional factory method looks like this:\r\n\r\n```java\r\n/**\r\n * Create a variant of {@link java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n *\r\n * <p>This can be useful when storing the {@code Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n *\r\n * <p>The returned {@code Properties} instance will be populated with\r\n * properties from the supplied {@code properties} object, but default\r\n * properties from the supplied {@code properties} object will not be copied.\r\n *\r\n * @param properties the {@code Properties} object from which to copy the\r\n * initial properties\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n * @see #createSortedProperties(boolean)\r\n */\r\npublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\r\n\treturn new SortedProperties(properties, omitComments);\r\n}\r\n```\r\n\r\nSo, I hope that meets all of your needs now.",
                    "Looks good, thanks Sam! :+1:",
                    "Thanks, @sbrannen. I can confirm that we have no need for storing to XML in a repeatable manner.\r\n\r\n",
                    "Oh... well... it turns out that my implementation fully supports XML as well. \ud83d\ude07 ",
                    "The new `createSortedProperties(...)` factory methods in `CollectionFactory` are now in place. See c39c4211df15500996142a265d7afcc31c23c6f8 for details, and feel free to try it out in an upcoming snapshot build."
                ]
            },
            {
                "issue_id": "23018",
                "issue_title": "Provide utility for writing Properties to a file in a repeatable manner",
                "issue_body": "Instances of `java.util.Properties` are typically written to file using `Properties#store`. Since this method also writes a timestamp in a comment, its use is problematic in projects that need to have [reproducible builds](https://reproducible-builds.org/).\r\n\r\nIf Spring Framework could provide utility for writing `Properties` to a file in a repeatable manner, this would IMO be of great benefit to all Spring projects. There are already several issues/PRs that are blocked due to the shortcomings of `Properties#store`:\r\n\r\n- spring-projects/spring-boot#14494\r\n- #22383\r\n\r\n/cc @dsyer @wilkinsona",
                "issue_state": "closed",
                "issue_comment": [
                    "As @jhoeller mentioned elsewhere, Spring already has a `PropertiesPersister` interface and `DefaultPropertiesPersister` implementation.\r\n\r\nSo, we'll look into providing support to filter out comment lines from the output (likely enabled via a new `boolean` flag in `DefaultPropertiesPersister`), which should take care of the timestamp comment.\r\n\r\n@vpavic, would that meet your needs?",
                    "I'm not sure that filtering comments alone is sufficient. To be guaranteed to be repeatable I believe it's also necessary to order the keys. Without ordering the keys, you are reliant on repeatable hashing of the keys which may not hold true under all circumstances.\r\n\r\nGradle contains [some code](https://github.com/gradle/gradle/blob/d40d48a02932cd12936e1c4829c0f1143c82aa5e/subprojects/base-services/src/main/java/org/gradle/internal/util/PropertiesUtils.java#L81-L119) for writing properties in a repeatable manner which could serve as inspiration.",
                    "Thanks for the feedback @sbrannen, I wasn't aware of `PropertiesPersister` - a custom implementation would probably do.\r\n\r\nThanks @wilkinsona, I forgot to mention there's also an ordering aspect to this.",
                    "> I'm not sure that filtering comments alone is sufficient. To be guaranteed to be repeatable I believe it's also necessary to order the keys. Without ordering the keys, you are reliant on repeatable hashing of the keys which may not hold true under all circumstances.\r\n\r\nOK. Thanks for bringing that up. We'll then have to take the order into account as well.\r\n",
                    "### Design Notes\r\n\r\nIt will likely be easiest to support consistent ordering by extending `Properties` and overriding the implementation of `keys()`.\r\n\r\nTo remove the comments, we will likely need to override `store(OutputStream, String)` and `store(Writer, String)` to _filter_ out all comments.\r\n\r\n### Open Issues\r\n\r\n@vpavic, @dsyer, @wilkinsona:\r\n\r\n* Can you please confirm that you do not need this support for the `storeToXML(...)` variants?\r\n* Is it acceptable to ignore (i.e., filter out) any user-supplied comments (provided via the `String comment` argument to `store(OutputStream, String)` or `store(Writer, String)`)?",
                    "I believe XML variants aren't needed.\r\n\r\nRegarding `PropertiesPersister` itself, it seems a bit obscure as code search doesn't reveal any (production) uses even in Framework's codebase - `Properties#store` is actually used in all places that write `Properties` instances.\r\n\r\nTo me `PropertiesPersister` looks like an overhead for this, as simple property writing helper with two variants (one accepting `OutputStream` the other `Writer`) of static `store` method would be much simpler to consume across the Spring portfolio. Both load and XML related parts of the API don't seem particularly relevant to the core problem being discussed here.",
                    "Thanks for the feedback, @vpavic.\r\n\r\nI am actually considering only a custom subclass of `Properties`. If I get that to work, I don't think there will be a need to implement a custom `PropertiesPersister`, modify `DefaultPropertiesPersister`, or introduce a new helper class.",
                    "OK, this feature is basically done, but I'd like to share it with you here first to see if it meets your needs.\r\n\r\nNew method in `org.springframework.core.CollectionFactory` (per recommendation by @jhoeller):\r\n\r\n```java\r\n/**\r\n * Create a variant of {@code java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n *\r\n * <p>This can be useful when storing the {@link Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n *\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n */\r\npublic static Properties createSortedProperties(boolean omitComments) {\r\n\treturn new SortedProperties(omitComments);\r\n}\r\n```\r\n\r\nImplementation of `SortedProperties`:\r\n\r\n```java\r\n/**\r\n * Specialization of {@link Properties} that sorts properties alphanumerically\r\n * based on their keys.\r\n *\r\n * <p>This can be useful when storing the {@link Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties.\r\n *\r\n * <p>Comments in generated properties files can also be optionally omitted\r\n * (see {@link SortedProperties#SortedProperties(boolean)}).\r\n *\r\n * @author Sam Brannen\r\n * @since 5.2\r\n * @see java.util.Properties\r\n */\r\nclass SortedProperties extends Properties {\r\n\r\n\tprivate static final String EOL = System.getProperty(\"line.separator\");\r\n\r\n\tprivate static final Comparator<Entry<Object, Object>> entryComparator = //\r\n\t\t(entry1, entry2) -> String.valueOf(entry1.getKey()).compareTo(String.valueOf(entry2.getKey()));\r\n\r\n\tprivate final boolean omitComments;\r\n\r\n\r\n\t/**\r\n\t * Construct a new {@code SortedProperties} instance that honors the supplied\r\n\t * {@code omitComments} flag.\r\n\t *\r\n\t * @param omitComments {@code true} if comments should be omitted when\r\n\t * storing properties in a file\r\n\t */\r\n\tSortedProperties(boolean omitComments) {\r\n\t\tthis.omitComments = omitComments;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void store(OutputStream out, String comments) throws IOException {\r\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\t\tsuper.store(baos, (this.omitComments ? null : comments));\r\n\t\tString contents = new String(baos.toByteArray(), StandardCharsets.ISO_8859_1);\r\n\t\tfor (String line : StringUtils.tokenizeToStringArray(contents, EOL)) {\r\n\t\t\tif (!omitComments || !line.startsWith(\"#\")) {\r\n\t\t\t\tout.write((line + EOL).getBytes(StandardCharsets.ISO_8859_1));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void store(Writer writer, String comments) throws IOException {\r\n\t\tStringWriter stringWriter = new StringWriter();\r\n\t\tsuper.store(stringWriter, (this.omitComments ? null : comments));\r\n\t\tString contents = stringWriter.toString();\r\n\t\tfor (String line : StringUtils.tokenizeToStringArray(contents, EOL)) {\r\n\t\t\tif (!omitComments || !line.startsWith(\"#\")) {\r\n\t\t\t\twriter.write(line + EOL);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void storeToXML(OutputStream out, String comments) throws IOException {\r\n\t\tsuper.storeToXML(out, (this.omitComments ? null : comments));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void storeToXML(OutputStream out, String comments, String encoding) throws IOException {\r\n\t\tsuper.storeToXML(out, (this.omitComments ? null : comments), encoding);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a sorted enumeration of the keys in this {@link Properties} object.\r\n\t * <p>The keys will be converted to strings if necessary using\r\n\t * {@link String#valueOf(Object)} and sorted alphanumerically according to\r\n\t * the natural order of strings.\r\n\t */\r\n\t@Override\r\n\tpublic synchronized Enumeration<Object> keys() {\r\n\t\tSet<Object> sortedKeys = new TreeSet<>();\r\n\t\tfor (Object key : super.keySet()) {\r\n\t\t\tsortedKeys.add(String.valueOf(key));\r\n\t\t}\r\n\t\treturn Collections.enumeration(sortedKeys);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a sorted set of the entries in this {@link Properties} object.\r\n\t * <p>The entries will be sorted based on their keys, and the keys will be\r\n\t * converted to strings if necessary using {@link String#valueOf(Object)}\r\n\t * and compared alphanumerically according to the natural order of strings.\r\n\t */\r\n\t@Override\r\n\tpublic Set<Entry<Object, Object>> entrySet() {\r\n\t\tSet<Entry<Object, Object>> sortedEntries = new TreeSet<>(entryComparator);\r\n\t\tsortedEntries.addAll(super.entrySet());\r\n\t\treturn Collections.synchronizedSet(sortedEntries);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n@vpavic, @dsyer, @wilkinsona, please let me know your thoughts.\r\n\r\nCheers,\r\n\r\nSam",
                    "Thanks @sbrannen, looks good at first glance.\r\n\r\nMy only concern is that this basically limits the use to `SortedProperties` instances, meaning you'd have to be control of both creation and persistence of properties. It would be nice if `SortedProperties` could wrap regular `Properies` instance so that we're be able to write it repeatable manner even when we're not in control of creation.",
                    "> It would be nice if `SortedProperties` could wrap regular `Properies` instance so that we're be able to write it repeatable manner even when we're not in control of creation.\r\n\r\nOK. I just added that locally. The additional factory method looks like this:\r\n\r\n```java\r\n/**\r\n * Create a variant of {@link java.util.Properties} that sorts properties\r\n * alphanumerically based on their keys.\r\n *\r\n * <p>This can be useful when storing the {@code Properties} instance in a\r\n * properties file, since it allows such files to be generated in a repeatable\r\n * manner with consistent ordering of properties. Comments in generated\r\n * properties files can also be optionally omitted.\r\n *\r\n * <p>The returned {@code Properties} instance will be populated with\r\n * properties from the supplied {@code properties} object, but default\r\n * properties from the supplied {@code properties} object will not be copied.\r\n *\r\n * @param properties the {@code Properties} object from which to copy the\r\n * initial properties\r\n * @param omitComments {@code true} if comments should be omitted when\r\n * storing properties in a file\r\n * @return a new {@code Properties} instance\r\n * @since 5.2\r\n * @see #createSortedProperties(boolean)\r\n */\r\npublic static Properties createSortedProperties(Properties properties, boolean omitComments) {\r\n\treturn new SortedProperties(properties, omitComments);\r\n}\r\n```\r\n\r\nSo, I hope that meets all of your needs now.",
                    "Looks good, thanks Sam! :+1:",
                    "Thanks, @sbrannen. I can confirm that we have no need for storing to XML in a repeatable manner.\r\n\r\n",
                    "Oh... well... it turns out that my implementation fully supports XML as well. \ud83d\ude07 ",
                    "The new `createSortedProperties(...)` factory methods in `CollectionFactory` are now in place. See c39c4211df15500996142a265d7afcc31c23c6f8 for details, and feel free to try it out in an upcoming snapshot build."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the use of `StringUtils.tokenizeToStringArray` with `contents.split(EOL)` within a `for` loop.  This suggests a simplification, potentially aiming for performance improvement by avoiding the extra method call and the likely overhead of `StringUtils.tokenizeToStringArray`.  The original code likely tokenized the input string based on the `EOL` (end of line) delimiter, and the change directly splits the string using the same delimiter",
            "avg_logprobs": -0.2724872398376465
        }
    },
    {
        "commit_hash": "5405c07d26db564cb680c713dce5abb859635147",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (!this.setMetadataReaderFactoryCalled) {\n+\t\t\tthis.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Configuration class processing uses MetadataReaderFactory for current ResourceLoader",
        "commit_body": "Issue: SPR-14684\n",
        "linked_issues": [
            {
                "issue_id": "19248",
                "issue_title": "ConfigurationClassParser does not use ApplicationContext's ResourceLoader for its MetadataReaderFactory [SPR-14684]",
                "issue_body": "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** opened **[SPR-14684](https://jira.spring.io/browse/SPR-14684?redirect=false)** and commented\n\n# Scenario description:\n\nI've got a spring webapp like this\n- webapp is main context + main classloader\n- plugins are child contexts + child classloaders. Note that plugins read files from disk\n  (via custom classloader, not from jar)\n  this work fine in spring 3.2.x.\n  When migrated to spring 4.3.2 + spring boot 1.4, I've got an issue starting up.\n  In some cases it doesn't load file using the expected resourceLoader (classpath instead of expexted file)\n  The only changing is I've used a spring boot annotated class starting instead a web.xml one.\n\n# Issue:\n\nIf you look at attacched files (stack), it seems that spring scan two times\n1. On scan 1 spring use the webapp/plugin ResourceLoader, so that file are loaded as FileSystemResource as  expected\n2. On scan 2 (ConfigurationClassParser one) spring use DefaultResourceLoader instead of the webapp/plugin one. In this case it recognize resource as classpath/jar and it fails (due to application logic). It seems that ConfigurationClassParser doesn't take in account main context\n\n# My ugly patch\n\nActually the only solution I found is to patch SimpleMetadataReaderFactory forcing my logic\n\n{{\t`@Override`\npublic MetadataReader getMetadataReader(String className) throws IOException {\nString resourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +\nClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;\nResource resource = this.resourceLoader.getResource(resourcePath);\n\n    \t// CLESIUS PATCH - BEGIN\n    \t// Load from disk instead of jar, otherwise crash\n    \tif(SingletonLoader.getInstance()!=null && className.startsWith(\"it.clesius\")){\n    \t\tClass<?> cPlugin=SingletonLoader.getInstance().getClass(className);\n    \t\tif (cPlugin!=null){\n    \t\t\ttry{\n    \t\t\t\tresourcePath=cPlugin.getClassLoader().getResource(ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX).toString().replace(\"file://\", \"//\");\n    \t\t\t\tresource=new FileSystemResource(resourcePath);\n    \t\t\t}catch(Exception e){\n    \t\t\t\tSystem.out.println(\"CLESIUS PATCH - Error on spring clesius Patch\");\n    \t\t\t}\n    \t\t}\n    \t}\t\t\n    \t// CLESIUS PATCH - END\t\t\n    \t\n    \tif (!resource.exists()) {\n    \t\t// Maybe an inner class name using the dot name syntax? Need to use the dollar syntax here...\n    \t\t// ClassUtils.forName has an equivalent check for resolution into Class references later on.\n    \t\tint lastDotIndex = className.lastIndexOf('.');\n    \t\tif (lastDotIndex != -1) {\n    \t\t\tString innerClassName =\n    \t\t\t\t\tclassName.substring(0, lastDotIndex) + '$' + className.substring(lastDotIndex + 1);\n    \t\t\tString innerClassResourcePath = ResourceLoader.CLASSPATH_URL_PREFIX +\n    \t\t\t\t\tClassUtils.convertClassNameToResourcePath(innerClassName) + ClassUtils.CLASS_FILE_SUFFIX;\n    \t\t\tResource innerClassResource = this.resourceLoader.getResource(innerClassResourcePath);\n    \t\t\tif (innerClassResource.exists()) {\n    \t\t\t\tresource = innerClassResource;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn getMetadataReader(resource);\n    }\n\n}}\n\n---\n\n**Affects:** 4.3.2\n\n**Attachments:**\n- [scan1_right.png](https://jira.spring.io/secure/attachment/23539/scan1_right.png) (_188.25 kB_)\n- [scan2_wrong(fail).png](https://jira.spring.io/secure/attachment/23538/scan2_wrong%28fail%29.png) (_183.84 kB_)\n\n**Issue Links:**\n- #19219 Cache ASM metadata at the context level\n- #19250 Consistent *Aware callbacks for TypeFilters, ImportSelectors and ImportBeanDefinitionRegistrars\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n`ConfigurationClassPostProcessor` instantiates its `CachingMetadataReaderFactory` via the `ClassLoader` only, not via the `ResourceLoader`, which leads to `CachingMetadataReaderFactory` internally creating its own `DefaultResourceLoader` for the given `ClassLoader`. This is clearly lacking and needs to be revised.\n\nHowever, I'm surprised that this actually worked in 3.2.x! This is probably due to more defensive class loading in 4.x, making use of the `CachingMetadataReaderFactory` in places where it did not in 3.2.x. Or are you making use of configuration classes in places where you did not use them in the 3.2.x based version of your application?\n\nIn any case, we'll fix this for the upcoming 4.3.3.\n",
                    "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** commented\n\nIn spring 3.2.x app boot from web.xml, now from spring boot. It's possible this code (ConfigurationClassPostProcessor ) was not used on my previous version of sw, before upgrade to spring 4.\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, thanks for the clarification! I suppose a directly equivalent arrangement probably wouldn't have worked in 3.2.x either, so this isn't an immediate regression. In any case, we'll do our best to make this work in 4.3.3, scheduled for release late next week.\n",
                    "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** commented\n\nok tks Juergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt would be great if you could give the latest `4.3.3.BUILD-SNAPSHOT` a try... We intend to release 4.3.3 next Monday but it'd be great to get your feedback ahead of that.\n",
                    "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** commented\n\nI should able to test it this afgternoon or at least on tomorrow\n",
                    "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** commented\n\nI'm using springboot 1.4 + some spring 4.3.2 deps. I've replaced/forced spring-core+spring-context to snapshot.\nIt doesn't work. Is it enough? May I replace something else?\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\n[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi) you must replace the whole spring framework and not individual jars. If you are using the `spring-boot-starter-parent`, just add `<spring.version>4.3.2.BUILD-SNAPSHOT</spring.version>` to your pom. Or just upgrade to Spring Boot `1.4.1.BUILD-SNAPSHOT` that already uses the latest spring framework version.\n\nAlway run `mvn dependencies:list -D sort` to make sure that you're using the expected version.\n\nOr you can generate an app from `start.spring.io` and choose `1.4.1.BUILD-SNAPSHOT`. That way you'll be on the latest release.\n",
                    "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** commented\n\nProbably you means <spring.version>4.3.3.BUILD-SNAPSHOT</spring.version> not 4.3.2..\nBtw my spring-core and spring-context was 4.3.3.BUILD-SNAPSHOT on test, checked in WEB-INF lib. I miss just to update  spring.boot to 1.4.1.BUILD-SNAPSHOT\nbut I suspect changes are in core/context not in spring boot.\nAnyway I'll try during weekend if possible.\n\n",
                    "**[Denis Miorandi](https://jira.spring.io/secure/ViewProfile.jspa?name=denis.miorandi)** commented\n\nI've made test with full spring replacement  1.4.1.BUILD-SNAPSHOT + 4.3.3.BUILD-SNAPSHOT. Btw I've verified war file outcome and there was no contamination of older versions.\nIt didn't work. I've got same behavior (from external perspective) that in 4.3.2. Btw I should make a debug session to give your more informations. Before do it what kind of test did you do?\nAre you able to replicate a scenario like the not working one in your automatic tests?\n\nActually without my patch it doesn't solve the issue.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a check (`if (!this.setMetadataReaderFactoryCalled)`) to ensure the `metadataReaderFactory` is initialized only once.  If it hasn't been initialized, a `CachingMetadataReaderFactory` is created and assigned to the field. This prevents redundant creation of the factory",
            "avg_logprobs": -0.17764386676606678
        }
    },
    {
        "commit_hash": "5459304a4b5e8dc6ce08ff8d9e09228ab7d72659",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+ * @author Juergen Hoeller\n-\t\t\t\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n-\t\t\t\t\tif (mapping.isSynthesizable()) {\n-\t\t\t\t\t\treturn true;\n+\t\t\t\t\tif (annotationType != this.annotationType) {\n+\t\t\t\t\t\tAnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);\n+\t\t\t\t\t\tif (mapping.isSynthesizable()) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Re-introduce support for annotation declarations with self references",
        "commit_body": "Closes gh-31400\n",
        "linked_issues": [
            {
                "issue_id": "31400",
                "issue_title": "AnnotationScanner scanning leads to StackOverflowError with recursive annotation",
                "issue_body": "**Affects:**  6.0.12\r\n\r\nI am trying to update from Spring boot 2.7.13 to 3.1.4.\r\nWe are using this custom annotation to document configuration properties.\r\n\r\n```\r\n@Target(AnnotationTarget.CLASS, AnnotationTarget.PROPERTY)\r\nannotation class DocProperty(\r\n  val name: String = \"\",\r\n  val displayName: String = \"\",\r\n  val description: String = \"\",\r\n  val defaultValue: String = \"\",\r\n  val defaultExplanation: String = \"\",\r\n  val children: Array<DocProperty> = [],\r\n  val prefix: String = \"\",\r\n  val removedIn: String = \"\",\r\n  val removalReason: String = \"\",\r\n  val hidden: Boolean = false\r\n)\r\n```\r\n\r\nWhen I run the app, it fails:\r\n\r\n```\r\n2023-10-10T17:17:04.743+02:00 ERROR 22027 --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed\r\n\r\norg.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: URL [jar:file:/Users/jenik/IdeaProjects/tolgee-server/public/backend/data/build/libs/data-local-plain.jar!/io/tolgee/configuration/tolgee/S3Settings.class]\r\n\tat org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:463) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:317) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:276) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ComponentScanAnnotationParser.parse(ComponentScanAnnotationParser.java:128) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:289) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:243) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:196) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:164) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:415) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:287) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:344) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:115) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:771) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:589) ~[spring-context-6.0.12.jar:6.0.12]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[spring-boot-3.1.4.jar:3.1.4]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) ~[spring-boot-3.1.4.jar:3.1.4]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:439) ~[spring-boot-3.1.4.jar:3.1.4]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:315) ~[spring-boot-3.1.4.jar:3.1.4]\r\n\tat io.tolgee.Application$Companion.main(Application.kt:26) ~[main/:na]\r\n\tat io.tolgee.Application.main(Application.kt) ~[main/:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]\r\n\tat org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50) ~[spring-boot-devtools-3.1.4.jar:3.1.4]\r\nCaused by: java.lang.StackOverflowError: null\r\n\tat java.base/java.lang.ref.ReferenceQueue.poll(ReferenceQueue.java:117) ~[na:na]\r\nCaused by: java.lang.StackOverflowError: null\r\n\r\n\tat org.springframework.util.ConcurrentReferenceHashMap$ReferenceManager.pollForPurge(ConcurrentReferenceHashMap.java:1006) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.util.ConcurrentReferenceHashMap$Segment.restructureIfNecessary(ConcurrentReferenceHashMap.java:574) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.util.ConcurrentReferenceHashMap$Segment.getReference(ConcurrentReferenceHashMap.java:495) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.util.ConcurrentReferenceHashMap.getReference(ConcurrentReferenceHashMap.java:265) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.util.ConcurrentReferenceHashMap.get(ConcurrentReferenceHashMap.java:235) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.getDeclaredAnnotations(AnnotationsScanner.java:446) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.getDeclaredAnnotation(AnnotationsScanner.java:435) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:144) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.<init>(AnnotationTypeMapping.java:122) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:68) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:245) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:241) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:199) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.computeSynthesizableFlag(AnnotationTypeMapping.java:405) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.<init>(AnnotationTypeMapping.java:126) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:68) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:245) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:241) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:199) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.computeSynthesizableFlag(AnnotationTypeMapping.java:405) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.<init>(AnnotationTypeMapping.java:126) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:68) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:245) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:241) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:199) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-6.0.12.jar:6.0.12]\r\n\tat \r\n...\r\n```\r\n\r\nI've epxlored what happens, and the issue is that method `org.springframework.core.annotation.AnnotationTypeMapping#computeSynthesizableFlag` finds the `children` property of our `DocProperty` class annotation and calls the `forAnnotationType`, with the `children`'s type which is `DocProperty` again. And that's infinite loop.\r\n\r\nIt's reproducible here: https://github.com/tolgee/tolgee-platform/pull/1938/commits/259cd313e625b9e87af26e4f9c0e7a4b96583ada (the specific commit)",
                "issue_state": "closed",
                "issue_comment": [
                    "It looks like #28618 removed the support for cyclic annotation definitions introduced in #28012 but unfortunately also removed the ability to handle nested references to the same annotation type.",
                    "Is there any workaround like ignoring the annotation?",
                    "I'm afraid there isn't an obvious workaround. We'll have to address this in our `AnnotationTypeMapping` implementation.\r\n\r\nNote that Java annotations are not allowed to refer to themselves in their attributes, so this remains Kotlin specific. Kotlin prohibits deep cycles (X -> Y -> X) in annotation declarations as of Kotlin 1.9 (aligned with Java) but still allows self references (in contrast to Java)... unfortunately we missed the latter part there.",
                    "@jhoeller The fix does not work for the following legal Kotlin code:\r\n```\r\n@Target(AnnotationTarget.CLASS, AnnotationTarget.PROPERTY)\r\nannotation class DocProperty(\r\n    val name: String = \"\",\r\n    val displayName: String = \"\",\r\n    val description: String = \"\",\r\n    val defaultValue: String = \"\",\r\n    val defaultExplanation: String = \"\",\r\n    val children: Array<DocProperty> = [],\r\n    val prefix: String = \"\",\r\n    val removedIn: String = \"\",\r\n    val removalReason: String = \"\",\r\n    val hidden: Boolean = false,\r\n    val externalMap: Array<DocPropertyMapEntry> = []\r\n)\r\n\r\nannotation class DocPropertyMapEntry(\r\n    val docProperty: DocProperty = DocProperty()\r\n)\r\n```\r\nsee the externalMap property. Can Spring add support for this valid use-case please \ud83d\ude4f \r\n\r\nThis is my use-case: https://github.com/OpenFolder/kotlin-asyncapi/blob/master/kotlin-asyncapi-annotation/src/main/kotlin/org/openfolder/kotlinasyncapi/annotation/Schema.kt"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant check for `synthesizable` annotations if the `annotationType` is the same as the current `annotationType`.  It now only checks for synthesizability if the `annotationType` being examined is *different* from the current one.  This optimization avoids unnecessary lookups and comparisons",
            "avg_logprobs": -0.22821554037240835
        }
    },
    {
        "commit_hash": "550f13e8ed678447a61872b4f9ff96d918003102",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tConvertersForPair convertersForPair = this.converters.get(convertiblePair);\n-\t\t\tif (convertersForPair == null) {\n-\t\t\t\tconvertersForPair = new ConvertersForPair();\n-\t\t\t\tthis.converters.put(convertiblePair, convertersForPair);\n-\t\t\t}\n-\t\t\treturn convertersForPair;\n+\t\t\treturn this.converters.computeIfAbsent(convertiblePair, k -> new ConvertersForPair());",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify GenericConversionService.getMatchableConverters()",
        "commit_body": "Closes gh-24403",
        "linked_issues": [
            {
                "issue_id": "24403",
                "issue_title": "Simplify GenericConversionService.getMatchableConverters()",
                "issue_body": "It can be simplify this way.",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a method that retrieves and potentially creates a `ConvertersForPair` object from a map (`this.converters`) with a single `computeIfAbsent` call.  This is a more concise and efficient way to achieve the same result, avoiding the need for a separate `if` statement to check for the existence of the key and create it if necessary.  The `computeIfAbsent` method handles both the lookup and creation atomically",
            "avg_logprobs": -0.20588033095650052
        }
    },
    {
        "commit_hash": "55b258f2dec5110145f9017fc8fc3ba05bbb7aeb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompDecoder.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tint index = inString.indexOf('\\\\');\n+\t\tif (index == -1) {\n+\t\t\treturn inString;\n+\t\t}\n-\t\tint index = inString.indexOf('\\\\');",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid unnecessary allocations in StompDecoder#unescape",
        "commit_body": "Closes gh-29443\n",
        "linked_issues": [
            {
                "issue_id": "29443",
                "issue_title": "Avoid unnecessary allocations in StompDecoder#unescape",
                "issue_body": "Hi,\r\n\r\nI noticed in one of our applications that a tiny amount (0,5-1%) of allocations is caused by `StompDecoder#unescape`. The unfortunate bit is that there is actually no unescaping needed in most of the cases. This PR avoids unnecessary allocations if the String to unescape is not containing any `\\` character.\r\n\r\nCheers,\r\nChristoph",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `5.3.x` and `main`.\r\n\r\nThanks \ud83d\udc4d "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a conditional check for the presence of a backslash (`\\\\`) character in the input string (`inString`).  If no backslash is found (index = -1), the original string is returned directly.  Previously, the code unconditionally proceeded with further processing, which is now avoided if no backslash exists.  This optimization likely improves performance by skipping unnecessary processing in cases where backslashes are absent",
            "avg_logprobs": -0.2544869815602022
        }
    },
    {
        "commit_hash": "55faf6e3205d26a4ba693f40c1ea1cef179f31cb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.http.HttpMethod;\n-\t\t\t\tboolean isGet = \"GET\".equals(method);\n-\t\t\t\tif (isGet || \"HEAD\".equals(method)) {\n+\t\t\t\tboolean isGet = HttpMethod.GET.matches(method);\n+\t\t\t\tif (isGet || HttpMethod.HEAD.matches(method)) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use HttpMethod enums",
        "commit_body": "See gh-26855\n",
        "linked_issues": [
            {
                "issue_id": "26855",
                "issue_title": "Use HttpMethod enum constants instead of strings in DispatcherServlet",
                "issue_body": "doDispatch method of Dispatcher servlet class uses hard coded strings, such as \"GET\" and \"HEAD\".\r\nso, I replaced it with HttpMethod enum.",
                "issue_state": "closed",
                "issue_comment": [
                    "@BryceYangS Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26855)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26855) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@BryceYangS Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26855)!",
                    "i think it's not a good idea",
                    "> i think it's not a good idea\r\n\r\n@TAKETODAY Could I hear why you think so? Your feedback will be of great help to my study.",
                    "I just stumbled over this PR - I hope you don't mind me commenting. I wonder if we should use `HttpMethod.GET.name().equals()` rather than `HttpMethod.GET.matches()`. I did a small benchmark (on JDK 11) comparing things, and the former is expectedly a bit faster because it avoids the map access.\r\n\r\n```\r\nMyBenchmark.testMatches                         avgt    6   4,476 \u00b1  1,153   ns/op\r\nMyBenchmark.testNameEquals                      avgt    6   2,462 \u00b1  0,114   ns/op\r\n```\r\nGiven that we deal with `DispatcherServlet` here, I wonder if we should strive for the better performing option even though it's definitely a micro-optimization.\r\n",
                    "@dreis2211 I suppose we could also fine-tune the `HttpMethod.matches` implementation to `name().equals(method)` then - if known to be faster?",
                    "@jhoeller I was wondering but it actually was like that before - see 3d87718fc6d14a9638682317121f9647e0441cc3. Maybe you remember why that changed?",
                    "@jhoeller @dreis2211 Thank all of your comments. I thought the problem about a performance for a while. If there is a reason why `HttpMethod.matches ` was changed, How about using `name().equals(method)` in DispatcherServlet?",
                    "@BryceYangS Using `name().equals(method)` is not as good as using the original",
                    "No idea why I changed that back then... maybe a vague suspicion that hashing within the `Map` lookup would be faster than a String equality comparison, or maybe just a stylistic notion? In any case, we can change the current `HttpMethod.resolve` implementation back to a name comparison if that is known to be faster, and then rely on that implementation where appropriate.",
                    "This has been merged and I've also switched HttpMethod matches to String equals comparison with b76e0c482608c664d5d1d701b995dc4ceb0ed340."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a string comparison (`\"GET\".equals(method)`) with a method call (`HttpMethod.GET.matches(method)`).  This change likely uses the `HttpMethod` enum for more type-safe and potentially more efficient comparison of HTTP methods.  The `matches` method is used instead of `equals` which suggests the `method` variable might contain more than just the string \"GET\"",
            "avg_logprobs": -0.27217731475830076
        }
    },
    {
        "commit_hash": "5619b005f03d5b4160c3a0bf31991067f58401be",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotatedElementUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * This method is invoked by\n-\t * {@link #searchWithGetSemantics(AnnotatedElement, Class, String, Processor, Set, int)}\n-\t * to perform the actual search within the supplied list of annotations.\n+\t * This method is invoked by {@link #searchWithGetSemantics} to perform\n+\t * the actual search within the supplied list of annotations.\n-\t\t\t\tif ((annotation.annotationType() == annotationType\n-\t\t\t\t\t\t|| annotation.annotationType().getName().equals(annotationName))\n-\t\t\t\t\t\t|| processor.alwaysProcesses()) {\n-\n+\t\t\t\tif (annotation.annotationType() == annotationType ||\n+\t\t\t\t\t\tannotation.annotationType().getName().equals(annotationName) ||\n+\t\t\t\t\t\tprocessor.alwaysProcesses()) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional logic within the `AnnotatedElementUtils` class.  The original code had a nested `if` statement checking for equality between the annotation type and the `annotationType` variable, or if the `annotationName` matched the `annotationType`'s name.  This was combined with a check for the `processor.alwaysProcesses()` condition.  The change removes unnecessary parentheses and improves readability by using a single `||` (OR) condition",
            "avg_logprobs": -0.3119078826904297
        }
    },
    {
        "commit_hash": "564c6f7f86467e1f831d107d571ec34501104b18",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/groovy/GroovyBeanDefinitionReader.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tfor (Object key : namedArgs.keySet()) {\n-\t\t\t\t\tString propName = (String) key;\n-\t\t\t\t\tsetProperty(propName, namedArgs.get(propName));\n+\t\t\t\tfor (Map.Entry<?, ?> entity : namedArgs.entrySet()) {\n+\t\t\t\t\tString propName = (String) entity.getKey();\n+\t\t\t\t\tsetProperty(propName, entity.getValue());",
        "change_count": 6,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "improve the performance of iteration",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a `for` loop iterating over the keys of a `Map` with an enhanced `for` loop using `Map.Entry`.  This change iterates directly over the key-value pairs of the `namedArgs` map, eliminating the need for a separate lookup of the value using the key.  This is more concise and likely more efficient",
            "avg_logprobs": -0.14322917492358717
        }
    },
    {
        "commit_hash": "56688ab36130aa9b08c456a2ef90287337c39a74",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tString headers = values.isEmpty() ? \"\" : \"masked\";\n+\t\t\t\tString headers;\n+\t\t\t\telse {\n+\t\t\t\t\theaders = (!values.isEmpty() ? \"masked\" : \"\");\n+\t\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": "See gh-31244\n",
        "linked_issues": [
            {
                "issue_id": "31244",
                "issue_title": "Use `List#isEmpty()` in `DispatcherServlet`",
                "issue_body": "There was no reason for getRequestUri() to be static, so we removed it.\r\n\r\nIf the reason the method is static is because it does not access state from the instance, then I think there are several more candidates for static.\r\nBased on this, I think that static in `getRequestUri()` is unnecessary.\r\n\r\n<br>\r\n\r\nAnd, all the methods in `DispatcherServlet` used `isEmpty()`, and only one part used `size() > 0`.\r\nI changed this to `isEmpty()` for uniformity.",
                "issue_state": "closed",
                "issue_comment": [
                    "Hi @shin-mallang,\r\n\r\n> There was no reason for getRequestUri() to be static, so we removed it.\r\n> \r\n> If the reason the method is static is because it does not access state from the instance, then I think there are several more candidates for static. Based on this, I think that static in `getRequestUri()` is unnecessary.\r\n\r\nThat method is intentionally `static` because it is an internal helper utility method that should not rely on state in a `DispatcherServlet` instance. Although it's not a steadfast rule in our code base, we often do that for such use cases, but sometimes we don't think about it. In light of that, I will omit that change when merging this PS and consistently make such utility methods `static` in a separate commit.\r\n\r\n> And, all the methods in `DispatcherServlet` used `isEmpty()`, and only one part used `size() > 0`. I changed this to `isEmpty()` for uniformity.\r\n\r\nGood catch. I've repurposed this PR to focus on that and have changed the title accordingly.",
                    "This has been merged into `main` in 3932f91117aad8afa082bab63ed7cc44f7c01b70 and revised in 56688ab36130aa9b08c456a2ef90287337c39a74.\r\n\r\nThanks",
                    "@sbrannen\nThanks for the answer!\nIt's a utility method, so that's why you wrote it with static!\n\nI have one question.\n\nIs there any advantage to doing it in this way other than it reveals the intent of the method is utility?\n\nI'm just curious as to the reasoning behind doing it this way.",
                    "> @sbrannen Thanks for the answer! \r\n\r\nYou're very welcome.\r\n\r\n> It's a utility method, so that's why you wrote it with static!\r\n\r\nYes\r\n\r\n> Is there any advantage to doing it in this way other than it reveals the intent of the method is utility?\r\n\r\nThe rationale is two-fold:\r\n\r\n1. It reveals the intent.\r\n2. The use of and invocation of static methods may potentially result in better performance.\r\n",
                    "@sbrannen \n\nThank you for your kind answer.\ud83d\ude47\ud83c\udffb\u200d\u2642\ufe0f\nIt really helped me a lot."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional expression that determines the value of the `headers` variable.  The original code used a ternary operator to set `headers` to either an empty string or \"masked\" based on the emptiness of the `values` collection.  The revised code uses an `else` block to achieve the same result, but with a slightly different order of operations.  This change is likely a stylistic choice, but it might also have subtle implications for code readability or potential future maintainability.",
            "avg_logprobs": -0.3003418159484863
        }
    },
    {
        "commit_hash": "574dffb60b52c7cb708a436b2939def65b94d0c9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {\n+\t\tint resolvedAutowireMode = mbd.getResolvedAutowireMode();\n+\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {\n-\t\t\tif (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) {\n+\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_NAME) {\n-\t\t\tif (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {\n+\t\t\tif (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Some trivial optimization in method populateBean() (#22792)",
        "commit_body": "Optimize the number of getResolvedAutowireMode() method calls",
        "linked_issues": [
            {
                "issue_id": "22792",
                "issue_title": "Some trivial optimization in method populateBean()",
                "issue_body": "I don't think it's necessary to call the same get method so many times, maybe can do some trivial optimization here.",
                "issue_state": "closed",
                "issue_comment": [
                    "@cenjieHo Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22792)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22792) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@cenjieHo Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22792)!",
                    "Thanks for raising this! Even if such field access through method calls is usually very efficient at runtime, this is worth changing for clarification purposes in any case: namely evaluating the same state of the field, never getting a different autowire mode returned from that getter. A one-time method call with a locally cached result makes this clear."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change introduces a temporary variable `resolvedAutowireMode` to store the result of `mbd.getResolvedAutowireMode()`.  This variable is then used in subsequent `if` statements, eliminating redundant calls to the getter method.  This change improves efficiency by reducing the number of method calls",
            "avg_logprobs": -0.16300684213638306
        }
    },
    {
        "commit_hash": "58e113a591fc040cbe1534ece68c5a28bf6d73bf",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/AutoProxyRegistrar.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tif (candidate == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid NPE in AutoProxyRegistrar when no attribute found",
        "commit_body": "Issue: SPR-15055\n",
        "linked_issues": [
            {
                "issue_id": "19621",
                "issue_title": "AutoProxyRegistrar throws NullPointer on @kotlin.Metadata Annotation [SPR-15055]",
                "issue_body": "**[Marvin Schramm](https://jira.spring.io/secure/ViewProfile.jspa?name=marvinschramm)** opened **[SPR-15055](https://jira.spring.io/browse/SPR-15055?redirect=false)** and commented\n\nWhen using a simple spring boot application with both mixed Java And Kotlin files\nThe Kotlin Plugin seems to introduce a new Annotation for some classes. \"`@kotlin`.Metadata\"\n\nWhen starting the Spring Boot Project the AutoProxyRegistrar.java#L63 is not able to resolve the\nannotation metadata and will throw a NullPointerException.\nIn my case, this only happens when i use the `@EnableCaching` Annotation (i think when not using it, the AutoProxyRegistrar class is not invoked)\n\n1. Repository For This is here\n   https://github.com/spring-projects/spring-framework-issues/pull/145\n\nOnly those two classes and a single dependency is needed to reproduce this issue\n\n```\n@EnableCaching\n@Configuration\nopen class CacheConfiguration {\n    //this can be empty. when removing the @EnableCaching Annotation everything works\n}\n```\n\n```\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n```\ngroup = 'org.springframework.issues'\nversion = '1.0.0.SNAPSHOT'\n\nbuildscript {\n    ext {\n        kotlin_version = '1.0.5-2'\n        springBootVersion = '1.4.3.RELEASE'\n    }\n    repositories {\n        jcenter()\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n        classpath(\"org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlin_version}\")\n    }\n}\n\napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'kotlin'\napply plugin: 'org.springframework.boot'\napply plugin: 'idea'\n\nrepositories {\n    maven { url 'http://repo.spring.io/snapshot' }\n    mavenCentral()\n}\n\ndependencies {\n    compile(group: 'org.springframework.boot', name: 'spring-boot-starter')\n}\n\n[compileJava, compileTestJava]*.options*.compilerArgs = ['-Xlint:all']\n\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n```\n\nP.S. I am sorry if this is more are Spring-Boot and not Spring Framework issue. It was not clear for me where I should report this issue.\n\n\n---\n\n**Affects:** 4.3.5, 5.0 M3\n\n**Reference URL:** http://stackoverflow.com/questions/41334909/spring-boot-kotlin-autoproxyregistrar-causes-nullpointer-exception\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nGood catch, fixed on `master` and `4.3.x` branches via [this change](https://github.com/spring-projects/spring-framework/commit/58e113a591fc040cbe1534ece68c5a28bf6d73bf).\n",
                    "**[Marvin Schramm](https://jira.spring.io/secure/ViewProfile.jspa?name=marvinschramm)** commented\n\nNice! Thank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for the `candidate` variable before continuing to the next iteration of the loop.  This prevents potential `NullPointerExceptions` if `candidate` is null at any point in the loop",
            "avg_logprobs": -0.0982078234354655
        }
    },
    {
        "commit_hash": "5912d6f52af193e8bc562db80a64062394158851",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/hibernate5/LocalSessionFactoryBean.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\tprivate boolean metadataSourcesAccessed = false;\n+\n+\t\tthis.metadataSourcesAccessed = true;\n+\t\tthis.metadataSourcesAccessed = true;\n+\t\tif (this.metadataSources != null && !this.metadataSourcesAccessed) {\n+\t\t\t// Repeated initialization with no user-customized MetadataSources -> clear it.\n+\t\t\tthis.metadataSources = null;\n+\t\t}\n+",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "LocalSessionFactoryBean clears default MetadataSources on reinitialization",
        "commit_body": "Issue: SPR-14815\n",
        "linked_issues": [
            {
                "issue_id": "19381",
                "issue_title": "Hibernate 5 LocalSessionFactoryBean should allow for dynamic mapping registration (like for Hibernate 4) [SPR-14815]",
                "issue_body": "**[Arunkumar](https://jira.spring.io/secure/ViewProfile.jspa?name=arung.cse)** opened **[SPR-14815](https://jira.spring.io/browse/SPR-14815?redirect=false)** and commented\n\nWe are working on a project where we have to invoke the\nlocalSessionFactoryBean.afterPropertiesSet(); to reload the hibernate's session factory to add dynamically created HBM from our application, but we got the org.hibernate.DuplicateMappingException.\n\nUpon debugging hibernate5.2.2 source code, we found that the issue starts at the localSessionFactoryBean.afterPropertiesSet().\n\n```java\n@Override\n\tpublic void afterPropertiesSet() throws IOException {\n\t\tLocalSessionFactoryBuilder sfb = new LocalSessionFactoryBuilder(\n\t\t\t\tthis.dataSource, getResourceLoader(), getMetadataSources());\n\n// Here the getMetadataSources() has been reused in LocalSessionFactoryBuilder\n\npublic MetadataSources getMetadataSources() {\n\t\tif (this.metadataSources == null) {\n\t\t\tBootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\t\tif (this.resourcePatternResolver != null) {\n\t\t\t\tbuilder = builder.applyClassLoader(this.resourcePatternResolver.getClassLoader());\n\t\t\t}\n\t\t\tthis.metadataSources = new MetadataSources(builder.build());\n\t\t}\n\t\treturn this.metadataSources;\n\t}\n\n/*Here the previously created metadatasources values are being returned without clearing the xmlbindings values, so hibernate again adds (duplicates) all the .hbm  files to its sessionfactory which finally results in DuplicateMappingException. */\n```\n\nAs a quick fix in our code we have cleared the getMetadataSources.getXnlBindings\n\n```java\nlocalSessionFactoryBean.getMetadataSources().getXmlBindings().clear();\n//and then we called the \nlocalSessionFactoryBean.afterPropertiesSet();\n```\n\nThis scenario will be reproduced only when we have the joined subclass hbm mapping, because  in hiberanate 5.2.2 the duplication validation happens at InFlightMetadataCollectorImpl (Line No: 268). This method will be invoked by ModelBinder class method : bindJoinedSubclassEntities( Line No: 576).\n\n---\n\n**Affects:** 4.3.3\n\n**Issue Links:**\n- #18285 Hibernate5 metadata access\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/5912d6f52af193e8bc562db80a64062394158851, https://github.com/spring-projects/spring-framework/commit/7cbab0efe3e939814657c5fdab7024bcd7eae339\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt's not clear to me what we could do better here. `LocalSessionFactoryBean` isn't really designed for registering dynamic mappings to begin with, so this looks like an enhancement request to me. However, what specifically could we be improving to make your case work?\n",
                    "**[Arunkumar](https://jira.spring.io/secure/ViewProfile.jspa?name=arung.cse)** commented\n\nIn Hibernate4.LocalSessionFactoryBean.afterPropertiesSet() , LocalSessionFactoryBuilder constructor has only (this.datasource, this.resourcePatternResolver) in constructor argument whereas in In Hibernate5.LocalSessionFactoryBean.afterPropertiesSet() the LocalSessionFactoryBuilder has metaDataSource  along with datasource and resourcePatternResolver as constructor argument.  This leads to the duplicate files added in xmlBinding variable in metadatasources and lead to DuplicatMappingException in Hibernate package.\n\nIs there any specific reason to reuse the metadaSources in Hibernate5.LocalSessionFactoryBean ?  because in 3 and 4 ORM packagaes it was working fine and we have been using it for long time.\n\nIt will be good if you can add the enhancement request for registering  the dynamic mapping of .hbm files.  Meanwhile we will use  localSessionFactoryBean.getMetadataSources().getXmlBindings().clear();  as our workaround.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs of 4.3.4, we're resetting the `MetadataSources` in `afterPropertiesSet` if they haven't been user-accessed (i.e. if there were no interactions with `setMetadataSources` / `getMetadataSources`. This should still allow for `MetadataSources` customizations as per #18285 while also covering your re-initialization case.\n",
                    "**[Arunkumar](https://jira.spring.io/secure/ViewProfile.jspa?name=arung.cse)** commented\n\nThank you so much !!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a `metadataSourcesAccessed` flag and uses it to prevent repeated initialization of `metadataSources` if no user-provided `MetadataSources` are present.  Previously, the code unconditionally initialized `metadataSources`.  The change now checks if `metadataSources` is already initialized and, if not, clears it.  This likely addresses a potential issue of unnecessary initialization or resource consumption",
            "avg_logprobs": -0.3524531140739535
        }
    },
    {
        "commit_hash": "593bd064e1466125ef2c25141e5da6d992f3cb94",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/config/TypedStringValue.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!(targetTypeValue instanceof Class)) {\n+\t\tif (!(targetTypeValue instanceof Class<?> clazz)) {\n-\t\treturn (Class<?>) targetTypeValue;\n+\t\treturn clazz;\n-\t\tif (targetTypeValue instanceof Class) {\n-\t\t\treturn ((Class<?>) targetTypeValue).getName();\n+\t\tif (targetTypeValue instanceof Class<?> clazz) {\n+\t\t\treturn clazz.getName();",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `TypedStringValue` refactors the handling of `targetTypeValue` when it's a `Class`.  It now uses a more concise and type-safe approach.  The original code cast `targetTypeValue` to `Class<?>` twice, once for checking the type and again for returning the value.  The updated code introduces a variable `clazz` to hold the `Class<?>` instance, improving readability and eliminating redundant casts",
            "avg_logprobs": -0.2842565155029297
        }
    },
    {
        "commit_hash": "59b66007638c6937daca6b0c5f97a0fbe8a111bf",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ClassUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\ttargetClass != null && !targetClass.equals(method.getDeclaringClass())) {\n+\t\t\t\ttargetClass != null && targetClass != method.getDeclaringClass()) {\n-\t\t\tif (resolvedPrimitive != null && lhsType.equals(resolvedPrimitive)) {\n+\t\t\tif (lhsType == resolvedPrimitive) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Class identity comparisons wherever possible",
        "commit_body": "Issue: SPR-12926\n",
        "linked_issues": [
            {
                "issue_id": "17519",
                "issue_title": "Spring Performance Optimization, Comparing Classes [SPR-12926]",
                "issue_body": "**[Daniel P Rossi](https://jira.spring.io/secure/ViewProfile.jspa?name=dr9885)** opened **[SPR-12926](https://jira.spring.io/browse/SPR-12926?redirect=false)** and commented\n\nThis is a task to update class comparisons to use \"==\" instead of \".equals()\". There is a significant performance gain in this change. It also makes utilities like \"BeanPropertyRowMapper\" just as efficient as writing a custom row mapper.\n\n---\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/pull/773\n\n**Attachments:**\n- [EqualsTest.java](https://jira.spring.io/secure/attachment/22801/EqualsTest.java) (_30.53 kB_)\n\n**Issue Links:**\n- #19493 Improve performance for conversions using a method parameter based type descriptor with annotations\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOn review, it seems odd that there is a significant performance gain here: `java.lang.Class` doesn't seem to override `Object.equals` and therefore inherits a straight reference equality check from it. In a live JVM, that reference comparison would get inlined and should be effectively identical to a direct reference check. Could you provide some details on why this makes a significant difference in your scenario?\n\nJuergen\n",
                    "**[Daniel P Rossi](https://jira.spring.io/secure/ViewProfile.jspa?name=dr9885)** commented\n\nI've written and attached a test that demonstrates the performance gain with \"JdbcUtils.getResultSetValue\" being changed to reference checks instead of equal checks...\n\nBefore: 42ms, 1000 tests, 14 distinct values\nAfter: 18ms, 1000 tests, 14 distinct values\n\nThis test should help prove my point. Let me know if there are any further questions.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIn such a micro-benchmark, the JVM isn't going to inline those calls yet. Method call overhead is going to make a significant difference there, in particular against a dummy `ResultSet` implementation. In a warmed-up JVM, those `equals` calls should all be inlined and the resulting performance equivalent to direct reference comparisons.\n\nWe - and I'd argue plenty of developers - rely on inlining for efficiency at runtime. Otherwise, even `Assert` calls or calls to utility methods would be inefficient. So generally speaking, optimizing a case that would be inlined anyway falls into the category of \"premature optimization\" in source code.\n\nAlso, the Java language specification does not explicitly guarantee that `Class` can be compared by reference. `Class.equals` may theoretically be implemented in a more lenient form on some JVMs, and we need to make sure we're correctly handling such comparisons in the general case.\n\nNow, that said, I wouldn't mind optimizing the checks in `JdbcUtils` since they're all referring to built-in JVM types which I can't imagine to be present in a non-unique form. It's just in other places in the framework where we're comparing user types for which I'd stick with `equals` for defensiveness.\n\nJuergen\n",
                    "**[Daniel P Rossi](https://jira.spring.io/secure/ViewProfile.jspa?name=dr9885)** commented\n\nI think having only JdbcUtils changed for this would be just fine (that was all I was originally after). It has a significant performance increase when using BeanPropertyRowMapper. This makes the need to write custom row mappers almost obsolete and can increase development time where this class becomes useful.\n\nI also agree defensive programming is a better way to go. Although, if there are any other places where multiple class types are being checked (like JdbcUtils), then I would strongly recommend this change as well.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'm doing a broader sweep through the codebase now where I'm replacing all comparisons with hard-coded `Class` references (i.e. `X.class.equals`) with identity comparisons. Also, we can use `IdentityHashMap` for maps that only hold built-in types in keys anyway (such as in `ClassUtils` and `BeanUtils`).\n\nIn other words, we're relying on `Class` identity for JDK types and Spring interface types now. This should be a safe assumption since otherwise we couldn't refer to those types in our source files or cast to them either. At the same time, we keep using `Class.equals` for any comparisons between user types.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out to be a pretty worthwhile sweep, reviewing quite a few hotspots. `NumberUtils` does plenty of class comparisons as well and may get invoked for many properties per request. The same applies to various parts of our dependency injection resolution algorithm.\n\nThe principle of comparing JDK classes and Spring interfaces by identity is now consistently applied across the codebase. We'll see whether there are any subtle regressions in the 4.2 RC phase but I doubt that there can be regressions for those specific purposes.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a `.equals()` check with a `!=` check in a conditional statement.  Specifically, it changes the condition `targetClass != null && !targetClass.equals(method.getDeclaringClass())` to `targetClass != null && targetClass != method.getDeclaringClass()`.  Additionally, it simplifies the nested `if` statement by changing `lhsType.equals(resolvedPrimitive)` to `lhsType == resolvedPrimitive`",
            "avg_logprobs": -0.1396152877807617
        }
    },
    {
        "commit_hash": "5ab966fbdefc33840ff2ac4c12b26a6c306b59cf",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/support/CronField.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t * minimum value of this field's range, except for daylight saving.\n+\t\t * minimum value of this field's range.\n-\t\t\tT result =  this.field.getBaseUnit().addTo(temporal, amount);\n-\t\t\t//adjust daylight saving\n-\t\t\tif (get(result) != range.getMinimum()) {\n-\t\t\t\tresult = this.field.adjustInto(result,result.range(this.field).getMinimum());\n+\t\t\tT result = this.field.getBaseUnit().addTo(temporal, amount);\n+\t\t\tcurrent = get(result);\n+\t\t\trange = result.range(this.field);\n+\t\t\t// adjust for daylight savings\n+\t\t\tif (current != range.getMinimum()) {\n+\t\t\t\tresult = this.field.adjustInto(result, range.getMinimum());",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": "See gh-28038\n",
        "linked_issues": [
            {
                "issue_id": "28038",
                "issue_title": "CronExpression fails to calculate next execution on the day of daylight saving time",
                "issue_body": "Affects: Spring Framework 5.3.15\r\n\r\nLooks like the fix for #26744 doesn't cover the following case.\r\n\r\nProblem: `CronExpression` fails to calculate properly next execution when running on the day of daylight saving time, just before DST is applied.\r\n\r\n```java\r\nZonedDateTime current = ZonedDateTime.of(LocalDateTime.parse(\"2021-03-28T01:00:00\"), ZoneId.of(\"Europe/Amsterdam\"));\r\nCronExpression cronExpression = CronExpression.parse(\"0 5 0 * * *\");\r\nZonedDateTime next = cronExpression.next(current);\r\n```\r\n\r\nIn this case the value returned by `cronExpression.next(current)` is `2021-03-30T00:05` instead of the expected `2021-03-29T00:05`.\r\n\r\nTo be more precise any input date between `2021-03-28T00:05+01:00` and `2021-03-28T01:59+01:00` will calculate next execution to `2021-03-30T00:05` instead of the expected `2021-03-29T00:05`.\r\n\r\nAfter DST, next execution is successfully calculated i.e. `2021-03-29T00:05`.",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for the PR,  @vikeychen "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removes a daylight saving adjustment check.  The original code had a conditional check (`if (get(result) != range.getMinimum())`) to adjust for daylight savings.  The updated code removes this check entirely, simplifying the logic.  It also introduces a new variable `current` to store the result of `get(result)` for better readability and potentially for further use in the subsequent logic",
            "avg_logprobs": -0.35337955474853516
        }
    },
    {
        "commit_hash": "5b47816183e4e9a0dc2ad5d2175065ac17539719",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tmultipartRequestParsed = processedRequest != request;\n+\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n+\t\t\telse if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) instanceof MultipartException) {\n+\t\t\t\tlogger.debug(\"Multipart resolution failed for current request before - \" +\n+\t\t\t\t\t\t\"skipping re-resolution for undisturbed error rendering\");\n+\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DispatcherServlet skips multipart resolution if error page exception attribute indicates MultipartException as root cause",
        "commit_body": "Issue: SPR-11716\n",
        "linked_issues": [
            {
                "issue_id": "16338",
                "issue_title": "Skip multipart checking so that multipart errors can be handled in an @Controller method using Servlet 3 <error-page> [SPR-11716]",
                "issue_body": "**[steve bread](https://jira.spring.io/secure/ViewProfile.jspa?name=solze)** opened **[SPR-11716](https://jira.spring.io/browse/SPR-11716?redirect=false)** and commented\n\nI have a multipartpart config in the web.xml to limit the max upload size\n\n```xml\n<servlet>\n     <!-- some elements excluded for brevity -->\n     <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n     <multipart-config>\n          <max-file-size>2097152</max-file-size>\n          <max-request-size>2097152</max-request-size>\n          <file-size-threshold>0</file-size-threshold>\n     </multipart-config>\n</servlet>\n```\n\nand a mapping to an error controller\n\n```xml\n<error-page>\n     <location>/error</location>\n</error-page>\n```\n\nI'm using Tomcat. A file upload greater than the max size results in an exception which the container attempts to forward to the error controller. Following the normal dispatch behavior for the error URL, Spring attempts to create a `StandardMultipartHttpServletRequest` again which once again results in a Tomcat exception for max size violation. So the error controller is not reached and instead a Tomcat error page is returned. It would be nice if there were a way to tell Spring to ignore the mutipart content for the error controller and create a regular request.\n\nIn Eclipse, I had Spring skip the multipart block in `DispatcherServlet.checkMultipart` and got the desired result.\n\nThe error controller for reference\n\n```java\n@Controller\n@RequestMapping(\"/error\")\npublic class ErrorController {\n\n\t@RequestMapping(headers = \"X-Requested-With=XMLHttpRequest\")\n\tpublic ResponseEntity<String> error(HttpServletRequest request, HttpServletResponse response) {\n\t\treturn new ResponseEntity<String>(\"An error occurred\", HttpStatus.BAD_REQUEST);\n\t}\n}\n```\n\n---\n\n**Affects:** 3.2.8\n\n**Issue Links:**\n- #16352 StandardServletMultipartResolver should support lazy resolution along the lines of CommonsMultipartResolver\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/5b47816183e4e9a0dc2ad5d2175065ac17539719, https://github.com/spring-projects/spring-framework/commit/d3c9a31e9a10a1128c2ad8b55e4cc0519d8af32c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're skipping multipart resolution if the error page exception attribute in the current request indicates a MultipartException as the root cause of triggering the error handler. This should hopefully address your scenario.\n\nJuergen\n",
                    "**[steve bread](https://jira.spring.io/secure/ViewProfile.jspa?name=solze)** commented\n\nThanks Juergen. I'll upgrade to Spring 4 once 4.0.4 is released and try it out.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logic for determining if a multipart request has been parsed.  Previously, `multipartRequestParsed` was set based solely on whether `processedRequest` differed from `request`.  The updated code adds a check for a `MultipartException` on a request attribute.  If a `MultipartException` is found, it logs a debug message and skips re-resolution, likely to prevent double processing and ensure proper error handling",
            "avg_logprobs": -0.3047770118713379
        }
    },
    {
        "commit_hash": "5b97c47fc4b9a4248db9cd2472f25ae78242baf4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/testFixtures/java/org/springframework/web/testfixture/servlet/MockHttpServletResponse.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tZonedDateTime expires = (cookie instanceof MockCookie ? ((MockCookie) cookie).getExpires() : null);\n-\t\t\tZonedDateTime expires = (cookie instanceof MockCookie ? ((MockCookie) cookie).getExpires() : null);\n+\t\telse if (expires != null) {\n+\t\t\tbuf.append(\"; Expires=\");\n+\t\t\tbuf.append(expires.format(DateTimeFormatter.RFC_1123_DATE_TIME));\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Sync changes in MockHttpServletResponse test fixture",
        "commit_body": "See gh-26558\n",
        "linked_issues": [
            {
                "issue_id": "26558",
                "issue_title": "Support cookies with Expires attribute but no Max-Age attribute in MockHttpServletResponse",
                "issue_body": "According to the spec it is allowed to have cookies that only use the `Expires` attribute (even though it's really old style).\r\n\r\n`MockHttpServletResponse` didn't previously support that properly.\r\n\r\nSo, added a testcase and made it work.",
                "issue_state": "closed",
                "issue_comment": [
                    "@koosg Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26558)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26558) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@koosg Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26558)!",
                    "For reference: [HTTP Cookie Syntax](https://tools.ietf.org/html/rfc6265#section-4.1.1).",
                    "This has been merged into `master` for 5.3.5 and backported to `5.2.x` for 5.2.14.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a conditional check (`else if (expires != null)`) to the code that appends the `Expires` header to a response.  Previously, the `Expires` header was unconditionally appended, regardless of whether the `expires` value was null.  Now, if `expires` is null, the header is not added.  The code also formats the `expires` value using `DateTimeFormatter",
            "avg_logprobs": -0.16308834075927733
        }
    },
    {
        "commit_hash": "5c77c3739ea2eaf292639a702f721c0b5a73a277",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DisposableBeanAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfor (Class<?> beanInterface : beanClass.getInterfaces()) {\n+\t\t\tfor (Class<?> beanInterface : ClassUtils.getAllInterfacesForClass(beanClass)) {",
        "change_count": 2,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Find destroy methods in superclass interfaces",
        "commit_body": "Related tests will be added in\nhttps://github.com/spring-projects/spring-aot-smoke-tests.\n\nCloses gh-32006\n",
        "linked_issues": [
            {
                "issue_id": "32006",
                "issue_title": "Destroy method not found in Native image for `ExecutorService` Bean type",
                "issue_body": "**Describe the issue**\r\nI have a Spring Boot 3 _(version 3.2.1)_ app with nothing on the classpath except `spring-boot-starter`.\r\n\r\nif I use following code:\r\n```java\r\npackage com.example.demo;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.context.annotation.Bean;\r\n\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\n\r\n@SpringBootApplication\r\npublic class DemoApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(DemoApplication.class, args);\r\n    }\r\n\r\n    @Bean\r\n    ExecutorService executorService() {\r\n        return Executors.newFixedThreadPool(10);\r\n    }\r\n}\r\n```\r\n\r\n...and then compile as Native image:\r\n```bash\r\nmvn clean native:compile -Pnative\r\n```\r\n\r\n...and run: \r\n```bash\r\n./target/demo\r\n```\r\n\r\n...then I get the following error:\r\n```bash\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'executorService': Invalid destruction signature\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:643) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:521) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975) ~[demo:6.1.2]\r\n        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:960) ~[demo:6.1.2]\r\n        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625) ~[demo:6.1.2]\r\n        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:762) ~[demo:3.2.1]\r\n        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:464) ~[demo:3.2.1]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[demo:3.2.1]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1358) ~[demo:3.2.1]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1347) ~[demo:3.2.1]\r\n        at com.example.demo.DemoApplication.main(DemoApplication.java:15) ~[demo:na]\r\nCaused by: org.springframework.beans.factory.support.BeanDefinitionValidationException: Could not find a destroy method named 'shutdown' on bean with name 'executorService'\r\n        at org.springframework.beans.factory.support.DisposableBeanAdapter.<init>(DisposableBeanAdapter.java:134) ~[na:na]\r\n        at org.springframework.beans.factory.support.AbstractBeanFactory.registerDisposableBeanIfNecessary(AbstractBeanFactory.java:1868) ~[demo:6.1.2]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:639) ~[demo:6.1.2]\r\n```\r\n\r\nAnd if I'll switch bean type to a precise one: _(`ThreadPoolExecutor`)_ instead of _(`ExecutorService`)_, then it works:\r\n```java\r\n    // This works\r\n    @Bean\r\n    ThreadPoolExecutor executorService() {\r\n        return (ThreadPoolExecutor) Executors.newFixedThreadPool(10);\r\n    }\r\n\r\n    // This doesn't work\r\n    @Bean\r\n    ExecutorService executorService() {\r\n        return Executors.newFixedThreadPool(10);\r\n    }\r\n```\r\n\r\nThis issue is almost exactly the same like this one: [#29545](https://github.com/spring-projects/spring-framework/issues/29545) except that now it only reproducing for `ExecutorService`.\r\n\r\n**Steps to reproduce the issue**\r\nPlease see reproducible Demo app: [spring-native-executor-demo.zip](https://github.com/spring-projects/spring-framework/files/13890213/spring-native-executor-demo.zip)\r\n\r\n**Describe GraalVM and your environment:**\r\n - GraalVM version: **17.0.9-graal**\r\n - JDK major version: **17**\r\n - OS: **macOS Sonoma 14.1.1 (23B81)**\r\n - Architecture: **ARM64**",
                "issue_state": "closed",
                "issue_comment": [
                    "Looks indeed very similar to #29545, especially given the fact that `ExecutorService` has the `void shutdown()` method defined at interface level.\r\n\r\nSurprisingly, I can't reproduce with using SDKman with `sdk use java 23.1.1.r21-nik` or `sdk use java 21.0.1-graalce`, but I can reproduce using `sdk use java 17.0.9-graalce`. On Spring AOT side, the metadata for `ExecutorService#shutdown` are generated as expected.\r\n\r\nThat likely indicates that this is a GraalVM limitation or bug only fixed in recent versions.\r\n\r\nAs consequence, and since we don't have any actionable item on Spring side, I close this ticket.\r\n\r\nI advise you to use a more recent GraalVM distribution or add invoke reflection hints on `ThreadPoolExecutor#shutdown`.",
                    "@sdeleuze thank you for quick investigation!\r\nI see that for different java versions the metadata for `ExecutorService`'s Destroy method generated differently.\r\n\r\nFor the Java 17 _(`sdk use java 17.0.9-graalce`)_ metadata looks like this:\r\n```json\r\n  {\r\n    \"name\": \"java.util.concurrent.ExecutorService\",\r\n    \"queryAllPublicMethods\": true,\r\n    \"queryAllDeclaredMethods\": true,\r\n    \"methods\": [\r\n      {\r\n        \"name\": \"shutdown\",    <<== one method, which is not default in ExecutorService interface\r\n        \"parameterTypes\": [ ]\r\n      }\r\n    ]\r\n  },\r\n\r\n```\r\n\r\n...but for the Java 21 _(`sdk use java 21.0.1-graalce`)_ metadata looks like this:\r\n\r\n```json\r\n  {\r\n    \"name\": \"java.util.concurrent.ExecutorService\",\r\n    \"queryAllPublicMethods\": true,\r\n    \"queryAllDeclaredMethods\": true,\r\n    \"methods\": [\r\n      {\r\n        \"name\": \"close\",      <<== new default method\r\n        \"parameterTypes\": [ ]\r\n      }\r\n    ]\r\n  },\r\n```\r\n\r\n...because, since the Java 19 `ExecutorService` interface extends `AutoClosable`, and has [`default void close()` method](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ExecutorService.html#close()).\r\n\r\nSo, probably this is the issue?",
                    "Good catch, this is probably the reason for such difference of behavior. But that's does not explain why the repro for #29545 works and this one on Java 17 doesn't.\r\n\r\nAfter a deeper look, I think I found the cause: #29545 does not attempt to find methods in superclass interfaces. As a consequence, I reopen this issue.",
                    "@sdeleuze I suppose this should be backported to 6.0.x as well?"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the original `beanClass.getInterfaces()` with `ClassUtils.getAllInterfacesForClass(beanClass)`.  This suggests a switch to using a utility method (`ClassUtils.getAllInterfacesForClass`) to retrieve all interfaces implemented by a class, likely to handle cases where the class hierarchy includes interfaces not directly listed in the class's interface array.  This change improves the code's robustness by ensuring all relevant interfaces are considered",
            "avg_logprobs": -0.21288492346322666
        }
    },
    {
        "commit_hash": "5cbc972a0de195ebb09645f65a1dea8fb85880c9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/listener/AbstractJmsListeningContainer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * at debug level.\n+\t * at warn level.\n-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(\"Listener container task [\" + task + \"] has been rejected and paused: \" + ex);\n+\t\tif (logger.isWarnEnabled()) {\n+\t\t\tlogger.warn(\"Listener container task [\" + task + \"] has been rejected and paused: \" + ex);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log rejected listener container tasks at warn level",
        "commit_body": "Closes gh-27451\n",
        "linked_issues": [
            {
                "issue_id": "27451",
                "issue_title": "DefaultMessageListenerContainer does not log an error/warning when consumer tasks have been rejected",
                "issue_body": "**Affects:** 5.1.2, 5.3.9\r\n\r\n_Background:_ We experienced an issue due to `DefaultMessageListenerContainer` no longer receiving messages. This was because of a misunderstanding on our part how `ThreadPoolExecutorFactoryBean` works. We used following settings for the executor:\r\n\r\ncorePoolSize=5\r\nmaximumPoolSize=10\r\nqueueCapacity=1\r\n\r\nwhich was injected into a `DefaultMessageListenerContainer` with these parameters:\r\n\r\nconcurrentConsumers=1\r\nmaxConcurrentConsumers=10\r\nmaxMessagesPerTask=1\r\n\r\nThe goal was to have a dynamic scaling of threads aligned with the scaling of consumers; however we shouldn't have set neither a queue capacity nor a maximum pool size and rather used something like `Executors.newCachedThreadPool()`; after all, the container will take care of not scheduling more than maxConcurrentConsumers * 2 threads in the worst case (since each task reschedules itself if all are busy).\r\n\r\nOur problem was reproducible given [this test](https://github.com/grubeninspekteur/defaultmessagelistenercontainer/blob/master/src/test/java/com/example/demo/MessageListenerTest.java), the log is available [here](https://github.com/grubeninspekteur/defaultmessagelistenercontainer/blob/master/experiment.log) (I killed the process after no more messages were being received).\r\n\r\n_The issue:_ There are some rejected task debug level log entries due to the executor misconfiguration, but no warn or error entries. I would expect at least the error \"All scheduled consumers have been paused, probably due to tasks having been rejected. Check your thread pool configuration! Manual recovery necessary through a start() call.\" at [DefaultMessageListenerContainer.java#L1180-L1183](https://github.com/spring-projects/spring-framework/blob/main/spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java#L1180-L1183) to appear. I don't understand why it didn't, since everything happens inside locks held on the `lifecycleMonitor`.\r\n\r\nOn a side note, why is the rejection of tasks logged only at debug level (not even info)? After all, dropping below `concurrentConsumers` raises a warning (this works in the test if I set `concurrentConsumers` to 2). Is there any use case of configuring an executor that occasionally rejects tasks?",
                "issue_state": "closed",
                "issue_comment": [
                    "Not sure why the error did not get logged, but in any case, each individual rejection should get logged at warn level at least. While executor implementations may temporarily reject tasks for any reason, it really isn't the norm, in particular not with the common executor implementations out there. I'll therefore backport the log level change to 5.2.18 as well."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging level for a message indicating a rejected and paused listener container task.  It changes the logging from debug level to warn level",
            "avg_logprobs": -0.13080569236509262
        }
    },
    {
        "commit_hash": "5d5cd17d33c59f105f992373d6e0aa013c7a02d3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t/** Cache of early target objects: cacheKey to bean instance. */\n-\tprivate final Map<Object, Object> earlyTargetReferences = new ConcurrentHashMap<>(16);\n+\tprivate final Map<Object, Object> earlyBeanReferences = new ConcurrentHashMap<>(16);\n-\t\tthis.earlyTargetReferences.put(cacheKey, bean);\n+\t\tthis.earlyBeanReferences.put(cacheKey, bean);\n-\t\t\tif (this.earlyTargetReferences.remove(cacheKey) != bean) {\n+\t\t\tif (this.earlyBeanReferences.remove(cacheKey) != bean) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish \"Rename earlyProxyReferences in AbstractAutoProxyCreator\"",
        "commit_body": "See gh-23914\n",
        "linked_issues": [
            {
                "issue_id": "23914",
                "issue_title": "Rename earlyProxyReferences to earlyBeanReferences in AbstractAutoProxyCreator",
                "issue_body": "The original map named earlyProxyReferences seems to stores the target object, not the proxy object.",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks @chenqimiao. For consistency with the method that fills the cache, I've renamed that to `earlyBeanReferences`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change renames the `earlyTargetReferences` map to `earlyBeanReferences` and updates the corresponding access and modification points within the `AbstractAutoProxyCreator` class.  This suggests a change in the intended meaning of the cache, possibly to better reflect that it stores references to beans rather than just target objects.  The key implication is a renaming of the cache to more accurately reflect its contents.  No significant change to the conditional logic or iteration constructs is apparent",
            "avg_logprobs": -0.4287108195196722
        }
    },
    {
        "commit_hash": "5dcd55b23b5dd43e5e7ef7241c15942ab8ceedb8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\tSimpMessageType messageType = SimpMessageHeaderAccessor.getMessageType(message.getHeaders());\n+\t\t\tif (messageType.equals(SimpMessageType.CONNECT) && logger.isErrorEnabled()) {\n+\t\t\t\tlogger.error(\"Message broker is not active. Ignoring: \" + message);\n+\t\t\t}\n+\t\t\telse if (logger.isDebugEnabled()) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log ignored CONNECT messages at error level",
        "commit_body": "Issue: SPR-11673\n",
        "linked_issues": [
            {
                "issue_id": "16296",
                "issue_title": "no msg when cannot authorize against external queue [SPR-11673]",
                "issue_body": "**[Prashant Deva](https://jira.spring.io/secure/ViewProfile.jspa?name=pdeva)** opened **[SPR-11673](https://jira.spring.io/browse/SPR-11673?redirect=false)** and commented\n\nSo i tried putting in the following lines in my code to pass a fake password:\n\n```\n StompBrokerRelayRegistration registration = config.enableStompBrokerRelay(\"/topic\");\n        registration.setRelayHost(\"xxxx.com\");\n        registration.setSystemPasscode(\"hello\");\n        registration.setClientPasscode(\"hello\");\n\n```\n\nthe funny thing is the logs still just show this:\n\n```\n16:24:47,103  INFO reactor-tcp-io-2 netty.NettyTcpClient:304 - CONNECT: [id: 0x0db8042b, /192.168.1.15:49980 => xxxx.com/162.242.220.165:61613]\n```\n\nof course there is no data transfer cause the msg queue itself wont allow authentication with a non-existent password, but nothing in the logs by spring shows we had a bad authentication\n\n\n---\n\n**Affects:** 4.0.3\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI see this for the \"system\" connection at startup (DEBUG level):\n\n```\n10:21:58 [reactor-tcp-io-1] StompDecoder - Decoded [Payload byte[32]][Headers={stompCommand=ERROR, nativeHeaders={content-type=[text/plain], message=[Bad CONNECT], content-length=[32], version=[1.0,1.1,1.2]}, simpMessageType=OTHER, contentType=text/plain, id=31149240-3fb5-63b8-15fd-11166e51e9f2, timestamp=1398867718551}]\n```\n\nAnd then this for client connections later (TRACE level):\n\n```\n10:22:31 [clientInboundChannel-2] StompBrokerRelayMessageHandler - Message broker is not active. Ignoring message id=7ac7d601-e1a9-587b-5dbc-a78dd0ac73dd\n```\n\nI made changes so that:\n\n(a) any STOMP ERROR frame received from the broker is logged at **error** level\n(b) any client CONNECT frame ignored when the broker is inactive is logged at **error** level\n(c) any other client message ignored when the broker is inactive is logged at **debug** level\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI'm marking this resolved. The messages should now appear as expected.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `CONNECT` messages and logs an error if the message broker is inactive.  Previously, all debug-level logging was handled by a single `if (logger.isDebugEnabled())` block.  Now, a `CONNECT` message is specifically checked and logged at the error level if the broker is inactive, while other debug-level logging is handled by the subsequent `else if` block.  This improves logging specificity and prioritizes error reporting for critical connection attempts",
            "avg_logprobs": -0.2612171745300293
        }
    },
    {
        "commit_hash": "5ec2cd79470aeaa8e676dfbe794a63b189349fa2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {\n+\t\t\t\tlogger.warn(\"Custom isolation level specified but no actual transaction initiated; \" +\n+\t\t\t\t\t\t\"isolation level will effectively be ignored: \" + definition);\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AbstractPlatformTransactionManager logs warning for custom isolation level in case of no actual transaction",
        "commit_body": "Issue: SPR-12600\n",
        "linked_issues": [
            {
                "issue_id": "17201",
                "issue_title": "Log warning for Isolation.READ_UNCOMMITTED with Propagation.NOT_SUPPORTED [SPR-12600]",
                "issue_body": "**[Ethan Zhang](https://jira.spring.io/secure/ViewProfile.jspa?name=ethanzhang)** opened **[SPR-12600](https://jira.spring.io/browse/SPR-12600?redirect=false)** and commented\n\nThe actual Isolation Level for the setting\n\"`@Transactional`(propagation = Propagation.NOT_SUPPORTED, isolation = Isolation.READ_UNCOMMITTED)\"\nis READ_COMMITTED rather than READ_UNCOMMITTED.\n\nThe environment:\nspring: 3.1.0\nhibernate: 3.5.6\n\n---\n\n**Affects:** 3.1 GA\n\n**Issue Links:**\n- #19583 Validation of existing transactions with transaction synchronization turned off not working (?)\n- #11234 Rollback of transaction participating in nested transaction should not enforce rollback of global transaction\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/5ec2cd79470aeaa8e676dfbe794a63b189349fa2\n\n0 votes, 6 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nNote that isolation levels are just supported within actual transactions, i.e. propagation REQUIRED or REQUIRES_NEW, initiating a resource transaction.\n\nYour configuration essentially suggests non-transactional execution, which - in the JDBC case - a JDBC driver doesn't support an isolation level for (since an underlying RDBMS doesn't support isolation levels in auto-commit mode).\n\nJuergen\n",
                    "**[Ethan Zhang](https://jira.spring.io/secure/ViewProfile.jspa?name=ethanzhang)** commented\n\nThanks a lot.\nI see, isolation levels are just supported within actual transactions!\n\nAnd I think it will be better if Spring can warn such configuration (configured a isolation level for Propagation.NOT_SUPPORTED).\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point, we could log a warning for such a scenario, assuming that the combination of settings never really makes sense...\n\nJuergen\n",
                    "**[Hanh Pham](https://jira.spring.io/secure/ViewProfile.jspa?name=hpham)** commented\n\nHi Jurgen,\n\nif you have this transactional configuration, you would also get the warning, although you do not need a transaction. Is this correct?\n\n`@Transactional`(propagation = Propagation.SUPPORTS, isolation = Isolation.REPEATABLE_READ, readOnly = true)\n\nThe commit:\nhttps://github.com/spring-projects/spring-framework/commit/5ec2cd79470aeaa8e676dfbe794a63b189349fa2\n\nHanh\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, you would also get the warning with that configuration, since your isolation level will always get ignored in that case as well. It's always the outermost transaction boundary initiating the isolation level, so a SUPPORTS boundary will never actually initiate it... Therefore you can simply omit the isolation level in such a case.\n\nJuergen\n",
                    "**[Hanh Pham](https://jira.spring.io/secure/ViewProfile.jspa?name=hpham)** commented\n\nThat right, this is my errors in reasoning. With SUPPORTS you can use exisiting transaction and with exisiting transaction you use the isolation level of the existing transaction.\n\nThanks for your answer.\n\nHanh\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check to see if a custom isolation level is specified in a `TransactionDefinition`.  If a custom level is set, but no actual transaction is initiated, a warning is logged to the logger, indicating that the isolation level will be ignored.  This is a defensive programming measure to prevent unexpected behavior",
            "avg_logprobs": -0.1905933086688702
        }
    },
    {
        "commit_hash": "5f2e298c08255bbda2b36ad0351146748d847bc6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\tboolean debugEnabled = logger.isDebugEnabled();\n-\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tif (debugEnabled) {\n-\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\tif (debugEnabled) {\n+\t\tboolean debugEnabled = logger.isDebugEnabled();\n-\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tif (debugEnabled) {\n-\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tif (debugEnabled) {",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Extract isDebugEnabled() checks to local variables",
        "commit_body": "Closes gh-24683",
        "linked_issues": [
            {
                "issue_id": "24683",
                "issue_title": "Extract isDebugEnabled() checks to local variables",
                "issue_body": "Add log level checks before log input in some classes.",
                "issue_state": "closed",
                "issue_comment": [
                    "@sbrannen Thanks for your review.\r\nI have updated this PR according to your guidance.\r\nLooking forward to your reply again.\r\n",
                    "This has been merged into `master` after various changes to the original PR. Please see the \"Show resolved\" comments for details.\r\n\r\nThanks",
                    "@sbrannen Thank you for your patience in explaining and modifying this PR , I have read every comment in detail, and I will pay more attention to these details in the future. Thanks again!\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code refactored the repeated `logger.isDebugEnabled()` checks within a block of code.  It now caches the result of `logger.isDebugEnabled()` into a `debugEnabled` boolean variable, improving efficiency by avoiding redundant calls to the logger. This change significantly reduces the number of method calls to the logger",
            "avg_logprobs": -0.22033600509166718
        }
    },
    {
        "commit_hash": "6013591fac1444df88bb75542367633373603a45",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/CollectionUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (isEmpty(source) || isEmpty(candidates)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor (Object candidate : candidates) {\n-\t\t\tif (source.contains(candidate)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n+\t\treturn findFirstMatch(source, candidates) != null;",
        "change_count": 10,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polish containsAny of CollectionUtils by reusing findFirstMatch",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The original code checked if both `source` and `candidates` were empty, and then iterated through `candidates` to see if any element was present in `source`.  The revised code uses a new method `findFirstMatch(source, candidates)` which likely performs the same check for emptiness and the iteration, but in a more concise and potentially optimized way.  The core logic of checking for a match within the collection is replaced by a single method call, improving readability and potentially performance",
            "avg_logprobs": -0.19336633682250975
        }
    },
    {
        "commit_hash": "60fac678844a5626f4f5c7150a648b981c4ce427",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/MediaType.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\n-\n+\t/**\n+\t * Create a new {@code MediaType} for the given {@link MimeType}.\n+\t * The type, subtype and parameters information is copied and {@code MediaType}-specific\n+\t * checks on parameters are performed.\n+\t * @param mimeType the MIME type\n+\t * @throws IllegalArgumentException if any of the parameters contain illegal characters\n+\t * @since 5.3.0\n+\t */\n-\t\tfor(MimeType mimeType : mimeTypes) {\n+\t\tfor (MimeType mimeType : mimeTypes) {",
        "change_count": 5,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polish",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a new constructor to the `MediaType` class in Spring's `http` package.  This constructor takes a `MimeType` object as input and creates a new `MediaType` instance from it.  Crucially, it performs validation on the parameters of the `MimeType` to ensure they conform to `MediaType`'s requirements.  The change also includes Javadoc documentation explaining the purpose and parameters of the new constructor",
            "avg_logprobs": -0.27594449996948245
        }
    },
    {
        "commit_hash": "61117245a6fa5ef793bfd447f6edaa4c1d432684",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t\t\t\t\tfor (int i = 0; i < arguments.length; i++) {\n-\t\t\t\t\t\t\t\tcachedMethodArguments[i] = descriptors[i];\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tSystem.arraycopy(descriptors, 0, cachedMethodArguments, 0, arguments.length);",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Replace manual array copy with native method call",
        "commit_body": "Closes gh-1606\n",
        "linked_issues": [
            {
                "issue_id": "1606",
                "issue_title": "Replace manual array copy with native method call",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": [
                    "Merged, thanks!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a manual loop (`for` loop) for copying elements from the `descriptors` array to the `cachedMethodArguments` array with a `System.arraycopy` method.  This is a more efficient way to perform the array copy",
            "avg_logprobs": -0.1495021184285482
        }
    },
    {
        "commit_hash": "6251222a23415d8b8788e79b9c208d3208988685",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\tprivate static volatile boolean kotlinWarningLogged;\n-\n-\t\t\t\tif (!kotlinWarningLogged) {\n-\t\t\t\t\tkotlinWarningLogged = true;\n-\t\t\t\t\tlogger.warn(\"For Jackson Kotlin classes support please add \" +\n-\t\t\t\t\t\t\t\"\\\"com.fasterxml.jackson.module:jackson-module-kotlin\\\" to the classpath\");\n-\t\t\t\t}\n+\t\t\t\t// jackson-module-kotlin not available",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove jackson-module-kotlin warning",
        "commit_body": "Closes gh-26962\n",
        "linked_issues": [
            {
                "issue_id": "26962",
                "issue_title": "Remove jackson-module-kotlin warning",
                "issue_body": "The Apollo GraphQL client depends on OkHttp 3 which depends on Kotlin. In a Java-based application, this results in the following warning being logged:\r\n\r\n```\r\n2021-05-20 19:06:02.663  WARN 41818 --- [kground-preinit] o.s.h.c.j.Jackson2ObjectMapperBuilder    : For Jackson Kotlin classes support please add \"com.fasterxml.jackson.module:jackson-module-kotlin\" to the classpath\r\n```\r\n\r\nAdding `com.fasterxml.jackson.module:jackson-module-kotlin` isn't the right thing to do as Jackson isn't handling any Kotlin types. The warning is the only logging done by `Jackson2ObjectMapperBuilder` so I could raise its log level to error without losing anything, but you have to know that's the right thing to do. I suspect many will unnecessarily add the dependency instead. In short, the warning feels a bit over-zealous to me.\r\n\r\nI wonder if it would be possible to detect an actual problem caused by the lack of `jackson-module-kotlin` and log something at that point instead? If that's not possible, perhaps the log message could be lowered to info level and softened a bit to indicate that `jackson-module-kotlin` is only needed if Jackson will be dealing with Kotlin classes?",
                "issue_state": "closed",
                "issue_comment": [
                    "I think would just remove that warning and refine the documentation to make that point more visible. It was introduced in the early days of Spring's Kotlin support, it is coming from how Jackson is architectured and nowadays most developers know how it works, https://start.spring.io/ and https://spring.io/guides/tutorials/spring-boot-kotlin/ being there for beginners.",
                    "In another project we also get the warn now after updating to spring-boot 2.5.\r\nThe project does not have Apollo GraphQL as a dependency. \r\nThe reason why `kotlin-stdlib-jdk8` is in the list of the projects dependencies is spring-security-config version 5.5.0.\r\nSpring-security-config 5.5.0 has `kotlin-stdlib-jdk8` as a compile dependency!",
                    "@julius-d can you please report that issue [against Spring Security](https://github.com/spring-projects/spring-security)?. The dependency change that you've described must be addressed there and there's nothing we can do about it here.",
                    "@julius-d Looks like [spring-security#9811](https://github.com/spring-projects/spring-security/issues/9811) is the same issue?\r\n\r\n/cc @snicoll \r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes the conditional check and logging of a warning about the missing `jackson-module-kotlin` dependency.  The code now unconditionally skips the warning, effectively disabling it.  This suggests the warning is no longer considered necessary or the developer anticipates the dependency will always be present",
            "avg_logprobs": -0.3544917271055024
        }
    },
    {
        "commit_hash": "62ea627965eb10eb3f3c2b2388ff6d1ac7ddb3a6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\n-\t\t\t\tif (Class.class.equals(beanClass) && \"classLoader\".equals(pd.getName())) {\n-\t\t\t\t\t// Ignore Class.getClassLoader() method - nobody needs to bind to that\n+\t\t\t\tif (Class.class.equals(beanClass) &&\n+\t\t\t\t\t\t(\"classLoader\".equals(pd.getName()) ||  \"protectionDomain\".equals(pd.getName()))) {\n+\t\t\t\t\t// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Revised exclusion of java.lang.Class properties",
        "commit_body": "Issue: SPR-11098\n",
        "linked_issues": [
            {
                "issue_id": "15724",
                "issue_title": "Minor issue with fix for CVE 2010-1622 [SPR-11098]",
                "issue_body": "**[John Melton](https://jira.spring.io/secure/ViewProfile.jspa?name=jtmelton)** opened **[SPR-11098](https://jira.spring.io/browse/SPR-11098?redirect=false)** and commented\n\nThere is a minor issue with the fix for CVE 2010-1622 (http://docs.spring.io/spring/docs/2.5.6.SEC03/changelog.txt). I don't have an exploitable vulnerability, but the issue could lead to a security issue. I couldn't find on the site how to specify this was a security issue and didn't want to post it in the open. Please let me know how to post with the visibility restricted.\n\n\n---\n\n**Affects:** 4.0 RC1\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/62ea627965eb10eb3f3c2b2388ff6d1ac7ddb3a6, https://github.com/spring-projects/spring-framework/commit/7f895222e17b0970d4f9ab038b2f03c26aaf6f03\n\n**Backported to:** [3.2.6](https://github.com/spring-projects/spring-framework/milestone/94?closed=1)\n\n0 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nFeel free to send it to me via email (it's gopivotal.com and I'm jhoeller there).\n\nJuergen\n",
                    "**[John Melton](https://jira.spring.io/secure/ViewProfile.jspa?name=jtmelton)** commented\n\nI emailed you a couple days ago, but received no response yet. Can you confirm you received it?\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for the `protectionDomain` property in addition to `classLoader` when determining whether to ignore a property.  Previously, only `classLoader` was excluded; now, `getProtectionDomain()` is also ignored.  This likely prevents binding to these methods, potentially for performance or security reasons",
            "avg_logprobs": -0.16035298145178592
        }
    },
    {
        "commit_hash": "62efdfb89c368fd3a3665fe78a7180692d174c23",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/cglib/proxy/MethodProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!c1.isInterface() && c1 != Object.class && !Factory.class.isAssignableFrom(c2)) {\n+\t\tif (c1 != Object.class && c1.isAssignableFrom(c2.getSuperclass()) && !Factory.class.isAssignableFrom(c2)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Try early initialization for all user-declared methods (including interfaces)",
        "commit_body": "Closes gh-32682\n",
        "linked_issues": [
            {
                "issue_id": "32682",
                "issue_title": "ConfigurationClassEnhancer should consistently trigger FastClass creation at build-time",
                "issue_body": "This is a follow-up of #32609 where we don't seem to generate the necessary FastClass when the factory bean method is declared in a parent interface.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement related to class compatibility checks.  The original condition checked if `c1` was not an interface, not the `Object` class, and `c2` was not assignable from `Factory`.  The revised condition checks if `c1` is not the `Object` class, if `c1` is assignable from `c2`'s superclass, and if `c2` is not assignable from `Factory`",
            "avg_logprobs": -0.12224141120910645
        }
    },
    {
        "commit_hash": "6305a69cc14f90a6e65e96362d38cab46e6c8b07",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/ContentDisposition.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+ * @author Sergey Tsypanov\n-\t\t\tsb.append((c == '\"' && !escaped) ? \"\\\\\\\"\" : c);\n+\t\t\tif (!escaped && c == '\"') {\n+\t\t\t\tsb.append(\"\\\\\\\"\");\n+\t\t\t} else {\n+\t\t\t\tsb.append(c);\n+\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid StringBuilder.append(Object) in ContentDisposition",
        "commit_body": "This commit avoids invoking StringBuilder.append(Object) in favor\nof explicit method calls to append(String) and append(char) in\nContentDisposition.escapeQuotationsInFilename(String).\n\nCloses gh-25056",
        "linked_issues": [
            {
                "issue_id": "25056",
                "issue_title": "Avoid StringBuilder.append(Object) in ContentDisposition",
                "issue_body": "The return type of expression `(c == '\"' && !escaped) ? \"\\\\\\\"\" : c` is `Object`, which implies a call to `StringBuilder.append(Object)`.\r\n\r\nThe implementation of the following means that lots of garbage objects are allocated as a result of `String.valueOf()`.\r\n\r\n\r\n```java\r\n@Override\r\npublic StringBuilder append(Object obj) {\r\n    return append(String.valueOf(obj));\r\n}\r\n```\r\n\r\nInstead of covariant append we can use exact signatures, i.e. one taking `char` and one taking `String` which allows us to avoid unnecessary allocations.\r\n\r\nThis [benchmark](https://raw.githubusercontent.com/stsypanov/strings/master/src/jmh/java/tsypanov/strings/string/StringBuilderCovariantAppendBenchmark.java) demonstrates significant improvement even for filename of length = 10:\r\n\r\n```\r\nJDK 8\r\n\r\nBenchmark                              (latin)  (length)  Mode  Cnt     Score     Error   Units\r\nappendCovariant                           true        10  avgt   50   180.230 \u00b1  10.346   ns/op\r\nappendExact                               true        10  avgt   50    68.517 \u00b1   1.479   ns/op\r\n\r\nappendCovariant                          false        10  avgt   50   177.713 \u00b1   4.438   ns/op\r\nappendExact                              false        10  avgt   50    67.798 \u00b1   1.364   ns/op\r\n\r\nappendCovariant:\u00b7gc.alloc.rate.norm       true        10  avgt   50   688.000 \u00b1   0.001    B/op\r\nappendExact:\u00b7gc.alloc.rate.norm           true        10  avgt   50   112.000 \u00b1   0.001    B/op\r\n\r\nappendCovariant:\u00b7gc.alloc.rate.norm      false        10  avgt   50   816.000 \u00b1   0.001    B/op\r\nappendExact:\u00b7gc.alloc.rate.norm          false        10  avgt   50   112.000 \u00b1   0.001    B/op\r\n\r\nJDK 14\r\n\r\nBenchmark                              (latin)  (length)  Mode  Cnt     Score     Error   Units\r\nappendCovariant                           true        10  avgt   50   228.858 \u00b1  18.627   ns/op\r\nappendExact                               true        10  avgt   50    57.950 \u00b1   2.660   ns/op\r\n\r\nappendCovariant                          false        10  avgt   50   292.879 \u00b1  12.408   ns/op\r\nappendExact                              false        10  avgt   50    90.228 \u00b1   2.277   ns/op\r\n\r\nappendCovariant:\u00b7gc.alloc.rate.norm       true        10  avgt   50   688.026 \u00b1   0.002    B/op\r\nappendExact:\u00b7gc.alloc.rate.norm           true        10  avgt   50   112.004 \u00b1   0.001    B/op\r\n\r\nappendCovariant:\u00b7gc.alloc.rate.norm      false        10  avgt   50  1096.040 \u00b1   0.002    B/op\r\nappendExact:\u00b7gc.alloc.rate.norm          false        10  avgt   50   200.008 \u00b1   0.001    B/op\r\n```\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks",
                    "Good catch!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a conditional append operation within a string builder with an `if-else` block.  The original code conditionally escaped double quotes; the updated code explicitly handles the escaping case, making the logic more readable and potentially more efficient.  The change improves the clarity of the escaping logic",
            "avg_logprobs": -0.2835252126057943
        }
    },
    {
        "commit_hash": "63fae8c5a7ea21e4ff59ee094cc4541c048e8e54",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/aot/generate/ClassNameGenerator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "- * Generates unique class names that can be used in ahead-of-time generated\n- * source code. This class is stateful so the same instance should be used for\n- * all name generation. Most commonly the class name generator is obtained via a\n- * {@link GenerationContext}.\n+ * Generate unique class names based on an optional target {@link Class} and\n+ * a feature name. This class is stateful so the same instance should be used\n+ * for all name generation. Most commonly the class name generator is obtained\n+ * via a {@link GenerationContext}.\n+ * @author Stephane Nicoll\n-\t * Generate a new class name for the given {@code target} /\n-\t * {@code featureName} combination.\n-\t * @param target the target of the newly generated class or {@code null} if\n-\t * there is not target.\n+\t * Generate a unique {@link ClassName} based on the specified {@code target}\n+\t * class and {@code featureName}. If a {@code target} is specified, the\n+\t * generated class name is a suffixed version of it.\n+\t * <p>For instance, a {@code com.example.Demo} target with an\n+\t * {@code Initializer} feature name leads to a\n+\t * {@code com.example.Demo__Initializer} generated class name. If such a\n+\t * feature was already requested for this target, a counter is used to\n+\t * ensure uniqueness.\n+\t * <p>If there is no target, the {@code featureName} is used to generate the\n+\t * class name in the {@value #AOT_PACKAGE} package.\n+\t * @param target the class the newly generated class relates to, or\n+\t * {@code null} if there is not target\n-\t\tif(target != null) {\n-\t\t\treturn generateSequencedClassName(target.getName().replace(\"$\", \"_\") + SEPARATOR + StringUtils.capitalize(featureName));\n+\t\tif (target != null) {\n+\t\t\treturn generateSequencedClassName(target.getName().replace(\"$\", \"_\")\n+\t\t\t\t\t+ SEPARATOR + StringUtils.capitalize(featureName));\n-\t\treturn generateSequencedClassName(AOT_PACKAGE+ featureName);\n+\t\treturn generateSequencedClassName(AOT_PACKAGE + featureName);",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Clarify the scope of target in ClassNameGenerator",
        "commit_body": "Closes gh-28517\n",
        "linked_issues": [
            {
                "issue_id": "28517",
                "issue_title": "Ambiguous behavior for ClassNameGenerator::generateClassName",
                "issue_body": "`ClassNameGenerator` has two variants for the `generateClassName` feature. One that takes a target `Class<?>` and another that takes a target `String`. I'm a bit confused by the concept of a target here and I think we should explain that a bit more in the javadocs.\r\n\r\nThese methods also have different behavior:\r\n\r\n```java\r\nClassName first = this.generator.generateClassName(java.io.InputStream.class, \"bytes\");\r\n// will result in java.io.InputStream__Bytes\r\n\r\nClassName first = this.generator.generateClassName(\"java.io.InputStream\", \"bytes\");\r\n// will result in __.JavaIoInputStream__Bytes\r\n```\r\n\r\nEven if the difference of behavior is intended, the name and docs are very similar. Also, a common use case for the `ClassNameGenerator` is about generating sources in a specific package to work around visibility issues. The second variant can make this case more difficult to achieve.\r\n\r\nAs a side note, this class is also referring to the now defunct `@see GeneratedClassName`.\r\n\r\ncc @philwebb @snicoll ",
                "issue_state": "closed",
                "issue_comment": [
                    "The `String` variant was added to support generation where there isn't a single class that can be linked. I think it's currently only used in `BeanRegistrationsAotContribution`. We should probably rename that method to make it clearer that there is no target class.\r\n\r\nI know @snicoll was wondering about the use of the `__` package in general, perhaps we can make the generated `BeanRegistrations` class be in the same package as the `@SpringBootApplication` class then we can drop the string version entirely.\r\n\r\nThe `ClassNameGenerator` should be removed, we dropped that class during the prototype work.",
                    "The second method that takes a `String` rather than a `Class<?>` has been removed in 4bd33cb6e0659df2cd0b9fa04feea8fd77e5a16d. I am going to look at the Javadoc and see if we can clarify "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the `ClassNameGenerator` class to improve clarity and functionality.  The most significant change is the introduction of a `target` parameter, allowing the generation of class names based on a specific target class.\\n\\n**Before:**\\n\\nThe class name was generated solely from the `featureName`.\\n\\n**After:**\\n\\nThe class name is now generated as a suffix of the `target` class's name, followed by the `featureName`",
            "avg_logprobs": -0.2670771217346191
        }
    },
    {
        "commit_hash": "66c63c374b8be03f765a84a386932920e6580402",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/session/AbstractSockJsSession.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import java.util.concurrent.ConcurrentHashMap;\n-\tprivate final Map<String, Object> attributes;\n+\tprivate final Map<String, Object> attributes = new ConcurrentHashMap<String, Object>();\n-\t\tthis.attributes = attributes;\n+\n+\t\tif (attributes != null) {\n+\t\t\tthis.attributes.putAll(attributes);\n+\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ensure handshake attrs are copied in SockJS session",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `Map<String, Object> attributes` field initialized later with a `ConcurrentHashMap<String, Object>` initialized directly.  Crucially, it now checks if the incoming `attributes` map is null before copying its contents to the new `this.attributes` map. This prevents a `NullPointerException` if the `attributes` parameter is null.  Essentially, the code now handles potential null input more robustly",
            "avg_logprobs": -0.2366178512573242
        }
    },
    {
        "commit_hash": "66e488850be2169e94c9daf161fb682094132ac2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-r2dbc/src/main/java/org/springframework/r2dbc/connection/init/ScriptUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * @since 5.2.16\n+\t * @since 5.3.8\n-\t\t\tif (!EOF_STATEMENT_SEPARATOR.equals(separatorToUse) && !containsSqlScriptDelimiters(statement, separatorToUse)) {\n+\t\t\tif (!EOF_STATEMENT_SEPARATOR.equals(separatorToUse) &&\n+\t\t\t\t\t!containsStatementSeparator(resource, statement, separatorToUse, commentPrefixes,\n+\t\t\t\t\t\tblockCommentStartDelimiter, blockCommentEndDelimiter)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ignore comments when searching for statement delimiter in ScriptUtils",
        "commit_body": "This commit picks up where 569ce840cf left off, by correctly invoking\nthe new containsStatementSeparator(...) method from\nexecuteSqlScript(...) in ScriptUtils in spring-r2dbc.\n\nSee gh-26911\n",
        "linked_issues": [
            {
                "issue_id": "26911",
                "issue_title": "Ignore comments when searching for SQL statement delimiter in ScriptUtils",
                "issue_body": "Spring Version: 5.3.4\r\nJDK: 15\r\n\r\nThe spring utility class ```org.springframework.jdbc.datasource.init.ScriptUtils``` falsely interepts single quote literals found within block comments of SQL resource files.\r\n\r\nTo understand the impact of this bug, I'll illustrate a scenario.\r\n\r\n**schema.sql**\r\n\r\n```sql\r\n/*\r\n    It's function is as follows..\r\n*/\r\n\r\nALTER TABLE public.User ADD CONSTRAINT\r\nUSER_PK PRIMARY KEY(id); \r\n...\r\n\r\n```\r\n\r\nFrom the resource file above, let's assume that the statement delimiter is that of ```ScriptUtils.DEFAULT_STATEMENT_SEPARATOR``` (';') and, accordingly, default comment block start & end separators are used as well ('/*  ...  */').\r\n\r\nLet's also make another assumption: the single quote found in the block comment within the ```schema.sql``` resource file is the only single quote in the entire resource file.\r\n\r\nIn my java utility class, my goal is to execute the statements in my resource file against a given JDBC connection. It would look something as follows:\r\n\r\n```java\r\nResource resource = new ClassPathResource(\"classpath:schema.sql\", Thread.currentThread().getContextClassLoader());\r\nEncodedResource encoded = new EncodedResource(resource, \"UTF-8\");\r\nScriptUtils.executeSql (getConnection(), encoded);\r\n```\r\n\r\nWhere ```getConnection()``` corresponds to my JDBC connection (assume it works accordingly). \r\n\r\nAccordingly, I would be met with a fault that looks similar to the following:\r\n\r\n```\r\norg.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement...\r\nALTER TABLE public.User ADD CONSTRAINT; ; nested exception is org.postgresql.util.PSQLException: ERROR: syntax error at end of input Position: 47\r\n```\r\nNotice how in the error message, it displays a **partial** SQL statement of what is intended.  This is because the ```.executeSql(...)``` function call defaulted to its FALLBACK_STATEMENT_SEPARATOR, \"\\n\". How do I know this?\r\n\r\nThe following is a fraction of code that is currently contained, at the time of writing this, is found within the ```.executeSql(...)``` internal call:\r\n\r\n```java\r\nif (separator == null) {\r\n\tseparator = DEFAULT_STATEMENT_SEPARATOR;\r\n}\r\nif (!EOF_STATEMENT_SEPARATOR.equals(separator) && !containsSqlScriptDelimiters(script, separator)) {\r\n\tseparator = FALLBACK_STATEMENT_SEPARATOR;\r\n}\r\n```\r\n\r\nSo I did a bit of digging and exploring within the internal check to ```containsSqlScriptDelimiters(...)``` and found the following:\r\n\r\n```java\r\npublic static boolean containsSqlScriptDelimiters(String script, String delim) {\r\n\t\tboolean inLiteral = false;\r\n\t\tboolean inEscape = false;\r\n\r\n\t\tfor (int i = 0; i < script.length(); i++) {\r\n\t\t\tchar c = script.charAt(i);\r\n\t\t\tif (inEscape) {\r\n\t\t\t\tinEscape = false;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// MySQL style escapes\r\n\t\t\tif (c == '\\\\') {\r\n\t\t\t\tinEscape = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c == '\\'') {\r\n\t\t\t\tinLiteral = !inLiteral;\r\n\t\t\t}\r\n\t\t\tif (!inLiteral && script.startsWith(delim, i)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n``` \r\n\r\nThe problem here is that it does not distinguish between literal single quotes from within block comments and executable statements. This is an issue because, going back to my resource file: ```schema.sql```, since I declared only a single literal quote within my inital block comment, the parsing fails to acknowledge the separator delimiter ( ';', in this case) within my executable portion (it's waiting for the end literal character!) and falls back to using the FALLBACK_STATEMENT_SEPARATOR. \r\n\r\nHere's the workaround I'm currently using:\r\n\r\n```sql\r\n/*\r\n    It\\'s function is as follows..\r\n*/\r\n\r\nALTER TABLE public.User ADD CONSTRAINT\r\nUSER_PK PRIMARY KEY(id); \r\n...\r\n\r\n```\r\n\r\nEscape single quotes within comments (for now)!\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Thank you for bringing this to our attention.\r\n\r\nWhile analyzing the issue, I discovered a separate issue regarding double quotes which will be addressed in #26935 for `5.3.x` and backported to `5.2.x`.\r\n\r\nThe issue you have raised here applies not only to block comments but also to single-line comments. In addition, it applies to the `ScriptUtils` implementations in `spring-jdbc` and `spring-r2dbc`.\r\n\r\nWe will investigate a fix for `5.3.x` and consider a backport to `5.2.x`.\r\n\r\nIn the interim, please continue using the workaround you discovered.",
                    "This has been fixed for 5.3.8 in 569ce840cf720b6534e5ff670fc34eaa151b73cb and backported to 5.2.16 in e4d843e41e61bc93b95d2431075a886aebd552f8.\r\n\r\nFeel free to try it out in the upcoming snapshots for 5.3.8 and 5.2.16."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the conditional logic within `ScriptUtils.java`.  Specifically, the `containsSqlScriptDelimiters` method has been replaced by a more complex `containsStatementSeparator` method, which now takes additional parameters (resource, statement, commentPrefixes, blockCommentStartDelimiter, blockCommentEndDelimiter).  This suggests a broader change in how statement separators are handled, likely to better accommodate different SQL script formats and comments",
            "avg_logprobs": -0.2685432052612305
        }
    },
    {
        "commit_hash": "674dc2f2039fb6186b35ab674c3046ecd5809bb3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tif (isEnableLoggingRequestDetails()) {\n+\t\t\tif (StringUtils.startsWithIgnoreCase(request.getContentType(), \"multipart/\")) {\n+\t\t\t\tparams = \"multipart\";\n+\t\t\t}\n+\t\t\telse if (isEnableLoggingRequestDetails()) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Do not log request parameters for multipart requests",
        "commit_body": "Closes gh-27350\n",
        "linked_issues": [
            {
                "issue_id": "27350",
                "issue_title": "CommonsMultipartResolver and DEBUG logging lead to empty fileMap in MultipartHttpServletRequest",
                "issue_body": "**Affects:** \\\r\nSpring: 5.3.9 but the error also occurs in earlier Versions (i could also reproduce it with 5.2.6)\r\n\r\n**Problem:**\r\nIf a CommonsMultipartResolver is used to Handle File Upload to a Spring RestController and the LogLevel of the Dispatcher Servlet is set to DEBUG a Request Containing a Multipart File leads to an empty FileMap on the MultipartHttpServletRequest. If eighter the LogLevel is not DEBUG or another Resolver is used the same Request contains a FileMap,.\r\n\r\n**Expected Behavior:**\r\nThe expected behavior would be that he LogLevel and the choice of the MultipartResolver do not change the behavior and the Request should always contain a File on the MultipartHttpServletRequest.\r\n\r\n**Example Application:**\r\nI created an example Application to check the behavior here:\r\nhttps://gitlab.com/katja_m_franz/springbug\r\nIt is a really small Application and i hope you can easily reproduce the described Problem. All Info on how to do that can be found on the projects readme.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a new conditional check to determine whether to log request details.  Previously, logging was controlled solely by `isEnableLoggingRequestDetails()`.  Now, if the request content type is \"multipart/\", the `params` variable is set to \"multipart\", *and then* the original logging check (`isEnableLoggingRequestDetails()`) is performed.  This suggests a prioritization of logging multipart requests separately",
            "avg_logprobs": -0.16952081059300622
        }
    },
    {
        "commit_hash": "67e3b1b5310b9ecc4cbcab6dab1262d5369bbde8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate final Map<Object, Object> earlyProxyReferences = new ConcurrentHashMap<>(16);\n+\t/** Cache of early target objects: cacheKey to bean instance. */\n+\tprivate final Map<Object, Object> earlyTargetReferences = new ConcurrentHashMap<>(16);\n-\t\tthis.earlyProxyReferences.put(cacheKey, bean);\n+\t\tthis.earlyTargetReferences.put(cacheKey, bean);\n-\t\t\tif (this.earlyProxyReferences.remove(cacheKey) != bean) {\n+\t\t\tif (this.earlyTargetReferences.remove(cacheKey) != bean) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Rename earlyProxyReferences in AbstractAutoProxyCreator",
        "commit_body": "See gh-23914\n",
        "linked_issues": [
            {
                "issue_id": "23914",
                "issue_title": "Rename earlyProxyReferences to earlyBeanReferences in AbstractAutoProxyCreator",
                "issue_body": "The original map named earlyProxyReferences seems to stores the target object, not the proxy object.",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks @chenqimiao. For consistency with the method that fills the cache, I've renamed that to `earlyBeanReferences`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change renames `earlyProxyReferences` to `earlyTargetReferences` and modifies the corresponding access to reflect this change.  This suggests a refactoring to distinguish between caching proxy objects and caching target objects.  The `if` statement now checks for the removal of the target object from the cache, rather than a proxy object.  This likely improves clarity and consistency in the code, potentially avoiding unintended behavior related to caching proxies",
            "avg_logprobs": -0.365548294581724
        }
    },
    {
        "commit_hash": "67f184293b94c076b0474231f739a74f42d5ffa8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tAssert.notNull(key, \"Null key returned for cache operation (maybe you are using named params \" +\n-\t\t\t\t\"on classes without debug info?) \" + context.metadata.operation);\n+\t\tif (key == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Null key returned for cache operation (maybe you are \" +\n+\t\t\t\t\t\"using named params on classes without debug info?) \" + context.metadata.operation);\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improve performance of generateKey",
        "commit_body": "Only compute the error message to display when the generated key is\nactually null instead of using Assert.notNull as the cache operation\n'toString()' method is non trivial and gets computed regardless of the\nresult.\n\nIssue: SPR-12527\n",
        "linked_issues": [
            {
                "issue_id": "17132",
                "issue_title": "CacheAspectSupport 's generateKey method should not concatenate Strings [SPR-12527]",
                "issue_body": "**[Kyrill Alyoshin](https://jira.spring.io/secure/ViewProfile.jspa?name=kyrill007)** opened **[SPR-12527](https://jira.spring.io/browse/SPR-12527?redirect=false)** and commented\n\n**CacheAspectSupport** class has the following line of code at the beginning of its **generateKey** method:\n\n```\nAssert.notNull(key, \"Null key returned for cache operation (maybe you are using named params \" +\n\t\t\t\t\"on classes without debug info?) \" + context.operation);\n```\n\nYourKit shows that this single method call takes about 15% of total time when invoking a \"cached\" method through Spring caching pipeline. It is not surprising because **context.operation** object has a non-trivial implementation of the **toString** method.\n\nWe really think that this _Assert.notNull_ call should be refactored into _if(key == null)..._ for performance reasons.\n\n\n---\n\n**Affects:** 4.1.3\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/67f184293b94c076b0474231f739a74f42d5ffa8\n\n**Backported to:** [4.0.9](https://github.com/spring-projects/spring-framework/milestone/121?closed=1)\n\n1 votes, 3 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nGood catch, most of the logging usage of `CacheOperation` are guarded by `logger.isTraceEnabled` - This may also be a nice improvements for Spring 4.0.x (that piece of code of yours is coming from 4.0.x I think)\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nFixed.\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller), I think that's a good candidate for a backport. What do you think?\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `Assert.notNull` check with an explicit `if` statement and `IllegalArgumentException` for a null `key`.  This change is functionally equivalent but provides more granular control over exception handling.  The original `Assert.notNull` likely wrapped the exception in a `IllegalArgumentException` internally, but the new code directly throws the exception",
            "avg_logprobs": -0.30761102127702267
        }
    },
    {
        "commit_hash": "6806aaf162f396e89cc07735d399737c87bcd2a1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CollectionFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\telse if (TreeSet.class == collectionType || SortedSet.class == collectionType || NavigableSet.class == collectionType) {\n+\t\telse if (TreeSet.class == collectionType || NavigableSet.class == collectionType\n+\t\t\t\t|| SortedSet.class == collectionType) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish \"Add missing TreeSet to CollectionFactory.createCollection()\"",
        "commit_body": "See gh-28949\n",
        "linked_issues": [
            {
                "issue_id": "28949",
                "issue_title": "Support TreeSet collection type in CollectionFactory.createCollection() without using reflection",
                "issue_body": "It seems to have been missed in #28718.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes the redundant `SortedSet.class == collectionType` check from the `else if` block.  The original code had a check for `SortedSet` which is now implied by the `NavigableSet` check.  This simplifies the conditional logic by removing a duplicate condition",
            "avg_logprobs": -0.19436192121662077
        }
    },
    {
        "commit_hash": "6887802526dbef2857c4c0106153c0650ec5e4aa",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/cglib/core/ReflectUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tMethodHandles.Lookup lookup =\n-\t\t\t\t\t\t(MethodHandles.Lookup) privateLookupInMethod.invoke(null, contextClass, MethodHandles.lookup());\n+\t\t\t\tMethodHandles.Lookup lookup = (MethodHandles.Lookup)\n+\t\t\t\t\t\tprivateLookupInMethod.invoke(null, contextClass, MethodHandles.lookup());\n-\t\t\t\tif (!(ex.getTargetException() instanceof IllegalArgumentException)) {\n-\t\t\t\t\tthrow new CodeGenerationException(ex.getTargetException());\n+\t\t\t\tThrowable target = ex.getTargetException();\n+\t\t\t\tif (target.getClass() != LinkageError.class && target.getClass() != IllegalArgumentException.class) {\n+\t\t\t\t\tthrow new CodeGenerationException(target);\n-\t\t\t\t// in case of IllegalArgumentException: fall through to defineClass\n+\t\t\t\t// in case of plain LinkageError (class already defined)\n+\t\t\t\t// or IllegalArgumentException (class in different package):\n+\t\t\t\t// fall through to traditional ClassLoader.defineClass below",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fallback to ClassLoader.defineClass for Lookup.defineClass LinkageError",
        "commit_body": "Issue: SPR-16902\n",
        "linked_issues": [
            {
                "issue_id": "21441",
                "issue_title": "Spring Boot DevTools on 5.1 fails with java.lang.LinkageError: loader attempted duplicate class definition [SPR-16902]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-16902](https://jira.spring.io/browse/SPR-16902?redirect=false)** and commented\n\nSpring Boot recently upgrade to Framework 5.1 SNAPSHOTS and we're now seeing \"loader attempted duplicate class definition\" errors with our devtools integration tests on Java 9 and Java 10 (Java 8 is fine).\n\n[Here's an example of a failing build](https://ci.spring.io/teams/spring-boot/pipelines/spring-boot/jobs/jdk9-build/builds/1283).\n\n```\nCaused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class org.springframework.boot.autoconfigure.http.HttpMessageConverters: Common causes of this problem include using a final class or a non-visible class; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader (instance of  jdk/internal/loader/ClassLoaders$AppClassLoader): attempted  duplicate class definition for name: \"org/springframework/boot/autoconfigure/http/HttpMessageConverters$$EnhancerBySpringCGLIB$$1d90bff9\"\n\tat org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:208) ~[spring-aop-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) ~[spring-aop-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver.buildLazyResolutionProxy(ContextAnnotationAutowireCandidateResolver.java:117) ~[spring-context-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver.getLazyResolutionProxyIfNecessary(ContextAnnotationAutowireCandidateResolver.java:52) ~[spring-context-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1062) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:818) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:724) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:197) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1276) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1133) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:503) ~[spring-beans-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\t... 34 common frames omitted\nCaused by: org.springframework.cglib.core.CodeGenerationException: java.lang.LinkageError-->loader (instance of  jdk/internal/loader/ClassLoaders$AppClassLoader): attempted  duplicate class definition for name: \"org/springframework/boot/autoconfigure/http/HttpMessageConverters$$EnhancerBySpringCGLIB$$1d90bff9\"\n\tat org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:502) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:359) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:582) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:106) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:104) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) ~[na:na]\n\tat org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:130) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:315) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:569) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:416) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:58) ~[spring-aop-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\tat org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:205) ~[spring-aop-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\t... 45 common frames omitted\nCaused by: java.lang.LinkageError: loader (instance of  jdk/internal/loader/ClassLoaders$AppClassLoader): attempted  duplicate class definition for name: \"org/springframework/boot/autoconfigure/http/HttpMessageConverters$$EnhancerBySpringCGLIB$$1d90bff9\"\n\tat java.base/java.lang.ClassLoader.defineClass1(Native Method) ~[na:na]\n\tat java.base/java.lang.System$2.defineClass(System.java:2120) ~[na:na]\n\tat java.base/java.lang.invoke.MethodHandles$Lookup.defineClass(MethodHandles.java:964) ~[na:na]\n\tat java.base/jdk.internal.reflect.GeneratedMethodAccessor25.invoke(Unknown Source) ~[na:na]\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]\n\tat org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:498) ~[spring-core-5.1.0.BUILD-SNAPSHOT.jar:5.1.0.BUILD-SNAPSHOT]\n\t... 59 common frames omitted\n```\n\nThe same tests on Spring Boot 2.0 (which uses Framework 5.0) pass fine on Java 8, 9 and 10.\n\nMy guess is this relates to #20414 and is probably caused by our slightly unusual DevTools classloader arrangement.\n\n---\n\n**Affects:** 5.1 RC1\n\n**Issue Links:**\n- #20414 MethodHandles.Lookup.defineClass for CGLIB class definition purposes\n- #21556 Revise ClassUtils.isPresent for exposing resolution exceptions in jlinked modules\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/6887802526dbef2857c4c0106153c0650ec5e4aa\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSince this is definitely a consequence of #20414 where we can't enforce the generation of a such a derived class into a specific `ClassLoader`, there is probably only one way out: keep using the old `ClassLoader.defineClass` approach for DevTools, even on JDK 9+. We already have a fallback for `IllegalArgumentException` coming out of the JDK 9 `MethodHandles.Lookup` API, so I guess we should simply fall back for `LinkageError` as well.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're falling back for `IllegalArgumentException} (class in different package) as well as plain {{LinkageError` (class already defined) now, matching the implementation of `MethodHandles.Lookup.defineClass` in JDK 9/10/11. We keep rethrowing all variants of `LinkageError` subclasses which typically indicate actual class definition issues.\n\nThis will be in the upcoming 5.1 snapshot. Please give it a try with DevTools and let me know how it goes...\n",
                    "**[Andy Wilkinson](https://jira.spring.io/secure/ViewProfile.jspa?name=awilkinson)** commented\n\nThanks, Juergen. Boot 2.1's build is now passing on both Java 9 and Java 10.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the exception handling within a method related to class loading using `MethodHandles.Lookup`.\\n\\n**Before:**\\n\\nThe code checked if the `targetException` was an `IllegalArgumentException` and threw a `CodeGenerationException` only if it wasn't.\\n\\n**After:**\\n\\nThe code now extracts the `targetException` into a `Throwable` variable",
            "avg_logprobs": -0.20786157608032227
        }
    },
    {
        "commit_hash": "68cc57549a56480b723b6112e1bee0de114eeda1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ReactiveTypeHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\n+\n+\t\t\t// Check terminal signal before processing element..\n+\t\t\tboolean isTerminated = this.terminated;\n+\n-\t\t\tif (this.terminated) {\n+\t\t\tif (isTerminated) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Restore correct order of terminated flag check",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a boolean variable `isTerminated` and uses it to check for a terminal signal *before* processing an element.  This change moves the termination check from inside the loop to the beginning, potentially improving performance or handling of termination signals in a more efficient way",
            "avg_logprobs": -0.39669510413860454
        }
    },
    {
        "commit_hash": "692c5f292da714c251280058d58e8c05176ef478",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware...\n+\t\t\t// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware\n-\t\t\t// Make resolvable dependencies (e.g. ResourceLoader) available here as well...\n+\t\t\t// Make resolvable dependencies (e.g. ResourceLoader) available here as well\n-\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType)  {\n+\tpublic <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) {\n-\t\t\t\t\t\telse  {\n+\t\t\t\t\t\telse {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes unnecessary comments and whitespace around the conditional logic.  Specifically, the `//` comments before and after the conditional `else` block are removed.  There are no changes to the conditional logic itself",
            "avg_logprobs": -0.35989519755045574
        }
    },
    {
        "commit_hash": "6c74fee5e88073ec321e956f7c5a1dd5b00f2b08",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/client/DefaultRestClient.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tUnknownContentTypeException unknownContentTypeException = new UnknownContentTypeException(bodyType, contentType,\n+\n+\t\t\tthrow new UnknownContentTypeException(bodyType, contentType,\n-\t\t\tif (observation != null) {\n-\t\t\t\tobservation.error(unknownContentTypeException);\n-\t\t\t}\n-\t\t\tthrow unknownContentTypeException;",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary error signal from DefaultRestClient",
        "commit_body": "Before UnknownContentTypeException is thrown, it is added to the current\nObservation but since UnknownContentTypeException is a\nRestClientException, the exception is added again in one of the\ncatch blocks later on.\n\nCloses gh-33347\n",
        "linked_issues": [
            {
                "issue_id": "33347",
                "issue_title": "RestClient observation flags error for UnknownContentTypeException twice",
                "issue_body": "When an `UnknownContentTypeException` is thrown by `RestClient` it flags the observation in error with it but that isn't necessary as this exception is a `RestClientException` and that's done higher in the stack already.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a variable declaration and the subsequent handling of an exception.  Instead of creating an `UnknownContentTypeException` object and then throwing it, the code now directly throws the exception.  This eliminates the intermediate variable and the associated `if` block that previously checked for an `observation` and potentially logged the error.  The effect is a slightly more concise and potentially slightly faster exception handling path",
            "avg_logprobs": -0.2456300084183856
        }
    },
    {
        "commit_hash": "6d5080825cd26ec29957de2626da9f117e32e41b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/KotlinDetector.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-\n-\tprivate static final Log logger = LogFactory.getLog(KotlinDetector.class);\n-\n-\t\tif (kotlinMetadata != null && !kotlinReflectPresent) {\n-\t\t\tlogger.info(\"Kotlin reflection implementation not found at runtime, related features won't be available.\");\n-\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove potentially confusing kotlin-reflect related log message",
        "commit_body": "Closes gh-24935\n",
        "linked_issues": [
            {
                "issue_id": "24935",
                "issue_title": "Remove potentially confusing kotlin-reflect related log message",
                "issue_body": "When using Spring Boot 2.2.6.RELEASE in Java, and I add a dependency that is written in Kotlin, Spring mentions \r\n\r\n> org.springframework.core.KotlinDetector - Kotlin reflection implementation not found at runtime, related features won't be available.\r\n\r\nThat's fine, the dependency doesn't use Kotlin reflection. What makes me concerned is that, after quickly looking around in the code it seems that Spring would change its behavior to use Kotlin internally if I were to add kotlin-reflect to the classpath. \r\n\r\nThis means that, if a dependency written in Kotlin, that also has kotlin-reflect, Spring will alter its behavior?\r\n\r\nI don't know if this poses a problem but it feels wrong and there doesn't seem to be a way to prevent Spring from using Kotlin even if it's on the classpath.\r\n\r\nAlso, the message cannot be hidden unless I overwrite the logger configuration outside of Spring.\r\nI want to make the warning go away and I don't want to alter my logger configuration outside of Spring. Alternatively I could add kotlin-reflect to make the warning go away, but then I'm wondering what is happening under the hood if all Kotlin requirements are met.\r\n\r\nSo I suggest some kind of mechanism to completely prevent using Kotlin as well as any warnings about it if not desired.\r\n\r\nPlease let me know if this is a non-issue!",
                "issue_state": "closed",
                "issue_comment": [
                    "The `KotlinDetector` class is part of the core spring-framework project. I'm going to transfer this issue for that team to review.",
                    "It is true that nowadays there are JVM libraries developed with Kotlin, like OkHttp, and we should not display a log message for that use case. Since the behavior of the framework is already fine with the relevant conditional checks already in place, let just drop this log message potentially confusing."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a log message that prints a warning if Kotlin reflection is not present at runtime.  Specifically, the `if (kotlinMetadata != null && !kotlinReflectPresent)` block, which previously logged an informational message, is now absent",
            "avg_logprobs": -0.11308831214904785
        }
    },
    {
        "commit_hash": "6d55b3a592547fc335c73e7d071e511fea8f89b9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/connection/SingleConnectionFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\t\t// Iterate over temporary copy in order to avoid ConcurrentModificationException,\n+\t\t\t// since listener invocations may in turn trigger registration of listeners...\n+\t\t\tSet<ExceptionListener> copy;\n-\t\t\t\t// Iterate over temporary copy in order to avoid ConcurrentModificationException,\n-\t\t\t\t// since listener invocations may in turn trigger registration of listeners...\n-\t\t\t\tfor (ExceptionListener listener : new LinkedHashSet<>(this.delegates)) {\n-\t\t\t\t\tlistener.onException(ex);\n-\t\t\t\t}\n+\t\t\t\tcopy = new LinkedHashSet<>(this.delegates);\n+\t\t\t}\n+\t\t\tfor (ExceptionListener listener : copy) {\n+\t\t\t\tlistener.onException(ex);",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Perform onException delegation outside of connection monitor",
        "commit_body": "Issue: SPR-15738\n",
        "linked_issues": [
            {
                "issue_id": "20294",
                "issue_title": "JMS Integration with Tibco causes deadlock while using DefaultMessageListenerContainer [SPR-15738]",
                "issue_body": "**[Anup Tagalpallewar](https://jira.spring.io/secure/ViewProfile.jspa?name=tanup02)** opened **[SPR-15738](https://jira.spring.io/browse/SPR-15738?redirect=false)** and commented\n\nI am facing this issue while using\nSpring-jms version 4.1.6\ntibjms version 6.3 (Tibco jar)\n\nWhen using a DefaultMessageListenerContainer, if there is an exception on established connection we intermittently get this deadlock issue.\n\nPlease find following stack trace for more information.\n\n    \"clientResponseListener-16\" - Thread t@242\n\njava.lang.Thread.State: BLOCKED\nat org.springframework.jms.connection.SingleConnectionFactory$SharedConnectionInvocationHandler.localStop(SingleConnectionFactory.java:640)\n- waiting to lock <1768ffa4> (a java.lang.Object) owned by \"TIBCO EMS TCPLink Reader (Server-999487)\" t@241\n  at org.springframework.jms.connection.SingleConnectionFactory$SharedConnectionInvocationHandler.invoke(SingleConnectionFactory.java:573)\n  at com.sun.proxy.$Proxy54.stop(Unknown Source)\n  at org.springframework.jms.connection.SingleConnectionFactory$SharedConnectionInvocationHandler.localStop(SingleConnectionFactory.java:644)\n- locked <1ea19285> (a java.lang.Object)\n  at org.springframework.jms.connection.SingleConnectionFactory$SharedConnectionInvocationHandler.invoke(SingleConnectionFactory.java:577)\n  at com.sun.proxy.$Proxy54.close(Unknown Source)\n  at org.springframework.jms.connection.ConnectionFactoryUtils.releaseConnection(ConnectionFactoryUtils.java:80)\n  at org.springframework.jms.listener.AbstractJmsListeningContainer.refreshSharedConnection(AbstractJmsListeningContainer.java:395)\n- locked <78213c8c> (a java.lang.Object)\n  at org.springframework.jms.listener.DefaultMessageListenerContainer.refreshConnectionUntilSuccessful(DefaultMessageListenerContainer.java:909)\n  at org.springframework.jms.listener.DefaultMessageListenerContainer.recoverAfterListenerSetupFailure(DefaultMessageListenerContainer.java:884)\n  at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1055)\n- locked <5f74909f> (a java.lang.Object)\n  at java.lang.Thread.run(Thread.java:745)\n\nLocked ownable synchronizers:\n- None\n\n  \"TIBCO EMS TCPLink Reader (Server-999487)\" - Thread t@241\n\njava.lang.Thread.State: BLOCKED\nat org.springframework.jms.connection.SingleConnectionFactory$AggregatedExceptionListener.onException(SingleConnectionFactory.java:670)\n- waiting to lock <1ea19285> (a java.lang.Object) owned by \"clientResponseListener-16\" t@242\n  at org.springframework.jms.connection.SingleConnectionFactory$AggregatedExceptionListener.onException(SingleConnectionFactory.java:671)\n- locked <1768ffa4> (a java.lang.Object)\n  at com.tibco.tibjms.TibjmsConnection._invokeOnExceptionCallback(TibjmsConnection.java:2054)\n  at com.tibco.tibjms.TibjmsConnection._onDisconnected(TibjmsConnection.java:2394)\n  at com.tibco.tibjms.TibjmsConnection$ServerLinkEventHandler.onEventDisconnected(TibjmsConnection.java:349)\n  at com.tibco.tibjms.TibjmsxLinkTcp$LinkReader.work(TibjmsxLinkTcp.java:330)\n  at com.tibco.tibjms.TibjmsxLinkTcp$LinkReader.run(TibjmsxLinkTcp.java:259)\n\nLocked ownable synchronizers:\n- None\n\n---\n\n**Affects:** 4.2.7\n\n**Issue Links:**\n- #15030 Memory leak with SimpleMessageListenerContainer and ChainedExceptionListener on Single/CachingConnectionFactory\n- #18000 ConcurrentModificationException in SingleConnectionFactory$AggregatedExceptionListener\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/6d55b3a592547fc335c73e7d071e511fea8f89b9, https://github.com/spring-projects/spring-framework/commit/a9a4d7cf78c980d143c04f55551c04dca1ae545a\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Anup Tagalpallewar](https://jira.spring.io/secure/ViewProfile.jspa?name=tanup02)** commented\n\nHi Juergen,\n\nCan you please suggest any workaround that might help avoid the deadlock?\n\nThanks\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've addressed this through moving `AggregatedExceptionListener`'s `onException` delegate calls outside of the `connectionMonitor` there, just taking a temporary copy of the current listeners within the monitor now. Fixed for 5.0 RC3, and to be backported to 4.3.10.\n\nI don't think Tibco should be using such a hard lock for `onException` callbacks in the first place... but I doubt they'll change that any time soon. So not taking a lock for those callbacks on Spring's side is the only thing we can do there.\n\nAs a workaround, you could try to get rid of your `SingleConnectionFactory` setup. `DefaultMessageListenerContainer` manages its own shared connection in any case, so you might not actually benefit from the additional `SingleConnectionFactory`...\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how exception listeners are notified.  Previously, a `LinkedHashSet` copy was created *inside* the loop to prevent `ConcurrentModificationException`.  The change now creates the copy *outside* the loop, improving efficiency by only creating the copy once.  This is a subtle but important optimization, as the previous approach created a new copy on each iteration",
            "avg_logprobs": -0.30964707708978034
        }
    },
    {
        "commit_hash": "6d7573262e604b5c8e58cd97309bd2486c478016",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/FormTag.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.util.CollectionUtils;\n-\t\tif ((processor != null) && (request instanceof HttpServletRequest)) {\n+\t\tif (processor != null && request instanceof HttpServletRequest) {\n-\t\tif (hiddenFields != null) {\n+\t\tif (!CollectionUtils.isEmpty(hiddenFields)) {\n+",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "FormTag skips rendering of hidden fields in case of empty Map",
        "commit_body": "Issue: SPR-16498\n",
        "linked_issues": [
            {
                "issue_id": "21041",
                "issue_title": "FormTag renders empty <div> tag [SPR-16498]",
                "issue_body": "**[Delete this account](https://jira.spring.io/secure/ViewProfile.jspa?name=todr)** opened **[SPR-16498](https://jira.spring.io/browse/SPR-16498?redirect=false)** and commented\n\nThe doEndTag method in org/springframework/web/servlet/tags/form/FormTag.java uses writeHiddenFields to write the ExtraHiddenFields to a \\<div> tag. The if statement inside writeHiddenFields checks for hiddenFields being null, but in the case of it being an empty Map will write an empty \\<div>\\</div> at the end of the \\<form>.\n\nPossible solutions:\n- remove encapsulating \\<div>, possible hidden inputs would be direct children of the \\<form> tag\n- check hiddenFields not only for null but also for empty keyset in the if condition\n\n\n\n---\n\n**Affects:** 4.3.14\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/350f318d2ec3f19855df0124a117ff3a30cdabc0, https://github.com/spring-projects/spring-framework/commit/6d7573262e604b5c8e58cd97309bd2486c478016\n\n**Backported to:** [4.3.15](https://github.com/spring-projects/spring-framework/milestone/164?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point, we're simply checking `CollectionUtils.isEmpty` there now. To be backported to 4.3.15.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `FormTag.java` removes redundant parentheses around the boolean expressions in the `if` statements and replaces a simple `null` check with a more robust check using `CollectionUtils.isEmpty`.\\n\\nSpecifically:\\n\\n* **`if ((processor != null) && (request instanceof HttpServletRequest))` becomes `if (processor != null && request instanceof HttpServletRequest)`:**  Removes unnecessary parentheses.\\n* **`if (hiddenFields != null)` becomes `if (!CollectionUtils",
            "avg_logprobs": -0.1403725814819336
        }
    },
    {
        "commit_hash": "6d91d54fc9e93bbecbfb2778cf4d1fed1a39b7f6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/support/StandardTypeConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate static ConversionService defaultConversionService;\n+\tprivate static volatile ConversionService defaultConversionService;\n-\t\tsynchronized (this) {\n-\t\t\tif (defaultConversionService == null) {\n-\t\t\t\tdefaultConversionService = new DefaultConversionService();\n-\t\t\t}\n+\t\tif (defaultConversionService == null) {\n+\t\t\tdefaultConversionService = new DefaultConversionService();",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "StandardTypeConverter initializes default ConversionService against volatile field",
        "commit_body": "Issue: SPR-14465\n",
        "linked_issues": [
            {
                "issue_id": "19034",
                "issue_title": "Ineffective synchronization in StandardTypeConverter constructor [SPR-14465]",
                "issue_body": "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** opened **[SPR-14465](https://jira.spring.io/browse/SPR-14465?redirect=false)** and commented\n\n`StandardTypeConverter`'s default constructor uses `synchronized (this)` for initializing a shared static `DefaultConversionService`. However, in a constructor, synchronization on `this` is effectively a no-op. Let's rather simply use a `volatile` variable there.\n\n---\n\n**Affects:** 3.2.17, 4.2.7, 4.3.1\n\n**Issue Links:**\n- #19515 Shared DefaultConversionService instance e.g. for BeanPropertyRowMapper\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/0065a160cc8316fec43adb8da80078d1ff3be242, https://github.com/spring-projects/spring-framework/commit/97d73eb70c46865f877c146978d96d7a380d2483, https://github.com/spring-projects/spring-framework/commit/6d91d54fc9e93bbecbfb2778cf4d1fed1a39b7f6, https://github.com/spring-projects/spring-framework/commit/cb64dd15838ee073631e145b21d3c9f78b35dcb8\n\n**Backported to:** [4.2.8](https://github.com/spring-projects/spring-framework/milestone/145?closed=1), [3.2.18](https://github.com/spring-projects/spring-framework/milestone/106?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the `synchronized` block with a `volatile` keyword for the `defaultConversionService` field.  This change removes the need for the `synchronized` block, potentially improving performance by avoiding unnecessary thread synchronization.  The `volatile` keyword ensures that all threads have access to the most up-to-date value of `defaultConversionService`.  The original code had a race condition where multiple threads could try to initialize `defaultConversionService` simultaneously",
            "avg_logprobs": -0.26200388858192847
        }
    },
    {
        "commit_hash": "6e0dfd6999aaec4590625de9f818abab16c3aa92",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.http.HttpHeaders;\n-\t * Indicates whether the {@code Accept-Charset} should be written to any outgoing request.\n+\t * Whether the {@code Accept-Charset} header should be written to any outgoing\n+\t * request sourced from the value of {@link Charset#availableCharsets()}.\n+\t * The behavior is suppressed if the header has already been set.\n-\t\tif (this.writeAcceptCharset) {\n-\t\t\toutputMessage.getHeaders().setAcceptCharset(getAcceptedCharsets());\n+\t\tHttpHeaders headers = outputMessage.getHeaders();\n+\t\tif (this.writeAcceptCharset && headers.get(HttpHeaders.ACCEPT_CHARSET) == null) {\n+\t\t\theaders.setAcceptCharset(getAcceptedCharsets());\n-\t\tCharset charset = getContentTypeCharset(outputMessage.getHeaders().getContentType());\n+\t\tCharset charset = getContentTypeCharset(headers.getContentType());",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Check if Accept-Charset is present before adding it",
        "commit_body": "Closes gh-22506\n",
        "linked_issues": [
            {
                "issue_id": "22506",
                "issue_title": "StringHttpMessageConverter will add all the default charsets even if Accept-Charset is set explicitly",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://pivotal.io/security !!!\r\n-->\r\n**Affects:** 5.1.5\r\n\r\n---\r\nHi,\r\nFirst, I would like to check if the current behavior of StringHttpMessageConverter is intentional. I found #15437 to be the same issue as I'm describing here, but its closed due to inactivity.\r\n\r\nCurrent Behavior\r\n============\r\nStringHttpMessageConverter will add all the available charsets available to the jvm in the `Accept-Charset` header when used to call apis with `RestTemplate`. This has two problems\r\n1) The outgoing request size can be huge\r\n2) The external system may not recognize all the charsets and throw errors (the issue I'm facing)\r\n\r\nIf this is not the intended behavior please see the proposal below\r\n\r\nProposal\r\n======\r\n```java\r\nprotected void writeInternal(String str, HttpOutputMessage outputMessage) throws IOException {\r\n  if (this.writeAcceptCharset) {\r\n    // Also check if Accept-Charset is already in headers before setting it        <----\r\n    outputMessage.getHeaders().setAcceptCharset(getAcceptedCharsets());\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n**NB: At the moment I'm using the below workaround. If this is intentional, please let me know if there is a better way. If not I'd be glad to work on the above proposal**\r\n```java\r\nRestTemplate restClient = new RestTemplate();\r\nList<HttpMessageConverter<?>> messageConverters = restClient.getMessageConverters();\r\nmessageConverters.forEach(\r\n    messageConverter -> {\r\n      if (messageConverter instanceof StringHttpMessageConverter) {\r\n        ((StringHttpMessageConverter) messageConverter).setWriteAcceptCharset(false);\r\n      }\r\n    }\r\n);\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for the suggestion to make the change. To ensure this makes it for 5.1.7 tomorrow, I've applied it myself. Also in master for 5.2 I've switched the default from `true` to `false`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change in `StringHttpMessageConverter` modifies how the `Accept-Charset` header is written to outgoing requests.  Previously, the header was always written if `writeAcceptCharset` was true.  Now, the header is only written if `writeAcceptCharset` is true *and* the `Accept-Charset` header is not already present in the `HttpHeaders`.  This change prevents redundant headers from being added.  The code also refactors to use `outputMessage",
            "avg_logprobs": -0.14013031959533692
        }
    },
    {
        "commit_hash": "6e3f974951b71b6566392f58135b71ffca6fd135",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/HttpHeaders.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t * Return a {@code HttpHeaders} object that can read and written to.\n+\t * Return a {@code HttpHeaders} object that can be read and written to.\n+\t * @since 5.1.1\n-\t\tif (headers instanceof ReadOnlyHttpHeaders) {\n+\t\tif (headers == EMPTY) {\n+\t\t\treturn new HttpHeaders();\n+\t\t}\n+\t\telse if (headers instanceof ReadOnlyHttpHeaders) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "HttpHeaders.writableHttpHeaders properly handles HttpHeaders.EMPTY",
        "commit_body": "Issue: SPR-17633\n",
        "linked_issues": [
            {
                "issue_id": "22164",
                "issue_title": "HttpHeaders.EMPTY is not immutable [SPR-17633]",
                "issue_body": "**[Alfred Thomas](https://jira.spring.io/secure/ViewProfile.jspa?name=alfred.thomas)** opened **[SPR-17633](https://jira.spring.io/browse/SPR-17633?redirect=false)** and commented\n\nAccording to the Javadoc, HttpHeaders.EMPTY is immutable.\r\nI found that by using the following code, headers could be added to HttpHeaders.EMPTY.\r\nFrom then on, any further calls will result in a non-empty HttpHeaders.\n\n```java\nHttpHeaders myHeaders = HttpHeaders.writableHttpHeaders(HttpHeaders.EMPTY);\r\nmy.add(HttpHeaders.ACCEPT_ENCODING, \"gzip\");\r\n```\n\nI have written a simple unit test to explain this issue:\n\n```java\n@Test\r\npublic void testUpdateEmptyHeaders() {\r\n    assertEquals(0, HttpHeaders.EMPTY.size()); // **Success**\r\n    HttpHeaders myHeaders = HttpHeaders.writableHttpHeaders(HttpHeaders.EMPTY);\r\n    myHeaders.add(HttpHeaders.ACCEPT_ENCODING, \"gzip\");\r\n    assertEquals(0, HttpHeaders.EMPTY.size()); // **Assert Fails**\r\n}\r\n```\n\nThis caused a bug in my code where I subsequently used HttpHeaders.EMPTY again to create a new writable HttpHeaders object. I then unknowingly introduced headers used in the previous object\n\n---\n\n**Affects:** 5.1.3\n\n**Reference URL:** https://stackoverflow.com/questions/53982635/possible-bug-in-spring-httpheaders\n\n**Issue Links:**\n- #21783 Improve WebFlux performance for header management\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/6e3f974951b71b6566392f58135b71ffca6fd135\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `HttpHeaders` class to handle the `EMPTY` case and improve the Javadoc.  Previously, it checked if the input `headers` was a `ReadOnlyHttpHeaders` instance. Now, it first checks if `headers` is the `EMPTY` instance. If it is, it returns a new `HttpHeaders` instance. Otherwise, if `headers` is a `ReadOnlyHttpHeaders`, it returns a copy",
            "avg_logprobs": -0.24664196014404297
        }
    },
    {
        "commit_hash": "6e936a408195f95d41f3463bb93e255218493664",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpConnector.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (!uri.isAbsolute()) {\n-\t\t\treturn Mono.error(new IllegalArgumentException(\"URI is not absolute: \" + uri));\n-\t\t}\n-",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove absolute URI check from ReactorClientHttpConnector",
        "commit_body": "This allows maknig use of the Unix Domain Socket support in Reactor 1.0.\n\nCloses gh-25929\n",
        "linked_issues": [
            {
                "issue_id": "25929",
                "issue_title": "Removes absolute URI check to support Unix Domain Socket URIs",
                "issue_body": "With support coming for [Unix Domain Sockets from io.projectreactor.netty](https://projectreactor.io/docs/netty/1.0.0-RC2/reference/index.html#_unix_domain_sockets_4) URIs no longer need to be absolute.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removed a check for an absolute URI.  Previously, if the URI wasn't absolute, an `IllegalArgumentException` was thrown.  Now, this check and exception are no longer present.  This suggests a change in the calling code or a broader design change that now assumes all URIs are absolute",
            "avg_logprobs": -0.24274934621957633
        }
    },
    {
        "commit_hash": "6f1acdd561e60b389fa2eefdecf1f2811018253d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/ResolvableType.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\n+\t\tif (type instanceof Class<?>) {\n+\t\t\treturn new ResolvableType(type, typeProvider, variableResolver, null);\n+\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize ResolvableType cache",
        "commit_body": "Prior to this commit, the ResolvableType static cache was holding a lot\nof duplicates for simple types. We are using too much metadata to compute\nthe key when the class has no generic information. so setFoo(String foo)\nand setBar(String bar) would result in two entries in the cache because\nthe TypeProvider is different. On a very simple application 65% of the\nentries in the cache were duplicate.\n\nWhen the type is a Class with no generic information, the ResolvableType\ninstance is a simple wrapper around it so we might just as well not cache\nit at all as the cost of finding it back from the cache is higher than\ncreating that simple wrapper.\n\nThis commit adds an explicit check; if the type is a simple Class we just\nreturn a \"resolved\" ResolvableType instance for it. On a few test cases,\nthis reduces the size of the cache by 85%\n\nIssue: SPR-12275\n",
        "linked_issues": [
            {
                "issue_id": "16880",
                "issue_title": "Duplicate entries in ResolvableType cache [SPR-12275]",
                "issue_body": "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** opened **[SPR-12275](https://jira.spring.io/browse/SPR-12275?redirect=false)** and commented\n\nWhile doing some investigations on #16021 we discovered that the `ResolvableType` internal cache was holding a **lot** of duplicates for simple types (i.e. `String`, `Integer`, etc).\n\nIt turns out that we are using too much metadata to compute the key when the class has no generic information. so `setFoo(String foo)` and `setBar(String bar)` would result in two entries in the cache because the `TypeProvider` is different.\n\n---\n\n**Affects:** 4.0.7, 4.1 GA\n\n**Issue Links:**\n- #16021 memory leak in class org.springframework.core.ResolvableType\n\n**Backported to:** [4.0.8](https://github.com/spring-projects/spring-framework/milestone/120?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nInvestigating this a bit further, the cost of creating a simple wrapper around the class is lower than checking the cache so we're now avoiding the cache altogether for simple types (i.e. non generic, simple types).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new `if` statement to the `ResolvableType` class.  If the input `type` is an instance of `Class`, a new `ResolvableType` object is created with the provided `type`, `typeProvider`, `variableResolver`, and `null` for the `generic` parameter.  This suggests a specialization for handling `Class` objects as input",
            "avg_logprobs": -0.1759177300988174
        }
    },
    {
        "commit_hash": "6f2f5bb8c1a0926c0d2be683bb721c3966cf9c80",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (target == attribute) {\n+\t\tif (target.equals(attribute)) {\n-\t\t\tif (mirror != attribute) {\n+\t\t\tif (!mirror.equals(attribute)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix annotation exceptions in tight memory",
        "commit_body": "Update `AnnotationTypeMapping` so that instance comparisons are no\nlonger used when checking attribute methods. Prior to this commit,\nin an environment with tightly constrained memory, the method cache\ncould be cleared and different method instances would be returned.\n\nCloses gh-23010\n",
        "linked_issues": [
            {
                "issue_id": "23010",
                "issue_title": "Soft reference-based cache causes confusing exception message from AnnotationTypeMapping resolveAliasTarget",
                "issue_body": "https://github.com/spring-projects/spring-framework/blob/9b3c92e8d2a9a284ec031687fdb6aad5c2407f67/spring-core/src/main/java/org/springframework/core/annotation/AnnotationTypeMapping.java#L184-L190\r\n\r\nI have a situation where `mirror` and `attribute` are different instances of the `name` attribute on `@Bean`. The use of `!=` then results in the following exception:\r\n\r\n```\r\nCaused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'value' in annotation [org.springframework.context.annotation.Bean] must be declared as an @AliasFor 'name', not 'name'.\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:186) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:130) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:122) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.<init>(AnnotationTypeMapping.java:99) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:107) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:68) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:61) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:46) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:215) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_181]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:211) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:179) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.process(TypeMappedAnnotations.java:417) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:400) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:366) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.processMethodAnnotations(AnnotationsScanner.java:382) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.processMethodInheritedAnnotations(AnnotationsScanner.java:248) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.processMethod(AnnotationsScanner.java:231) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.process(AnnotationsScanner.java:109) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:96) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:77) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations.scan(TypeMappedAnnotations.java:244) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations.get(TypeMappedAnnotations.java:151) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations.get(TypeMappedAnnotations.java:133) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.findAutowiredAnnotation(AutowiredAnnotationBeanPostProcessor.java:508) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.lambda$buildAutowiringMetadata$2(AutowiredAnnotationBeanPostProcessor.java:476) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.util.ReflectionUtils.doWithLocalMethods(ReflectionUtils.java:320) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata(AutowiredAnnotationBeanPostProcessor.java:471) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata(AutowiredAnnotationBeanPostProcessor.java:438) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(AutowiredAnnotationBeanPostProcessor.java:233) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors(AbstractAutowireCapableBeanFactory.java:1081) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:567) ~[spring-beans-5.2.0.M2.jar:5.2.0.M2]\r\n\t... 15 common frames omitted\r\n```\r\n\r\nThe problem occurs when running a Spring Boot application with a very tightly constrained max heap. I suspect it's due to eviction from the soft reference cache used by `AnnotationTypeMappings`. It's not limited to `@Bean` as I have also seen it with `@RequestMapping`:\r\n\r\n```\r\nCaused by: org.springframework.core.annotation.AnnotationConfigurationException: Attribute 'value' in annotation [org.springframework.web.bind.annotation.RequestMapping] must be declared as an @AliasFor 'path', not 'path'.\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:186) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasTarget(AnnotationTypeMapping.java:130) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.resolveAliasedForTargets(AnnotationTypeMapping.java:122) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMapping.<init>(AnnotationTypeMapping.java:99) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:107) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:68) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:61) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.<init>(AnnotationTypeMappings.java:46) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:215) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) ~[na:1.8.0_181]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:211) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:179) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.process(TypeMappedAnnotations.java:417) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:400) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations$MergedAnnotationFinder.doWithAnnotations(TypeMappedAnnotations.java:366) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.processMethodAnnotations(AnnotationsScanner.java:382) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.processMethodHierarchy(AnnotationsScanner.java:266) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.processMethod(AnnotationsScanner.java:236) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.process(AnnotationsScanner.java:109) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:96) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotationsScanner.scan(AnnotationsScanner.java:77) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations.scan(TypeMappedAnnotations.java:244) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.TypeMappedAnnotations.get(TypeMappedAnnotations.java:151) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation(AnnotatedElementUtils.java:633) ~[spring-core-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.createRequestMappingInfo(RequestMappingHandlerMapping.java:262) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getMappingForMethod(RequestMappingHandlerMapping.java:225) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.getMappingForMethod(RequestMappingHandlerMapping.java:65) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2]\r\n\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lambda$detectHandlerMethods$0(AbstractHandlerMethodMapping.java:271) ~[spring-webmvc-5.2.0.M2.jar:5.2.0.M2]\r\n\t... 26 common frames omitted\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "I unfortunately couldn't easily add a unit test for this. @wilkinsona could you run your sample again with the latest snapshot and confirm things are now OK?",
                    "Looks good to me. Thanks."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces the `==` operator with `.equals()` in two `if` statements.  This likely changes the behavior of the code to perform a *content-based* comparison instead of a *reference-based* comparison for the `target` and `attribute` objects.  This is a crucial change, as `==` checks if the variables refer to the same object in memory, while `.equals()` checks if the objects have the same content",
            "avg_logprobs": -0.1834791374206543
        }
    },
    {
        "commit_hash": "6fdf5ef6eeba50387686082f2dd4d1407a669f39",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tClass<?>[] interfaces = ia.getInterfaces();\n-\t\t\tfor (Class<?> iface : interfaces) {\n-\t\t\t\tremoveInterface(iface);\n+\t\t\tfor (Class<?> ifc : ia.getInterfaces()) {\n+\t\t\t\tremoveInterface(ifc);",
        "change_count": 5,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": "See gh-24205\n",
        "linked_issues": [
            {
                "issue_id": "24205",
                "issue_title": "Simplify AdvisedSupport.removeAdvisor()",
                "issue_body": "1) it's not necessary to call `IntroductionAdvisor.getInterfaces()` twice for each iteration\r\n2) instead of calling `ArrayList.get()` and then `ArrayList.remove()` we can once call `ArrayList.remove()` to get and remove item by its index",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the loop variable `iface` with `ifc`.  This is a purely cosmetic change; it alters the variable name from `iface` to `ifc` within the `for` loop, but does not affect the logic of the loop or the functionality of the code.  No significant change to conditional logic or iteration constructs is present",
            "avg_logprobs": -0.2804452331972794
        }
    },
    {
        "commit_hash": "6fed3425437ab1736244a8d77005b4fa8fa3e57b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/persistenceunit/DefaultPersistenceUnitManager.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tif (ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION.equals(this.defaultPersistenceUnitRootLocation)) {\n+\t\t\t\tlogger.debug(\"Unable to resolve classpath root as persistence unit root URL\");\n+\t\t\t\treturn null;\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine DefaultPersistenceUnitManager#determineDefaultPersistenceUnitRootUrl",
        "commit_body": "This commit refines the implementation to be more\nlenient when defaultPersistenceUnitRootLocation is equals\nto ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION and an\nIOException is thrown, which happens when running on\nnative image.\n\nCloses gh-29137\n",
        "linked_issues": [
            {
                "issue_id": "29137",
                "issue_title": "DefaultPersistenceUnitManager.determineDefaultPersistenceUnitRootUrl is unable to resolve root url in native image",
                "issue_body": "Bootstrapping the `DefaultPersistenceUnitManager` fails in native image being unable to resolve the root url. Replacing `determineDefaultPersistenceUnitRootUrl` via a substitution that returns `null` allowed to initialize the `PersistenceUnitManager`.  \r\n\r\nSee: [pring-aot-smoke-tests#113](https://github.com/spring-projects/spring-aot-smoke-tests/pull/113/files#diff-3f810a09badaf6852c87168c71c77aa4871afec6e8a526ed5c512c0e600156f6)",
                "issue_state": "closed",
                "issue_comment": [
                    "I guess it would also help to call `setDefaultPersistenceUnitRootLocation(null)` since the implementation already has that escape hatch? We should make the default implementation more defensive though, there is no need to fail hard, at least not with the `ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION` as input. This could be as straightforward as just logging the \"Unable to resolve persistence unit root URL\" message and returning `null` instead of throwing a `PersistenceException` there, potentially with an `if` check to only perform such a lenient return in case of `defaultPersistenceUnitRootLocation == ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check to see if the `defaultPersistenceUnitRootLocation` is set to a special value (`ORIGINAL_DEFAULT_PERSISTENCE_UNIT_ROOT_LOCATION`).  If it is, a debug log message is printed, and `null` is returned.  This suggests a handling of a specific case where the default location is not resolvable",
            "avg_logprobs": -0.12034857432047526
        }
    },
    {
        "commit_hash": "70cb96c1d832eccd0d7e8ab5768cf63bda6879c1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\tif (method.getParameterCount() == 0) {\n+\t\t\t\t\tif (!method.getDeclaringClass().isRecord() && method.getParameterCount() == 0) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ignore @Value on record property",
        "commit_body": "See gh-31433\n",
        "linked_issues": [
            {
                "issue_id": "31433",
                "issue_title": "Use of @Value in compact constructor of a record should not register method injection",
                "issue_body": "When I try to use `@Value` annotation a record property, I get a warning in the logs that autowiring should only be used on methods with parameters. What that seems to imply is that attaching `@Value` on the property is actually attaching it on the generated method `property()`, which has no parameters.\r\n\r\nExample:\r\n```java\r\n@Component\r\npublic record MyRecord(@Value(\"${myProp}\") String prop) {}\r\n```\r\n\r\nOutput:\r\n```\r\n02:21:15.043 [main] INFO  o.s.b.f.a.AutowiredAnnotationBeanPostProcessor - Autowired annotation should only be used on methods with parameters: public java.lang.String com.example.MyRecord.prop()\r\n```\r\n\r\nMy fix is to just check first, if the bean is a record or not.",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for the PR but are you sure that the code you've shared above currently triggers the warning? Does it work at all? \r\n\r\nIt fails for me as follows:\r\n\r\n```\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'myComponent': Injection of autowired dependencies failed; nested exception is java.lang.IllegalAccessException: Can not set final java.lang.String field com.example.demo.MyComponent.prop to java.lang.String\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:405) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:955) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:921) ~[spring-context-5.3.29.jar:5.3.29]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.29.jar:5.3.29]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:731) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:408) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:307) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1303) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1292) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat com.example.demo.DemoApplication.main(DemoApplication.java:12) ~[classes/:na]\r\nCaused by: java.lang.IllegalAccessException: Can not set final java.lang.String field com.example.demo.MyComponent.prop to java.lang.String\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:76) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:80) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.UnsafeQualifiedObjectFieldAccessorImpl.set(UnsafeQualifiedObjectFieldAccessorImpl.java:79) ~[na:na]\r\n\tat java.base/java.lang.reflect.Field.set(Field.java:799) ~[na:na]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:646) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\t... 17 common frames omitted\r\n```\r\n\r\nTurning a `record` into a bean is a bit odd. In any case, please clarify your assumptions as we can't really process this until we understand it.",
                    "@snicoll I confirm that log is triggered.\r\n```\r\n o.s.b.f.a.AutowiredAnnotationBeanPostProcessor INFO Autowired annotation should only be used on methods with parameters: public java.lang.String io.example.showcase.MyRecord.prop()\r\n\r\n```",
                    "Thanks. \"logging a warning\" broke my brain, I was looking for a warning, not an info message. The bits on testing and use of record remains though.",
                    "@snicoll Sorry for the misunderstanding, it is an INFO log, but communicating a sort of warning, didn't know how to call it. \r\n\r\nIt works well for me with the code I provided (+ basic Spring Boot project, latest, JDK 21 or 17).\r\n\r\nAs for `record` being odd when used as a bean. I was just experimenting with records + Spring. Using records as a bean seems mostly equivalent to e.g.:\r\n```java\r\n@Component\r\npublic class MyClass {\r\n  private String prop;\r\n  public MyClass(@Value(\"${myProp}\") String prop) {\r\n    this.prop = prop;\r\n  }\r\n  // getter\r\n}\r\n```\r\n\r\nBut you're kinda right. Now that I think about the use cases, it might not be that needed. If I have some service that needs a property value, and I use a record for it, I'd get an unwanted property accessor automatically, which is not great. I was thinking more like loading properties into a \"configuration\" carrying bean, but that's also possible with e.g.:\r\n```java\r\n@ConfigurationProperties(prefix = \"config\")\r\npublic record Config(String first, String second) {}\r\n```\r\nwhich works well.",
                    ">  I was thinking more like loading properties into a \"configuration\" carrying bean,\r\n\r\nYeah, sorry. You're totally right. The `@Value` with a record makes sense indeed.",
                    "@martin-lukas thanks very much for making your first contribution to Spring Framework."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check `!method.getDeclaringClass().isRecord()` to the `if` statement.  This means the conditional now only executes if the method's declaring class is *not* a record class *and* the method has zero parameters.  This suggests the original check was potentially causing issues with record classes and their methods, and the change is intended to prevent those issues",
            "avg_logprobs": -0.18761090198195124
        }
    },
    {
        "commit_hash": "70e6e3bb39c9db1a85a77411707fb560292b7b3e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/sockjs/client/SockJsClient.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!isRunning()) {\n+\t\tif (isRunning()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix condition check in SockJsClient lifecycle method",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change inverts the condition in the `if` statement.  Originally, the code checked if the `SockJsClient` was *not* running.  Now, it checks if the `SockJsClient` *is* running.  This likely reverses the behavior of the surrounding code block",
            "avg_logprobs": -0.16056710197812035
        }
    },
    {
        "commit_hash": "71463fb3991a2b7e8e79cafa91a824c51f4fc73a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (this.alreadyCreated.add(beanName)) {\n+\t\t\t\tif (!this.alreadyCreated.contains(beanName)) {\n+\t\t\t\t\tthis.alreadyCreated.add(beanName);\n-\t\tthis.alreadyCreated.remove(beanName);\n+\t\tsynchronized (this.mergedBeanDefinitions) {\n+\t\t\tthis.alreadyCreated.remove(beanName);\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AbstractBeanFactory consistently guards add/remove operations against alreadyCreated Set",
        "commit_body": "Issue: SPR-14269\n",
        "linked_issues": [
            {
                "issue_id": "18841",
                "issue_title": "markBeanAsCreated does not clear merged bean definition in a thread-safe fashion [SPR-14269]",
                "issue_body": "**[Marcin Piela](https://jira.spring.io/secure/ViewProfile.jspa?name=mpiela)** opened **[SPR-14269](https://jira.spring.io/browse/SPR-14269?redirect=false)** and commented\n\nWhen creating a context and then calling `getBean` on it from multiple threads we sometimes get a `BeanInitializationException` from `RequiredAnnotationBeanPostProcessor.postProcessPropertyValues`.\nAttached is a simple maven project to reproduce. In a loop it:\n1. creates a fresh spring context\n2. attempts to fetch some beans from it in parallel.\n   The number of threads and max number of loop iterations can be passed as the first and second argument to the Main class.\n   Usage:\n   `mvn clean package && java -jar target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar`\n   We never get any errors when the getBean method is called from a single thread, so:\n   `java -jar target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar 1`\n   always works.\n   We don't get any errors for spring version 4.1.9, but as long as we switch to 4.2.0 or later the errors start occuring.\n   Example exception:\n\n```\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'service-2' defined in class path resource [example-context.xml]: Cannot resolve reference to bean 'bean_0_1' while setting bean property 'bean_0_1'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bean_0_1' defined in URL [jar:file:/home/mpiela/devel/repo/spring-bug/target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar!/test/Bean_0_1.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Properties 'bean_1_0' and 'bean_1_1' are required for bean 'bean_0_1'\n\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:359)\n\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1481)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:325)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\n\tat org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1054)\n\tat test.Main.lambda$tryToGetBean$0(Main.java:75)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bean_0_1' defined in URL [jar:file:/home/mpiela/devel/repo/spring-bug/target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar!/test/Bean_0_1.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Properties 'bean_1_0' and 'bean_1_1' are required for bean 'bean_0_1'\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:325)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\n\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:351)\n\t... 13 more\nCaused by: org.springframework.beans.factory.BeanInitializationException: Properties 'bean_1_0' and 'bean_1_1' are required for bean 'bean_0_1'\n\tat org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.postProcessPropertyValues(RequiredAnnotationBeanPostProcessor.java:156)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1214)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543)\n\t... 17 more\n```\n\n---\n\n**Affects:** 4.2.6\n\n**Attachments:**\n- [spring-bug.tar.gz](https://jira.spring.io/secure/attachment/23392/spring-bug.tar.gz) (_2.25 kB_)\n\n**Issue Links:**\n- #16851 Reduce BeanDefinition cloning in AbstractBeanFactory.getMergedBeanDefinition\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9064d38e4c77addbb5682e28e8c04df9fc8cd652, https://github.com/spring-projects/spring-framework/commit/71463fb3991a2b7e8e79cafa91a824c51f4fc73a, https://github.com/spring-projects/spring-framework/commit/933bbf2de90c720e6ada08089c3401317230d3b0, https://github.com/spring-projects/spring-framework/commit/6efa0589170fbcdd7fc0fe850d5b55b75918fdb2\n\n**Backported to:** [4.2.7](https://github.com/spring-projects/spring-framework/milestone/144?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nthe method **markBeanAsCreated(String beanName)**  in AbstractBeanFactory is not thread safe.\nthread A and thread B try to call this method, A check **!this.alreadyCreated.contains(beanName)** return true, then call **this.alreadyCreated.add(beanName);** at this time B check **!this.alreadyCreated.contains(beanName)** return false, then B out of this method, but now A does not finish **clearMergedBeanDefinition(beanName);** then B call **getMergedLocalBeanDefinition(String beanName)** may return old BeanDefinition\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nI have a pull request, https://github.com/spring-projects/spring-framework/pull/1059, please help to review.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nMoving the `this.alreadyCreated.add(beanName)` call right after `clearMergedBeanDefinition(beanName)` seems to be the most efficient way out here: In case of a race condition, we'll clear the merged bean definition too often but that's acceptable; we'll at least guarantee that subsequent steps will always see an up-to-date bean definition then.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\n`@Juergen` Hoeller I have tried not adding synchronized (this.alreadyCreated), when running the test still throw the same exception with more attempts(one test happened after 239 attempts of 4 threads). You can have a try. I still do not know why it is happen, but it is actually happened.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nthe error just occurs just because the too ofter clear the merged bean definition in multi threads for method **protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd, BeanDefinition containingBd) throws BeanDefinitionStoreException** If thread A first clear merged bean then call **getMergedBeanDefinition** and create a new **RootBeanDefinition**, but thread B first clear the merged bean definition then call **getMergedBeanDefinition** and create another new **RootBeanDefinition**, there will be two different BeanDefinitions.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSince `getMergedBeanDefinition` operates within a full lock, there should never be two different bean definitions stored there. Temporary use of two different (but equivalent) merged bean definitions is not an issue; we do that in other scenarios as well.\n\nHave you tried to reproduce this against the latest `4.3.0.BUILD-SNAPSHOT`? It would help a lot to isolate failures against that re-ordered but non-synchronized scenario since there might be some related bug lurking in our merged bean definition handling.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nI have download latest code and running ./gradlew install then using 4.3.0.BUILD-SNAPSHOT, the issues can be reproduced.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nif there are two different merged bean definitions for same beanName, the method **InjectionMetadata.checkPropertySkipping(PropertyValues pvs)** will not work correctly because same InjectionMetadata cached from **CommonAnnotationBeanPostProcessor.findResourceMetadata** for same beanName but different PropertyValues.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! Thanks for the insight, I'll have another pass today.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've addressed this through synchronizing on `this.mergedBeanDefinitions` now, checking for `this.alreadyCreated.add(beanName)` within and clearing the merged bean definition if the `add` call returned `true`. We still do an non-synchronized `!this.alreadyCreated.contains(beanName)` first, so overall this should not cause any inefficiency in a fully initialized system.\n\nThe use of the `this.mergedBeanDefinitions` lock is in sync with `getMergedBeanDefinition`, in order to prevent interleaving with ongoing merge attempts as well (where an old version might get cached in certain race condition cases otherwise, e.g. with concurrent type matching attempts touching the same bean and the bean definition having been modified inbetween).\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\n`@Juergen` Do you test your code? I have test it and still can reproduce the issue. I have test my pull request via 8 thread and 40000 attempts without reproduce the issue.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt'd be great if you could run your tests against the latest `4.3.0.BUILD-SNAPSHOT` again... Please make sure that it's actually the latest, not a locally cached old snapshot.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOuch, there might indeed be a remaining issue since the `add` exposes itself for early `contains` checks again... I was just checking the re-merge behavior but not potential access to an old bean definition. Alright, one more pass coming here, moving the `add` to the end of the `synchronized` block.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nnot the issue of add method, the issue in your commit is same with no synchronized because the method getMergedLocalBeanDefinition(String beanName) are not synchronized in line 1176.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs far as I can see, with the `add` moved, the code is analogous to your pull request now, just using a different lock to synchronize on.\n\n`getMergedLocalBeanDefinition` does not have to be synchronized from my perspective. As long as the `clearMergedBeanDefinition` call happens before we expose a bean as already created, any actual creation attempts will see the fresh bean definition. And for concurrent type matching purposes, an old bean definition is good enough.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nBTW, I'm currently working on a whole range of 4.2.x backports, so this fix will appear in the upcoming `4.2.7.BUILD-SNAPSHOT` as well (actually, there first).\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nI do not mean getMergedLocalBeanDefinition need synchronized, I mean non-syncrhonzied getMergedLocalBeanDefinition case your commit not work.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThat's true but it isn't meant to cover that case: The common lock is just intended to cover `mergedBeanDefinitions` add/remove attempts, where a remove does not happen while another thread is currently doing a merge (e.g. from a type match attempt) based on potentially outdated metadata... so it rather happens right afterwards then.\n\nIn any case, I can't reproduce the reported issue anymore with the `add` moved to the end of the `synchronized (mergedBeanDefinitions)` block, not even with 8 threads and 40.000 attempts. So I guess we can consider your case covered now? The current `4.2.7.BUILD-SNAPSHOT` and the upcoming `4.3.0.BUILD-SNAPSHOT` contain that candidate state.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of `alreadyCreated` set in `AbstractBeanFactory`.  The original code used `add()` to check if a bean name was already created, then removed it.  The updated code now uses `contains()` to check for existence, adds the bean name only if it's not already present, and critically, adds a `synchronized` block around the `remove` operation on `mergedBeanDefinitions`",
            "avg_logprobs": -0.22649486541748046
        }
    },
    {
        "commit_hash": "716e7de8415485dffe25aee446458deebf540c5c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (typeDescriptor.startsWith(\"[\") || typeDescriptor.startsWith(\"L\")) {\n+\t\t// If the SpEL exitDescriptor is not for a primitive (single character),\n+\t\t// ASM expects the typeDescriptor to end with a ';'.\n+\t\tif (typeDescriptor.length() > 1) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify implementation of SpelNodeImpl.loadClassForExitDescriptor(...)",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional check within `SpelNodeImpl`.  Previously, it checked if the `typeDescriptor` started with `[` or `L`.  The updated code now checks if the `typeDescriptor`'s length is greater than 1.  This suggests a change in how the code handles type descriptors, likely to accommodate ASM's expectations for non-primitive types (which now require a trailing semicolon)",
            "avg_logprobs": -0.2242479133605957
        }
    },
    {
        "commit_hash": "7244c9aea191d5afba4179e69a0139925206a9bd",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationsScanner.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\twhile (source != null && source != Object.class\n-\t\t\t\t&& !hasPlainJavaAnnotationsOnly(source) && remaining > 0) {\n+\t\twhile (source != null && source != Object.class && remaining > 0\n+\t\t\t\t&& !hasPlainJavaAnnotationsOnly(source)) {\n-\t\t\t\tname.startsWith(\"org.springframework.lang.\");\n+\t\t\t\tname.startsWith(\"org.springframework.lang.\") ||\n+\t\t\t\tname.startsWith(\"org.springframework.util.\") ||\n+\t\t\t\t(name.startsWith(\"com.sun\") && !name.contains(\"Proxy\"));",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Add more aggressive annotation element filtering",
        "commit_body": "Refine the element filtering performed by `AnnotationsScanner` to also\ncover `org.springframework.util` and most `com.sun` classes which turn\nout to be referenced quite frequently and which we know contain no\nuseful annotations.\n\nSee gh-21697\n",
        "linked_issues": [
            {
                "issue_id": "21697",
                "issue_title": "Create replacement API for handling merged annotations [SPR-17161]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-17161](https://jira.spring.io/browse/SPR-17161?redirect=false)** and commented\r\n\r\nThe existing `AnnotationUtils` and `AnnotatedElementUtils` have grown quite a bit over the years and could do with being revisited now that we have pretty comprehensive support for merged annotations throughout the framework.\r\n\r\nSome common issues with the current utils classes include:\r\n\r\n* Quite a broad API (~58 public methods between them) that can make it hard for users to find the right method.\r\n* Some performance concerns. The classes often appear near the top when profiling applications and a typical application will synthesize quite a few annotations.\r\n* Difficult to evolve. We have some ideas around using annotation processing at compile time to pre-compute some information. It's quite hard to currently plug this in to the existing code.\r\n* Complicated meta-data relationships. There's quite a complicated relationship between `AnnotatedTypeMetadata` and the utils and the meta-data API is different.\r\n\r\nA new API could help us to determine which methods are really needed and provide the potential for more intelligent caching or pre-computed data.\r\n\r\n---\r\n\r\n**Affects:** 5.1 RC1\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nSome initial prototype work for this is here: https://github.com/philwebb/spring-framework/tree/annotations\n\nThe new API tries to separate the representation of merged annotations from the way that they're discovered. This helps to reduce the surface area of the API since `find...` vs `get...` semantic methods are no longer needed. For example, to get only the direct annotations and related meta-annotations you would call `MergedAnnotations.from(element, SearchStrategy.DIRECT)`. For a complete search of all superclasses and interface you would do  `MergedAnnotations.from(element, SearchStrategy.EXHAUSTIVE)`. Regardless of the method used to find the `MergedAnnotations`, the API is identical and contains contains methods to:\n\n* Determine if an annotation is present\n* Get a single merged annotation\n* Get a stream of a specific annotation type\n* Get a stream of all annotations\n\nThe `MergedAnnotation` interface allows you to inspect information about the annotation and `synthesize` it if required. The method on the interface are also designed to be used when working with streams. Some typical examples:\n\n```java\n// is an annotation present or meta-present\nmergedAnnotations.isPresent(ExampleAnnotation.class);\n\n// get the merged \"value\" attribute of ExampleAnnotation (either direct or meta-present)\nmergedAnnotations.get(ExampleAnnotation.class).getString(\"value\");\n\n// get all meta-annotations but no direct annotations\nmergedAnnotations.stream().anyMatch(MergedAnnotation::isMetaPresent);\n\n// get all ExampleAnnotation declarations (include any meta-annotations) and print the merged \"value\" attributes\nmergedAnnotations.stream(ExampleAnnotation.class).map(a -> a.getString(\"value\")).forEach(System.out::println);\n \n```\n\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the `while` loop condition in `AnnotationsScanner`.  The original condition included a check for `name.startsWith(\"org.springframework.lang.\")` *inside* the loop\\'s continuation condition.  The updated code moves this check *outside* the continuation condition, and adds checks for `name.startsWith(\"org.springframework.util.\")` and `(name.startsWith(\"com.sun\") && !name.contains(\"Proxy\"))`",
            "avg_logprobs": -0.18113630294799804
        }
    },
    {
        "commit_hash": "72590dbb21048245e0af2ea507e7b0896330e89d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/connection/CachingConnectionFactory.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\treturn getCachedProducer((Destination) args[0]);\n+\t\t\t\t\tDestination dest = (Destination) args[0];\n+\t\t\t\t\tif (!(dest instanceof TemporaryQueue || dest instanceof TemporaryTopic)) {\n+\t\t\t\t\t\treturn getCachedProducer(dest);\n+\t\t\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "CachingConnectionFactory does not cache producer for temporary queue/topic",
        "commit_body": "Issue: SPR-16353\n",
        "linked_issues": [
            {
                "issue_id": "20900",
                "issue_title": "JMS Producers are cached even when the destination is a temporary queue causing a memory leak [SPR-16353]",
                "issue_body": "**[Facundo Velazquez](https://jira.spring.io/secure/ViewProfile.jspa?name=facundovs)** opened **[SPR-16353](https://jira.spring.io/browse/SPR-16353?redirect=false)** and commented\n\nLooking at the code, in CachingConnectionFactory class, I can see [this fix](https://github.com/spring-projects/spring-framework/commit/b91e989ad4eb99999fc16944f37509b6bec06901) was added some years ago for fixing the same case but on the consumer side.\nHowever, [Temporary queue producers are always cached](https://github.com/spring-projects/spring-framework/blob/master/spring-jms/src/main/java/org/springframework/jms/connection/CachingConnectionFactory.java#L325).\n\nThis scenario was discovered in a request-response scenario which is causing a memory leak in the Mule ESB.  At least from my perspective, it doesn't make sense, since temporary queues producers won't be used more than once.\n\n---\n\n**Affects:** 4.3.13, 5.0.2\n\n**Issue Links:**\n- #20995 CachingConnectionFactory - Invalid session in session cache\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/72590dbb21048245e0af2ea507e7b0896330e89d, https://github.com/spring-projects/spring-framework/commit/bf4cadaddaae4c89c1015bf9a75b6954f0637313\n\n**Backported to:** [4.3.14](https://github.com/spring-projects/spring-framework/milestone/163?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, we need to skip caching for temporary destinations with producers as well. Fixed for 5.0.3 now, and to be backported to 4.3.14.\n",
                    "**[Facundo Velazquez](https://jira.spring.io/secure/ViewProfile.jspa?name=facundovs)** commented\n\nHi Juergen Hoeller. Thank you very much for the fix!\nPlease let me know if you have an ETA for the 4.3.14 release.\nRegards.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOur current target dates are always up on the roadmap page: https://jira.spring.io/browse/SPR/?selectedTab=com.atlassian.jira.jira-projects-plugin:roadmap-panel\n\nFor 4.3.14, it's currently January 18th. It may move by a few days but it's definitely going out in January still.\n",
                    "**[Facundo Velazquez](https://jira.spring.io/secure/ViewProfile.jspa?name=facundovs)** commented\n\nThank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the method to handle `TemporaryQueue` and `TemporaryTopic` destinations differently.  Previously, all destinations were passed to `getCachedProducer`.  Now, if the destination is a `TemporaryQueue` or `TemporaryTopic`, it's skipped and `getCachedProducer` is not called.  This suggests a performance optimization, likely because temporary destinations don't need caching",
            "avg_logprobs": -0.212248178175938
        }
    },
    {
        "commit_hash": "72685b1d819d0fda74ebf17a489080059051baed",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/FileCopyUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t * Close the {@link Closeable} as a null-safety.\n-\t *\n-\t * @param closeable to close, may be null.\n+\t * Attempt to close the supplied {@link Closeable}, silently swallowing any\n+\t * exceptions.\n+\t * @param closeable the {@code Closeable} to close\n-\tprivate static void close(@Nullable Closeable closeable) {\n-\t\tif (closeable == null) return;\n+\tprivate static void close(Closeable closeable) {\n-\t\t} catch (IOException e) {\n-\t\t\t// do nothing\n+\t\t} catch (IOException ex) {\n+\t\t\t// ignore",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": "See gh-24393\n",
        "linked_issues": [
            {
                "issue_id": "24393",
                "issue_title": "Add close() method in FileCopyUtils to reduce duplication",
                "issue_body": "That can be reduced by the close method.",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master` and revised in 72685b1d819d0fda74ebf17a489080059051baed.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change in `FileCopyUtils.java` modifies the `close` method to handle potential `IOExceptions` during the closing of a `Closeable` object.  The original code silently ignored any exceptions thrown during the close operation.  The updated code now attempts to close the `Closeable`, but catches and ignores any `IOException` that might occur, effectively making the method more robust by preventing exceptions from propagating",
            "avg_logprobs": -0.21165468215942382
        }
    },
    {
        "commit_hash": "739d2881faf7d98bfbf09cab3a5fae0f2e87497d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/annotation/support/PrincipalMethodArgumentResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "- * {@link HandlerMethodArgumentResolver} to a {@link Principal} or {@link Optional} of {@link Principal}.\n+ * Resolver for arguments of type {@link Principal}, including {@code Optional<Principal>}.\n-\t\tif (parameter.isOptional()) {\n-\t\t\treturn Optional.ofNullable(user);\n-\t\t} else {\n-\t\t\treturn user;\n-\t\t}\n+\t\treturn parameter.isOptional() ? Optional.ofNullable(user) : user;",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the resolution of `Principal` arguments.  Previously, there was an `if/else` block to handle optional `Principal` arguments.  The updated code uses a concise ternary operator to achieve the same result, returning either the `Optional`-wrapped `Principal` or the `Principal` itself, depending on whether the parameter is marked as optional. This improves readability and conciseness",
            "avg_logprobs": -0.20293458302815756
        }
    },
    {
        "commit_hash": "7582adc0bc4d9456465338f92198fbcbdc84151a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicates.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tif (requestPath.endsWith(\"/\") && !subPath.endsWith(\"/\")) {\n+\t\t\t\tsubPath += \"/\";\n+\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix trailing slash in nested path",
        "commit_body": "This commit adds a trailing slash to the nested path if the request path\nalso ends with a slash. For instance, given the request \"/foo/bar/\", and\nnested path pattern \"/foo/**\", we expect the nested path to be \u201c/bar/\u201d,\nnot \u201c/bar\".\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure consistency in path endings.  If the `requestPath` ends with a slash (`/`) but the `subPath` does *not*, the `subPath` is modified to append a slash.  This likely addresses a potential issue with handling paths that should include trailing slashes",
            "avg_logprobs": -0.23442560342641977
        }
    },
    {
        "commit_hash": "772a26a743466ef84239aa97f1e07560426ad71b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/PostProcessorRegistrationDelegate.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (beanName != null && this.beanFactory.containsBean(beanName)) {\n+\t\t\tif (beanName != null && this.beanFactory.containsBeanDefinition(beanName)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "polishing",
        "commit_body": "Issue: SPR-12761\n",
        "linked_issues": [
            {
                "issue_id": "17358",
                "issue_title": "ProxyAsyncConfiguration is eagerly loaded due to AsyncAnnotationBeanPostProcessor [SPR-12761]",
                "issue_body": "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** opened **[SPR-12761](https://jira.spring.io/browse/SPR-12761?redirect=false)** and commented\n\nThe test-case to reproduce:\n\n```java\n@ContextConfiguration\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class EnableAsyncTests {\n\n\t@Test\n\tpublic void testIt() {}\n\n\t@Configuration\n\t@EnableAsync\n\tpublic static class ContextConfiguration {\n\n\t}\n\n}\n```\n\nAnd we see in logs:\n\n```\n2015-02-27 12:47:46,007 INFO PostProcessorRegistrationDelegate$BeanPostProcessorChecker [main] : Bean 'org.springframework.scheduling.annotation.ProxyAsyncConfiguration' of type [class org.springframework.scheduling.annotation.ProxyAsyncConfiguration$$EnhancerBySpringCGLIB$$5806bc78] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n```\n\nAs far as I can tell making `ProxyAsyncConfiguration.asyncAdvisor()` bean-method as `static` should fix the issue, because `AsyncAnnotationBeanPostProcessor` is `BeanPostProcessor`.\n\n\n---\n\n**Affects:** 4.1.5\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/772a26a743466ef84239aa97f1e07560426ad71b, https://github.com/spring-projects/spring-framework/commit/31df7155ab40e6f4b98f4fd46ad9229031a716c4\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nUnfortunately, just making it `static` won't work since the arrangement relies on `ImportAware` processing which is only available for non-static configuration class instances.\n\nI suppose this eager loading of the configuration class doesn't cause any actual issues to begin with. So we could also re-consider refining `BeanPostProcessorChecker` towards ignoring synthetic beans, and making sure that `@Enable`-triggered beans are indeed marked as synthetic. This is not the first time we're considering this, after all.\n\nJuergen\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nRevisited the condition to exclude infrastructure beans as those won't be a target for such post-processing.\n",
                    "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** commented\n\nGreat! Thank you, [St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)!\nWith that we can mark some our internal beans with `ROLE_INFRASTRUCTURE` to avoid that noise as well.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `this.beanFactory.containsBean(beanName)` with `this.beanFactory.containsBeanDefinition(beanName)`.  This likely alters the logic to check if a bean *definition* exists, rather than if a fully instantiated bean exists.  This is a subtle but potentially important difference, as a bean definition might exist but not be instantiated yet",
            "avg_logprobs": -0.12987541541075096
        }
    },
    {
        "commit_hash": "775ffbe10b89d419a4d2a1409eccaf51188f93a9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceHttpRequestHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (path.contains(\"../\")) {\n+\t\tif (path.contains(\"..\")) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improve static resource path check",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change simplifies the condition checking for paths containing \"..\" (parent directory).  The original `path.contains(\"../\")` has been replaced with `path.contains(\"..\")`.  This change is functionally equivalent but more concise.  It directly checks for the presence of the parent directory indicator without needing to look for the literal \"../\" substring",
            "avg_logprobs": -0.22056498997647997
        }
    },
    {
        "commit_hash": "7772b914c694b5b16d6e9c9f56acf7b03b47f9d4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (ex instanceof BeanCurrentlyInCreationException) {\n+\t\t\tif (ex.contains(BeanCurrentlyInCreationException.class)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Deep BeanCurrentlyInCreationException check in getTypeForFactoryBean",
        "commit_body": "Issue: SPR-16427\n",
        "linked_issues": [
            {
                "issue_id": "20973",
                "issue_title": "Spurious WARNINGs when XML declared TransactionProxyFactoryBean's target bean depends on an annotation declared bean that depends on another bean [SPR-16427]",
                "issue_body": "**[Andrew H](https://jira.spring.io/secure/ViewProfile.jspa?name=meowpressreturn)** opened **[SPR-16427](https://jira.spring.io/browse/SPR-16427?redirect=false)** and commented\n\nWhile trying to update some old XML configured code to use annotation configuration for bean declarations I started to see many WARNINGs about BeanCreationException in my log on startup.\n\nHaving spend quite some time trying to find where I had created a circular dependency in my beans, I realised that I hadn't and that the WARNINGs were all associated with XML declarations of TransactionProxyFactoryBean. I did some experimentation and created a small project to reproduce the issue in isolation.\n\nConsider the following bean configuration:\n\n**transactionManager**- A no-op dummy implementation of PlatformTransactionManager declared in XML\n\n**bazBean**- A TransactionProxyFactoryBean whose target is bazBean_target\n\n**bazBean_target**, A BazBean that can be declared with XML or with `@Component`, its constructor takes a BarBean\n\n**barBean**- A BarBean declared using `@Component`, its constructor takes a FooBean\n\n**fooBean** - A FooBean declared using XML or `@Component`, its constructor takes no arguments\n\nFor the example, none of these beans need have any methods or actually do anything. The BazBean and BarBean classes use constructor injection, and FooBean has no dependencies. It is necessary for BarBean to depend on another bean. If BarBean has no dependencies then the WARNING doesn't occur.\n\nThe above configuration (with bazBean_target in xml) will result in the following 1 warning being logged on startup:\n\n_WARNING: Bean creation exception on non-lazy FactoryBean type check: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bazBean' defined in class path resource [context.xml]: Cannot resolve reference to bean 'bazBean_target' while setting bean property 'target'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bazBean_target' defined in class path resource [context.xml]: Cannot resolve reference to bean 'barBean' while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'barBean': Requested bean is currently in creation: Is there an unresolvable circular reference?_\n\nIf you define bazBean_target using `@Component` you will get the following 2 warnings logged:\n\n\\_WARNING: Bean creation exception on non-lazy FactoryBean type check: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bazBean' defined in class path resource [context.xml]: Cannot resolve reference to bean 'bazBean_target' while setting bean property 'target'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'bazBean_target' defined in file [C:\\dev\\beancreationwarning\\target\\classes\\com\\example\\beancreationwarning\\beans\\BazBean.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'barBean': Requested bean is currently in creation: Is there an unresolvable circular reference?\nJan 28, 2018 7:51:12 PM org.springframework.beans.factory.support.AbstractBeanFactory getTypeForFactoryBean\nWARNING: Bean creation exception on non-lazy FactoryBean type check: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bazBean' defined in class path resource [context.xml]: Cannot resolve reference to bean 'bazBean_target' while setting bean property 'target'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'bazBean_target': Requested bean is currently in creation: Is there an unresolvable circular reference?_\n\nThe beans do get created and work fine.\n\nThe order of annotated bean creation plays a role:\n\nIn the above example, if you declare another bean using `@Component` that depends on a BarBean and its classname comes alphabetically before BarBean - say \"Aardvard\" for example, then the warning on bazBean vanishes, but if you rename Aardvark to Zebra, the warning will return.\n\nI have not experimented to determine if the issue occurs with Java Config or with other types of ProxyFactoryBean. It is present in Spring 4.3.14 and 5.0.3 (and I would suspect earlier versions, but haven't verified)\n\n---\n\n**Affects:** 4.3.14, 5.0.3\n\n**Attachments:**\n- [beancreationwarning_20180129T123600.zip](https://jira.spring.io/secure/attachment/25355/beancreationwarning_20180129T123600.zip) (_7.43 kB_)\n\n**Issue Links:**\n- #21024 Errors when Java Config declared TransactionProxyFactoryBean's target bean depends on an annotation declared bean that depends on another bean\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/65743a68e6c3c4a12128d2093ec9be2f4954767f, https://github.com/spring-projects/spring-framework/commit/7772b914c694b5b16d6e9c9f56acf7b03b47f9d4\n\n**Backported to:** [4.3.15](https://github.com/spring-projects/spring-framework/milestone/164?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out to be a suboptimal check in `getTypeForFactoryBean`: We should not only check the outer exception for a `BeanCurrentlyInCreationException` but also its underlying causes. Fixed for 5.0.4 now, and to be backported to 4.3.15.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a direct instanceof check with a `contains` method call.  This likely uses a more sophisticated mechanism for determining if the exception `ex` is an instance of `BeanCurrentlyInCreationException` or a subclass.  The `contains` method likely leverages the exception's class hierarchy, potentially offering a more flexible and robust way to handle the check",
            "avg_logprobs": -0.2620449317129035
        }
    },
    {
        "commit_hash": "7816c9e411578493407533315030c476daf160c3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/DefaultParameterNameDiscoverer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import org.springframework.aot.AotDetector;\n-\n- * to the ASM-based {@link LocalVariableTableParameterNameDiscoverer} (when not using\n- * AOT-processed optimizations) for checking debug information in the class file.\n+ * to the ASM-based {@link LocalVariableTableParameterNameDiscoverer} (when not in\n+ * a native image) for checking debug information in the class file.\n-\t\tif (!AotDetector.useGeneratedArtifacts()) {\n+\t\tif (!NativeDetector.inNativeImage()) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Exclude LocalVariableTableParameterNameDiscoverer based on native image check",
        "commit_body": "See gh-29531\n",
        "linked_issues": [
            {
                "issue_id": "29531",
                "issue_title": "Deprecate `LocalVariableTableParameterNameDiscoverer` completely (avoiding its exposure in native images)",
                "issue_body": "`DefaultParameterNameDiscoverer` should be updated to not use `LocalVariableTableParameterNameDiscoverer` when running as a native image.",
                "issue_state": "closed",
                "issue_comment": [
                    "I think this should behave the same way on the JVM. the check should be on AOT not native. ",
                    "Could be great for consistency indeed even if technically on JVM + AOT we have to the capability to use it. Let's validate the choice in today's Framework meeting.",
                    "I updated the PR accordingly.",
                    "An interesting case in terms of automatic exclusion indeed.\r\n\r\nWe certainly don't want to support that parameter name discovery strategy in a native image (where the underlying class files are generally not available), and it's not recommended in any other scenario either... since you can always compile with `-parameters` instead, with no need to parse class files then. In such a recommended setup, `StandardReflectionParameterNameDiscoverer` will always be able to resolve the parameter names first, so `LocalVariableTableParameterNameDiscoverer` will never actually be reached.\r\n\r\nFrom that perspective, for a setup following Java 8+ recommendations, `LocalVariableTableParameterNameDiscoverer` could even be removed completely. It's only really there for backwards compatibility with older setups that got migrated without `-parameters`. Baking that assumption into our AOT arrangement - namely that you need to compile with `-parameters` when you are optimizing for AOT, completely avoiding unnecessary class file parsing - seems sensible.",
                    "I'm afraid we'll have to return to a `NativeDetector` check here since `AotDetector` is in the higher-level `aot` package whereas `DefaultParameterNameDiscoverer` is a very low-level `core` component. Since there is no significant difference to be expected in practice, I don't think the cycle-free narrower check matters. After all, `LocalVariableTableParameterNameDiscoverer` is effectively not applicable in a native image due to its class file parsing approach, so it arguably does make sense to exclude it on that basis and rely on `-parameters` usage by convention.",
                    "Reopening this one after a team discussion: It is ultimately preferable to deprecate `LocalVariableTableParameterNameDiscoverer` completely, not using it by default in any setup anymore, since that class file parsing strategy has been long superseded by the Java 8 `-parameters` flag on `javac` already.\r\n\r\nWe have considered doing this before and meant to address the native image impact of it in 6.0 but somehow missed this last week. So let's fix this glitch now, in time for the Boot 3.0 GA release, with a note in the upgrade wiki page.",
                    "As a lenient measure for the transition period, we'll keep `LocalVariableTableParameterNameDiscoverer` active on the JVM but log a warning for each successful parameter name resolution. This will only be logged when parameter names actually need to be inspected, and only when `StandardReflectionParameterNameDiscoverer` did not return anything, suggesting that compilation with `-parameters` has been missed somewhere."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces the condition for using the ASM-based `LocalVariableTableParameterNameDiscoverer` from checking for AOT-generated artifacts to checking if the code is running in a native image.  Specifically, it replaces `AotDetector.useGeneratedArtifacts()` with `NativeDetector.inNativeImage()`.  This change reflects a shift in how Spring handles AOT compilation, potentially using a different detection mechanism for native image builds",
            "avg_logprobs": -0.17551306618584528
        }
    },
    {
        "commit_hash": "78549d4963a15c6decfd17ea9be15f27c3cdc03c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/client/reactive/JdkClientHttpRequest.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.util.MultiValueMap;\n-\t\tthis.builder.header(HttpHeaders.COOKIE, getCookies().values().stream()\n-\t\t\t\t.flatMap(List::stream).map(HttpCookie::toString).collect(Collectors.joining(\";\")));\n+\t\tMultiValueMap<String, HttpCookie> cookies = getCookies();\n+\t\tif (!cookies.isEmpty()) {\n+\t\t\tthis.builder.header(HttpHeaders.COOKIE, cookies.values().stream()\n+\t\t\t\t\t.flatMap(List::stream).map(HttpCookie::toString).collect(Collectors.joining(\";\")));\n+\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix cookie management in reactive JdkClientHttpRequest",
        "commit_body": "Prevent cookies to be set to empty in the HTTP request if no cookie\nis present\n\nSee gh-32799\n",
        "linked_issues": [
            {
                "issue_id": "32799",
                "issue_title": "Do not send Cookie header in reactive JdkClientHttpRequest if no cookies added",
                "issue_body": "Prevent cookies to be set to empty in the HTTP request if no cookie is present.\r\nThe `Cookie` header should not be sent if no cookie is set in the HTTP message.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null-safety check to the cookie header setting.  Previously, the code unconditionally set the `Cookie` header, potentially leading to errors if `getCookies()` returned an empty map.  The updated code now checks if the `cookies` map is empty. If it is, the header is not set, preventing potential issues.  This change improves robustness by avoiding unnecessary header setting when no cookies are present",
            "avg_logprobs": -0.19010289510091147
        }
    },
    {
        "commit_hash": "787b09b202f0eb507d5e5c687bde5282c5a6bb22",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/DefaultParameterNameDiscoverer.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "- * {@link KotlinReflectionParameterNameDiscoverer} is added first in the list and used\n- * for Kotlin classes and interfaces. When compiling or running as a Graal native image,\n- * no {@link ParameterNameDiscoverer} is used.\n+ * {@link KotlinReflectionParameterNameDiscoverer} is added first in the list and\n+ * used for Kotlin classes and interfaces. When compiling or running as a GraalVM\n+ * native image, the {@code KotlinReflectionParameterNameDiscoverer} is not used.\n+ * @author Sam Brannen\n-\t\tif (!GraalDetector.inImageCode()) {\n-\t\t\tif (KotlinDetector.isKotlinReflectPresent()) {\n-\t\t\t\taddDiscoverer(new KotlinReflectionParameterNameDiscoverer());\n-\t\t\t}\n-\t\t\taddDiscoverer(new StandardReflectionParameterNameDiscoverer());\n-\t\t\taddDiscoverer(new LocalVariableTableParameterNameDiscoverer());\n+\t\tif (KotlinDetector.isKotlinReflectPresent() && !GraalDetector.inImageCode()) {\n+\t\t\taddDiscoverer(new KotlinReflectionParameterNameDiscoverer());\n+\t\taddDiscoverer(new StandardReflectionParameterNameDiscoverer());\n+\t\taddDiscoverer(new LocalVariableTableParameterNameDiscoverer());",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Relax GraalVM check in DefaultParameterNameDiscoverer",
        "commit_body": "Prior to this commit, DefaultParameterNameDiscoverer did not register\nany discovers when compiling or running as a GraalVM native image.\n\nThis commit relaxes the GraalVM check so that it is only applied to the\nregistration of KotlinReflectionParameterNameDiscoverer.\n\nConsequently, StandardReflectionParameterNameDiscoverer and\nLocalVariableTableParameterNameDiscoverer are once again always\nregistered by DefaultParameterNameDiscoverer.\n\nCloses gh-24600\n",
        "linked_issues": [
            {
                "issue_id": "24600",
                "issue_title": "Relax GraalVM checks in DefaultParameterNameDiscoverer",
                "issue_body": "## Status Quo\r\n\r\n`DefaultParameterNameDiscoverer` does not register any default discoverers when running within a GraalVM native image; however, the `LocalVariableTableParameterNameDiscoverer` works properly given appropriate entries in the `resource-config.json` and `reflect-config.json` GraalVM native image configuration files.\r\n\r\nThough not yet verified, `StandardReflectionParameterNameDiscoverer` may potentially work in a current (or future) GraalVM release.\r\n\r\n## Proposal \r\n\r\nWe should relax the checks performed in `DefaultParameterNameDiscoverer` in order to give `LocalVariableTableParameterNameDiscoverer` and `StandardReflectionParameterNameDiscoverer` a chance to work.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the order and conditional application of `ParameterNameDiscoverer` implementations.  Previously, `KotlinReflectionParameterNameDiscoverer` was conditionally added *after* `StandardReflectionParameterNameDiscoverer` and `LocalVariableTableParameterNameDiscoverer`.  Now, it's added first in the list, but only if both Kotlin reflection is present *and* we're not running in a GraalVM native image",
            "avg_logprobs": -0.20189517974853516
        }
    },
    {
        "commit_hash": "7a0e5a378a04817805ddaac30310fb10b12970b7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/ChannelSendOperator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (key == IntAttr.PREFETCH) {\n+\t\tif (key == Attr.PREFETCH) {\n-\t\tif (key == ScannableAttr.PARENT) {\n+\t\tif (key == Attr.PARENT) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Update for reactor-core change",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies two `if` statements in `ChannelSendOperator`.  It replaces `IntAttr.PREFETCH` with `Attr.PREFETCH` and `ScannableAttr.PARENT` with `Attr.PARENT`.  This suggests a renaming of constants related to attributes used in the channel sending operation",
            "avg_logprobs": -0.13908368349075317
        }
    },
    {
        "commit_hash": "7b2c74b05c5ca195f7259e1c4e6a2e94737eb613",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tthis.validator = validator;\n+\t\tif(validator instanceof LocalValidatorFactoryBean) {\n+\t\t\tthis.validator = ((LocalValidatorFactoryBean) validator).getValidator();\n+\t\t}\n+\t\telse {\n+\t\t\tthis.validator = validator;\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improving method validation support for BV 1.1",
        "commit_body": "Update MethodValidationPostProcessor.setValidator(...) to use\nLocalValidatorFactoryBean.getValidator() when possible.\n\nThis is required because LocalValidatorFactoryBean does not directly\nimplement the forExecutables() method introduced in bean validation v1.1.\n\nIssue: SPR-10644\n",
        "linked_issues": [
            {
                "issue_id": "15272",
                "issue_title": "AbstractMethodError thrown within MethodValidationInterceptor [SPR-10644]",
                "issue_body": "**[Nick Williams](https://jira.spring.io/secure/ViewProfile.jspa?name=guitarking117)** opened **[SPR-10644](https://jira.spring.io/browse/SPR-10644?redirect=false)** and commented\n\nI've filed so many bugs since 4.M1 came out, I don't know whether y'all are gonna love me or hate me. :-)\n\nI have the following interface and implementation:\n\n```\n@Validated\npublic interface EmployeeService\n{\n    public void saveEmployee(\n            @NotNull(message = \"{validate.employeeService.saveEmployee}\")\n            @Valid Employee employee\n    );\n\n    public Employee getEmployee(\n            @Min(value = 1L,\n                    message = \"{validate.employeeService.getEmployee.id}\") long id\n    );\n\n    @NotNull\n    public List<Employee> getAllEmployees();\n}\n```\n\n```\n@Service\npublic class DefaultEmployeeService implements EmployeeService\n{\n    @Override\n    public void saveEmployee(Employee employee)\n    {\n        // no-op\n    }\n\n    @Override\n    public Employee getEmployee(long id)\n    {\n        return null;\n    }\n\n    @Override\n    public List<Employee> getAllEmployees()\n    {\n        return null; // to force trigger a validation error\n    }\n}\n```\n\nI then have a simple controller that uses the service:\n\n```\n@Controller\npublic class EmployeeController\n{\n    @Inject EmployeeService employeeService;\n\n    @RequestMapping(value = \"/\", method = RequestMethod.GET)\n    public String listEmployees(Map<String, Object> model)\n    {\n        model.put(\"employees\", this.employeeService.getAllEmployees());\n        return \"employee/list\";\n    }\n}\n```\n\nI defined a `MethodValidationPostProcessor`, which attaches a `MethodValidationInterceptor` to my `DefaultEmployeeService` methods. When I go to the handler method in the browser, I get this error:\n\n```\njava.lang.AbstractMethodError: org.springframework.validation.beanvalidation.LocalValidatorFactoryBean.forExecutables()Ljavax/validation/executable/ExecutableValidator;\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:491)\n\torg.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:191)\n\torg.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:176)\n\torg.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:118)\n\torg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\torg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)\n\tcom.sun.proxy.$Proxy36.getAllEmployees(Unknown Source)\n\tcom.wrox.site.EmployeeController.listEmployees(EmployeeController.java:23)\n\tsun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:491)\n\torg.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:219)\n\torg.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)\n\torg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\n\torg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:747)\n\torg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:688)\n\torg.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)\n\torg.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:925)\n\torg.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856)\n\torg.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:946)\n\torg.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:837)\n\tjavax.servlet.http.HttpServlet.service(HttpServlet.java:621)\n\torg.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:822)\n\tjavax.servlet.http.HttpServlet.service(HttpServlet.java:728)\n\torg.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:83)\n```\n\nThis is because `LocalValidatorFactoryBean` (`SpringValidatorAdapter`) does not implement `forExecutables`. Here's what the JavaDoc has to say about that:\n\n> Note that Bean Validation 1.1's #forExecutables method isn't supported: We do not expect that method to be called by application code; consider MethodValidationInterceptor instead. If you really need programmatic #forExecutables access, inject this class as a ValidatorFactory and call getValidator() on it, then #forExecutables on the returned native Validator reference instead of directly on this class.\n\nWell, I am using a `MethodValidationInterceptor`. `MethodValidationInterceptor` calls `forExecutables`, so I'm sure you can see the problem here. I managed to work around this by changing my post-processor definition from this:\n\n```\n@Bean\npublic MethodValidationPostProcessor methodValidationPostProcessor()\n{\n    MethodValidationPostProcessor processor =\n            new MethodValidationPostProcessor();\n    processor.setValidator(this.localValidatorFactoryBean());\n    return processor;\n}\n```\n\nTo this:\n\n```\n@Bean\npublic MethodValidationPostProcessor methodValidationPostProcessor()\n{\n    MethodValidationPostProcessor processor =\n            new MethodValidationPostProcessor();\n    processor.setValidator(this.localValidatorFactoryBean().getValidator());\n    return processor;\n}\n```\n\nHowever, this is non-obvious and certainly not documented clearly.\n\nI see no reason for the restriction documented on `LocalValidatorFactoryBean` regarding `forExecutables`. There's no reason that `SpringValidatorAdapter` can't implement this method. If the underlying `Validator` is BV 1.1, great. If it's not, the call to the method will throw an `AbstractMethodError`. But it already does that now, just always, even if the `Validator` is BV 1.1.\n\nI'll send in a pull request shortly.\n\n\n---\n\n**Affects:** 4.0 M1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/7b2c74b05c5ca195f7259e1c4e6a2e94737eb613, https://github.com/spring-projects/spring-framework/commit/84249740b85e6b414a6969d79aa2bb73602dedd6\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Nick Williams](https://jira.spring.io/secure/ViewProfile.jspa?name=guitarking117)** commented\n\nHmmm. This wasn't as easy as I thought it was going to be. `forExecutables` returns a type that is also new to BV 1.1, so I can't just add a method that isn't `@Override` but has the same signature and return type. So, the way I see it, we have two options:\n\n1) Upgrade the library to BV 1.1, implement the method, and then document that the method is not supported and throws `AbstractMethodError` if you're using BV 1.0 instead of 1.1 (not a huge change from now, but makes configuration more obvious, so I'm for this one).\n\n2) Update the `MethodValidationInterceptor` (or would `MethodValidationPostProcessor` be better?) to detect if its `Validator` is a `SpringValidatorAdapter` and get the underlying `Validator` in that case. This would achieve the simplification of configuration without upgrading to BV 1.1. However, it feels like a hack to me. I'm open to this idea, and will submit a pull request if y'all think it's the best route to take.\n\nThoughts?\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nI think we will want to retain BV 1.0 support at least with Spring 4.0 so option 2 would look better to me.\n\nWhat about changing `MethodValidationPostProcessor.setValidator`\n\n```java\npublic void setValidator(Validator validator) {\n\tif(validator instanceof ValidatorFactory) {\n\t\tthis.validator = ((ValidatorFactory) validator).getValidator();\n\t}\n\telse {\n\t\tthis.validator = validator;\n\t}\n}\n```\n\nWould that work?\n",
                    "**[Nick Williams](https://jira.spring.io/secure/ViewProfile.jspa?name=guitarking117)** commented\n\nAgreed. I had already implemented this in my local repository and verified that it resolved the issue I was seeing. I have now pushed the commit and submitted a pull request.\n\nhttps://github.com/SpringSource/spring-framework/pull/305\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nThanks, I have applied this with the minor change of checking for `LocalValidatorFactoryBean` rather than `ValidatorFactory`.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code now checks if the injected `validator` is an instance of `LocalValidatorFactoryBean`.  If it is, it retrieves the underlying validator from the `LocalValidatorFactoryBean` and assigns that to the `this.validator` field. Otherwise, it assigns the original `validator` to `this.validator`.  This change likely aims to ensure that the actual validator instance is used, rather than a factory",
            "avg_logprobs": -0.13909496579851424
        }
    },
    {
        "commit_hash": "7b3f5fd855fe822ef1bfb21c3fa0d430c0713e39",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ResourceUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t// Tomcat's \"jar:war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt\"\n+\t\t\t// Tomcat's \"war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt\"\n+\t\t\tif (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {\n+\t\t\t\treturn new URL(warFile);\n+\t\t\t}\n-\t * <p>Furthermore, this method works on JDK 1.4 as well,\n-\t * in contrast to the {@code URL.toURI()} method.",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ResourceUtils.extractArchiveURL properly deals with top-level war URLs",
        "commit_body": "Issue: SPR-15556\n",
        "linked_issues": [
            {
                "issue_id": "20115",
                "issue_title": "ResourceUtils.extractArchiveURL fails to work under Tomcat 8.0.41 with unpackWARs=false [SPR-15556]",
                "issue_body": "**[Alexey Veklov](https://jira.spring.io/secure/ViewProfile.jspa?name=veklov)** opened **[SPR-15556](https://jira.spring.io/browse/SPR-15556?redirect=false)** and commented\n\nHi\n\nIt looks like ResourceUtils.extractArchiveURL also has an issue (Spring 4.3.8.RELEASE).\n\nSee comments in below snippet (marked with AV):\n\n```\npublic static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {\n           // AV jarUrl = war:file:/C:/<...>.war*/<...>/<...>.css\n     String urlFile = jarUrl.getFile();\n           // AV urlFile = file:/C:/<...>.war*/<...>/<...>.css\n     int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);\n     if (endIndex != -1) {\n          // Tomcat's \"jar:war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt\"\n          String warFile = urlFile.substring(0, endIndex);\n          int startIndex = warFile.indexOf(WAR_URL_PREFIX); // AV <-- startIndex == -1\n          if (startIndex != -1) {\n                    return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));\n           }\n      }\n      // Regular \"jar:file:...myjar.jar!/myentry.txt\"\n      return extractJarFileURL(jarUrl);\n }\n```\n\n---\n\n**Affects:** 4.3.8\n\n**Issue Links:**\n- #19895 PathMatchingResourcePatternResolver fails to work under Tomcat 8.0.41 with unpackWARs=false\n- #20240 Classpath Resource URL handling still wrong with Tomcat 8.5.12\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/c6deeb31ecc73f56b3b5d43df4cd87fe8112814d, https://github.com/spring-projects/spring-framework/commit/7b3f5fd855fe822ef1bfb21c3fa0d430c0713e39\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the handling of \"war\" protocol URLs in `ResourceUtils`.  Specifically, it removes the now-unnecessary \"jar:war\" prefix check and replaces it with a direct check for the \"war\" protocol.  This suggests a simplification of the URL parsing logic, potentially removing redundant steps.  The change also returns a new `URL` object constructed from the `warFile` string.  The original comment about compatibility with JDK 1.4 is removed",
            "avg_logprobs": -0.28504159927368167
        }
    },
    {
        "commit_hash": "7b95bd72f7e9922f655c582f47c2fe80d8664a1b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (mimeTypes.size() >= 50) {\n+\t\tif (mimeTypes.size() > 50) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix condition for \"Too many elements\" in MimeTypeUtils.sortBySpecificity()",
        "commit_body": "See gh-31254\nCloses gh-31769\n",
        "linked_issues": [
            {
                "issue_id": "31254",
                "issue_title": "HeaderContentNegotiationStrategy.resolveMediaTypes throws unexpected IllegalArgumentException ",
                "issue_body": "**Affects:** 6.0.11\r\n\r\nParsing of http accept header throws IllegalArguemntException which is unexpected, and causes unexpected application behavior.\r\nExample stack trace\r\n\r\n```\r\nToo many elements\r\njava.lang.IllegalArgumentException: Too many elements\r\nat org.springframework.util.Assert.isTrue(Assert.java:122)\r\nat org.springframework.util.MimeTypeUtils.sortBySpecificity(MimeTypeUtils.java:365)\r\nat org.springframework.web.accept.HeaderContentNegotiationStrategy.resolveMediaTypes(HeaderContentNegotiationStrategy.java:55)\r\nat org.springframework.web.accept.ContentNegotiationManager.resolveMediaTypes(ContentNegotiationManager.java:128)\r\nat org.springframework.web.servlet.mvc.condition.ProducesRequestCondition.getAcceptedMediaTypes(ProducesRequestCondition.java:290)\r\nat org.springframework.web.servlet.mvc.condition.ProducesRequestCondition.getMatchingCondition(ProducesRequestCondition.java:208)\r\nat org.springframework.web.servlet.mvc.method.RequestMappingInfo.getMatchingCondition(RequestMappingInfo.java:401)\r\nat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:110)\r\nat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getMatchingMapping(RequestMappingInfoHandlerMapping.java:68)\r\n```\r\n\r\nClass HeaderContentNegotiationStrategy currently catches only InvalidMediaTypeException, but IllegalArgumentException can also be thrown here.\r\n```\r\npublic List<MediaType> resolveMediaTypes(NativeWebRequest request)\r\n\t\t\tthrows HttpMediaTypeNotAcceptableException {\r\n\r\n\t\tString[] headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT);\r\n\t\tif (headerValueArray == null) {\r\n\t\t\treturn MEDIA_TYPE_ALL_LIST;\r\n\t\t}\r\n\r\n\t\tList<String> headerValues = Arrays.asList(headerValueArray);\r\n\t\ttry {\r\n\t\t\tList<MediaType> mediaTypes = MediaType.parseMediaTypes(headerValues);\r\n\t\t\tMimeTypeUtils.sortBySpecificity(mediaTypes);\r\n\t\t\treturn !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;\r\n\t\t}\r\n\t\tcatch (InvalidMediaTypeException ex) {\r\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n\t\t}\r\n\t}\r\n```\r\nplease consider changing of this catch to IllegalArgumentException (InvalidMediaTypeException  is a subclass of IllegalArgumentException). This change would make behavior more predictable. \r\n\r\n\r\n\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Good catch!\r\n\r\nAlthough this is very minor, it is technically a regression. \r\n\r\nSo I've labeled it as such, and we'll back port it to 6.0.x",
                    "@sbrannen in #31254 it was notified `MimeTypeUtils.sortBySpecificity` was throwing an `IllegalArgumentException` when the number of MimeTypes in the Accept header was greater than 50. \r\n\r\nTo fix it, the proposed change was to modify `HeaderContentNegotiationStrategy` to catch `IllegalArgumentExceptiion` instead of `InvalidMediaTypeException` (`InvalidMediaTypeException` is a sub-type of `IllegalArgumentException`).\r\n\r\nInstead, the `assert` that was throwing the `IllegalArgumentException` was replaced by an `if` condition that throws `InvalidMimeTypeException` which is a sub-type of `IllegalArgumentException`.\r\n\r\nTherefore, the same runtime problem is being reproduced. Only changed `IllegalArgumentException` with `InvalidMimeTypeException`.\r\n\r\nThis problem was reported in this issue and it was just changed the `if` statement replacing the `>=` with `>`.\r\n\r\nWhy haven't you changed the `catch` clause as originally requested in #31254? The same runtime crash is still happening.",
                    "@jandroalvarez, please note that this PR was closed over 3 months ago in 6.1.2.\r\n\r\nIf you believe you have discovered a further regression or bug, please open a new issue.\r\n\r\nThanks",
                    "To answer your question, it appears there may have been an oversight.\r\n\r\n> Why haven't you changed the `catch` clause as originally requested in #31254? The same runtime crash is still happening.\r\n\r\nI suppose you're proposing to change what we currently have from:\r\n\r\n```java\r\ncatch (InvalidMediaTypeException ex) {\r\n\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n}\r\n```\r\n\r\nTo:\r\n\r\n```java\r\ncatch (InvalidMediaTypeException | InvalidMimeTypeException ex) {\r\n\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n}\r\n```\r\n\r\nOr:\r\n\r\n```java\r\ncatch (IllegalArgumentException ex) {\r\n\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n}\r\n```\r\n\r\nI'm not convinced that we should catch `IllegalArgumentException` there.\r\n\r\nBut if you're effectively suggesting the former (`InvalidMediaTypeException | InvalidMimeTypeException`), then please [create a new issue](https://github.com/spring-projects/spring-framework/issues/new).\r\n\r\nCheers!",
                    "@jandroalvarez, to ensure the issue you've reported does not get lost, I am going to go ahead and create a new issue based on your input now.\r\n\r\nSo, there's no need for you to create a new issue.\r\n\r\n- See #32483"
                ]
            },
            {
                "issue_id": "31769",
                "issue_title": "Fix condition for \"Too many elements\" in `MimeTypeUtils.sortBySpecificity()`",
                "issue_body": "This PR fixes condition for \"Too many elements\" in `MimeTypeUtils.sortBySpecificity()` that seems to have been changed accidentally in 05c3ffb2fbdf358c6a23309a3118b0a64ecb4b40 to align with its Javadoc again.\r\n\r\nSee gh-31254",
                "issue_state": "closed",
                "issue_comment": [
                    "Good catch!\r\n\r\nAlthough this is very minor, it is technically a regression. \r\n\r\nSo I've labeled it as such, and we'll back port it to 6.0.x",
                    "@sbrannen in #31254 it was notified `MimeTypeUtils.sortBySpecificity` was throwing an `IllegalArgumentException` when the number of MimeTypes in the Accept header was greater than 50. \r\n\r\nTo fix it, the proposed change was to modify `HeaderContentNegotiationStrategy` to catch `IllegalArgumentExceptiion` instead of `InvalidMediaTypeException` (`InvalidMediaTypeException` is a sub-type of `IllegalArgumentException`).\r\n\r\nInstead, the `assert` that was throwing the `IllegalArgumentException` was replaced by an `if` condition that throws `InvalidMimeTypeException` which is a sub-type of `IllegalArgumentException`.\r\n\r\nTherefore, the same runtime problem is being reproduced. Only changed `IllegalArgumentException` with `InvalidMimeTypeException`.\r\n\r\nThis problem was reported in this issue and it was just changed the `if` statement replacing the `>=` with `>`.\r\n\r\nWhy haven't you changed the `catch` clause as originally requested in #31254? The same runtime crash is still happening.",
                    "@jandroalvarez, please note that this PR was closed over 3 months ago in 6.1.2.\r\n\r\nIf you believe you have discovered a further regression or bug, please open a new issue.\r\n\r\nThanks",
                    "To answer your question, it appears there may have been an oversight.\r\n\r\n> Why haven't you changed the `catch` clause as originally requested in #31254? The same runtime crash is still happening.\r\n\r\nI suppose you're proposing to change what we currently have from:\r\n\r\n```java\r\ncatch (InvalidMediaTypeException ex) {\r\n\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n}\r\n```\r\n\r\nTo:\r\n\r\n```java\r\ncatch (InvalidMediaTypeException | InvalidMimeTypeException ex) {\r\n\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n}\r\n```\r\n\r\nOr:\r\n\r\n```java\r\ncatch (IllegalArgumentException ex) {\r\n\tthrow new HttpMediaTypeNotAcceptableException(\r\n\t\t\t\"Could not parse 'Accept' header \" + headerValues + \": \" + ex.getMessage());\r\n}\r\n```\r\n\r\nI'm not convinced that we should catch `IllegalArgumentException` there.\r\n\r\nBut if you're effectively suggesting the former (`InvalidMediaTypeException | InvalidMimeTypeException`), then please [create a new issue](https://github.com/spring-projects/spring-framework/issues/new).\r\n\r\nCheers!",
                    "@jandroalvarez, to ensure the issue you've reported does not get lost, I am going to go ahead and create a new issue based on your input now.\r\n\r\nSo, there's no need for you to create a new issue.\r\n\r\n- See #32483"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement.  Previously, the code checked if the `mimeTypes` list had 50 or more elements.  The change now checks if the list has *greater than* 50 elements.  This is a subtle but important change, as it avoids a potential issue where a list of exactly 50 elements would trigger the block, which it no longer will",
            "avg_logprobs": -0.2580459873850753
        }
    },
    {
        "commit_hash": "7c47f554c02a506a8f69af2f7d664794b0df3479",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (asyncManager.hasConcurrentResult() &&\n-\t\t\t\t\tasyncManager.getConcurrentResultContext().length > 0 &&\n-\t\t\t\t\tasyncManager.getConcurrentResultContext()[0] instanceof ModelAndViewContainer) {\n-\n+\t\t\tif (asyncManager.hasConcurrentResult()) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary check in RequestMappingHandlerAdapter",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant check for the length of the `asyncManager.getConcurrentResultContext()` array and whether the first element is an instance of `ModelAndViewContainer`.  The original code was effectively checking for a non-empty array containing a `ModelAndViewContainer` at index 0.  The updated code simplifies this by only checking if `asyncManager.hasConcurrentResult()` is true.  This suggests a potential optimization, as the previous check involved multiple array operations",
            "avg_logprobs": -0.24375400940577188
        }
    },
    {
        "commit_hash": "7d3f42b27bd0042f1461e3e2ef45bbd641b05fa3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/config/AbstractJmsListenerEndpoint.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.util.StringUtils;\n+\t/**\n+\t * Set a custom id for this endpoint.\n+\t */\n+\t/**\n+\t * Return the id of this endpoint (possibly generated).\n+\t */\n+\t\tif (StringUtils.hasText(getId())) {\n+\t\t\tlistenerContainer.setBeanName(getId());\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Expose endpoint id as listener container name (for transaction/thread name)",
        "commit_body": "Closes gh-26683\n",
        "linked_issues": [
            {
                "issue_id": "26683",
                "issue_title": "Expose @JmsListener endpoint id to annotation-derived listener container (for transaction definition name)",
                "issue_body": "\r\nTransaction name is always null when debug logging `@Transactional`` @JmsListener` methods.\r\n\r\nThis chunk of code in `AbstractPollingMessageListenerContainer `returns null for` getBeanName():`\r\n\r\n```\r\n                                // Use bean name as default transaction name.\r\n                                if (this.transactionDefinition.getName() == null) {\r\n                                                String beanName = getBeanName();\r\n                                                if (beanName != null) {\r\n                                                                this.transactionDefinition.setName(beanName);\r\n                                                }\r\n                                }\r\n```\r\n\r\nIt should be easy to support by setting the beanName from the endpoint passed into `createListenerContainer(JmsListenerEndpoint endpoint) {  ... }` in `AbstractJmsListenerContainerFactory`.",
                "issue_state": "closed",
                "issue_comment": [
                    "As a side note, exposing the endpoint id also enables the listener container to use specific thread names based on that id, just like the bean name for a manually defined listener container is also showing up in the thread names (with the default task executor)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to potentially set the `listenerContainer`'s `beanName` to the `AbstractJmsListenerEndpoint`'s `id` if the `id` is not null or empty.  This suggests a mechanism for customizing the listener container's name based on the endpoint's ID.  The addition of `StringUtils.hasText` improves the robustness of the code by avoiding potential `NullPointerExceptions` and handling empty strings",
            "avg_logprobs": -0.15852262597335012
        }
    },
    {
        "commit_hash": "7defbfc18b5e43f1de271419ea37ace7a2984d43",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tWebSocketSessionHolder holder = this.sessions.get(session.getId());\n+\t\tif (holder != null) {\n+\t\t\tsession = holder.getSession();\n+\t\t}\n-\t\tWebSocketSessionHolder holder = this.sessions.get(session.getId());",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ensure concurrent WebSocketSession wrapper is used",
        "commit_body": "Issue: SPR-13326\n",
        "linked_issues": [
            {
                "issue_id": "17911",
                "issue_title": "Race condition when inbound message handling fails and StompSubProtocolHandler sends ERROR frame [SPR-13326]",
                "issue_body": "**[Tong Chen](https://jira.spring.io/secure/ViewProfile.jspa?name=chentong)** opened **[SPR-13326](https://jira.spring.io/browse/SPR-13326?redirect=false)** and commented\n\nIf for any reason such as some message parsing failed, StompSubProtocolHandler.sendErrorMessage is called and it ultimately calling StandardWebSocketSession.sendTextMessage to send the error msg back to client.\n\nBut from that method call I am getting exception:\n\"The remote endpoint was in state [TEXT_PARTIAL_WRITING] which is an invalid state for called method\".\n\nIt looks like a race condition because when it is trying to use the native session to send msg back, the native session is also used by other normal messages.\nAdding the following work around seems to fixed the problem.\n\n```java\n@Override\nprotected void sendTextMessage(TextMessage message) throws IOException {\n    Session nativeSession = getNativeSession();\n    synchronized (nativeSession) {\n        nativeSession.getBasicRemote().sendText(message.getPayload(), message.isLast());\n    }\n}\n```\n\nThe message calling flow is quite complicated so I may have missed something obvious please let me know if my observation is flawed.\n\n---\n\n**Issue Links:**\n- #18029 Lock acquired on object responseLock in method sendMessageInternal of class AbstractHttpSockJsSession is not released in some error condition resulting in deadlock\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/33f9eadd6a2e2eceacdb78bb2432d1a788024512, https://github.com/spring-projects/spring-framework/commit/7defbfc18b5e43f1de271419ea37ace7a2984d43\n\n**Backported to:** [4.1.8](https://github.com/spring-projects/spring-framework/milestone/132?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nWhat version of Spring Framework are you using and also what server/version?\n\nThe `SubProtocolWebSocketHandler` which delegates to `StompSubProtocolHandler` wraps every WebSocketSession with `ConcurrentWebSocketSessionDecorator` and that has been the case since 4.0.3. Can you provide a stack trace that will confirm if the session decoration is in place? Also are you using more or less standard `@EnableWebSocketMessageBroker` setup or something else?\n",
                    "**[Tong Chen](https://jira.spring.io/secure/ViewProfile.jspa?name=chentong)** commented\n\nI am using spring 4.1.5.RELEASE\nAnd I am using WebSocketMessageBrokerConfigurationSupport (rather than `@EnableWebSocketMessageBroker`) and only configured     \nregistry.addEndpoint(\"/dashboard\").withSockJS()\nand\nregistry.enableSimpleBroker(\"/topic/\");\nregistry.setApplicationDestinationPrefixes(\"/\");\n\nStacktrace\njava.lang.IllegalStateException: The remote endpoint was in state [TEXT_PARTIAL_WRITING] which is an invalid state for called method\nat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$StateMachine.checkState(WsRemoteEndpointImplBase.java:1148)\nat org.apache.tomcat.websocket.WsRemoteEndpointImplBase$StateMachine.textPartialStart(WsRemoteEndpointImplBase.java:1106)\nat org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendPartialString(WsRemoteEndpointImplBase.java:224)\nat org.apache.tomcat.websocket.WsRemoteEndpointBasic.sendText(WsRemoteEndpointBasic.java:49)\nat org.springframework.web.socket.adapter.standard.StandardWebSocketSession.sendTextMessage(StandardWebSocketSession.java:199)\nat org.springframework.web.socket.adapter.AbstractWebSocketSession.sendMessage(AbstractWebSocketSession.java:105)\nat org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.writeFrameInternal(WebSocketServerSockJsSession.java:222)\nat org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.writeFrame(AbstractSockJsSession.java:325)\nat org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.sendMessageInternal(WebSocketServerSockJsSession.java:212)\nat org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.sendMessage(AbstractSockJsSession.java:161)\nat org.springframework.web.socket.messaging.StompSubProtocolHandler.sendErrorMessage(StompSubProtocolHandler.java:312)\nat org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageFromClient(StompSubProtocolHandler.java:276)\nat org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:309)\nat org.springframework.web.socket.handler.WebSocketHandlerDecorator.handleMessage(WebSocketHandlerDecorator.java:75)\nat org.springframework.web.socket.handler.LoggingWebSocketHandlerDecorator.handleMessage(LoggingWebSocketHandlerDecorator.java:56)\nat org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecorator.handleMessage(ExceptionWebSocketHandlerDecorator.java:72)\nat org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.delegateMessages(AbstractSockJsSession.java:385)\nat org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.handleMessage(WebSocketServerSockJsSession.java:194)\nat org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler.handleTextMessage(SockJsWebSocketHandler.java:92)\nat org.springframework.web.socket.handler.AbstractWebSocketHandler.handleMessage(AbstractWebSocketHandler.java:43)\nat org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.handleTextMessage(StandardWebSocketHandlerAdapter.java:112)\nat org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.access$000(StandardWebSocketHandlerAdapter.java:42)\nat org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:82)\nat org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:79)\nat org.apache.tomcat.websocket.WsFrameBase.sendMessageText(WsFrameBase.java:393)\nat org.apache.tomcat.websocket.WsFrameBase.processDataText(WsFrameBase.java:494)\nat org.apache.tomcat.websocket.WsFrameBase.processData(WsFrameBase.java:289)\nat org.apache.tomcat.websocket.WsFrameBase.processInputBuffer(WsFrameBase.java:130)\nat org.apache.tomcat.websocket.server.WsFrameServer.onDataAvailable(WsFrameServer.java:60)\nat org.apache.tomcat.websocket.server.WsHttpUpgradeHandler$WsReadListener.onDataAvailable(WsHttpUpgradeHandler.java:203)\nat org.apache.coyote.http11.upgrade.AbstractServletInputStream.onDataAvailable(AbstractServletInputStream.java:198)\nat org.apache.coyote.http11.upgrade.AbstractProcessor.upgradeDispatch(AbstractProcessor.java:96)\nat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:654)\nat org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223)\nat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1558)\nat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1515)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\nat java.lang.Thread.run(Thread.java:745)\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOops, looks like we are only passing the concurrent session decorator to SubProtocolHandler for outbound messages and never did so for inbound messages for which we don't typically use the session unless inbound message handling fails and we try to send an ERROR frame to the client. Thanks for reporting!\n",
                    "**[Tong Chen](https://jira.spring.io/secure/ViewProfile.jspa?name=chentong)** commented\n\nThanks Rossen, in the mean time, can you suggest a nicer workaround (rather than the synchronized block I put in)?\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nSince you're already using WebSocketMessageBrokerConfigurationSupport, you could override subProtocolWebSocketHandler and return a SubProtocolWebSocketHandler sub-class overriding `handleMessage(WebSocketSession session, WebSocketMessage<?> message)` and delegating to `super` with a decorated session. The only catch is that the map with decorated sessions is a private field in SubProtocolWebSocketHandler so you'll have to get it with reflection I'm afraid (e.g. using ReflectionUtils#makeAccessible).\n",
                    "**[Chandan](https://jira.spring.io/secure/ViewProfile.jspa?name=cpandey05)** commented\n\nIs this issue Only with Stomp? I am observing similar issue while using SockJs support -client is sockjs which uses JSON RPC protocol. For some conditions it is resulting in Race Conditions:\nWaiting for Monitor Lock on java/lang/Object@0x000000000C9465E0\nat org/springframework/web/socket/sockjs/transport/session/AbstractHttpSockJsSession.sendMessageInternal(AbstractHttpSockJsSession.java:279(Compiled Code))\nat org/springframework/web/socket/sockjs/transport/session/AbstractSockJsSession.sendMessage(AbstractSockJsSession.java:161(Compiled Code))\n\nAbstractHttpSockJsSession acquires a lock while sending message :\n`@Override`\nprotected final void sendMessageInternal(String message) throws SockJsTransportFailureException {\nsynchronized (this.responseLock) {\n\nFor this reason, I was not using lock in my handlers. When a synchronised block, it alleviates the issue\n\n`@Override`\npublic void handleTextMessage(WebSocketSession session,\nTextMessage message) {\nsynchronized (engine) {\nengine.handle(message.getPayload());\n}\n}\n\nI am using 4.1.5 but I am unable to assess the exact cause of race condition. If possible, please confirm if this issue is for HTTP handlers as well -then I can propose a lib upgrade (We use platform so it might be a tedious process and needs concrete validations)\n",
                    "**[Andre Gon\u00e7alves](https://jira.spring.io/secure/ViewProfile.jspa?name=andrepcg)** commented\n\n`@Chandan` I'm having the same issue with SockJS. I'm on 4.2.7\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nAre you at the WebSocket/SockJS level, i.e. not using the sub-protocol support? The STOMP support also takes care of sending messages concurrently. If using a WebSocketSession directly you need take care of synchronizing the sends. This shouldn't be too hard however if you wrap the session. See my response under #18029.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check to retrieve a `WebSocketSessionHolder` from a `sessions` map.  If found, the `session` is updated to the one held in the `holder`.  This implies the previous version lacked this crucial step of potentially retrieving a session from a cache or holder",
            "avg_logprobs": -0.2627608189817335
        }
    },
    {
        "commit_hash": "7e8ffc7bf56dcc9d7fcc3992589b126b0eecf22f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/env/CompositePropertySource.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (propertySource instanceof EnumerablePropertySource) {\n-\t\t\t\tnames.addAll(Arrays.asList(((EnumerablePropertySource<?>) propertySource).getPropertyNames()));\n+\t\t\tif (!(propertySource instanceof EnumerablePropertySource)) {\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\t\"Failed to enumerate property names due to non-enumerable property source: \" + propertySource);\n+\t\t\tnames.addAll(Arrays.asList(((EnumerablePropertySource<?>) propertySource).getPropertyNames()));",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "CompositePropertySource rejects getPropertyNames call when containing a non-enumerable source",
        "commit_body": "Issue: SPR-12788\n",
        "linked_issues": [
            {
                "issue_id": "17385",
                "issue_title": "CompositePropertySource doesn't fulfil EnumerablePropertySource [SPR-12788]",
                "issue_body": "**[Konrad Garus](https://jira.spring.io/secure/ViewProfile.jspa?name=konrad.garus)** opened **[SPR-12788](https://jira.spring.io/browse/SPR-12788?redirect=false)** and commented\n\nIn #16897 `CompositePropertySource` became `EnumerablePropertySource`. It doesn't fully satisfy its contract though and it violates Liskov substitution principle.\n\nFor example, Spring Boot assumes that `EnumerablePropertySource.getPropertyNames` contains names of all properties available on the property source. That is not the case with `CompositePropertySource` containing non-enumerable property sources. See also https://github.com/spring-projects/spring-boot/issues/2608\n\n---\n\n**Affects:** 4.1.5\n\n**Issue Links:**\n- #16897 CompositePropertySource should extend EnumerablePropertySource\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/7e8ffc7bf56dcc9d7fcc3992589b126b0eecf22f\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point, but I wonder what we can do about this... A `CompositePropertySource` won't be able to retrieve property names from a contained non-enumerable source. We cannot un-implement `EnumerablePropertySource`, so the only option seems to be to refine the latter's javadoc and clarify that the exposed property names are not necessarily complete. (And that separately checking for `CompositePropertySource` may make sense.)\n\nJuergen\n",
                    "**[Konrad Garus](https://jira.spring.io/secure/ViewProfile.jspa?name=konrad.garus)** commented\n\nIf you change the contract on `EnumerablePropertySource`, what would this class represent? A `PropertySource` that provides a way to see **some** of its property names?\n\nIf that was the official specification, it would pretty much mean: \"Use at your own risk, but in the end you'll have to call `getProperty` to **really** see if it contains given property\".\n\n`EnumerablePropertySource` has very clean, but strong specification. I'd say if some property source cannot satisfy it, it shouldn't pretend it does. Maybe it should throw something like `IllegalStateException` if you call `getPropertyNames` and it finds itself containing a non-enumerable `PropertySource`?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI like that idea: an `IllegalStateException` when it encounters a non-enumerable property source underneath sounds like a fine compromise.\n\nWe can easily make this change for 4.2. However, for 4.1.x, it's probably better to preserve the existing behavior, avoiding any disruption at this late maintenance stage of the branch.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `CompositePropertySource` modifies the handling of `EnumerablePropertySource` instances.  The original code checked if a `propertySource` was an `EnumerablePropertySource` and, if so, added its property names to a list.  The change now reverses this logic: it checks if the `propertySource` *is not* an `EnumerablePropertySource`",
            "avg_logprobs": -0.12230797767639161
        }
    },
    {
        "commit_hash": "7ea85a959c810c1689fc04b8d0c2bd17e5fe6e08",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/multipart/support/StandardServletMultipartResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t// To be on the safe side: explicitly delete all parts.\n+\t\t// To be on the safe side: explicitly delete the parts,\n+\t\t// but only actual file parts (for Resin compatibility)\n-\t\t\t\tpart.delete();\n+\t\t\t\tif (request.getFile(part.getName()) != null) {\n+\t\t\t\t\tpart.delete();\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix MultipartResolver Resin compatibility",
        "commit_body": "StandardServletMultipartResolver#cleanupMultipart now takes care to\ndelete only actual file parts for Resin compatibility.\n\nIssue: SPR-9299\n",
        "linked_issues": [
            {
                "issue_id": "13937",
                "issue_title": "org.springframework.web.multipart.support.StandardServletMultipartResolver.cleanupMultipart causes an IOException on Resin [SPR-9299]",
                "issue_body": "**[Ralph Schaer](https://jira.spring.io/secure/ViewProfile.jspa?name=ralsa)** opened **[SPR-9299](https://jira.spring.io/browse/SPR-9299?redirect=false)** and commented\n\nTesting the StandardServletMultipartResolver on Resin 4.0.27 with this form.\n\n\\<form action=\"uploadTest\" method=\"post\" enctype=\"multipart/form-data\">\n\\<input type=\"hidden\" name=\"hiddenParameter\" value=\"theHiddenValue\" />\n...\n\\</form>\n\nThe resolver tries to cleanup the parts with the cleanupMultipart method\nby calling part.delete();\n\nResin throws this exception\n\n8:08:25.093 [resin-port-8080-19] WARN  o.s.w.m.s.StandardServletMultipartResolver - Failed to perform cleanup of multipart items\nava.io.IOException: Part.delete() is not applicable to part 'hiddenParameter':'theHiddenValue'\nat com.caucho.server.http.AbstractCauchoRequest$PartImpl.delete(AbstractauchoRequest.java:1086) ~[resin.jar:4.0.27]       \nat org.springframework.web.multipart.support.StandardServletMultipartResolver.cleanupMultipart(StandardServletMultipartResolver.java:65) ~[spring-web-3.1.1.RELEASE.jar:3.1.1.RELEASE]\n\nNot sure why Resin not simply ignores the call to delete() for this kind of parts, as all the other servers (Tomcat, Jetty) do.\n\n\n\n---\n\n**Affects:** 3.1.1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9fcb5781873417e3e9ce8f2a932d3de4649a26c4, https://github.com/spring-projects/spring-framework/commit/7ea85a959c810c1689fc04b8d0c2bd17e5fe6e08\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how file parts are deleted in `StandardServletMultipartResolver`.  Previously, all parts were deleted unconditionally.  The updated code now only deletes parts that correspond to actual uploaded files (checked using `request.getFile(part.getName()) != null`). This change is likely to improve compatibility with Resin, a specific servlet container, by avoiding unnecessary deletion of parts that aren't associated with files",
            "avg_logprobs": -0.1707995770925499
        }
    },
    {
        "commit_hash": "7ef3257b031000b9f092d4014902bd676c607c9c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import javax.servlet.RequestDispatcher;\n-\t\t\tHttpServletMapping mapping = request.getHttpServletMapping();\n+\t\t\tHttpServletMapping mapping = (HttpServletMapping) request.getAttribute(RequestDispatcher.INCLUDE_MAPPING);\n+\t\t\tif (mapping == null) {\n+\t\t\t\tmapping = request.getHttpServletMapping();\n+\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Correctly determine HttpServletMapping for INCLUDE",
        "commit_body": "Closes gh-26216\n",
        "linked_issues": [
            {
                "issue_id": "26216",
                "issue_title": "Wrong HttpServletMapping used on INCLUDE in UrlPathHelper.skipServletPathDetermination",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://pivotal.io/security !!!\r\n-->\r\n**Affects:** 5.3.1\r\n\r\nIn `UrlPathHelper.skipServletPathDetermination()` the servlet mapping from the request is used. But if the request is processing an include then the mapping in the request is for the original path. The servlet mapping for the include is in the request attribute `RequestDispatcher.INCLUDE_MAPPING` (\"javax.servlet.include.mapping\").\r\n\r\nSo that method uses the wrong servlet mapping and therefore in some cases return the wrong result. And I'm guessing the same goes for when there's a forward, but that I haven't verified. Then the servlet mapping is in `RequestDispatcher.FORWARD_MAPPING`.\r\n\r\nOr is this an issue with the container? In my case I use tomcat 9.0.39.",
                "issue_state": "closed",
                "issue_comment": [
                    "Mainly we check it isn't a PATH mapping (e.g. `\"/path/*\"`). That's the more problematic case where the Servlet path prefix needs to be determined and stripped. Presumably on a given server, mapping by path prefix is either used or not. Can you provide more details for a more specific case?",
                    "Let me give you some more background on the issue.\r\n\r\nIf you have a **jsp** page with an **include tag** which includes the result of a spring controller method, then it will fail when using spring-framework 5.3.1. In 5.2.10.RELEASE it works just fine.\r\n\r\nAnd the reason for the failure is that when processing the include it's still in the context of the request for the jsp file. So the servlet mapping of the request will contain the servlet mapping for the jsp which usually is EXTENSION (*.jsp). But the include path might be of type PATH and then the `UrlPathHelper.skipServletPathDetermination()` will return the wrong result for the include and therefore generate a `NoHandlerFoundException`.\r\n\r\nI've attached a sample war project which demonstrates the problem: [spring-example.zip](https://github.com/spring-projects/spring-framework/files/5651733/spring-example.zip). In index.jsp there's an include tag which includes the result of a spring controller (/spring/example). But that include fails with a `NoHandlerFoundException`. But if I go directly to that url I'll get the result without any `NoHandlerFoundException`.\r\n\r\nTo solve this issue the correct servlet mapping must be used in `UrlPathHelper.skipServletPathDetermination(`). And the servlet mapping for the include is in the request attribute _javax.servlet.include.mapping_ according to Servlet 4 spec (chapter 9.3.1).\r\n\r\nAnd the same problem might affect forwards, but I haven't investigated that. But then then servlet mapping is in _javax.servlet.forward.mapping_.",
                    "Thanks for the sample and extra detail. So in your case, the request starts with a JSP page that includes a request to a Servlet mapped by prefix, and on an include the Servlet container returns original request details by default. For forward it's the other way around, with the Servlet container returning current request details by default. Hence I think only include is affected.",
                    "@rstoyanchev A big thanks for the quick response and fix! I can confirm that it resolves my issue."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how `HttpServletMapping` is retrieved.  Previously, it directly accessed `request.getHttpServletMapping()`.  Now, it first attempts to get the mapping from `request.getAttribute(RequestDispatcher.INCLUDE_MAPPING)`. If that's null, it falls back to the original method.  This suggests a potential optimization to handle include requests more efficiently by caching the mapping",
            "avg_logprobs": -0.16218941386153057
        }
    },
    {
        "commit_hash": "7f1062159ee9926d5abed7cadc2b36b6b7fc242e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/HttpStatus.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\tprivate static final HttpStatus[] VALUES;\n+\n+\tstatic {\n+\t\tVALUES = values();\n+\t}\n+\n+\n-\t\tfor (HttpStatus status : values()) {\n+\t\t// used cached VALUES instead of values() to prevent array allocation\n+\t\tfor (HttpStatus status : VALUES) {",
        "change_count": 9,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Copy HttpStatus::values to prevent allocation",
        "commit_body": "Before this commit, HttpStatus::resolve used the values() method in its\nlogic. This causes a new array to be allocated for each invocation,\nand results in memory overhead.\n\nThis commit makes a copy of the HttpStatus values array, and uses that\nto resolve status codes.\n\nCloses gh-26842\n",
        "linked_issues": [
            {
                "issue_id": "26842",
                "issue_title": "HttpStatus.resolve allocates HttpStatus.values() once per invocation",
                "issue_body": "I just noticed looking at profiles of some reactor based benchmarks we run to measure Datadog tracer overhead that `HttpStatus.resolve` allocates an `HttpStatus[]` once per invocation, so once per response. In a very modest throughput benchmark (~600rps) this is allocating 1MB/s just to resolve the integer status code to the `HttpStatus` enum value.\r\n<img width=\"997\" alt=\"Screenshot 2021-04-21 at 22 35 38\" src=\"https://user-images.githubusercontent.com/16439049/115624009-e81d8980-a2f1-11eb-8e95-024611d0009d.png\">\r\n\r\nI tracked the spring framework code down [here](https://github.com/spring-projects/spring-framework/blob/5b1ab31559798df83f1e8d54d2b754f12c69c14e/spring-web/src/main/java/org/springframework/http/HttpStatus.java#L553).\r\n\r\nThis could be fixed by caching `HttpStatus.values()` in an array, which could be iterated over as many times as one likes without any further allocation.\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "I think we can do better than a cached array, and might as well start using a `Map<Integer, HttpStatus>`.",
                    "Boxing HTTP status codes can be problematic because the common ones all fall outside the range of the `Integer` cache. We use [this](https://github.com/DataDog/dd-trace-java/blob/master/internal-api/src/main/java/datadog/trace/api/cache/RadixTreeCache.java) data structure for representing mappings between small, sparse finite sets of integers (such as status codes or ports) and arbitrary things, which works very well for tracing, and something similar may be applicable here. ",
                    "Thanks you for help.\r\n\r\nI am not sure if we want to introduce a new data structure into the framework to resolve this. I'll make a copy of the array instead, as originally suggested.",
                    "That makes sense - we don't record any time spent in `HttpStatus.resolve` at all, it only shows up for the allocations."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the `values()` method call within a loop with a pre-calculated array (`VALUES`).  This significantly optimizes performance by avoiding the repeated allocation of the `HttpStatus` array within the loop.  The `VALUES` array is now initialized statically, caching the result of `values()`",
            "avg_logprobs": -0.19266820332360646
        }
    },
    {
        "commit_hash": "7f1d5d790ed4f96a03b4f604ff8e9358bb086952",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/AbstractMethodMessageHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (this.applicationContext == null) {\n-\t\t\tlogger.warn(\"No ApplicationContext available for detecting beans with message handling methods.\");\n-\t\t\treturn;\n-\t\t}\n+\t\tif (this.applicationContext == null) {\n+\t\t\tlogger.warn(\"No ApplicationContext available \" +\n+\t\t\t\t\t\"for auto-detection of beans with message handling methods.\");\n+\t\t\treturn;\n+\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging message when an `ApplicationContext` is missing.  The original message was simply \"No ApplicationContext available for detecting beans with message handling methods.\"  The updated message adds context by specifying that the `ApplicationContext` is needed for *auto-detection* of beans. This clarifies the reason for the warning.  No functional change to the conditional logic itself",
            "avg_logprobs": -0.16537025647285658
        }
    },
    {
        "commit_hash": "7f26e8cfc6798187ec463d0ee9d9cdd26d9605be",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/SynthesizedMergedAnnotationInvocationHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (classLoader == interfaceClass.getClassLoader()) {\n+\t\t\treturn true;\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Short-circuit interface visibility check in case of same ClassLoader",
        "commit_body": "Closes gh-24664\n",
        "linked_issues": [
            {
                "issue_id": "24664",
                "issue_title": "Short circuit check in SynthesizedMergedAnnotationInvocationHandler.isVisible()",
                "issue_body": "While testing `spring-core` within a GraalVM native image (which uses a single, system-wide `ClassLoader`), it became apparent that the visibility check within `SynthesizedMergedAnnotationInvocationHandler.isVisible(ClassLoader, Class<?>)` could be short circuited to avoid an unnecessary invocation of `Class.forName`.\r\n\r\n@jhoeller suggested something along the lines of the following.\r\n\r\n```java\r\n\tprivate static boolean isVisible(ClassLoader classLoader, Class<?> interfaceClass) {\r\n\t\t// short circuit?\r\n\t\tif (interfaceClass.getClassLoader() == classLoader) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn Class.forName(interfaceClass.getName(), false, classLoader) == interfaceClass;\r\n\t\t}\r\n\t\tcatch (ClassNotFoundException ex) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n```",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check to see if the `classLoader` is the same as the `interfaceClass`'s classloader.  If they are the same, it returns `true`.  This suggests a potential optimization to avoid unnecessary further checks.  The original code likely had a more complex or potentially slower check that is now short-circuited in this specific case",
            "avg_logprobs": -0.16973095673781174
        }
    },
    {
        "commit_hash": "7f5d6ea3f9ac682b4c73d93bb148f2b906e1acb4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CollectionFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate static Class<?> navigableSetClass = null;\n-\n-\tprivate static Class<?> navigableMapClass = null;\n-\n-\t\t\telse if (SortedSet.class.equals(collectionType) || collectionType.equals(navigableSetClass)) {\n+\t\t\telse if (SortedSet.class.equals(collectionType) || NavigableSet.class.equals(collectionType)) {\n-\t\t\telse if (SortedMap.class.equals(mapType) || mapType.equals(navigableMapClass)) {\n+\t\t\telse if (SortedMap.class.equals(mapType) || NavigableMap.class.equals(mapType)) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fixed NavigableSet/NavigableMap detection in createCollection/createMap",
        "commit_body": "Issue: SPR-11257\n",
        "linked_issues": [
            {
                "issue_id": "15882",
                "issue_title": "NavigableSet and NavigableMap lookup missing in CollectionFactory class in spring-core [SPR-11257]",
                "issue_body": "**[Mark Rekveld](https://jira.spring.io/secure/ViewProfile.jspa?name=markrekveld)** opened **[SPR-11257](https://jira.spring.io/browse/SPR-11257?redirect=false)** and commented\n\nI ran into this issue\n\n```\nCaused by: java.lang.IllegalArgumentException: Unsupported Collection interface: java.util.NavigableSet\n\tat org.springframework.core.CollectionFactory.createCollection(CollectionFactory.java:147) ~[spring-core-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\tat org.springframework.core.convert.support.CollectionToCollectionConverter.convert(CollectionToCollectionConverter.java:68) ~[spring-core-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\tat org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:35) ~[spring-core-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\tat org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:178) ~[spring-core-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\tat org.springframework.integration.util.BeanFactoryTypeConverter.convertValue(BeanFactoryTypeConverter.java:123) ~[spring-integration-core-3.0.0.RELEASE.jar:?]\n\tat org.springframework.expression.spel.support.ReflectionHelper.convertArguments(ReflectionHelper.java:284) ~[spring-expression-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\tat org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:62) ~[spring-expression-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\tat org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:122) ~[spring-expression-4.0.0.RELEASE.jar:4.0.0.RELEASE]\n\t... 97 more\n```\n\nWhen looking into this, I found that in 4.0.0.RELEASE is missing some code that is present in 3.2.6.RELEASE\n\n```\nClassLoader cl = CollectionFactory.class.getClassLoader();\ntry {\n  navigableSetClass = cl.loadClass(\"java.util.NavigableSet\");\n  navigableMapClass = cl.loadClass(\"java.util.NavigableMap\");\n  approximableCollectionTypes.add(navigableSetClass);\n  approximableMapTypes.add(navigableMapClass);\n}\ncatch (ClassNotFoundException ex)\n{\n}\n```\n\nIs missing in `CollectionFactory` class in version 4.0.0.RELEASE\n\n\n---\n\n**Affects:** 4.0 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/7f5d6ea3f9ac682b4c73d93bb148f2b906e1acb4\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Mark Rekveld](https://jira.spring.io/secure/ViewProfile.jspa?name=markrekveld)** commented\n\nSome digging and I found that the JDK support was updated to 1.6 for Spring 4 but the `navigableSetClass` is always `null` since the lookup code was removed and so it cannot create a `TreeSet` if the collection type is `NavigableSet`\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `CollectionFactory` modifies the conditional logic for determining the appropriate `Class` for `SortedSet` and `SortedMap` types.  Specifically, it replaces `navigableSetClass` and `navigableMapClass` checks with explicit checks for `NavigableSet` and `NavigableMap` respectively.  This change likely improves type safety and clarity by directly referencing the desired types",
            "avg_logprobs": -0.18966850780305408
        }
    },
    {
        "commit_hash": "7f700cc63eadacfec243857bf5c9a13397bebca7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (inputMessage.getServletRequest().getMethod() == \"GET\"\n+\t\t\tif (\"GET\".equals(inputMessage.getServletRequest().getMethod())",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a string comparison using `==` with a `.equals()` method call.  Specifically, it now checks if the HTTP method is \"GET\" using `inputMessage.getServletRequest().getMethod().equals(\"GET\")`.  This is a more robust and idiomatic way to compare strings in Java, preventing potential `NullPointerExceptions` if `inputMessage.getServletRequest().getMethod()` returns `null`",
            "avg_logprobs": -0.1432944466085995
        }
    },
    {
        "commit_hash": "7f79ccbec0bad256aa7b3bfdd11af1db1f8976b4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/config/ScopedProxyBeanDefinitionDecorator.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (node instanceof Element ele) {\n-\t\t\tif (ele.hasAttribute(PROXY_TARGET_CLASS)) {\n-\t\t\t\tproxyTargetClass = Boolean.parseBoolean(ele.getAttribute(PROXY_TARGET_CLASS));\n-\t\t\t}\n+\t\tif (node instanceof Element ele && ele.hasAttribute(PROXY_TARGET_CLASS)) {\n+\t\t\tproxyTargetClass = Boolean.parseBoolean(ele.getAttribute(PROXY_TARGET_CLASS));",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Combine conditions for better readability and simplicity",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change combines two `if` statements into a single conditional expression.  The original code checked if the node was an `Element` *and* if that `Element` had the `PROXY_TARGET_CLASS` attribute.  The revised code checks both conditions in a single `if` statement, making the logic more concise.  This is a minor refactoring that improves readability and potentially reduces execution overhead by avoiding an extra conditional check",
            "avg_logprobs": -0.1676572693718804
        }
    },
    {
        "commit_hash": "7ff257c0ea00c02e453c8390c641835ebe778955",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/view/script/ScriptTemplateViewResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tview.setLocale(locale);\n+\t\tif (view != null) {\n+\t\t\tview.setLocale(locale);\n+\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Prevent NPE in ScriptTemplateView when no view is found",
        "commit_body": "Issue: SPR-15064\n",
        "linked_issues": [
            {
                "issue_id": "19630",
                "issue_title": "Support i18n and nested template loading in ScriptTemplateView render function [SPR-15064]",
                "issue_body": "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** opened **[SPR-15064](https://jira.spring.io/browse/SPR-15064?redirect=false)** and commented\n\nThe render function called by `ScriptTemplateView` has currently 3 parameters provided:\n- `String template`: the content of the template resource\n- `Map<String, Object>`: the model to use to render the view\n- `String url`: the url of the 2 view\n\nTo achieve i18n support for messages and nested template loading, we need to provide these additional informations:\n- a `ResourceBundleMessageSource` instance (or the `ApplicationContext` that allows to retrieve it)\n- the view `Locale`\n- a `Function<String, String>` that allows the render function to call `ScriptTemplateView#getTemplate(String)`\n\nI see mainly 2 ways to support that:\n\n1) We could be possible leverage `setExposeContextBeansAsAttributes()` or `setExposedContextBeanNames()` to access to context beans and expose them via model attributes.\n\n2) We could transform the 3rd parameter passed to the script function (currently `String url`) to `RenderingContext` that would contains `String url`, `Locale locale`, `ResourceBundleMessageSource messageSource` and `Function<String, String> templateLoader` properties. This would be a breaking change for people using `url` but `ScriptTemplateView` is a rather feature, and `url` is not widely used, so I consider this as an option in order to be consistent and provide such flexible mechanism for further needs + it provides these properties in a type-safe way which would be valuable for Kotlin JSR-223 support.\n\n---\n\n**Issue Links:**\n- #19625 Add Kotlin ScriptTemplateView tests (_**\"depends on\"**_)\n- #18033 Expose view url to render function in ScriptTemplateView\n- #20992 Update and improve script templating documentation\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/7ff257c0ea00c02e453c8390c641835ebe778955, https://github.com/spring-projects/spring-framework/commit/98642c7e29eb9596533341411b311c83c6aa5aa7, https://github.com/spring-projects/spring-framework/commit/2d95199466c52e26ff4c5c3e327e8ae6114e807f, https://github.com/spring-projects/spring-framework/commit/2a5d1b086f514fe4ddf0d9e8a42d09416f93d36a\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Yevhenii Melnyk](https://jira.spring.io/secure/ViewProfile.jspa?name=yevhenii-melnyk)** commented\n\nNot sure if the following stuff is appropriate here but I didn't want to open a new issue without discussion. So, the situation is following:\n\nI was trying to use two different template view resolvers in my Spring mvc app. For example, kotlin and javascript at the same time. Creation of 2 ViewResolver beans is not the problem. It seems impossible to use two `ScriptTemplateConfigurer` because `ScriptTemplateConfig` is being acquired in [ScriptTemplateView.autodetectViewConfig](https://github.com/spring-projects/spring-framework/blob/b503e4679ce37ac099be668cc1e33705da3fead1/spring-web-reactive/src/main/java/org/springframework/web/reactive/result/view/script/ScriptTemplateView.java#L261-L271) by `ScriptTemplateConfig.class` from Spring context.\n\nIs there a way to use two scripting engines at the same time or this feature is not supported currently?\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nIndeed this is currently not supported out of the box, but maybe you could make it works for your use case by extending `ScriptTemplateConfig*` classes for Kotlin or Javascript with specify dedicated `View` and `ViewConfigurer` classes.\n",
                    "**[Yevhenii Melnyk](https://jira.spring.io/secure/ViewProfile.jspa?name=yevhenii-melnyk)** commented\n\nI'll leave the [stackoverflow post regarding multiple configurers](http://stackoverflow.com/questions/41678075/multiple-scripttemplateviewresolvers-in-spring-mvc-app/41702033) here in case somebody has a same question I've got. The implementation is really easy. Thank you S\u00e9bastien Deleuze.\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nSee also this related [pull request](https://github.com/spring-projects/spring-framework/pull/1262) for providing i18n support, I will try to provide a solution that fulfill that need too.\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) Could you please have a look to [this pull request](https://github.com/spring-projects/spring-framework/pull/1304) I have just submitted to say me if you are ok with such approach.\n\nThis change would be breaking (on the script side, not on java side) for people using the third `url` parameter that we introduced as part of #18033 in `4.2.2`, but `ScriptTemplateView` is a rather young functionality, and this variant with an `url` parameter is likely to not being used very widely, so I would take the opportunity of our major `5.0` release to define a consistent and future proof render function SPI.\n\nAs you can see [here](https://github.com/spring-projects/spring-framework/pull/1304/commits/1072377ad8d35fde7cefe9281f20a7e2d3d86c54#diff-43cdb62aaabca74d4a2cd0902c934b4e) the migration path is trivial.\n\nI preferred this option over using `setExposeContextBeansAsAttributes()` or `setExposedContextBeanNames()` because:\n- It allows to be consistent about the various parameters we pass to the rendering function (`url` versus others)\n- It is type-safe which matters for Kotlin Script and more discoverable than something based on model attributes\n- It avoids to mix model attributes designed to be rendered in the template, and those informations designed to be used in the rendering function\n- It will allow us to add new rendering properties without breaking the script API\n\nI also choose to provide the `ApplicationContext` rather than directly the `ResourceBundleMessageSource` bean because that avoids to make assumption about how to retrieve it (by type, by name) and allows a wide range of use cases in addition to i18n. See it in action in [this Kotlin Script example](https://github.com/sdeleuze/spring-framework/blob/1072377ad8d35fde7cefe9281f20a7e2d3d86c54/spring-web-reactive/src/test/resources/org/springframework/web/reactive/result/view/script/kotlin/render.kts).\n",
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nNotice that this improvement allow this kind of Kotlin type-safe templates with i18n and nested template support:\n\n```\nimport org.springframework.web.reactive.result.view.script.*\n\n\"\"\"${include(\"header\") }\n<p>${i18n(\"hello\")} $foo</p>\n${include(\"footer\")}\"\"\"\n```\n\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for the `view` object before setting the locale.  Previously, `view.setLocale(locale)` could throw a `NullPointerException` if `view` was null.  The addition of the `if (view != null)` block prevents this exception.  This is a defensive programming improvement",
            "avg_logprobs": -0.07855142565334544
        }
    },
    {
        "commit_hash": "803fc2001907636605aa3ed2fcdf1437171761a5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tMap<String, ViewResolver> map = BeanFactoryUtils.beansOfTypeIncludingAncestors(\n+\t\t\tString[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n-\t\t\tif (map.isEmpty()) {\n+\t\t\tif (names.length == 1) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Correct check for ViewResolver beans",
        "commit_body": "Check for bean names of type rather than actual beans.\n\nIssue: SPR-12267\n",
        "linked_issues": [
            {
                "issue_id": "16872",
                "issue_title": "Spring 4.1 with WebMvcConfigurationSupport enabled does not register a default view resolver [SPR-12267]",
                "issue_body": "**[kyle leonhard](https://jira.spring.io/secure/ViewProfile.jspa?name=kyle-leonhard)** opened **[SPR-12267](https://jira.spring.io/browse/SPR-12267?redirect=false)** and commented\n\nAfter upgrading to 4.1.0 I noticed that jsp views were no longer resolving.   The app wasn't explicitly creating any view resolvers so I assumed some default resolvers had changed.  I went a digging a bit and found the below.\n\nThe DispatcherServlet registers, if no viewResolvers have been registered, default view resolvers in initViewResolvers.  This causes leads to an InternalResourceViewResolver being registered.  Before upgrading to 4.1 this is the resolver that was resolving my app's views.\n\nFirst, the app is using `@EnableWebMvc`.  In 4.1 WebMvcConfigurationSupport added the mvcViewResolver method which registers a composite view resolver.  In my case the viewResolverRegistry contains no viewResolvers so the composite resolver has nothing to delegate to.  The registered composite view resolver causes the initViewResolvers method in DispatcherServlet to skip registration of the default view resolvers.  My app ends up with no useful viewResolvers registered (just the composite with no delegates).\n\nThe issue is easy to work around (register a viewResolver), but it seems non-intuitive that enabling WebMvc support would cause this.\n\nLet me know if there are any more details I can provide or if there are suggestions on how to better configure things.\n\n---\n\n**Affects:** 4.1 GA\n\n**Issue Links:**\n- #16629 ThymeleafViewResolver not used by Spring 4.1 resulting in \"circular view path\" error\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/803fc2001907636605aa3ed2fcdf1437171761a5, https://github.com/spring-projects/spring-framework/commit/49cf30e964f1dc1e80e5e78833e55ac5f5a33f0e\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nActually this is what we had initially before an issue surfaced where another ViewResolver with default order (lowest precedence) may be \"shadowed\", see #16629. Seems like we need to refine the approach and check if other ViewResolver beans exist. That was we can preserve the DispatcherServlet default behavior when no ViewResolver declarations are made.\n",
                    "**[kyle leonhard](https://jira.spring.io/secure/ViewProfile.jspa?name=kyle-leonhard)** commented\n\nThanks. Keep up the good work!\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nNo worries, thanks for the report.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a method that retrieved all view resolvers as a `Map` with one that retrieves them as an array of `String` bean names.  Critically, it changes the conditional check from checking if the `Map` is empty to checking if the array has exactly one element. This suggests a potential change in how view resolvers are expected to be configured",
            "avg_logprobs": -0.25111841201782226
        }
    },
    {
        "commit_hash": "80fb8ea8137975e072c7611f5ae197cadd470da7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (this.exitTypeDescriptor == null) {\n+\t\t\treturn false;\n+\t\t}\n-\t\t\treturn (this.exitTypeDescriptor != null && this.arrayTypeDescriptor != null);\n+\t\t\treturn (this.arrayTypeDescriptor != null);\n+\t\t\t\t\t\tTypedValue result = accessor.read(this.evaluationContext, this.targetObject, this.name);\n-\t\t\t\t\t\treturn accessor.read(this.evaluationContext, this.targetObject, this.name);\n+\t\t\t\t\t\treturn result;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid unnecessary compilation attempts in SpEL's Indexer",
        "commit_body": "Closes gh-32677\n",
        "linked_issues": [
            {
                "issue_id": "32677",
                "issue_title": "Avoid unnecessary compilation attempts in SpEL's `Indexer`",
                "issue_body": "In the current implementation of SpEL's `Indexer`, the `exitTypeDescriptor` is sometimes ignored when checking whether the expression is compilable, and sometimes the `exitTypeDescriptor` is tracked for a failed evaluation attempt.\r\n\r\nThat behavior results in attempts to compile expressions which cannot be compiled, which should be avoided.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the `Indexer` class to return a `TypedValue` instead of a boolean.  Previously, it returned `true` if both `exitTypeDescriptor` and `arrayTypeDescriptor` were not null, and `false` otherwise.  The change now short-circuits the check, returning `false` *only* if `exitTypeDescriptor` is null.  Crucially, it then proceeds to call `accessor",
            "avg_logprobs": -0.19417245864868163
        }
    },
    {
        "commit_hash": "8137cc95669690f3e4055d6ccf484e98a07b6703",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/rowset/ResultSetWrappingSqlRowSet.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.util.StringUtils;\n-\t\t\t\t\tif (table != null && !table.isEmpty()) {\n+\t\t\t\t\tif (StringUtils.hasLength(table)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the original `if (table != null && !table.isEmpty())` condition with `if (StringUtils.hasLength(table))`.  This change leverages the Spring `StringUtils` utility class to check if the `table` string is not null and not empty.  This is a more concise and potentially more robust way to perform the null and empty check, as `StringUtils.hasLength` handles potential null values gracefully",
            "avg_logprobs": -0.13084815098689154
        }
    },
    {
        "commit_hash": "81aca78579df061e08aa0e6a6488b3e4d3ebb3dc",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/FormatHelper.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "+import org.springframework.util.ClassUtils;\n-\t * Produce a nice string for a given method name with specified arguments.\n+\t * Produce a readable representation for a given method name with specified arguments.\n-\t * @return nicely formatted string, eg. foo(String,int)\n+\t * @return a nicely formatted representation, e.g. {@code foo(String,int)}\n-\t * Produce a nice string for a given class object.\n-\t * For example, a string array will have the formatted name \"java.lang.String[]\".\n-\t * @param clazz The class whose name is to be formatted\n-\t * @return a formatted string suitable for message inclusion\n+\t * Determine a readable name for a given Class object.\n+\t * <p>A String array will have the formatted name \"java.lang.String[]\".\n+\t * @param clazz the Class whose name is to be formatted\n+\t * @return a formatted String suitable for message inclusion\n+\t * @see ClassUtils#getQualifiedName(Class)\n-\t\tif (clazz == null) {\n-\t\t\treturn \"null\";\n-\t\t}\n-\t\treturn clazz.getTypeName();\n+\t\treturn (clazz != null ? ClassUtils.getQualifiedName(clazz) : \"null\");",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Delegate to common ClassUtils.getQualifiedName",
        "commit_body": "Issue: SPR-15237\n",
        "linked_issues": [
            {
                "issue_id": "19802",
                "issue_title": "Use Class.getTypeName() where appropriate  [SPR-15237]",
                "issue_body": "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** opened **[SPR-15237](https://jira.spring.io/browse/SPR-15237?redirect=false)** and commented\n\nHey,\n\nI just noticed that we could use Class.getTypeName() in ClassUtils.getQualifiedName() and  FormatHelper.formatClassNameForMessage() now that we're on JDK 8.\n\nFind my proposal attached. Happy to read your feedback.\n\nCheers,\nChristoph\n\n\n---\n\n**Affects:** 5.0 M4\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1320, and commits https://github.com/spring-projects/spring-framework/commit/ab50f7b0d583565f9428a1d917524c6bbe1e4237, https://github.com/spring-projects/spring-framework/commit/81aca78579df061e08aa0e6a6488b3e4d3ebb3dc, https://github.com/spring-projects/spring-framework/commit/5cfa7e71bb878cde25b03b79cd5b9c58f12a12df, https://github.com/spring-projects/spring-framework/commit/5f90a7eee9df803bb866c74b47682f076b3e4561\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `FormatHelper.java` refactors the method for producing a string representation of a class.  It improves the method's documentation and the returned string's readability.  Crucially, it now uses `ClassUtils.getQualifiedName()` for a more standard and potentially more informative representation of the class, especially for array types.  The original `clazz.getTypeName()` is replaced with a concise null check and the use of the utility method",
            "avg_logprobs": -0.31718488693237307
        }
    },
    {
        "commit_hash": "81fde5ec4103e3db28bf79073691938a4743b121",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/MethodParameter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t// Try first with identity checks for greater performance.\n+\t\t// Potentially try again with object equality checks in order to avoid race\n+\t\t// conditions while invoking java.lang.reflect.Executable.getParameters().\n+\t\tfor (int i = 0; i < allParams.length; i++) {\n+\t\t\tif (parameter.equals(allParams[i])) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Ensure that MethodParameter.findParameterIndex() is thread-safe",
        "commit_body": "Prior to this commit, parallel invocations of\nMethodParameter.findParameterIndex() (invoked indirectly via\nSynthesizingMethodParameter.forParameter() and\nMethodParameter.forParameter()) could intermittently lead to an\nIllegalArgumentException being thrown due to a race condition in the\ninternal implementation of the JDK's\njava.lang.reflect.Executable.getParameters() method.\n\nThis commit addresses this issue by introducing a fallback for-loop\nthat iterates over the candidate parameters a second time using\nequality checks instead of identity checks.\n\nIssue: SPR-17534\n",
        "linked_issues": [
            {
                "issue_id": "22066",
                "issue_title": "MethodParameter.findParameterIndex() is not thread-safe [SPR-17534]",
                "issue_body": "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** opened **[SPR-17534](https://jira.spring.io/browse/SPR-17534?redirect=false)** and commented\n\n## Status Quo\n\nAs discussed in #22065, `org.springframework.core.MethodParameter.findParameterIndex(Parameter)` is not thread-safe due to the manner in which `java.lang.reflect.Executable.getParameters()` is implemented in the JDK.\n\n## Proposed Solution\n\nThe following change has been verified to result in thread-safe behavior.\n\nWhether or not we want two iterations is up for debate.\n\n```java\nprotected static int findParameterIndex(Parameter parameter) {\r\n\tExecutable executable = parameter.getDeclaringExecutable();\r\n\tParameter[] allParams = executable.getParameters();\r\n\t\r\n\t// Try first with identity checks for greater performance.\r\n\tfor (int i = 0; i < allParams.length; i++) {\r\n\t\tif (parameter == allParams[i]) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\t// Potentially try again with object equality in order to avoid race\r\n\t// conditions while accessing java.lang.reflect.Executable.getParameters().\r\n\tfor (int i = 0; i < allParams.length; i++) {\r\n\t\tif (parameter.equals(allParams[i])) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\tthrow new IllegalArgumentException(\"Given parameter [\" + parameter +\r\n\t\t\t\"] does not match any parameter in the declaring executable\");\r\n}\r\n```\n\n## Deliverables\n\n1. Ensure that `MethodParameter.findParameterIndex()` is thread-safe\n\n---\n\n**Affects:** 5.0.10, 5.1 GA\n\n**Issue Links:**\n- #22065 Parameter resolution in SpringExtension is not thread-safe\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/81fde5ec4103e3db28bf79073691938a4743b121, https://github.com/spring-projects/spring-framework/commit/f0e69e06b7c0b4b1c8cbf7c17cfc21ab92ce983c\n\n**Backported to:** [5.0.11](https://github.com/spring-projects/spring-framework/milestone/192?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nThis has been fixed on `master` (5.1.3) and `5.0.x` (5.0.11).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a performance optimization to `MethodParameter` by first attempting an identity check (`parameter.equals(allParams[i])`) to find the index of a parameter within an array (`allParams`).  If the identity check fails, the code now potentially performs an object equality check, mitigating potential race conditions when retrieving parameter information from `java.lang.reflect.Executable`.  This change prioritizes speed by using identity checks where possible, but falls back to object equality for robustness.",
            "avg_logprobs": -0.3168619728088379
        }
    },
    {
        "commit_hash": "8417a73913a2352fc988a63d60872f0a98f51734",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/JdbcUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (name.length() > 1 && name.substring(1,2).equals(\"_\")) {\n+\t\t\tif (name.length() > 1 && name.substring(1, 2).equals(\"_\")) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": "Closes gh-1340\n",
        "linked_issues": [
            {
                "issue_id": "1340",
                "issue_title": "Polishing",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a spurious extra space in the `if` statement's condition.  The original and updated code are functionally identical; the only difference is a whitespace correction",
            "avg_logprobs": -0.3584880034128825
        }
    },
    {
        "commit_hash": "84963ba4d865e995fc17483a7cc857bdce595e2f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CoroutinesUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t\t\t\t\tif (!(type.isMarkedNullable() && arg == null) && type.getClassifier() instanceof KClass<?> kClass\n-\t\t\t\t\t\t\t\t\t\t\t&& KotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {\n+\t\t\t\t\t\t\t\t\tif (!(type.isMarkedNullable() && arg == null) &&\n+\t\t\t\t\t\t\t\t\t\t\ttype.getClassifier() instanceof KClass<?> kClass &&\n+\t\t\t\t\t\t\t\t\t\t\tKotlinDetector.isInlineClass(JvmClassMappingKt.getJavaClass(kClass))) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes unnecessary parentheses around the `&&` condition in the `if` statement.  This is a purely stylistic change; it does not alter the logic of the conditional.  The original code was slightly more verbose",
            "avg_logprobs": -0.17885908873184866
        }
    },
    {
        "commit_hash": "84cc7ffdf6330ed4e437bb67fa2708c9ffa3b340",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/ServletServerHttpRequest.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (true || !hasQuery) {\n+\t\t\t\tif (!hasQuery) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix test failure",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an unnecessary condition in the `ServletServerHttpRequest` class.  The original `if (true || !hasQuery)` statement was equivalent to simply `if (!hasQuery)`.  The modification simplifies the code by removing the redundant `true ||`",
            "avg_logprobs": -0.16586951856259946
        }
    },
    {
        "commit_hash": "85cecb66e5526ad29fda44b1d63ab7f202aed0e3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/handler/invocation/reactive/InvocableHandlerMethod.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * Configure a reactive registry. This is needed for cases where the response\n-\t * is fully handled within the controller in combination with an async void\n-\t * return value.\n-\t * <p>By default this is an instance of {@link ReactiveAdapterRegistry} with\n-\t * default settings.\n-\t * @param registry the registry to use\n+\t * Configure a reactive adapter registry. This is needed for async return values.\n+\t * <p>By default this is a {@link ReactiveAdapterRegistry} with default settings.\n-\t * @return a Mono with the result from the invocation.\n+\t * @return a Mono with the result from the invocation\n-\n-\t\t\treturn isAsyncVoidReturnType(returnType, adapter) ?\n-\t\t\t\t\tMono.from(adapter.toPublisher(value)) : Mono.justOrEmpty(value);\n+\t\t\treturn (isAsyncVoidReturnType(returnType, adapter) ?\n+\t\t\t\t\tMono.from(adapter.toPublisher(value)) : Mono.justOrEmpty(value));\n+\t\tMethodParameter[] parameters = getMethodParameters();\n-\t\tMethodParameter[] parameters = getMethodParameters();\n+\n-\t\tif (!exMsg.contains(parameter.getExecutable().toGenericString())) {\n+\t\tif (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Consistent parameter retrieval across InvocableHandlerMethod variants",
        "commit_body": "See gh-22900\n",
        "linked_issues": [
            {
                "issue_id": "22900",
                "issue_title": "Check if null before accessing exception message in webflux InvocableHandlerMethod#logArgumentErrorIfNecessary",
                "issue_body": "Add null check before call `message.contains`.\r\n\r\nException message should be null checked before accessing it in [InvocableHandlerMethod#logArgumentErrorIfNecessary](https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219).\r\n\r\nIf message is null, NPE will be thrown and webflux responds 500(INTERNAL SERVER ERROR).\r\n\r\nIn [corresponding function in webmvc](https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219), exception message is checked before accessing its method. I think webflux should do in the same manner.\r\n\r\nRefs.\r\n- https://github.com/spring-projects/spring-framework/blob/e16a134/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java#L172\r\n- https://github.com/spring-projects/spring-framework/blob/e16a134/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/InvocableHandlerMethod.java#L219",
                "issue_state": "closed",
                "issue_comment": [
                    "@sakuna63 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22900)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22900) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@sakuna63 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22900)!",
                    "Thanks for the PR.\r\n\r\n> I will create issue later.\r\n\r\nPlease don't. since the move to github for issues we don't need an issue and a PR as one supersedes the other.\r\n",
                    "@snicoll OK. I've already created issue before reading your comment. I close https://github.com/spring-projects/spring-framework/issues/22901."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the `InvocableHandlerMethod` class to improve clarity and consistency in configuring a reactive adapter registry for handling async return values.\\n\\n**Key Changes:**\\n\\n* **Renamed Parameter:**  `registry` is renamed to `adapter`, reflecting the specific type of registry being used.  This change improves readability and aligns with the existing codebase's terminology.\\n* **Simplified Javadoc:** The Javadoc is made more concise and focused on the purpose of the parameter.",
            "avg_logprobs": -0.3639176177978516
        }
    },
    {
        "commit_hash": "8662b7773c01c710aa44b684b292335695199436",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfor (String url : StringUtils.delimitedListToStringArray(\n+\t\t\tfor (String path : StringUtils.delimitedListToStringArray(\n-\t\t\t\t\tif (url.endsWith(ResourceUtils.JAR_FILE_EXTENSION)) {\n+\t\t\t\t\tif (path.endsWith(ResourceUtils.JAR_FILE_EXTENSION)) {\n+\t\t\t\t\t\tFile file = new File(path);\n-\t\t\t\t\t\t\t\tResourceUtils.FILE_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR);\n+\t\t\t\t\t\t\t\tResourceUtils.FILE_URL_PREFIX + file.getAbsolutePath() +\n+\t\t\t\t\t\t\t\tResourceUtils.JAR_URL_SEPARATOR);\n-\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + url +\n+\t\t\t\t\t\tlogger.debug(\"Cannot search for matching files underneath [\" + path +",
        "change_count": 10,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "PathMatchingResourcePatternResolver converts manifest entries to absolute paths",
        "commit_body": "Issue: SPR-14934\n",
        "linked_issues": [
            {
                "issue_id": "19501",
                "issue_title": "PathMatchingResourcePatternResolver provides duplicate resources with relative URL [SPR-14934]",
                "issue_body": "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** opened **[SPR-14934](https://jira.spring.io/browse/SPR-14934?redirect=false)** and commented\n\nThis is a regression introduced by #18260\n\n`PathMatchingResourcePatternResolver#doFindAllClassPathResources` first gets the path returned by the `LaunchedUrlClassLoader` which will add the URLs of all nested jar  + the URL of `BOOT-INF-classes`, something like `URL [jar:file:/Users/snicoll/workspace/pivotal/spring-framework-issues/SPR-13685/target/SPR-13685-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/]`\n\nBecause we need to get all XML files from the root (path is the empty string) we also invoke `addAllClassLoaderJarRoots` which works recursively as follow:\n\n* does not add anything with `LaunchedUrlClassLoader`\n* with `classLoader.getSystemClassLoader()` adds `URL [jar:file:/Users/snicoll/workspace/pivotal/spring-framework-issues/SPR-13685/target/SPR-13685-0.0.1-SNAPSHOT.jar!/]`\n* with its parent (`AppClassLoader`)  adds `URL [jar:file:SPR-13685-0.0.1-SNAPSHOT.jar!/]` via `addClassPathManifestEntries`. It also adds a bunch of entries from JDK jars\n* does not add anything with `ExtClassLoader`\n\nSo we have the following entries for the candidate location:\n\n```\njar:file:/Users/snicoll/workspace/pivotal/spring-framework-issues/SPR-13685/target/SPR-13685-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/\njar:file:/Users/snicoll/workspace/pivotal/spring-framework-issues/SPR-13685/target/SPR-13685-0.0.1-SNAPSHOT.jar!/\njar:file:SPR-13685-0.0.1-SNAPSHOT.jar!/\n```\n\nSo, for the same `a.xml` at the root of the classpath in `src/main/resources` we end up with the following candidates:\n\n```\njar:file:/Users/snicoll/workspace/pivotal/spring-framework-issues/SPR-13685/target/SPR-13685-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/a.xml\njar:file:/Users/snicoll/workspace/pivotal/spring-framework-issues/SPR-13685/target/SPR-13685-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes/a.xml\njar:file:SPR-13685-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes/a.xml\n```\n\nAt this point I can only guess that each entry match each candidate in the list above (in that order).  it isn't obvious how the second one lead to a lookup in `BOOT-INF/classes` though but given that a `!` is missing in the second case, it's an indication it may come from that faulty URL.\n\nA [repro project is available](https://github.com/spring-projects/spring-framework-issues/tree/ec15861593195a709e271aa80a974270e1e009bf/SPR-13685)\n\n---\n\n**Affects:** 4.3 GA\n\n**Issue Links:**\n- #18260 PathMatchingResourcePatternResolver does not consider manifest based classpaths\n- #19503 PathMatchingResourcePatternResolver finds duplicate resources for executable jars but not for executable wars\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nWhile working on this issue, we've discovered a Spring Boot issue as well, check [#7449](https://github.com/spring-projects/spring-boot/issues/7449)\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `PathMatchingResourcePatternResolver` modifies how JAR files are handled within a loop.  The original code iterated over `url` strings, checking if each `url` ended with a JAR extension.  The updated code now iterates over `path` strings, and instead of using the original `url` directly, it creates a `File` object from the `path` and uses the `File`'s `getAbsolutePath()` method to construct the `url`.",
            "avg_logprobs": -0.20253942489624024
        }
    },
    {
        "commit_hash": "86733a98da91c57d2ac28365a82da3e3fbd15fb1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "- * sub-classes to deviate from the default. Unwrap the content of a\n+ * sub-classes to deviate from the default. Unwraps the content of a\n-\t * {@link EventListener} annotation or any matching attribute on a meta-annotation.\n+\t * {@link EventListener} annotation or any matching attribute on a composed\n+\t * annotation.\n+\t\t\t// TODO annotationAttributes are null with proxy\n-\t\t\telse { // TODO annotationAttributes null with proxy\n+\t\t\t// TODO Remove once AnnotatedElementUtils supports annotations on proxies\n+\t\t\telse {\n-\t\t\t\tthis.condition = (eventListener != null ? eventListener.condition() : null);\n+\t\t\t\tthis.condition = (eventListener != null ? eventListener.condition() : \"\");",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish ApplicationListenerMethodAdapter",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ApplicationListenerMethodAdapter` modifies how it handles the `condition` attribute of the `@EventListener` annotation.  The key change is in the handling of cases where the `annotationAttributes` are null, likely due to proxies.\\n\\nInstead of a simple `else` block that assigned `null` to `this.condition`, the code now:\\n\\n1. **Adds a comment:**  `// TODO Remove once AnnotatedElementUtils supports annotations on proxies`",
            "avg_logprobs": -0.2566368293762207
        }
    },
    {
        "commit_hash": "8694a0aac06388332373765a3cf0a494b0243a90",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import java.util.Arrays;\n+\n-\t * {@link java.lang.annotation.Inherited inherited}. For greater clarity regarding inherited\n-\t * annotations, consider using {@link #isAnnotationInherited(Class, Class)} instead.\n+\t * {@linkplain java.lang.annotation.Inherited inherited}. For greater clarity\n+\t * regarding inherited annotations, consider using\n+\t * {@link #isAnnotationInherited(Class, Class)} instead.\n-\t\tfor (Annotation annotation : Arrays.asList(clazz.getDeclaredAnnotations())) {\n+\t\tfor (Annotation annotation : clazz.getDeclaredAnnotations()) {\n-\t * on the supplied {@code clazz} and is {@link java.lang.annotation.Inherited inherited}\n-\t * i.e., not declared locally for the class).\n+\t * on the supplied {@code clazz} and is {@linkplain java.lang.annotation.Inherited inherited}\n+\t * (i.e., not declared locally for the class).\n-\t * will not be traversed. See the {@link java.lang.annotation.Inherited JavaDoc} for the\n-\t * &#064;Inherited meta-annotation for further details regarding annotation inheritance.\n+\t * will not be traversed. See the {@linkplain java.lang.annotation.Inherited Javadoc} for the\n+\t * {@code @Inherited} meta-annotation for further details regarding annotation inheritance.\n-\t * on the supplied {@code clazz} and is {@link java.lang.annotation.Inherited inherited}\n+\t * on the supplied {@code clazz} and is <em>inherited</em>",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Minor changes to AnnotationUtils",
        "commit_body": "- Polished Javadoc for isAnnotationDeclaredLocally() and\n  isAnnotationInherited().\n- Removed unnecessary call to Arrays.asList() in\n  isAnnotationDeclaredLocally().\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `AnnotationUtils.java` removes an unnecessary `Arrays.asList()` call within a `for` loop iterating over declared annotations.  More importantly, the change improves clarity by using `{@linkplain java.lang.annotation.Inherited}` and `{@linkplain java.lang.annotation.Inherited Javadoc}` instead of `{@link java.lang.annotation.Inherited}` and `{@link java.lang.annotation.Inherited JavaDoc}`",
            "avg_logprobs": -0.13384498596191408
        }
    },
    {
        "commit_hash": "871bb57e025d1daa42524040f038819a6c19ceef",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\telse if (method.getName().equals(\"getWarnings\") || method.getName().equals(\"clearWarnings\")) {\n+\t\t\t\t// Avoid creation of target Connection on pre-close cleanup (e.g. in Hibernate Session)\n+\t\t\t\treturn null;\n+\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "TransactionAwareDataSourceProxy locally handles get/clearWarnings call",
        "commit_body": "Closes gh-23346\n",
        "linked_issues": [
            {
                "issue_id": "23346",
                "issue_title": "Session.close() accidentally triggers creation of TransactionAwareDataSourceProxy Connection",
                "issue_body": "**Affects:** 3.1.4.RELEASE\r\nUsing hibernate: 3.6.10.Final\r\n\r\n---\r\nI'm facing an issue caused by opening connections with database on session.close call.\r\nFor some reason, hibernate throws an exception when is opening a connection with database, then he starts to rollback the transaction.\r\nFrom now on, a proxy connection exists in session (`TransactionAwareInvocationHandler`), but real connection with database does not exists.\r\n\r\nAfter that, _spring-orm_ call `SessionFactoryUtils.closeSession`, and this goes to close connection, but real connection failed to be created\r\n\r\nHibernate `ConnectionManager`, before close the connection call `JDBCExceptionReporter.logAndClearWarnings( connection );` (connection parameter is proxy `TransactionAwareInvocationHandler` connection without real connection because creation failed)\r\n\r\nThen `TransactionAwareInvocationHandler` create a new connection with database because `getWarnings` and `clearWarnings` are not mapped methods in invoke\r\nThis connection is closed right after creation, but when I am inside a transaction, this connection resource is binded to thread and never unbinded. Because _spring-tx_ is alredy in a rollback block.\r\n\r\nI think a connection should not be opened when some of those two methods `getWarnings` and `clearWarnings` are called and real connection does not exists.\r\n\r\nhttps://github.com/zgsolucoes/spring-framework/commit/35c0b084906e6d122b13980df12383958a935213",
                "issue_state": "closed",
                "issue_comment": [
                    "Good point! We're locally handling `getWarnings` and `clearWarnings` calls in `TransactionAwareDataSourceProxy` now. I'll also backport this to 5.0.15 and 4.3.25."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds an `else if` clause to the existing conditional logic.  This new clause checks if the method being invoked is `getWarnings` or `clearWarnings`.  If it is, the method returns `null`.  This likely prevents the creation of a target connection in specific scenarios, such as during pre-close cleanup within a Hibernate session, potentially improving performance or resource management",
            "avg_logprobs": -0.1758050799369812
        }
    },
    {
        "commit_hash": "871e378ed054d95f19bcb75fa0f01e202e83f367",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (aspectClass.getSuperclass().getAnnotation(Aspect.class) != null &&\n-\t\t\t\t!Modifier.isAbstract(aspectClass.getSuperclass().getModifiers())) {\n+\t\tClass<?> superclass = aspectClass.getSuperclass();\n+\t\tif (superclass.getAnnotation(Aspect.class) != null &&\n+\t\t\t\t!Modifier.isAbstract(superclass.getModifiers())) {\n-\t\t\t\t\taspectClass.getSuperclass().getName() + \"]\");\n+\t\t\t\t\tsuperclass.getName() + \"]\");",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish AbstractAspectJAdvisorFactory",
        "commit_body": "Closes gh-27340",
        "linked_issues": [
            {
                "issue_id": "27340",
                "issue_title": "Polish AbstractAspectJAdvisorFactory",
                "issue_body": "Left out invoke the native method.",
                "issue_state": "closed",
                "issue_comment": [
                    "@Inmord Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=27340)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=27340) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@Inmord Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=27340)!",
                    "This has been merged into `main`.\r\n\r\nThanks for submitting your first PR to the Spring Framework! \ud83d\udc4d ",
                    "@Inmord, for future PRs, please make sure you create your PR against the `main` branch instead of the `5.2.x` branch.\r\n\r\nThanks",
                    "> @Inmord\uff0c\u5bf9\u4e8e\u672a\u6765\u7684 PR\uff0c\u8bf7\u786e\u4fdd\u60a8\u9488\u5bf9`main`\u5206\u652f\u800c\u4e0d\u662f\u5206\u652f\u521b\u5efa PR `5.2.x`\u3002\r\n> \r\n> \u8c22\u8c22\r\n\r\nOkay, thanks.\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `aspectClass.getSuperclass()` with a local variable `superclass`.  This is a minor optimization, likely to improve readability and potentially performance by avoiding repeated calls to `aspectClass.getSuperclass()`.  The original code accessed the superclass multiple times, while the revised code stores it in a variable, reducing redundant lookups.  The change also updates the string literal to use the local variable `superclass` instead of `aspectClass",
            "avg_logprobs": -0.2704158401489258
        }
    },
    {
        "commit_hash": "871f705bca8da88c95966b9ab37d9aefa0dd24ca",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!componentScans.isEmpty() &&\n-\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\tif (!componentScans.isEmpty()) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove ComponentScan duplicate condition",
        "commit_body": "Closes gh-27077\n",
        "linked_issues": [
            {
                "issue_id": "27077",
                "issue_title": "Conditions to determine if `@ComponentScan` should be applied can be chosen from the wrong class",
                "issue_body": "Here is an example that demonstrates [the problem](https://github.com/snicoll-scratches/demo-condition-parent/blob/3e586697d23af0fe530422aa82c8148146b0efc0/src/main/java/com/example/demo/BaseConfiguration.java#L13): https://github.com/snicoll-scratches/demo-condition-parent\r\n\r\n`ConfigurationClassParser` does the following when it determines if a `@ComponentScan` should be applied: https://github.com/spring-projects/spring-framework/blob/df588e030f069dd31997ff747839f1d8d5d8d7c7/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L292\r\n\r\nIt is processed on the `sourceClass` rather than the configuration class being built. The former can be a parent in the hierarchy. In such a case, the conditions in the parent are going to be considered (and the conditions of the configuration class will be ignored).\r\n\r\nI am wondering how useful this condition is though. Considering that we should ignore the conditions on the parent, the conditions on the configuration class could have been evaluated prior to run `@ComponentScan`.\r\n\r\nAt some point in the history of the project 620c16f5c7bb543b18f71b2848f90461f8646237 was reverted to not process conditions on parent classes. ",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a check for `shouldSkip` from the `ConfigurationClassParser`.  Previously, if component scans were present, the code would skip processing if `conditionEvaluator` returned `true` for `ConfigurationPhase.REGISTER_BEAN`.  The updated code now unconditionally processes component scans if they exist.  This suggests a change in how the condition evaluation is handled or a removal of a specific skipping logic for bean registration",
            "avg_logprobs": -0.34382980171291305
        }
    },
    {
        "commit_hash": "87fa2c3b97c7ee4785c4109ebd14ff3310f9db11",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/StringUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (lastCharIndex == inString.length()) {\n+\t\t\treturn inString;\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid unnecessary String instantiation in StringUtils.deleteAny()",
        "commit_body": "This commit avoids unnecessary String instantiation in\nStringUtils.deleteAny() if nothing was deleted from the\ninput string.\n\nCloses gh-24924",
        "linked_issues": [
            {
                "issue_id": "24924",
                "issue_title": "Avoid unnecessary String instantiation in StringUtils.deleteAny()",
                "issue_body": "When I was reading https://github.com/spring-projects/spring-framework/pull/24870, I noticed that `String` instantiation in `StringUtils.deleteAny()` isn't necessary when nothing is deleted. So this PR changes to avoid it.\r\n\r\nThis is a straightforward change, but I just ran [the same benchmark](https://github.com/izeye/samples-jmh-gradle/blob/d193de7d08ce7d8de71dc6ba724cb89018501d20/src/jmh/java/com/izeye/samples/jmh/SpringStringUtilsDeleteAnyBenchmark.java) used in https://github.com/spring-projects/spring-framework/pull/24870. The result is as follows:\r\n\r\n```\r\nBenchmark                                                                                                    Mode  Cnt     Score   Error   Units\r\nSpringStringUtilsDeleteAnyBenchmark.original                                                                 avgt         68.215           ns/op\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.alloc.rate                                                  avgt       1384.675          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.alloc.rate.norm                                             avgt        104.000            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.churn.PS_Eden_Space                                         avgt       1359.258          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.churn.PS_Eden_Space.norm                                    avgt        102.091            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.churn.PS_Survivor_Space                                     avgt          0.048          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.churn.PS_Survivor_Space.norm                                avgt          0.004            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.count                                                       avgt         21.000          counts\r\nSpringStringUtilsDeleteAnyBenchmark.original:\u00b7gc.time                                                        avgt         12.000              ms\r\nSpringStringUtilsDeleteAnyBenchmark.patched                                                                  avgt         20.938           ns/op\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.alloc.rate                                                   avgt       4510.715          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.alloc.rate.norm                                              avgt        104.000            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.churn.PS_Eden_Space                                          avgt       4477.181          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.churn.PS_Eden_Space.norm                                     avgt        103.227            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.churn.PS_Survivor_Space                                      avgt          0.074          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.churn.PS_Survivor_Space.norm                                 avgt          0.002            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.count                                                        avgt         69.000          counts\r\nSpringStringUtilsDeleteAnyBenchmark.patched:\u00b7gc.time                                                         avgt         38.000              ms\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted                                   avgt         13.284           ns/op\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.alloc.rate                    avgt       2734.452          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.alloc.rate.norm               avgt         40.000            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.churn.PS_Eden_Space           avgt       2788.360          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.churn.PS_Eden_Space.norm      avgt         40.789            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.churn.PS_Survivor_Space       avgt          0.036          MB/sec\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.churn.PS_Survivor_Space.norm  avgt          0.001            B/op\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.count                         avgt         43.000          counts\r\nSpringStringUtilsDeleteAnyBenchmark.patchedSkipNewStringWhenNothingDeleted:\u00b7gc.time                          avgt         22.000              ms\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to see if the `lastCharIndex` is equal to the length of the input string `inString`.  If they are equal, the original string `inString` is returned directly, avoiding further processing.  This likely optimizes a previous implementation by preventing unnecessary operations when the last character is already at the end of the string",
            "avg_logprobs": -0.12729054528313713
        }
    },
    {
        "commit_hash": "88049e9b5cf9bf77d2712bb090e12a2b96887aee",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/EventListenerMethodProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!this.nonAnnotatedClasses.contains(targetType) && !isSpringContainerClass(targetType)) {\n+\t\tif (!this.nonAnnotatedClasses.contains(targetType) &&\n+\t\t\t\t!targetType.getName().startsWith(\"java\") &&\n+\t\t\t\t!isSpringContainerClass(targetType)) {\n+\n+",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "EventListenerMethodProcessor skips annotation search on java classes",
        "commit_body": "Closes gh-22564\n",
        "linked_issues": [
            {
                "issue_id": "22564",
                "issue_title": "Skip more classes when processing beans in EventListenerMethodProcessor",
                "issue_body": "The `EventListenerMethodProcessor` currently skips beans where`isSpringContainerClass` returns true. There are a few more types that we could also consider skipping:\r\n\r\n* Anything in `java.lang` classes\r\n* Any `java.util` classes\r\n* Any `javax.servlet` classes\r\n\r\nAll of these turn out to be pretty common beans in Spring Boot applications.",
                "issue_state": "closed",
                "issue_comment": [
                    "This may have been superseded by e3a9826e56e8fcb9e57f31b255998a095d8f8155 which by default will skip `java*` types.",
                    "I'll consider this for a backport to 5.1.6, even if it is generally covered on master already."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new condition to the `if` statement.  Previously, the code checked if a `targetType` was not in a list of `nonAnnotatedClasses` and wasn\\'t a Spring container class.  The addition of `!targetType.getName().startsWith(\"java\")` now excludes any classes whose name begins with \"java\".  This suggests a change in the intended scope of the filtering logic, likely to prevent processing of core Java classes",
            "avg_logprobs": -0.20901783307393393
        }
    },
    {
        "commit_hash": "884c7696cebadc877d63d8212e311f9f3489b9fd",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tif (KotlinDetector.isKotlinType(method.getDeclaringClass()) && KotlinDelegate.isSuspend(method)) {\n-\t\t\t\tthrow new IllegalStateException(\"Unsupported suspending handler method detected: \" + method);\n+\t\t\tif (KotlinDetector.isKotlinType(method.getDeclaringClass())) {\n+\t\t\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n+\t\t\t\tif ((parameterTypes.length > 0) && \"kotlin.coroutines.Continuation\".equals(parameterTypes[parameterTypes.length - 1].getName())) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Unsupported suspending handler method detected: \" + method);\n+\t\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Make it possible to run Spring MVC without kotlin-reflect",
        "commit_body": "Closes gh-24828\n",
        "linked_issues": [
            {
                "issue_id": "24828",
                "issue_title": "Make it possible to run Spring MVC without kotlin-reflect",
                "issue_body": "Spring Framework Kotlin support has been designed to make it possible to run it without `kotlin-reflect` artifact (even if various features are disable in that case). The Coroutines check in `AbstractHandlerMethodMapping.MappingRegistry#register` should have a `kotlin-reflect` lenient check instead of throwing a `java.lang.NoClassDefFoundError: kotlin.reflect.jvm.ReflectJvmMapping` like currently in Spring Framework 5.2.5.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refines the check for suspending handler methods in Kotlin.  The original check only looked at whether the method was declared in a Kotlin class and if it was marked as `suspend`.  The updated code now adds a more specific check: it verifies if the last parameter of the method is a `kotlin.coroutines.Continuation`.  This change likely addresses a potential false positive in the previous implementation by ensuring that only methods explicitly accepting a `Continuation` are flagged as unsupported",
            "avg_logprobs": -0.22163560218417766
        }
    },
    {
        "commit_hash": "88cac6a4a3a84ff9891d226d7ad47d2707af6d96",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (targetMethod.getDeclaringClass().isInterface()) {\n+\t\tif (targetMethod.getDeclaringClass().isInterface() && targetMethod.getDeclaringClass() != targetClass &&\n+\t\t\t\tobtainPointcutExpression().getPointcutExpression().contains(\".\" + targetMethod.getName() + \"(\")) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduce creation of composite interfaces to actual method references in current pointcut",
        "commit_body": "Closes gh-29519\n",
        "linked_issues": [
            {
                "issue_id": "29519",
                "issue_title": "`AspectJExpressionPointcut#getTargetShadowMatch` tentatively creates proxies for every bean",
                "issue_body": "So this is a continuation of\r\nhttps://github.com/spring-projects-experimental/spring-native/issues/956\r\nwhich is still an open issue with Boot 3 (RC2 + latest snapshot)\r\n\r\nWhile simple methods expressions like this just work fine\r\n\"execution(public * org.goafabric.calleeservice.aspect.TestComponent.*(..))\"\r\n\r\nMore complex expressions, that e.g. leverage an custom anntotation, don't.\r\nTo be more specific .. they work with console applications, but crash the moment wie have WEB on the classpath.\r\nWhich somehow explains the error.\r\nTried to set the jdk proxy interfaces that graalvm demands, but stopped after the 3rd roundtrip because this seems\r\nto be a neverending road ...\r\n\r\nI've attached a simple example that works with non native, but crashes on bootstrap of the native image.\r\nWhat's also a little mind boggeling .. is that i have to register a simple hint for the Test Aspect.\r\nWhile the aot-smoke-tests don't ...\r\n\r\n[error.txt](https://github.com/spring-projects/spring-boot/files/10041368/error.txt)\r\n[example.zip](https://github.com/spring-projects/spring-boot/files/10041400/example.zip)\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "@goafabric thanks but that's not a Spring Boot concern. Moving to framework.",
                    "- Potentially a duplicate of #28711",
                    "Thx for answering that fast .. insanely fast ...\r\n\r\nhttps://github.com/spring-projects/spring-framework/issues/28711 is a little different \r\n\r\nIt at least explains why i had to set\r\n`hints.reflection().registerType(TestAspect.class, MemberCategory.INVOKE_DECLARED_METHODS)`.\r\n\r\nBut with this the invocation works .. for all use cases as long as it is a simple console application.\r\n\r\nCombine it with web and it crashes. So I guess this is a little different.",
                    "That's an interesting one. We have:\r\n```java\r\n@Component\r\n@Aspect\r\npublic class TestAspect {\r\n\r\n    @Around(\"@within(org.goafabric.calleeservice.aspect.TestAnnotation)\")\r\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\r\n        try {\r\n            return joinPoint.proceed();\r\n        } finally {\r\n            final Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();\r\n            System.err.println(\"aspects wrapped method : \" + toString(method));\r\n        }\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\nThe sample indeed fails with errors like:\r\n```\r\nCaused by: com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface org.springframework.boot.web.embedded.tomcat.ConfigurableTomcatWebServerFactory, interface org.springframework.context.ResourceLoaderAware, interface org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory, interface org.springframework.boot.web.server.ConfigurableWebServerFactory] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles=<comma-separated-config-files> and -H:DynamicProxyConfigurationResources=<comma-separated-config-resources> options.\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.core.util.VMError.unsupportedFeature(VMError.java:89) ~[na:na]\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.core.reflect.proxy.DynamicProxySupport.getProxyClass(DynamicProxySupport.java:171) ~[na:na]\r\n        at java.base@17.0.5/java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:47) ~[callee-service:na]\r\n        at java.base@17.0.5/java.lang.reflect.Proxy.getProxyClass(Proxy.java:398) ~[callee-service:na]\r\n        at org.springframework.util.ClassUtils.createCompositeInterface(ClassUtils.java:783) ~[na:na]\r\n        at org.springframework.aop.aspectj.AspectJExpressionPointcut.getTargetShadowMatch(AspectJExpressionPointcut.java:432) ~[na:na]\r\n        at org.springframework.aop.aspectj.AspectJExpressionPointcut.matches(AspectJExpressionPointcut.java:290) ~[na:na]\r\n        at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:251) ~[na:na]\r\n        at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:288) ~[na:na]\r\n        at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:320) ~[na:na]\r\n        at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:128) ~[callee-service:6.0.3]\r\n        at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:97) ~[callee-service:6.0.3]\r\n        at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:78) ~[callee-service:6.0.3]\r\n        at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:366) ~[callee-service:6.0.3]\r\n        at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:318) ~[callee-service:6.0.3]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:435) ~[callee-service:6.0.3]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1754) ~[callee-service:6.0.3]\r\n        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:599) ~[callee-service:6.0.3]\r\n        ... 16 common frames omitted\r\n```\r\n\r\nSo I began to add more proxy hints, but at some point I stopped because even with that hint configuration, that's not enough to make it work.\r\n```\r\n hints.proxies()\r\n                    .registerJdkProxy(OrderedFilter.class, Filter.class, BeanNameAware.class, EnvironmentAware.class,\r\n                            EnvironmentCapable.class, ServletContextAware.class, InitializingBean.class, DisposableBean.class)\r\n                    .registerJdkProxy(WebServerFactoryCustomizer.class, Ordered.class)\r\n                    .registerJdkProxy(ApplicationContextAware.class, EnvironmentCapable.class, EnvironmentAware.class,\r\n                            Servlet.class, ServletConfig.class, Serializable.class)\r\n                    .registerJdkProxy(DispatcherServletPath.class, ServletContextInitializer.class, Ordered.class)\r\n                    .registerJdkProxy(ErrorPageRegistrar.class, Ordered.class)\r\n                    .registerJdkProxy(ViewResolver.class, Ordered.class, ServletContextAware.class, ApplicationContextAware.class)\r\n                    .registerJdkProxy(ErrorViewResolver.class, Ordered.class)\r\n                    .registerJdkProxy(ErrorAttributes.class, Ordered.class)\r\n                    .registerJdkProxy(ErrorAttributes.class, HandlerExceptionResolver.class, Ordered.class)\r\n                    .registerJdkProxy(WebMvcConfigurer.class, ServletContextAware.class)\r\n                    .registerJdkProxy(ResourceLoaderAware.class, ApplicationContextAware.class, ServletContextAware.class)\r\n                    .registerJdkProxy(ConfigurableTomcatWebServerFactory.class, ResourceLoaderAware.class,\r\n                            ConfigurableServletWebServerFactory.class, ConfigurableWebServerFactory.class);\r\n```\r\n\r\n@jhoeller It looks like `AspectJExpressionPointcut#getTargetShadowMatch` tentatively create proxies for every bean [in this try catch block](https://github.com/spring-projects/spring-framework/blob/main/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java#L431-L439). I am wondering about the performance impact on the JVM, and on native that means we would need to create proxy hints for every bean, leading to massive compatibility headaches and increased footprint. Is this something we could refine from your point of view?",
                    "That composite interface creation is only really needed for default methods in interfaces and similar scenarios where interface-based method implementations are inherited rather than implemented locally. I've added a corresponding condition to reduce the creation of composite interfaces to actual method references in the current pointcut, that is, only when the pointcut actually refers to a non-overridden default method or the like. This should eliminate all of the common cases above.",
                    "I confirm the example is now working as expected with method hints (`hints.reflection().registerType(TestAspect.class, MemberCategory.INVOKE_DECLARED_METHODS);`) which will be inferred via #28711.",
                    "@sdeleuze \r\nthank you for finally having this fixed\r\nis there any kind of way i can try it out myself already ?\r\n\r\nboot 3.0.2-snapshot still seems to rely on framework-core 6.0.3\r\nand including framework-core 6.0.4-SNAPSHOT did not solve the issue\r\n\r\nor do i just have to wait for a release ? :)\r\n\r\nthx",
                    "Thanks should go to @jhoeller for the fix ;-)\r\n\r\nYou can override the Framework version in Boot, otherwise just wait a bit, Spring Framework 6.0.4 has been released today and will be picked up by Boot shortly.",
                    "yes i saw it on twitter yesterday evening, thx 4 letting me know and of course also to @jhoeller ",
                    "@sdeleuze \r\nI can happily report that everything is working now with boot 3.0.2-SNAPSHOT\r\nEven more complex applications finally including CircuitBreaker Annotation\r\nSo thx again to both of you.\r\n\r\nAs a sugar on top .. would it be possible to get rid of the \"hints.reflection().registerType\" ?\r\nBecause basically everything annotated with Aspect should qualify already qualify for reflection ?\r\n\r\nOr .. \"at least\" as a fallback, at least have a working variant of \"RegisterForReflectionBinding\"\r\n\r\nThen it would also be nice to have spring cloud resilience4j working out of the box.\r\nI opened an issue a while ago, that was just closed\r\nhttps://github.com/spring-cloud/spring-cloud-circuitbreaker/issues/159\r\n\r\nAnd this basically needs \r\n\" hints.reflection().registerType(io.github.resilience4j.spring6.circuitbreaker.configure.CircuitBreakerAspect.class, builder -> builder.withMembers(MemberCategory.INVOKE_DECLARED_METHODS));\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
                    "Please create a related issue with me mentioned with a minimal reproducer and a detailed description of the type hint inference you would expect."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `if` statement.  Previously, the code checked only if the `targetMethod`'s declaring class was an interface.  Now, it also checks if the declaring class is different from the `targetClass` *and* if the pointcut expression contains a specific method signature (including the method name and parentheses).  This suggests a refinement to avoid potential issues when dealing with interfaces and method names within the pointcut expression",
            "avg_logprobs": -0.16360485076904296
        }
    },
    {
        "commit_hash": "8921be18de88a0a1e63136c9d77d52eeea0acbe2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/support/StandardTypeLocator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tif (loadedType != null &&\n-\t\t\t\t!(this.classLoader instanceof SmartClassLoader scl && scl.isClassReloadable(loadedType))) {\n-\t\t\tthis.typeCache.put(typeName, loadedType);\n+\t\tif (loadedType != null) {\n+\t\t\tif (!(this.classLoader instanceof SmartClassLoader scl && scl.isClassReloadable(loadedType))) {\n+\t\t\t\tthis.typeCache.put(typeName, loadedType);\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Properly return loaded type even if identified as reloadable",
        "commit_body": "Closes gh-31668\n",
        "linked_issues": [
            {
                "issue_id": "31668",
                "issue_title": "SpEL expression on a reloadable type can no longer be resolved",
                "issue_body": "Starting with Boot 3.1.6/Framework 6.0.14, the following SpEL expression fails to resolve the referenced type, but _only_ when devtools is on the classpath: `T(com.example.MyEnum).VALUE`\r\nThe following exception is thrown:\r\n```\r\nException in thread \"restartedMain\" java.lang.reflect.InvocationTargetException\r\n        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)\r\n        at java.base/java.lang.reflect.Method.invoke(Method.java:580)\r\n        at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:50)\r\nCaused by: org.springframework.expression.spel.SpelEvaluationException: EL1005E: Type cannot be found 'com.example.demo.MyEnum'\r\n        at org.springframework.expression.spel.support.StandardTypeLocator.findType(StandardTypeLocator.java:128)\r\n        at org.springframework.expression.spel.ExpressionState.findType(ExpressionState.java:180)\r\n        at org.springframework.expression.spel.ast.TypeReference.getValueInternal(TypeReference.java:70)\r\n        at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:61)\r\n        at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:97)\r\n        at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:114)\r\n        at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:142)\r\n        at com.example.demo.DemoApplication.main(DemoApplication.java:15)\r\n        at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\r\n        ... 2 more\r\n```\r\n\r\nDowngrading to Framework 6.0.13, _or_ removing devtools fixes it.\r\n\r\nReproducer: [demo.zip](https://github.com/spring-projects/spring-boot/files/13457797/demo.zip)\r\n\r\nMain:\r\n```java\r\n@SpringBootApplication\r\npublic class DemoApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(DemoApplication.class, args);\r\n\r\n        System.out.println(new SpelExpressionParser()\r\n                .parseExpression(\"T(com.example.demo.MyEnum).VALUE\")\r\n                .getValue());\r\n    }\r\n\r\n}\r\n```\r\nMyEnum.java:\r\n```java\r\npublic enum MyEnum {\r\n    VALUE\r\n}\r\n```\r\n\r\nExtract and run `./mvnw spring-boot:run`, the exception occurs.\r\nOpen the pom.xml and change the Spring Framework version to 6.0.13, run again and the code succeeds.\r\nAlternatively, leave the Spring Framework version as is and remove the devtools dependency instead, run again and the code succeeds as well.\r\n\r\nMaybe related: #31579 ",
                "issue_state": "closed",
                "issue_comment": [
                    "Ouch that's an oversight in the `StandardTypeLocator` cache handling where we mean to not cache if the class is reloadable, but the code path actually not just bypasses the cache, it also bypasses the return statement... Sorry for the glitch, we'll fix this ASAP."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change restructures the conditional logic.  The original code checked for `loadedType` being non-null *and* a condition related to class reloadability.  The revised code now first checks if `loadedType` is non-null.  If it is, it then checks the class reloadability condition.  This is a minor refactoring that improves readability by separating the null check from the class reloadability check.  The effect is functionally identical; the change is primarily stylistic",
            "avg_logprobs": -0.25854284286499024
        }
    },
    {
        "commit_hash": "8934eb8464e9efdc560c0d8b1ffb34ddbd18bc0a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ClassUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+ * @author Sebastien Deleuze\n+\t/** Precomputed value for the combination of private, static and final modifiers. */\n+\tprivate static final int NON_OVERRIDABLE_MODIFIER = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;\n+\n+\t/** Precomputed value for the combination of public and protected modifiers. */\n+\tprivate static final int OVERRIDABLE_MODIFIER = Modifier.PUBLIC | Modifier.PROTECTED;\n+\n-\t\tif (Modifier.isPrivate(method.getModifiers())) {\n+\t\tif ((method.getModifiers() & NON_OVERRIDABLE_MODIFIER) != 0) {\n-\t\tif (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {\n+\t\tif ((method.getModifiers() & OVERRIDABLE_MODIFIER) != 0) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize ClassUtils#getMostSpecificMethod",
        "commit_body": "This commit optimizes ClassUtils#getMostSpecificMethod which is\na method frequently invoked in typical Spring applications.\n\nIt refines ClassUtils#isOverridable by considering static and\nfinal modifiers as non overridable and optimizes its implementation.\n\nCloses gh-30272\n",
        "linked_issues": [
            {
                "issue_id": "30272",
                "issue_title": "Optimize `ClassUtils#getMostSpecificMethod`",
                "issue_body": "Hi,\r\n\r\nI've been profiling some (test-)application context starts lately on Spring Framework 5.x and noticed that with one of our medium-larger applications - which I'm unfortunately not able to share - that during startup almost 100K exceptions are being thrown (caused by some Aspects not in our control). The large majority of this is ending up in `ClassUtils.getMostSpecificMethod`.  The majority of cases seems to be caused by checking for the static factory methods on `Map.of`, `Map.ofEntries`etc. with the target class `Properties` where we already now that they won't exist. (`Properties` is checked because Spring Data repositories have an inner bean for the named queries, I believe)\r\n\r\n<img width=\"1042\" alt=\"image\" src=\"https://user-images.githubusercontent.com/6304496/229538050-0538a954-e0ee-42cb-ac48-03a769b1e451.png\">\r\n\r\nI can't imagine this to be super fast or efficient. Could we do anything about that? I'm wondering if it would make sense to exclude `static` methods here in the first place. Or have some sort of pre-defined list of methods or classes that we know won't find certain things. Or caching the lookups etc.\r\n\r\nWe haven't been able to upgrade these apps so far to 6.x because the Spring-Security changes are blocking us from a smoother upgrade, but a quick check also revealed that nothing really drastically changed in that regards in the codebase and the risk of checking for methods that are known to not exist still applies. Having that said, there might be a chance that this particular issue for us is reduced with https://github.com/spring-projects/spring-data-commons/commit/712477bf365def70bad92220304a08dd52393b2e but I haven't been able to confirm this just yet.\r\n\r\nAnyhow, I'd appreciate if you could take a look if this can be somehow improved.\r\n\r\nCheers,\r\nChristoph",
                "issue_state": "closed",
                "issue_comment": [
                    "@dreis2211 After discussing with @jhoeller, I implemented filtering out both `static` and `final` methods, and that indeed reduces the number of invocations of the rest of the logic. Since `ClassUtils#getMostSpecificMethod` and `ClassUtils#isOverridable` are frequently invoked, I optimised the implementation as well. If you can, please share the impact on your application.\r\n\r\nIf you want to do more test about further optimizations, https://github.com/spring-projects/spring-petclinic is using a lot those methods as well, so feel free to use it to share more specific feedback.\r\n\r\nThe fix will be available in Spring Framework 5.3, 6.0 and 6.1.",
                    "@sdeleuze Thanks. I won't be able to share anything in the foreseeable future, at least no in-depth analysis. But I'll see if it has any impact once it's live in one of our applications."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces checks for `private`, `public`, and `protected` modifiers with a more efficient bitwise AND operation using precomputed constants.  Specifically:\\n\\n* **`private` and `static` and `final` check:**  The original `if (Modifier.isPrivate(method.getModifiers()))` is replaced with `if ((method.getModifiers() & NON_OVERRIDABLE_MODIFIER) != 0)`",
            "avg_logprobs": -0.18680513381958008
        }
    },
    {
        "commit_hash": "89802cfc11bc7b94387bf75f376dc08218e3946c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (getAnnotations().length != other.getAnnotations().length) {\n+\t\tif (!Arrays.equals(getAnnotations(), other.getAnnotations())) {\n-\t\tfor (Annotation ann : getAnnotations()) {\n-\t\t\tif (!ann.equals(other.getAnnotation(ann.annotationType()))) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "TypeDescriptor avoids merged annotations for equality comparisons",
        "commit_body": "Issue: SPR-14926\nIssue: SPR-14929\n",
        "linked_issues": [
            {
                "issue_id": "19496",
                "issue_title": "ConversionService performance regression [SPR-14929]",
                "issue_body": "**[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell)** opened **[SPR-14929](https://jira.spring.io/browse/SPR-14929?redirect=false)** and commented\n\nConsider the following:\n\n```java\npublic class SpELTests {\n\n\t@Test\n\tpublic void test() {\n\t\tExpression exp = new SpelExpressionParser().parseExpression(\n\t\t\t\t\"#target.filter(headers['dummyHeader'] != null \"\n\t\t\t\t+ \"? headers['dummyHeader'] \"\n\t\t\t\t+ \": T(org.springframework.util.Assert).isTrue(false, 'required header not available: dummyHeader'))\");\n\t\tMessage<String> message = MessageBuilder.withPayload(\"foo\").setHeader(\"dummyHeader\", \"bar\").build();\n\t\tEvaluationContext context = new StandardEvaluationContext();\n\t\tcontext.setVariable(\"target\", new DummyFilter());\n\t\tStopWatch watch = new StopWatch();\n\t\twatch.start();\n\t\tfor (int i = 0; i < 5000; i++) {\n\t\t\tObject value = exp.getValue(context, message);\n\t\t}\n\t\twatch.stop();\n\t\tSystem.out.println(\"Elapsed: \" + watch.getTotalTimeSeconds());\n\t}\n\n\tpublic static class DummyFilter {\n\n\t\t@Filter\n\t\tpublic boolean filter(@Header(\"dummyHeader\") String dummyValue) {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n}\n```\n\nWhen run with Spring Framework 4.3.3 it runs in < 0.5 seconds; with 4.3.4 it takes 40+ seconds.\n\nWith YourKit, I tracked the problem down to `DefaultConversionService.getConverter()` with source and target type descriptors:\n\n```\njava.lang.String\n@org.springframework.messaging.handler.annotation.Header java.lang.String\n```\n\nThe performance issue is because `this.converterCache.get(key);` seems to miss on every iteration (which in turn causes `AnnotationUtils.getDefaultValue()` which is where the cost is incurred). `getDefaultConverter()` correctly returns a NoOp converter which is inserted into the cache but, for some reason, that entry is not found in later iterations.\n\nAfter several iterations, `this.converterCache` contains\n\n```\n{ConverterCacheKey [sourceType = java.lang.String, targetType = @org.springframework.messaging.handler.annotation.Header java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.String, targetType = @org.springframework.messaging.handler.annotation.Header java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.String, targetType = java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.String, targetType = @org.springframework.messaging.handler.annotation.Header java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.String, targetType = @org.springframework.messaging.handler.annotation.Header java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.Boolean, targetType = java.lang.Boolean]=NO_OP}\n```\n\nWith 4.3.3, I `this.converterCache` contains:\n\n```\n{ConverterCacheKey [sourceType = java.lang.String, targetType = @org.springframework.messaging.handler.annotation.Header java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.String, targetType = java.lang.String]=NO_OP, \nConverterCacheKey [sourceType = java.lang.Boolean, targetType = java.lang.Boolean]=NO_OP}\n```\n\nSo the issue seems to be the cache entries are not found, perhaps some problem with the hash.\n\n---\n\n**Affects:** 4.3.4\n\n**Issue Links:**\n- [INT-4170](https://jira.spring.io/browse/INT-4170) The delivery of message with be much slower to downstream filter with Header parameter\n- #19410 AnnotationFormatterFactory should support `@AliasFor`\n- #18287 Differentiate between TypeDescriptors with same annotations but different attributes\n- #19388 GenericConversionService.addConverter should be able to determine generic types from target class behind proxy\n- #19493 Improve performance for conversions using a method parameter based type descriptor with annotations\n- #19626 Annotated method argument matching performance issue\n\n0 votes, 7 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI've attached a screenshot showing the culprit in a test case provided for the original ticket in Spring HATEOAS. Under `GenericConversionService.getConverter(\u2026)` there's another 35% block for `ConcurrentReferenceHashMap.put(\u2026)` boiling down to basically the same call path into the `equals(\u2026)` implementation of `TypeDescriptor`.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out as a different variant of #19496: It's not the annotation comparisons being so expensive per se, it's rather just the **merged** annotation comparisons that we unnecessarily triggered from `TypeDescriptor.equals` there as of 4.3.4 due to some unfortunate interaction.\n\nAs of 4.3.5, we're comparing the raw declared annotations which seems efficient enough. Being able to isolate the descriptor to type plus annotations seems beneficial still, since for conversion purposes, it doesn't matter which signature the type and the annotations actually came from.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI didn't dive in deeper as I was sort of assuming the \"new way\" of looking up annotations would always include the synthesization of annotations. Anyway, thanks for the quick turnaround!\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI don't see any significant changes in the numbers after the recent fixes . However, it looks like the hotspot has changed to be `AnnotationConverterKey.equals(\u2026)` again triggering `equals(\u2026)` method on the proxy (see new screenshot). Looks like the shortcut in `TypeDescriptor` has caused the code to run into a different but as costly comparison later?\n\nAlso, the ticket was marked as fixed in 4.3.5 but I couldn't find a related commit in the 4.3.x branch.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nIt looks like that `AnnotationPrinterConverter.convert(Object, TypeDescriptor, TypeDescriptor)` looks up the annotation on the target type, which returns a merged annotation. That merged annotation is then used in `AnnotationConverterKey` and its `equals(\u2026)` which in turn then basically causes the same problem as originally described.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI created a local \"fix\" using the annotation type and the target type descriptor in the cache key instead of the annotation instance (not sure that creates really valid equals comparisons, I just wanted to see where I get if that hotspot is removed. The next thing I run into is the actual conversion. That seems to work well for simple conversions. However, playing around with it, I discovered something quite obscure again:\n\n```java\nResponseEntity<Object> someMethod(@RequestParam(\"foo\") @DateTimeFormat(iso = ISO.DATE) Date date) {\u2026}\n```\n\nLetting the `ConversionService` convert `Date` instances into `Strings` is a lot slower than e.g. `Integers`. 1 million conversions of `Integer` instances take ~150ms. For `Date` formatting, those numbers raise to ~600ms, interestingly with the JodaTime converters involved, which was surprising. If I switch to `LocalDateTime` instances, those numbers boost up to ~4200ms (see new Screenshot), unfortunately with most of the time spent in the JDK, especially `StringBuilder.setLength()`. Is that somethign we should bring up with the JDK team?\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nLooks like the usage of `DateTimeFormatter.ISO_DATE` (or the constants in general as it also appears with `ISO_DATE_TIME`, too) is significantly degrading performance. I've created [a benchmark](https://gist.github.com/olivergierke/487d58bd146a47574fb5a8316f950b04) to showcase this and pinged Stephen on Twitter to see where this goes.\n"
                ]
            },
            {
                "issue_id": "19493",
                "issue_title": "Improve performance for conversions using a method parameter based type descriptor with annotations [SPR-14926]",
                "issue_body": "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** opened **[SPR-14926](https://jira.spring.io/browse/SPR-14926?redirect=false)** and commented\n\nWhen a conversion is invoked using a `TypeDescriptor` instance that was created for a `MethodParameter` containing annotations, the lookup of the `Converter` is significantly slowed down as the `TypeDescriptor` instances undergo an `\u2026.equals(\u2026)` check that's quite expensive due to the synthesized annotations.\n\nI wonder whether `TypeDescriptor` really needs to compare the annotations if the method and the parameter index are well defined as they by definition uniquely identify the parameter.\n\nHere's a sample test case showing the issue:\n\n```java\npackage org.example.myapi;\n\nimport java.lang.reflect.Method;\nimport java.util.Date;\n\nimport org.junit.Test;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.convert.ConversionService;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.format.annotation.DateTimeFormat.ISO;\nimport org.springframework.format.support.DefaultFormattingConversionService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n/**\n * @author Oliver Gierke\n */\npublic class FooTests {\n\n\tprivate static final int ITERATIONS = 1000000;\n\n\tprivate static final ConversionService CONVERSION_SERVICE = new DefaultFormattingConversionService();\n\tprivate static final TypeDescriptor STRING_TYPE = TypeDescriptor.valueOf(String.class);\n\n\t@Test\n\tpublic void methodParameterWithAnnotations() {\n\n\t\tDate date = new Date();\n\n\t\tMethod method = ReflectionUtils.findMethod(SomeController.class, \"someMethod\", Date.class);\n\t\tTypeDescriptor sourceDescriptor = TypeDescriptor.nested(new MethodParameter(method, 0), 0);\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tfor (int i = 0; i < ITERATIONS; i++) {\n\t\t\tCONVERSION_SERVICE.convert(date, sourceDescriptor, STRING_TYPE);\n\t\t}\n\n\t\tlong duration = (System.currentTimeMillis() - startTime);\n\n\t\tSystem.out.println(\"With annotations \" + duration);\n\t}\n\n\t@Test\n\tpublic void methodParameterWithoutAnnotations() {\n\n\t\tMethod method = ReflectionUtils.findMethod(SomeController.class, \"someMethod\", String.class);\n\t\tTypeDescriptor sourceDescriptor = TypeDescriptor.nested(new MethodParameter(method, 0), 0);\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tfor (int i = 0; i < ITERATIONS; i++) {\n\t\t\tCONVERSION_SERVICE.convert(\"Foo\", sourceDescriptor, STRING_TYPE);\n\t\t}\n\n\t\tlong duration = (System.currentTimeMillis() - startTime);\n\n\t\tSystem.out.println(\"Without annotations \" + duration);\n\t}\n\n\tstatic class SomeController {\n\n\t\tResponseEntity<Object> someMethod(@RequestParam(\"foo\") @DateTimeFormat(iso = ISO.DATE) Date date) {\n\t\t\treturn null;\n\t\t}\n\n\t\tResponseEntity<Object> someMethod(String value) {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n```\n\n---\n\n**Affects:** 4.3.4\n\n**Reference URL:** https://github.com/spring-projects/spring-hateoas/issues/511\n\n**Attachments:**\n- [Bildschirmfoto 2016-11-21 um 11.20.48.PNG](https://jira.spring.io/secure/attachment/23623/Bildschirmfoto+2016-11-21+um+11.20.48.PNG) (_154.80 kB_)\n- [Bildschirmfoto 2016-11-26 um 13.16.01.PNG](https://jira.spring.io/secure/attachment/23633/Bildschirmfoto+2016-11-26+um+13.16.01.PNG) (_89.78 kB_)\n- [Bildschirmfoto 2016-11-26 um 13.56.30.PNG](https://jira.spring.io/secure/attachment/23634/Bildschirmfoto+2016-11-26+um+13.56.30.PNG) (_110.74 kB_)\n\n**Issue Links:**\n- #17519 Spring Performance Optimization, Comparing Classes\n- #19410 AnnotationFormatterFactory should support `@AliasFor`\n- #18287 Differentiate between TypeDescriptors with same annotations but different attributes\n- #19496 ConversionService performance regression\n- #19626 Annotated method argument matching performance issue\n- #19525 `@DateTimeFormat`(iso = ISO.DATE_TIME) should use optimized formatter for LocalDateTime\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI've attached a screenshot showing the culprit in a test case provided for the original ticket in Spring HATEOAS. Under `GenericConversionService.getConverter(\u2026)` there's another 35% block for `ConcurrentReferenceHashMap.put(\u2026)` boiling down to basically the same call path into the `equals(\u2026)` implementation of `TypeDescriptor`.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out as a different variant of #19496: It's not the annotation comparisons being so expensive per se, it's rather just the **merged** annotation comparisons that we unnecessarily triggered from `TypeDescriptor.equals` there as of 4.3.4 due to some unfortunate interaction.\n\nAs of 4.3.5, we're comparing the raw declared annotations which seems efficient enough. Being able to isolate the descriptor to type plus annotations seems beneficial still, since for conversion purposes, it doesn't matter which signature the type and the annotations actually came from.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI didn't dive in deeper as I was sort of assuming the \"new way\" of looking up annotations would always include the synthesization of annotations. Anyway, thanks for the quick turnaround!\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI don't see any significant changes in the numbers after the recent fixes . However, it looks like the hotspot has changed to be `AnnotationConverterKey.equals(\u2026)` again triggering `equals(\u2026)` method on the proxy (see new screenshot). Looks like the shortcut in `TypeDescriptor` has caused the code to run into a different but as costly comparison later?\n\nAlso, the ticket was marked as fixed in 4.3.5 but I couldn't find a related commit in the 4.3.x branch.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nIt looks like that `AnnotationPrinterConverter.convert(Object, TypeDescriptor, TypeDescriptor)` looks up the annotation on the target type, which returns a merged annotation. That merged annotation is then used in `AnnotationConverterKey` and its `equals(\u2026)` which in turn then basically causes the same problem as originally described.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nI created a local \"fix\" using the annotation type and the target type descriptor in the cache key instead of the annotation instance (not sure that creates really valid equals comparisons, I just wanted to see where I get if that hotspot is removed. The next thing I run into is the actual conversion. That seems to work well for simple conversions. However, playing around with it, I discovered something quite obscure again:\n\n```java\nResponseEntity<Object> someMethod(@RequestParam(\"foo\") @DateTimeFormat(iso = ISO.DATE) Date date) {\u2026}\n```\n\nLetting the `ConversionService` convert `Date` instances into `Strings` is a lot slower than e.g. `Integers`. 1 million conversions of `Integer` instances take ~150ms. For `Date` formatting, those numbers raise to ~600ms, interestingly with the JodaTime converters involved, which was surprising. If I switch to `LocalDateTime` instances, those numbers boost up to ~4200ms (see new Screenshot), unfortunately with most of the time spent in the JDK, especially `StringBuilder.setLength()`. Is that somethign we should bring up with the JDK team?\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nLooks like the usage of `DateTimeFormatter.ISO_DATE` (or the constants in general as it also appears with `ISO_DATE_TIME`, too) is significantly degrading performance. I've created [a benchmark](https://gist.github.com/olivergierke/487d58bd146a47574fb5a8316f950b04) to showcase this and pinged Stephen on Twitter to see where this goes.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a length-based comparison of annotations with a deep comparison using `Arrays.equals()`.  The original code checked if the annotation arrays had the same length, but did not verify the contents of the annotations.  The new code now compares the entire annotation array for equality, ensuring that both the number and the *content* of annotations are identical.  This change likely improves the accuracy of the `equals` method for `TypeDescriptor` objects",
            "avg_logprobs": -0.27956654163117106
        }
    },
    {
        "commit_hash": "89b8449999769cbc412cd3301614630bbe98ae34",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tParsedSql parsedSql = this.parsedSqlCache.get(sql);\n-\t\t\tif (parsedSql == null) {\n-\t\t\t\tparsedSql = NamedParameterUtils.parseSqlStatement(sql);\n-\t\t\t\tthis.parsedSqlCache.put(sql, parsedSql);\n-\t\t\t}\n-\t\t\treturn parsedSql;\n+\t\t\treturn parsedSqlCache.computeIfAbsent(sql, NamedParameterUtils::parseSqlStatement);",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify getParsedSql() method in NamedParameterJdbcTemplate",
        "commit_body": "Closes gh-24358",
        "linked_issues": [
            {
                "issue_id": "24358",
                "issue_title": "Simplify getParsedSql() method in NamedParameterJdbcTemplate",
                "issue_body": "It can simplify this way. ",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks",
                    "For future reference, please make sure to:\r\n\r\n- update the copyright date if appropriate: f527ca7515dce934594235861e6361405d551f96\r\n- adhere to coding guidelines: 734db23f4eb99e4489a9349dd77de78e53f7f33d\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a manual `if` statement and cache lookup with a `computeIfAbsent` method.  This leverages the `computeIfAbsent` method on the `parsedSqlCache` to efficiently retrieve or compute the `ParsedSql` object for a given SQL statement (`sql`).  If the `ParsedSql` is not found in the cache, `NamedParameterUtils::parseSqlStatement` is executed to create it and then placed in the cache",
            "avg_logprobs": -0.25368169784545896
        }
    },
    {
        "commit_hash": "89c7c6e9dd85d880aeea71ec0c3c944a7030d109",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-import org.springframework.core.KotlinDetector;\n-import org.springframework.core.KotlinReflectionParameterNameDiscoverer;\n+ * @author Sebastien Deleuze\n-\tpublic LocalValidatorFactoryBean() {\n-\t\tif (KotlinDetector.isKotlinReflectPresent()) {\n-\t\t\tthis.parameterNameDiscoverer = new KotlinReflectionParameterNameDiscoverer();\n-\t\t}\n-\t}\n-\n-\n-\t * <p>Default is Hibernate Validator's own internal use of standard Java reflection,\n-\t * with an additional {@link KotlinReflectionParameterNameDiscoverer} if Kotlin\n-\t * is present. This may be overridden with a custom subclass or a Spring-controlled\n+\t * <p>Default is Hibernate Validator's own internal use of standard Java reflection.\n+\t * This may be overridden with a custom subclass or a Spring-controlled",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix bean validation on suspending function parameters",
        "commit_body": "This commit leverages Hibernate Validator's own internal use\nof standard Java reflection to perform validation on suspending\nfunction, which fixes the ArrayIndexOutOfBoundsException previously\nobserved.\n\nValidation of suspending function return values remains unsupported\nas Hibernate Validator is not Coroutines aware.\n\nCloses gh-23499\n",
        "linked_issues": [
            {
                "issue_id": "23499",
                "issue_title": "Bean validation doesn't work on Kotlin coroutines controller parameters",
                "issue_body": "**Affects:**  5.2.0.RC1\r\n\r\nwhen using Kotlin suspend function and Validated annotation, like this.\r\n\r\n    package example\r\n    \r\n    import org.springframework.http.HttpStatus\r\n    import org.springframework.http.ResponseEntity\r\n    import org.springframework.validation.annotation.Validated\r\n    import org.springframework.web.bind.annotation.RequestMapping\r\n    import org.springframework.web.bind.annotation.RestController\r\n\r\n    @Validated\r\n    @RestController\r\n    class Foo {\r\n        @RequestMapping(\"/foo\")\r\n        suspend fun foo() = ResponseEntity(\"foo\", HttpStatus.OK)\r\n    }\r\n\r\noccured exception.\r\n\r\n    java.lang.ArrayIndexOutOfBoundsException: 0\r\n            at java.util.Arrays$ArrayList.get(Arrays.java:3841) ~[na:1.8.0_102]\r\n            Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:\r\n    Error has been observed at the following site(s):\r\n            |_ checkpoint \u21e2 Handler example.Foo#foo(Continuation) [DispatcherHandler]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.authorization.AuthorizationWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.authorization.ExceptionTranslationWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.authentication.logout.LogoutWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.savedrequest.ServerRequestCacheWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.context.SecurityContextServerWebExchangeWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.context.ReactorContextWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.header.HttpHeaderWriterWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.config.web.server.ServerHttpSecurity$ServerWebExchangeReactorContextWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.security.web.server.WebFilterChainProxy [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.cloud.sleuth.instrument.web.TraceWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain]\r\n            |_ checkpoint \u21e2 HTTP GET \"/foo\" [ExceptionHandlingWebHandler]\r\n    Stack trace:\r\n                    at java.util.Arrays$ArrayList.get(Arrays.java:3841) ~[na:1.8.0_102]\r\n                    at org.hibernate.validator.internal.metadata.aggregated.ParameterMetaData$Builder.build(ParameterMetaData.java:169) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibern ate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.findParameterMetaData(ExecutableMetaData.java:435) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:388) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:204) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:166) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:265) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:233) ~[hibernate-validator-6.0.17.Final.jar:6.0.17.Final]\r\n                    at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:104) ~[spring-context-5.2.0.RC1.jar:5.2.0.RC1]\r\n                    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.0.RC1.jar:5.2.0.RC1]\r\n                    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) ~[spring-aop-5.2.0.RC1.jar:5.2.0.RC1]\r\n    ...",
                "issue_state": "closed",
                "issue_comment": [
                    "`@Validated` is indeed not yet Coroutines compliant, we need to fix that by using Coroutines aware methods to discover method parameters.",
                    "I am not entirely sure what we should do here. The issue comes from `MethodValidationInterceptor` which is obviously not Coroutines aware, but JSR-303 is designed to deal with Java reflection API not Kotlin one. We could maybe pass a fake parameter value for the `Continuation` one, but there are other issues like how to support annotation on return values, the fact that WebMvc is not supported yet, etc.\r\n\r\nGiven those uncertainties, it seems more reasonable to postpone this issue for 5.3.",
                    "Hello, @sdeleuze , any updates? Today, I think about another annotation something like KValidated as temporary solution, For example you can add new annotation KValidated which should be used only in kotlin. And after add KMethodValidationInterceptor with similary behaviour as MethodValidationInterceptor, what do you think about this? And can you describe the problem with solution please?. Why we can't just use CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args); as it is used in InvocableHandlerMethod?",
                    "@kostya05983 Even after adding support for Coroutines via `CoroutinesUtils.invokeSuspendingFunction` there is an error at Hibernate Validator level, so I suggest you or somebody raises an issue on Hibernate Validator side for such support. See the related stack trace bellow:\r\n\r\n```\r\nat java.base/java.util.Arrays$ArrayList.get(Arrays.java:4351)\r\nat org.hibernate.validator.internal.properties.javabean.JavaBeanExecutable.getParameterName(JavaBeanExecutable.java:86)\r\nat org.hibernate.validator.internal.metadata.aggregated.ParameterMetaData$Builder.build(ParameterMetaData.java:165)\r\nat org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.findParameterMetaData(ExecutableMetaData.java:436)\r\nat org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:391)\r\nat org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataBuilder$BuilderDelegate.build(BeanMetaDataBuilder.java:260)\r\nat org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataBuilder.build(BeanMetaDataBuilder.java:133)\r\nat org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.createBeanMetaData(BeanMetaDataManagerImpl.java:206)\r\nat org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.getBeanMetaData(BeanMetaDataManagerImpl.java:165)\r\nat org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:267)\r\nat org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:235)\r\nat org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:110)\r\nat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\r\nat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749)\r\nat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691)\r\nat com.example.FooCoroutinesController$$EnhancerBySpringCGLIB$$1b76b143.find(<generated>)\r\n```\r\n\r\n#22462 fix should be all what is needed on Spring side.",
                    "For reference, this is the hibernate issue: https://hibernate.atlassian.net/browse/HV-1638",
                    "I've build a workaround for this issue: https://gist.github.com/pschichtel/830b7943ea43b7cb58cadd984b54b903",
                    "Hit by this while trying Spring GraphQL with validation in the classpath. This makes it impossible to call suspended `@QueryMapping` methods. \r\nHibernate Validator issue is prioritized as Minor and unlikely to be fixed soon. Can validation be disabled at HandlerMethod level OR concrete method level?",
                    "> I've build a workaround for this issue: https://gist.github.com/pschichtel/830b7943ea43b7cb58cadd984b54b903\r\n\r\nHope this long-awaited fix will be included in Spring although it was a problem from Hibernate Validator.\r\n\r\n",
                    "I created a [sample project](https://github.com/hantsy/spring-puzzles/tree/master/validation-ktco) based on the solution provided by @pschichtel .",
                    "> https://gist.github.com/pschichtel/830b7943ea43b7cb58cadd984b54b903\r\n\r\njust added your workaround to my project and got around the arrayindexoutofbounds with hibernate-validator enabled. The project was using openapi generator to create a reactive kotlin api based on webflux. with reactive=true and useBeanValidation=true every query failed with arrayindexoutofbounds",
                    "@sdeleuze @sbrannen @bclozel my issure has discover a way to solve that problem [https://github.com/spring-projects/spring-framework/issues/29793](url)",
                    "Indeed #29566 that we made for unrelated reasons may allow us to solve this issue. i am not sure #29840 is the way I would implement it, but that provide a good basis for testing. I will have a deeper look and send my feedback.",
                    "@sdeleuze thanks for your replay",
                    "Based on a quick test, it seems just removing the usage of `KotlinReflectionParameterNameDiscoverer` in `LocalValidatorFactoryBean` combined with the changes done in #29566 fix parameter validation with Coroutines.\r\n\r\nCould people interested in getting that fix test my changes on https://github.com/sdeleuze/spring-framework/commit/gh-23499 and provide a feedback here?",
                    "i don't think hibernate validation will compatible with the kotlin suspend function. \r\ni have read some replay from hibernate validation\r\n\r\nhttps://hibernate.atlassian.net/browse/HV-1638\r\nhttps://hibernate.atlassian.net/browse/HV-1796",
                    "@sdeleuze  ![image](https://user-images.githubusercontent.com/5616997/213130358-d9c925c1-bcba-4b79-8c1c-77e9982d6381.png)\r\nit may be solved by jetbrain remove that parameter",
                    "On Spring side, I have the feeling that `KotlinReflectionParameterNameDiscoverer` in `LocalValidatorFactoryBean` does more harm than good. Coroutines use case seems totally broken with it, works for typical use case (unless I get different feedback but that's what my quick test shown).\r\n\r\nSome Kotlin use cases may still be broken until Kotlin team move forward on https://youtrack.jetbrains.com/issue/KT-40857, but I could ask them to move forward on that issue.\r\n\r\nCould you please test my branch and let me know how it goes for typical use case?",
                    "i will have a test",
                    "@cjdxhjj Any chance you could test and provide a feedback?",
                    "@sdeleuze i'm sorry for the slow response, i'm on holidy, i would try it as soon as possible.",
                    "@sdeleuze i have just do a simple test with \r\n![image](https://user-images.githubusercontent.com/5616997/214594802-bc234a99-4128-476d-869a-d017684c3767.png)\r\n![image](https://user-images.githubusercontent.com/5616997/214594893-cb835609-ba2c-406f-8924-c4fd20c3a4c2.png)\r\n![image](https://user-images.githubusercontent.com/5616997/214595114-c8e50cfc-a91b-4ec4-8e42-06393eb9829f.png)\r\nthat works.",
                    "Bean validation on suspending function parameters should be fixed as of Spring Framework 6.0.5, I don't think the fix is doable easily on 5.3.x so I won't backport it. Validation of suspending function return values remains unsupported as Hibernate Validator is not Coroutines aware, but I think parameter validation was the most critical need.",
                    "@sdeleuze thanks a lot",
                    "Hello! I'm not sure this is a related issue, though, let's see if we should open a new ticket.\r\n\r\nAfter upgrading from Spring Boot 3.0.2 to 3.0.4 validations on GraphQL controller parameters work as expected, but I'm now having a problem with custom ConstraintValidators which are not triggered at all.\r\n\r\nPlease see a sample code:\r\n```kotlin\r\n@Controller\r\n@Validated\r\nclass CompanyController {\r\n\r\n    @PreAuthorize(\"hasRole('ROLE_COMPANY_EDIT')\")\r\n    @MutationMapping(\"createCompany\")\r\n    suspend fun createCompany(\r\n        @Argument(\"input\")\r\n        @Valid\r\n        companyInput: CompanyInput\r\n    ): CompanyResponse {\r\n        // TODO..\r\n    }\r\n}\r\n\r\n@CompanyNameUniquePerWhitelabelId\r\ndata class CompanyInput(\r\n    val companyType: CompanyType,\r\n    val name: String,\r\n    @IsIso2Country val registeredAddressCountryCode: Int\r\n)\r\n\r\n@MustBeDocumented\r\n@Constraint(validatedBy = [CompanyNameUniquePerWhitelabelIdValidator::class])\r\n@Target(AnnotationTarget.CLASS)\r\n@Retention(AnnotationRetention.RUNTIME)\r\nannotation class CompanyNameUniquePerWhitelabelId(\r\n    val message: String = \"This company name already exists for Provided whitelabel.\",\r\n    val groups: Array<KClass<*>> = [],\r\n    val payload: Array<KClass<out Any>> = []\r\n)\r\n\r\nclass CompanyNameUniquePerWhitelabelIdValidator : ConstraintValidator<CompanyNameUniquePerWhitelabelId, CompanyInput> {\r\n\r\n    override fun isValid(companyInput: CompanyInput?, context: ConstraintValidatorContext?): Boolean {\r\n        // TODO\r\n    }\r\n}\r\n\r\n@MustBeDocumented\r\n@Constraint(validatedBy = [Iso2CountryValidator::class])\r\n@Target(AnnotationTarget.FIELD)\r\n@Retention(AnnotationRetention.RUNTIME)\r\nannotation class IsIso2Country(\r\n    val message: String = \"Wrong country code\",\r\n    val groups: Array<KClass<*>> = [],\r\n    val payload: Array<KClass<out Any>> = []\r\n)\r\n\r\nclass Iso2CountryValidator : ConstraintValidator<IsIso2Country, Int?> {\r\n    override fun isValid(value: Int?, context: ConstraintValidatorContext?): Boolean {\r\n        // TODO\r\n    }\r\n}\r\n```\r\n\r\nIn my case, none of `Iso2CountryValidator#isValid` and `CompanyNameUniquePerWhitelabelIdValidator#isValid` is triggered.\r\n\r\nAny thoughts?\r\n\r\nThanks!\r\nMichal",
                    "@Michal-Kucera this might be related to this issue: https://github.com/spring-projects/spring-graphql/issues/624 which was fixed in this commit https://github.com/spring-projects/spring-graphql/commit/581b1108f21101a09e799489b54b5a2888c3e62c, and will be released with Spring GraphQL 1.1.3.",
                    "Thanks for your fast response @koenpunt! Next time I should perhaps first look into graphql issues :)",
                    "Nice issue request. Thanks, @Michal-Kucera "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removed a conditional check for Kotlin reflection and the associated instantiation of `KotlinReflectionParameterNameDiscoverer`.  Previously, if Kotlin reflection was present, a `KotlinReflectionParameterNameDiscoverer` was used; now, the default behavior is always to use standard Java reflection.  This change likely simplifies the initialization logic and removes a dependency on Kotlin reflection being available.  The original constructor's Javadoc comment was also removed or significantly altered",
            "avg_logprobs": -0.3051956691099017
        }
    },
    {
        "commit_hash": "8a29bfba3f85f0500c95c78f463ba3644133eaf2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/function/DefaultEntityResponseBuilder.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (name!=null && !HttpHeaders.CONTENT_LENGTH.equals(name)) {\n+\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {\n-\t\t\t\tif (name!= null && !HttpHeaders.CONTENT_LENGTH.equals(name)) {\n+\t\t\t\tif (!HttpHeaders.CONTENT_LENGTH.equals(name)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing external contribution",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removed a redundant check for `name != null`.  The original code had an `if (name!=null && !HttpHeaders.CONTENT_LENGTH.equals(name))` which was simplified to `if (!HttpHeaders.CONTENT_LENGTH.equals(name))`.  This change removes an unnecessary condition.  The implication is that the `name` variable is only used in the context where it's guaranteed to be non-null",
            "avg_logprobs": -0.19267147189968234
        }
    },
    {
        "commit_hash": "8a7e839ad07211a2da51fa04fb33fe167ab79dc4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/function/server/DefaultRenderingResponseBuilder.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (view instanceof RedirectView) {\n-\t\t\t\tHttpStatus httpStatus = HttpStatus.resolve(rawStatusCode());\n-\t\t\t\tif (httpStatus != null && httpStatus.is3xxRedirection()) {\n-\t\t\t\t\tRedirectView redirectView = (RedirectView) view;\n-\t\t\t\t\tredirectView.setStatusCode(httpStatus);\n+\t\t\tif (view instanceof RedirectView redirectView) {\n+\t\t\t\tHttpStatusCode statusCode = statusCode();\n+\t\t\t\tif (statusCode.is3xxRedirection()) {\n+\t\t\t\t\tredirectView.setStatusCode(statusCode);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a verbose `if` statement checking for a `RedirectView` and resolving an `HttpStatus` with a more concise and type-safe approach using a local variable declaration and the `HttpStatusCode` class.  The original code cast `view` to `RedirectView` twice, and used `HttpStatus.resolve()`, which could return null",
            "avg_logprobs": -0.29156435012817383
        }
    },
    {
        "commit_hash": "8b023b17c948bb180794a23207903718404e2cca",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/ApplicationContextAwareProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tpublic Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {\n-\n+\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n-\t\tif (System.getSecurityManager() != null ) {\n+\t\tif (System.getSecurityManager() != null) {\n-\t@Override\n-\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n-\t\treturn bean;\n-\t}\n-",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": "See gh-23435\n",
        "linked_issues": [
            {
                "issue_id": "23435",
                "issue_title": "Avoid unnecessary processing in ApplicationContextAwareProcessor",
                "issue_body": "It could return bean that do not meet the requirements immediately to avoid subsequent operations",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master` in 1dc2177a4af5c6ff8622017b9a79cecba1d8c635 and polished in 8b023b17c948bb180794a23207903718404e2cca.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes the `@Override` annotation from the `postProcessAfterInitialization` method and removes an unnecessary blank line.  The most significant change is the removal of the unnecessary `@Override` annotation from the `postProcessAfterInitialization` method.  This suggests the method signature was already correctly overriding a method in a superclass.  The change also removes a blank line, which is a minor stylistic change",
            "avg_logprobs": -0.3591065979003906
        }
    },
    {
        "commit_hash": "8b3b8d070e3e177d580bd9da337ad73ebb707170",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/xml/BeansDtdResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tint dtdNameStart = systemId.indexOf(DTD_NAME);\n-\t\t\tif (dtdNameStart > lastPathSeparator) {\n+\t\t\tint dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);\n+\t\t\tif (dtdNameStart != -1) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Consistently detect spring-beans.dtd reference in last path segment",
        "commit_body": "Issue: SPR-13549\n",
        "linked_issues": [
            {
                "issue_id": "18125",
                "issue_title": "Consistently detect spring-beans.dtd reference [SPR-13549]",
                "issue_body": "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** opened **[SPR-13549](https://jira.spring.io/browse/SPR-13549?redirect=false)** and commented\n\nAs per https://github.com/spring-projects/spring-framework/commit/8e4bfa9cc17d2192e33d20023ab3b4b732087f83#commitcomment-11747566, `BeansDtdResolver` uses a sub-optimal lookup for the DTD name, potentially not detecting it if the same name occurs in a previous path segment. Consistently checking the last path segment would be more reliable.\n\n---\n\n**Affects:** 4.1.6, 4.1.7\n\n**Issue Links:**\n- #17433 There is no spring-beans.dtd file inside of the spring-beans-4.1.5.RELEASE jar\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/8b3b8d070e3e177d580bd9da337ad73ebb707170, https://github.com/spring-projects/spring-framework/commit/50c59425d98badb415f0f49cebc9cfc63a6a3f90\n\n**Backported to:** [4.1.8](https://github.com/spring-projects/spring-framework/milestone/132?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the search for the DTD name within the `systemId` string.  The original code used `systemId.indexOf(DTD_NAME)`, which started the search from the beginning of the string.  The updated code uses `systemId.indexOf(DTD_NAME, lastPathSeparator)`, starting the search *after* the last path separator",
            "avg_logprobs": -0.14433318138122558
        }
    },
    {
        "commit_hash": "8bd8c4f627216b054268f188130614e70a5f9dac",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+ * @author Sebastien Deleuze\n-\t\telse if (void.class == returnType) {\n+\t\telse if (void.class == returnType || \"kotlin.Unit\".equals(returnType.getName())) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add support for `@Async` Kotlin function returning `Unit?`",
        "commit_body": "Closes gh-31881\n",
        "linked_issues": [
            {
                "issue_id": "31881",
                "issue_title": "`@Async` does not support `Unit?` return type",
                "issue_body": "**Affects:** 6.0.13\r\n\r\n---\r\nWhen using `@Async` with Kotlin functions, it is not possible to use `Unit?`-returning functions.\r\n`kotlin.Unit` corresponds to `void` in Java (https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/), but the nullable version is not recognized when submitting the task: https://github.com/spring-projects/spring-framework/blob/main/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java#L295",
                "issue_state": "closed",
                "issue_comment": [
                    "Could you please provide a reproducer as an attached archive or a link to a repository?",
                    "While creating a reproduction, I narrowed the issue down. It actually does only occur when returning `Unit?`, I updated the original issue accordingly.\r\n[minimal reproduction](https://github.com/spring-projects/spring-framework/files/13744553/async-issue.zip)\r\n",
                    "Interesting, thanks for sharing, I will have a deeper look."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `kotlin.Unit` to the `AsyncExecutionAspectSupport` class.  Previously, only `void` return types were handled in a specific `else if` block.  The modification now includes `kotlin.Unit` in this conditional, likely to support Kotlin's `Unit` type, which is analogous to Java's `void`. This ensures proper handling of asynchronous methods returning `kotlin.Unit`",
            "avg_logprobs": -0.20629537370469836
        }
    },
    {
        "commit_hash": "8c605dd08251ca648c30aabed43d921229b7d3b1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionParserDelegate.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\telse if (namespaceUri.startsWith(\"http://www.springframework.org/\")) {\n+\t\t\telse if (namespaceUri.startsWith(\"http://www.springframework.org/schema/\")) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "BeanDefinitionParserDelegate uses http://www.springframework.org/schema/",
        "commit_body": "See gh-22839\n",
        "linked_issues": [
            {
                "issue_id": "22839",
                "issue_title": "Add Nohttp Checks",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": [
                    "> Did you have a target branch in mind for this? Looks like 5.1.x would be a good candidate.\r\n\r\n@snicoll Thanks for the comments. I was not sure where the Framework team wanted this merged. It appears that @jhoeller is ok with the general changes going into 5.1.x except for the nohttp being added to the build. I'll let him verify what his thoughts are.\r\n\r\nAs per the discussion on Slack, I pushed changes to make it so that BeanDefinitionParserDelegate now uses http://www.springframework/schema/ so it is automatically ignored by nohttp. This means there is no need for suppressions.xml at all anymore.",
                    "Indeed, the documentation changes in particular could easily go into 5.1.x.\r\nThe license URL updates in the new source files are clearly master only, as are the tool-related changes.",
                    "@snicoll @jhoeller Thanks for all the feedback. Is there anything else you need from me on this?",
                    "@rwinch a build based on that branch does not work for me. Is that to be expected?\r\n\r\n```\r\nFAILURE: Build failed with an exception.\r\n\r\n* What went wrong:\r\nExecution failed for task ':checkstyleNohttp'.\r\n> Checkstyle rule violations were found. See the report at: file:///Users/snicoll/workspace/pivotal/spring-framework/build/reports/checkstyle/nohttp.html\r\n  Checkstyle files with violations: 1024\r\n  Checkstyle violations by severity: [error:6153]\r\n```",
                    "@rwinch As Stephane suggested, can we decompose this PR a bit? Separating the nohttp tool bit from the doc changes seems worthwhile indeed. Also, it's not entirely clear to me either which example URLs we should really be using now.",
                    "FWIW, I'll make the license headers in those two new test sources consistent with the rest in a separate revision. That's really a plain oversight even aside from the nohttp tool, in contrast to the headers in the gradlew scripts which are generated... So those remaining changes are really primarily motivated by the tool, and we need to take into account that those gradlew scripts get regenerated on a Gradle upgrade.",
                    "> @rwinch a build based on that branch does not work for me. Is that to be expected?\r\n> \r\n> ```\r\n> FAILURE: Build failed with an exception.\r\n> \r\n> * What went wrong:\r\n> Execution failed for task ':checkstyleNohttp'.\r\n> > Checkstyle rule violations were found. See the report at: file:///Users/snicoll/workspace/pivotal/spring-framework/build/reports/checkstyle/nohttp.html\r\n>   Checkstyle files with violations: 1024\r\n>   Checkstyle violations by severity: [error:6153]\r\n> ```\r\n\r\nIt does not fail for me. Can you post more details (i.e. files and the failures)? Perhaps you have stale files from the build or IDE still? Did you try a fresh clone or using `git clean -dfxn` (remove the n and run again if you are fine with the files being removed).\r\n\r\n> Thanks for the PR, I've added a few comments. I must share I am bit confused as when to add https and when http is ok in example URLs. I wonder how the tool is supposed to catch that.\r\n\r\nSee https://github.com/spring-io/nohttp/tree/master/nohttp#thought-process\r\n\r\n \r\n> Also, 18 commits sounds a bit invasive for such a change. I had started to polish it to 3: one to add the plugin to the build, one to change the header to https and one with all the rest (with the note that one commit should be a separate PR IMO).\r\n> \r\n> Would you mind rebase and squash the URLs changes in one commit?\r\n\r\nNo problem. Done.",
                    "It seems there might be [differing](https://github.com/spring-projects/spring-framework/pull/22839#pullrequestreview-234351701) [opinions](https://github.com/spring-projects/spring-framework/pull/22839#issuecomment-490017215) on how to split up the commits. I updated to switch to how @snicoll suggested the commits be split up (mostly because it was the first comment I saw). If you prefer, please feel free to split up the commits in another way.",
                    "I've rebased this work but I am not keen to merge at this point:\r\n\r\n* If your working copy is using IntelliJ IDEA, the IDE puts files in a separate location (`out` in each modules). If you happen to fix this outside the IDE it may not have catch up and will fail the build\r\n* Running `./gradlew nohttp` on the command line took almost 6 minutes, that's roughly, a third of our current build time. I got confused initially as there is a separate task for checkstyle that took 20s. \r\n* I had one build failure with an OOM\r\n\r\nRunning `./gradlew nohttp` with my rebase leads to\r\n\r\n```\r\n> Task :nohttp FAILED\r\n\r\nFAILURE: Build failed with an exception.\r\n\r\n* What went wrong:\r\nExecution failed for task ':nohttp'.\r\n> Process 'command '/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home/bin/java'' finished with non-zero exit value 60\r\n\r\n* Try:\r\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\r\n\r\n* Get more help at https://help.gradle.org\r\n```\r\n\r\n@rwinch can you please have a look to it?",
                    "@snicoll The `nohttp` task isn't really intended for anything other that fixing an existing codebase. At the moment, it [doesn't use settings](https://github.com/spring-io/nohttp/issues/16) from the nohttp extension. This means that everything is included by default. To use it, [follow the examples](https://github.com/spring-io/nohttp/tree/master/nohttp-gradle#nohttp-samples) in the documentation.\r\n\r\nPlease run `checkstyleNohttp` to verify the build. For me this runs in 3 seconds and passes. Note that the plugin adds `checkstyleNohttp` to a dependency to `check` task, so you running `check` executes `checkstyleNohttp`.",
                    "Yes, I've edited my comment in the meantime. It does not run in 3s for me though. What about the `out` directories? Excluding them would also allow duplicate checks.",
                    "> Yes, I've edited my comment in the meantime. \r\n\r\nHmm...not sure I understand this. I don't [see an edit](https://github.com/spring-projects/spring-framework/pull/22839#issuecomment-501611083) since I commented?\r\n\r\n![image](https://user-images.githubusercontent.com/362503/59438344-f676f200-8db8-11e9-8f79-ad10b1c40e13.png)\r\n\r\n> It does not run in 3s for me though.\r\n\r\nHow long does it take?\r\n\r\n> What about the out directories? Excluding them would also allow duplicate checks.\r\n\r\nYou could add an exclusion on them in nohttp configuration if you want to. I'm not sure how much this is going to gain since `*.class` files are already excluded.",
                    "In my edit 5h ago, I wrote the following\r\n\r\n>  I got confused initially as there is a separate task for checkstyle that took 20s.\r\n",
                    "Ok thanks that clarifies the edit and the amount of time it is taking. I'm still wondering:\r\n\r\n> You could add an exclusion on them in nohttp configuration if you want to. I'm not sure how much this is going to gain since *.class files are already excluded.",
                    "@rwinch yeah probably my use case was odd. I hadn't rebuild your PR in my IDE so it blew up but I guess once we're good it's not really necessary. The only use case I see is someone making a mistake in an xml file, fixing it, then the build would fail again until a build is done at the IDE level. I still think excluding those directories would be better (especially as it represents a duplication)",
                    "I pushed an update to my branch that:\r\n* merges your changes for rebasing off master\r\n* excludes the out directory of each project",
                    "Running the build breaks for me as it's looking at `spring-framework/spring-websocket/bin/spring-websocket.log`. This may be an old artifact in my local repo but ignoring `.log` file looks sensible to me.",
                    "@rwinch did you test this branch against a fresh checkout or something (i.e. without building the framework first). I thought I had some outdated artifacts but it looks like the exclusions are not properly applied.\r\n\r\nHere is a gist that shows the error I currently have: https://gist.github.com/snicoll/ac6b5ba8c469bd79a22183704b5df852\r\n\r\nI am happy to revisit those and polish the PR but I'd like to first understand if I am missing something and if it's ok to exclude those resources.",
                    "The build works for me even though I have built other branches.\r\n\r\nIt seems like the failures you are getting are due to the build directory of modules that no longer exist in source control. For example, `spring-instrument-tomcat` and `spring-struts` do not exist in master. We should only exclude build directories of actual projects. You should make sure to clean that up before checking.",
                    "Sorry @rwinch I was focused on the `spring-websocket/bin` and I thought that one was legit. I should have reviewed the list more carefully.\r\n\r\nIt's now merged, I also upgraded to `0.0.3.RELEASE`. Thanks! \r\n\r\n",
                    "The updates to `whitelist.lines` somehow got lost in the merge, but I added them in 5e9a22d118778487255a1e1d87c2368f69f2e329.\r\n\r\nSo hopefully that takes care of everything for this PR.",
                    "Ooops, for some reason I had a stale version of the PR. Thanks for noticing Sam!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement in `BeanDefinitionParserDelegate`.  Previously, it checked if the `namespaceUri` started with `\"http://www.springframework.org/\"`.  The change now checks if it starts with `\"http://www.springframework.org/schema/\"`.  This likely reflects a change in the Spring XML namespaces, updating the expected prefix for schema locations",
            "avg_logprobs": -0.15812990665435792
        }
    },
    {
        "commit_hash": "8c9383da7c9ce02408c4e22eb8b6fdc07043582d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/BridgeMethodResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import org.springframework.util.Assert;\n-\t\twhile (!Object.class.equals(superclass)) {\n+\t\twhile (superclass != null && !Object.class.equals(superclass)) {\n-\t\tAssert.isTrue(bridgeMethod != null);\n-\t\tAssert.isTrue(bridgedMethod != null);",
        "change_count": 5,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "BridgeMethodResolver properly handles bridge methods in interfaces",
        "commit_body": "Issue: SPR-9330\n",
        "linked_issues": [
            {
                "issue_id": "13968",
                "issue_title": "BridgeMethodResolver throws exception when trying to find bridged method if method is declired in interface or it is abstract [SPR-9330]",
                "issue_body": "**[Dmitry Kudinov](https://jira.spring.io/secure/ViewProfile.jspa?name=dkudinov)** opened **[SPR-9330](https://jira.spring.io/browse/SPR-9330?redirect=false)** and commented\n\nIn combination of Scala Collection and Spring Security with annotations enabled BridgeMethodResolver failed to find bridged method for Scala's method \"public abstract java.lang.Object scala.collection.TraversableLike.$plus$plus(scala.collection.TraversableOnce,scala.collection.generic.CanBuildFrom)\"\n\nException thrown:\njava.lang.IllegalStateException: Failed to load ApplicationContext\nat org.springframework.test.context.TestContext.getApplicationContext(TestContext.java:308)\nat org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:109)\nat org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:75)\nat org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:321)\nat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:220)\nat org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:301)\nat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\nat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:303)\nat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:240)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\nat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)\nat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\nat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:180)\nat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\nat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\nat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'someItems' defined in class path resource [test-spring-and-scala-collection-context.xml]: Initialization of bean failed; nested exception is java.lang.IllegalArgumentException: Class must not be null\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:527)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)\nat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:580)\nat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)\nat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)\nat org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:84)\nat org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:1)\nat org.springframework.test.context.TestContext.loadApplicationContext(TestContext.java:280)\nat org.springframework.test.context.TestContext.getApplicationContext(TestContext.java:304)\n... 24 more\nCaused by: java.lang.IllegalArgumentException: Class must not be null\nat org.springframework.util.Assert.notNull(Assert.java:112)\nat org.springframework.util.ReflectionUtils.findMethod(ReflectionUtils.java:145)\nat org.springframework.core.BridgeMethodResolver.searchForMatch(BridgeMethodResolver.java:210)\nat org.springframework.core.BridgeMethodResolver.findGenericDeclaration(BridgeMethodResolver.java:148)\nat org.springframework.core.BridgeMethodResolver.isBridgeMethodFor(BridgeMethodResolver.java:135)\nat org.springframework.core.BridgeMethodResolver.searchCandidates(BridgeMethodResolver.java:103)\nat org.springframework.core.BridgeMethodResolver.findBridgedMethod(BridgeMethodResolver.java:77)\nat org.springframework.core.annotation.AnnotationUtils.getAnnotation(AnnotationUtils.java:77)\nat org.springframework.core.annotation.AnnotationUtils.findAnnotation(AnnotationUtils.java:99)\nat org.springframework.security.access.annotation.SecuredAnnotationSecurityMetadataSource.findAttributes(SecuredAnnotationSecurityMetadataSource.java:42)\nat org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource.getAttributes(AbstractFallbackMethodSecurityMetadataSource.java:47)\nat org.springframework.security.access.method.DelegatingMethodSecurityMetadataSource.getAttributes(DelegatingMethodSecurityMetadataSource.java:53)\nat org.springframework.security.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor$MethodSecurityMetadataSourcePointcut.matches(MethodSecurityMetadataSourceAdvisor.java:129)\nat org.springframework.aop.support.AopUtils.canApply(AopUtils.java:217)\nat org.springframework.aop.support.AopUtils.canApply(AopUtils.java:254)\nat org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:286)\nat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:117)\nat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:87)\nat org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:68)\nat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:359)\nat org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:322)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:407)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1426)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)\n... 36 more\n\nIn attachment there is Maven-based project with single test and all required dependencies configured.\n\nIssue in BridgeMethodResolver#findGenericDeclaration(Method bridgeMethod) method:\n...\nClass superclass = bridgeMethod.getDeclaringClass().getSuperclass();\nwhile (!Object.class.equals(superclass)) {\n...\nfor method, defined in interface, call to \"getDeclaringClass().getSuperclass()\" returns null\n\nFix can be something like\nwhile (superclass != null && !Object.class.equals(superclass)) {\n\n\n\n---\n\n**Affects:** 3.0.7\n\n**Attachments:**\n- [spring-security-scala-collection.zip](https://jira.spring.io/secure/attachment/19593/spring-security-scala-collection.zip) (_2.99 kB_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/8c9383da7c9ce02408c4e22eb8b6fdc07043582d, https://github.com/spring-projects/spring-framework/commit/1e888706d39fdc2609f0a80ffb3a7bbf833af9a3\n\n**Backported to:** [3.1.4](https://github.com/spring-projects/spring-framework/milestone/83?closed=1)\n\n1 votes, 1 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Chris Beams](https://jira.spring.io/secure/ViewProfile.jspa?name=cbeams)** commented\n\nArjen, could you take a look at this?\n",
                    "**[Arjen Poutsma](https://jira.spring.io/secure/ViewProfile.jspa?name=arjen.poutsma)** commented\n\nNot anytime soon, I'm afraid.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `Assert.isTrue` check and adds a null check for `superclass`.  Previously, the `while` loop condition only checked for `Object.class.equals(superclass)`. The updated condition now includes `superclass != null`, preventing a `NullPointerException` if `superclass` is null.  This change improves robustness by handling potential null values",
            "avg_logprobs": -0.25230845698603876
        }
    },
    {
        "commit_hash": "8cb24e0d93c9a073fc9a8b50692c90c2e19a5b43",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/concurrent/SettableListenableFuture.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tthis.completingThread = null;  // only first check actually counts\n+\t\t\tif (check) {\n+\t\t\t\tthis.completingThread = null;  // only first match actually counts\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SettableTask.checkCompletingThread() only resets marker after match",
        "commit_body": "Issue: SPR-15409\n",
        "linked_issues": [
            {
                "issue_id": "19972",
                "issue_title": "SettableListenableFuture setException is inconsistent with callbacks under race [SPR-15409]",
                "issue_body": "**[Ivan Sopov](https://jira.spring.io/secure/ViewProfile.jspa?name=isopov)** opened **[SPR-15409](https://jira.spring.io/browse/SPR-15409?redirect=false)** and commented\n\nIn continuation of #19781 and #19766 I decided to test setException method of SettableListenableFuture and received another portion of strange results.\n\nWith methods set(value) and setException(new Exception()) executed under race following cases are possible:\n- Both methods return false but SuccessCallback is executed\n- Both methods return false but FailureCallback is executed\n\nI consider these cases as two flavors of the same problem - actually I expect that one of two methods will always return true.\n\nJcstress-based tests may be found here:\nhttps://github.com/isopov/isopov-jcstress/blob/master/src/main/java/com/sopovs/moradanen/jcstress/spring/SettableListenableFuture3Test.java\n\nAlso I tried to reproduce the problem without jcstress to better understand it and make sure that it lies not in my poor understanding of jcstress:\nhttps://github.com/isopov/isopov-jcstress/blob/master/src/main/java/com/sopovs/moradanen/jcstress/spring/SettableListenableFutureMain3Test.java\nThis test does not reproduce the problem as reliably as jcstress-based one, but sometimes it still reproduces both flavors of the problem in the single run.\n\n---\n\n**Affects:** 4.3.7\n\n**Issue Links:**\n- #19766 SettableListenableFuture may be both set and canceled successfully\n- #19781 SettableListenableFuture may be successfully set with failureCallback executed and success callback ignored\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/8321f01bf808dab90186b5009caa9698565d015e, https://github.com/spring-projects/spring-framework/commit/8cb24e0d93c9a073fc9a8b50692c90c2e19a5b43\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThere was indeed a bug in `SettableTask.checkCompletingThread`: We should only reset the marker after a **successful** check, otherwise a non-successful check may invalidate it and a subsequent potentially successful check can't find the corresponding marker anymore. I've fixed that in master now and will backport it to 4.3.8.\n\nNote that your test has a race condition of its own: For a valid immediate comparison, each `success/successCallback` and `exception/failCallback` pair needs to be checked within a common monitor for the pair, otherwise they may be temporarily out of sync.\n\n```\nsynchronized (container.SUCCESS_MONITOR) {\n    if (container.result.successCallback && !container.result.success) {\n        System.out.println(\"SuccessCallback without success!\");\n    }\n}\n```\n\n```\nsynchronized (container.SUCCESS_MONITOR) {\n    // success flag and success callback flag set within the same monitor\n    container.result.success = container.future.set(\"foo\");\n}\n```\n\nand the same for the `setException` case, e.g. with a `container.FAIL_MONITOR`. Alternatively, I guess you could also batch the results and compare all of them at the very end.\n",
                    "**[Ivan Sopov](https://jira.spring.io/secure/ViewProfile.jspa?name=isopov)** commented\n\nI've build current master from sources and all my tests pass - thank you!\n\nThanks for this catch - indeed Main-based \"simple\" test reports failures even with the fix and has its own bug.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the initialization of `completingThread`.  Previously, `completingThread` was always set to `null`.  Now, it's only set to `null` if a boolean flag `check` is true.  This suggests a potential optimization where the `completingThread` is only cleared under specific conditions, likely related to a race condition or similar concurrency issue",
            "avg_logprobs": -0.26531007766723635
        }
    },
    {
        "commit_hash": "8cce40469631327e0afdd5d41393248313819270",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (returnValue == null && Void.class.equals(returnValueClass)) {\n+\t\t\treturn;\n+\t\t}\n+",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add check for ResponseEntity<void> with null return value",
        "commit_body": "Issue: SPR-12287\n",
        "linked_issues": [
            {
                "issue_id": "16892",
                "issue_title": "HttpEntity parameter 'null' in method (regression) [SPR-12287]",
                "issue_body": "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** opened **[SPR-12287](https://jira.spring.io/browse/SPR-12287?redirect=false)** and commented\n\nHi,\n\nLinux\nJava 1.8.0_20\n\nJust upgraded to Spring 4.1.1 (was using Spring 4.1.0 prior). I'm now receiving this error on a controller that is working for 4.1.0.\n\n```\njava.lang.IllegalArgumentException: HttpEntity parameter 'null' in method public java.lang.Object org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod$1.call() throws java.lang.Exception is not parameterized or has more than one parameter\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.getHttpEntityType(HttpEntityMethodProcessor.java:110) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.getReturnValueType(HttpEntityMethodProcessor.java:150) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:119) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:138) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:71) ~[spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:122) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:868) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:707) [servlet-api-3.1.jar:3.1.0]\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) [spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:790) [servlet-api-3.1.jar:3.1.0]\n\tat org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:769) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1667) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:108) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160) [spring-security-web-4.0.0.M2.jar:na]\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter.doFilterInternal(OpenEntityManagerInViewFilter.java:177) [spring-orm-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.servlets.CrossOriginFilter.handle(CrossOriginFilter.java:248) [jetty-servlets-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.servlets.CrossOriginFilter.doFilter(CrossOriginFilter.java:211) [jetty-servlets-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:101) [spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1650) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:583) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:577) [jetty-security-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1125) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515) [jetty-servlet-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1059) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:189) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:110) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.Server.handleAsync(Server.java:553) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:318) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.server.HttpChannel.run(HttpChannel.java:262) [jetty-server-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:610) [jetty-util-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:539) [jetty-util-9.2.3.v20140905.jar:9.2.3.v20140905]\n\tat java.lang.Thread.run(Thread.java:745) [na:1.8.0_20]\n```\n\nI'm going to have to revert back to 4.1.0.\n\nThank you\n\n-=david=-\n\n---\n\n**Affects:** 4.1.1\n\n**Issue Links:**\n- #19365 IllegalArgumentException: HttpEntity parameter 'null'\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/c5e360d886931f761c2be5ff4b31d5df2042d415, https://github.com/spring-projects/spring-framework/commit/8cce40469631327e0afdd5d41393248313819270, https://github.com/spring-projects/spring-framework/commit/956b66bbd466bb7a68e8499a483139a516572b24\n\n0 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis is likely a side effect of [commit a9b2a1](https://github.com/spring-projects/spring-framework/commit/a9b2a12491aa2259851b93824b7e560b3dbd1902). Is it a case of the controller returning an HttpEntity with a null body? Can you confirm the controller method signature?\n",
                    "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** commented\n\nHi Rossen,\n\nThank you for your prompt reply. The controller method signature that is being invoked is this:\n\n```\npublic Callable<ResponseEntity<Void>> post(@PathVariable final Long mId,\n                                               @PathVariable final Long vId,\n                                               @RequestBody final MOR mor,\n                                               final HttpServletRequest httpServletRequest) {\n   return () -> {\n       ...\n       ...\n       return new ResponseEntity<>(HttpStatus.OK);\n   }\n \n}\n```\n\nUnfortunately, I have a `@ControllerAdvice` enabled, which is catching the exception and returning back a JSON response (to the client) informing the client of a system error - so I'm unable to say if the method returns a null body (you could say it's not, since the ControllerAdvice is calling a MappingJackson2JsonView that is returning JSON).\n\nIf I can be of any further assistance, please do let me know.\n\n-=david=-\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOkay thanks, that should be enough to reproduce the issue.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\n[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan) I tried using the above method signature but wasn't able to reproduce the issue.\n\nPlease take a look at the sample project https://github.com/spring-projects/spring-framework-issues/tree/master/SPR-12287 I created.\n",
                    "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** commented\n\nHi Rossen,\n\nThank you for the update. I've reconfirmed on my side that this update to 4.1.1 breaks still. The POSTs still cause this exception - GETs seem to be okay. I will attempt to see if I can figure out on my side anything that may be of use. I had a look at your test app, but not had a chance to run it.\n\nFYI, this is the stack I've just seen:\n\n```\njava.lang.IllegalArgumentException: HttpEntity parameter 'null' in method public java.lang.Object org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod$1.call() throws java.lang.Exception is not parameterized or has more than one parameter\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.getHttpEntityType(HttpEntityMethodProcessor.java:110) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.getReturnValueType(HttpEntityMethodProcessor.java:150) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:119) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:138) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:71) ~[spring-web-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:122) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83) ~[spring-webmvc-4.1.1.RELEASE.jar:4.1.1.RELEASE]\n```\n\n",
                    "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** commented\n\nHi Rossen,\n\nI've done some more playing around.\n\nIf I change my type signature to simply return a String it works fine\n\n```\n@ResponseStatus(CREATED)\n@RequestMapping(value = \"/{mId}/v/{vId}/o\", method = POST, consumes = JSON, produces = JSON)\n@PreAuthorize(\"@mas.isAllowed(#mId) and  @mas.hasCrudPermission('o', 'create')\")\npublic Callable<String> post(@PathVariable final Long mId,\n                                           @PathVariable final Long vId,\n                                           @RequestBody final MOR mor,\n                                           final HttpServletRequest httpServletRequest) {\n```\n\nYou know, you're probably going to shoot me! but it would have been very helpful to you if I included the annotations in my reply to your request for an example above. Perhapt it may help. One thing I'm doing is that I have an advice being actioned:\n\n```\norg.springframework.web.servlet.mvc.method.annotation.JsonViewResponseBodyAdvice\n```\n\nSo, it appears that any composite object (i.e., Callable<ResponseEntity\\<Void>>) is always throwing an exception for me as above, whereas simple return types, such as Callable\\<Employee> works successfully.\n\nI hope that helps a bit more.\n\n-=david=-\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nNever mind, I got it reproduced. Thanks.\n",
                    "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** commented\n\nReally!\n\nThat's amazing. I've just cloned the #16892 repo, added in jackson and the JSON view resolver, and was trying to get it to fail like on my application - couldn't do it - I was about to break down in tears :-) :-)\n\nWhat's the issue? Totally curious! :-)\n\n-=david=-\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI pushed the changes I made. The key part is actually using 4.1.1 :)\n\nThe issue is related to the use of Callable<ResponseEntity<?>> where the ResponseEntity has no body. It has trouble extracting the parameterized type from the method signature in this specific scenario. Previously it worked because we didn't try to go any further if the body was null. #16766 in 4.1.1 changed that. Hence the issue.\n",
                    "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** commented\n\nw00t!\n\nI look forward to Spring 4.1.2! :-)\n\n-=david=-\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should be fixed now with [commit 956b66](https://github.com/spring-projects/spring-framework/commit/956b66bbd466bb7a68e8499a483139a516572b24). If you can please give it a try with 4.1.2.BUILD-SNAPSHOT after this build is completed https://build.spring.io/browse/SPR-PUB-1781.\n",
                    "**[David Harrigan](https://jira.spring.io/secure/ViewProfile.jspa?name=dharrigan)** commented\n\nHi,\n\nTested with 4.1.2.BUILD-SNAPSHOT and I'm happy to report that the error, as reported, is not happening anymore :-)\n\nThanks Rossen!\n\n-=david=-\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nGreat, thanks for verifying!\n",
                    "**[Marcel Overdijk](https://jira.spring.io/secure/ViewProfile.jspa?name=marceloverdijk)** commented\n\nI'm seeing a similar issue in 4.1.1. I tested today with 4.1.2.BUILD-SNAPSHOT but still get the problem.\n\nThe case I have is I have a custom ResponseEntityExceptionHandler like:\n\n```\n@ControllerAdvice\npublic class CustomResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    @ResponseBody\n    public ResponseEntity handleResourceNotFoundException(ResourceNotFoundException e) {\n        return ResponseEntity.notFound().build();\n    }\n}\n```\n\nI'm using Spring's Test MvcMock framework to test but in case I the ResourceNotFoundException is thrown from my controller I get the same exception:\n\n```\n2014-10-16 23:02:11.748 ERROR 11136 --- [           main] .m.m.a.ExceptionHandlerExceptionResolver : Failed to invoke @ExceptionHandler method: public org.springframework.http.ResponseEntity org.mycomp.web.exception.CustomResponseEntityExceptionHandler.handleResourceNotFoundException(org.mycomp.web.exception.ResourceNotFoundException)\n\njava.lang.IllegalArgumentException: HttpEntity parameter 'null' in method public org.springframework.http.ResponseEntity org.mycomp.web.exception.CustomResponseEntityExceptionHandler.handleResourceNotFoundException(org.mycomp.web.exception.ResourceNotFoundException) is not parameterized or has more than one parameter\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.getHttpEntityType(HttpEntityMethodProcessor.java:110)\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.getReturnValueType(HttpEntityMethodProcessor.java:150)\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:119)\n\tat org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:138)\n\tat org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:71)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:128)\n\tat org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:362)\n\tat org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:60)\n\tat org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:138)\n\tat org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:75)\n\tat org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1167)\n\tat org.springframework.test.web.servlet.TestDispatcherServlet.processHandlerException(TestDispatcherServlet.java:109)\n\tat org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1004)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:955)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:620)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)\n\tat org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:62)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:727)\n\tat org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:170)\n\tat org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:137)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:110)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:57)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n\tat org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:137)\n\tat org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:145)\n\tat org.springframework.test.web.servlet.MockMvc$perform.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n\tat org.mycomp.web.controller.BookControllerTests.get_should_return_not_found_when_vat_rate_does_not_exists(BookControllerTests.groovy:149)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:483)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:72)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:81)\n\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:216)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:82)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:60)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:67)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:162)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:160)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:483)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)\n\n2014-10-16 23:02:11.767  INFO 11136 --- [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction for test context [DefaultTestContext@5fb7b227 testClass = BookControllerTests, testInstance = org.mycomp.web.controller.BookControllerTests@6eb58fdd, testMethod = get_should_return_not_found_when_vat_rate_does_not_exists@BookControllerTests, testException = org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.mycomp.web.exception.ResourceNotFoundException, mergedContextConfiguration = [WebMergedContextConfiguration@12aa9370 testClass = BookControllerTests, locations = '{}', classes = '{class org.mycomp.Application}', contextInitializerClasses = '[]', activeProfiles = '{test}', propertySourceLocations = '{}', propertySourceProperties = '{}', resourceBasePath = 'src/main/webapp', contextLoader = 'org.springframework.boot.test.SpringApplicationContextLoader', parent = [null]]].\n\norg.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.mycomp.web.exception.ResourceNotFoundException\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:978)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:620)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)\n\tat org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:62)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:727)\n\tat org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:170)\n\tat org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:137)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:201)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:110)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:57)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)\n\tat org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:137)\n\tat org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:145)\n\tat org.springframework.test.web.servlet.MockMvc$perform.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)\n\tat org.mycomp.web.controller.BookControllerTests.get_should_return_not_found_when_vat_rate_does_not_exists(BookControllerTests.groovy:149)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:72)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:81)\n\tat org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:216)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:82)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:60)\n\tat org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:67)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:162)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:160)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)\nCaused by: org.mycomp.web.exception.ResourceNotFoundException\n\tat org.mycomp.web.controller.BookController.get(BookController.java:67)\n\tat org.mycomp.web.controller.BookController$$FastClassBySpringCGLIB$$726a7f3d.invoke(<generated>)\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:717)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:266)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:653)\n\tat org.mycomp.web.controller.BookController$$EnhancerBySpringCGLIB$$585dbc5d.get(<generated>)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)\n\t... 75 more\n```\n\nShould I create a separate issue for this?\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nNo it's fine to keep it under this report. It looks like in this example the ResponseEntity is declared as a raw type without a generic parameter.\n",
                    "**[Marcel Overdijk](https://jira.spring.io/secure/ViewProfile.jspa?name=marceloverdijk)** commented\n\nYes that's indeed the case:\n\n```\n@RequestMapping(value = \"/{id}\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n@Transactional(readOnly = true)\npublic ResponseEntity get(@PathVariable(\"id\") Long id) {\n    // get resource\n    return ResponseEntity.ok().body(resource);\n}\n```\n\nNote that I do this on purpose to be able to return different objects based on what happens in the controller.\nI also want to avoid to use something like ResponseEntity\\<Object> to avoid bloating my code.\n\nI assume using a raw ResponseEntity type should be supported, right?\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should be fixed now with [commit c5e360](https://github.com/spring-projects/spring-framework/commit/c5e360d886931f761c2be5ff4b31d5df2042d415).\n",
                    "**[Marcel Overdijk](https://jira.spring.io/secure/ViewProfile.jspa?name=marceloverdijk)** commented\n\nThx Rossen, I can confirm this is now fixed with 4.1.2.BUILD-20141017.172150-32\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThanks for confirming!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check for `null` return value and `Void` return type.  If both conditions are true, the method now returns early (without further processing).  This likely avoids an exception or unnecessary processing when a method is declared to return `void`",
            "avg_logprobs": -0.16558042006059126
        }
    },
    {
        "commit_hash": "8cced42fb2cdbe1d0864ca6c576d81d4cb8dcb49",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jcl/src/main/java/org/apache/commons/logging/LogAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tthis.logger = loggerContext.getLogger(name);\n+\t\t\tLoggerContext context = loggerContext;\n+\t\t\tif (context == null) {\n+\t\t\t\t// Circular call in early-init scenario -> static field not initialized yet\n+\t\t\t\tcontext = LogManager.getContext(Log4jLog.class.getClassLoader(), false);\n+\t\t\t}\n+\t\t\tthis.logger = context.getLogger(name);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use local LoggerContext in Log4jLog when static field not initialized yet",
        "commit_body": "Closes gh-24440\n",
        "linked_issues": [
            {
                "issue_id": "24440",
                "issue_title": "Cycle in LogAdapter.Log4jLog initialization within log appender",
                "issue_body": "**Affects:**  5.2.x\r\n\r\nThe Spring implementation of commons-logging has the following logic within the `LogAdapter` for Log4j2...\r\n\r\n```\r\n\t\tprivate static final LoggerContext loggerContext =\r\n\t\t\t\tLogManager.getContext(Log4jLog.class.getClassLoader(), false);\r\n\r\n...\r\n\r\n\t\tpublic Log4jLog(String name) {\r\n\t\t\tthis.logger = loggerContext.getLogger(name);\r\n\t\t}\r\n```\r\n\r\nIf a custom appender depends on a class that has a static logger defined, we get an NPE on the `loggerContext` because the constructor is called before the static field is initialized.\r\n\r\nFor the full context of the issue, see https://github.com/spring-projects/spring-amqp-samples/issues/59 and https://github.com/spring-projects/spring-amqp/issues/1148. The work-around was to defer initialization of the classes with the static loggers until the log system is initialized.\r\n\r\nThis may be an unsolvable catch-22 but I thought I should at least raise the issue in case the Spring Team has ideas. This was not an issue with Boot 1.5/Spring 4.3.\r\n\r\nHere is a simple example that exhibits the behavior:\r\n\r\n```java\r\n@SpringBootApplication\r\npublic class Rgh1148Application {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(Rgh1148Application.class, args);\r\n\t}\r\n\r\n}\r\n\r\n@Plugin(name = \"Test\", category = \"Core\", elementType = \"appender\", printObject = true)\r\npublic class MyAppender extends AbstractAppender {\r\n\r\n\tprivate final SomeClass someClass = new SomeClass();\r\n\r\n\tpublic MyAppender(String name, Filter filter, Layout<? extends Serializable> layout, boolean ignoreExceptions,\r\n\t\t\tProperty[] properties) {\r\n\t\tsuper(name, filter, layout, ignoreExceptions, properties);\r\n\t}\r\n\r\n\t@PluginFactory\r\n\tpublic static MyAppender create(\r\n\t\t\t@PluginConfiguration final Configuration configuration,\r\n\t\t\t@PluginAttribute(\"name\") String name,\r\n\t\t\t@PluginElement(\"Layout\") Layout<? extends Serializable> layout,\r\n\t\t\t@PluginElement(\"Filter\") Filter filter,\r\n\t\t\t@PluginAttribute(\"ignoreExceptions\") boolean ignoreExceptions) {\r\n\t\treturn new MyAppender(name, filter, layout, ignoreExceptions, null);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void append(LogEvent event) {\r\n\t\tthis.someClass.foo(event);\r\n\t}\r\n\r\n}\r\n\r\nclass SomeClass {\r\n\r\n\tprivate static final Log logger = LogFactory.getLog(SomeClass.class);\r\n\r\n\tpublic void foo(LogEvent event) {\r\n\t\tlogger.info(event);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Configuration packages=\"com.example.demo\">\r\n\t<Appenders>\r\n\t\t<Console name=\"STDOUT\" target=\"SYSTEM_OUT\">\r\n\t\t\t<PatternLayout pattern=\"%m%n\" />\r\n\t\t</Console>\r\n\t\t<Test name=\"myAppender\">\r\n\t\t</Test>\r\n\t</Appenders>\r\n\t<Loggers>\r\n\t\t<Root>\r\n\t\t\t<AppenderRef ref=\"STDOUT, myAppender\" />\r\n\t\t</Root>\r\n\t</Loggers>\r\n</Configuration>\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n\t<modelVersion>4.0.0</modelVersion>\r\n\t<parent>\r\n\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\r\n\t\t<version>2.2.4.RELEASE</version>\r\n\t\t<relativePath/> <!-- lookup parent from repository -->\r\n\t</parent>\r\n\t<groupId>com.example</groupId>\r\n\t<artifactId>rgh1148</artifactId>\r\n\t<version>0.0.1-SNAPSHOT</version>\r\n\t<name>rgh1148</name>\r\n\t<description>Demo project for Spring Boot</description>\r\n\r\n\t<properties>\r\n\t\t<java.version>1.8</java.version>\r\n\t</properties>\r\n\r\n\t<dependencies>\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t\t<artifactId>spring-boot-starter</artifactId>\r\n\t\t\t<exclusions>\r\n\t\t\t\t<exclusion>\r\n\t\t\t\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t\t\t\t<artifactId>spring-boot-starter-logging</artifactId>\r\n\t\t\t\t</exclusion>\r\n\t\t\t</exclusions>\r\n\t\t</dependency>\r\n\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t\t<artifactId>spring-boot-starter-log4j2</artifactId>\r\n\t\t</dependency>\r\n\r\n\t\t<dependency>\r\n\t\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\r\n\t\t\t<scope>test</scope>\r\n\t\t\t<exclusions>\r\n\t\t\t\t<exclusion>\r\n\t\t\t\t\t<groupId>org.junit.vintage</groupId>\r\n\t\t\t\t\t<artifactId>junit-vintage-engine</artifactId>\r\n\t\t\t\t</exclusion>\r\n\t\t\t</exclusions>\r\n\t\t</dependency>\r\n\t</dependencies>\r\n\r\n\t<build>\r\n\t\t<plugins>\r\n\t\t\t<plugin>\r\n\t\t\t\t<groupId>org.springframework.boot</groupId>\r\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\r\n\t\t\t</plugin>\r\n\t\t</plugins>\r\n\t</build>\r\n\r\n</project>\r\n```\r\n\r\n```\r\n2020-01-27 15:02:40,570 main ERROR Unable to invoke factory method in class com.example.demo.MyAppender for element Test: java.lang.ExceptionInInitializerError java.lang.reflect.InvocationTargetException\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:136)\r\n\tat org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:1002)\r\n\tat org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:942)\r\n\tat org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:934)\r\n\tat org.apache.logging.log4j.core.config.AbstractConfiguration.doConfigure(AbstractConfiguration.java:552)\r\n\tat org.apache.logging.log4j.core.config.AbstractConfiguration.initialize(AbstractConfiguration.java:241)\r\n\tat org.apache.logging.log4j.core.config.AbstractConfiguration.start(AbstractConfiguration.java:288)\r\n\tat org.apache.logging.log4j.core.LoggerContext.setConfiguration(LoggerContext.java:579)\r\n\tat org.apache.logging.log4j.core.LoggerContext.reconfigure(LoggerContext.java:651)\r\n\tat org.apache.logging.log4j.core.LoggerContext.reconfigure(LoggerContext.java:668)\r\n\tat org.apache.logging.log4j.core.LoggerContext.start(LoggerContext.java:253)\r\n\tat org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:153)\r\n\tat org.apache.logging.log4j.core.impl.Log4jContextFactory.getContext(Log4jContextFactory.java:45)\r\n\tat org.apache.logging.log4j.LogManager.getContext(LogManager.java:194)\r\n\tat org.apache.commons.logging.LogAdapter$Log4jLog.<clinit>(LogAdapter.java:155) <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\r\n\tat org.apache.commons.logging.LogAdapter$Log4jAdapter.createLog(LogAdapter.java:122)\r\n\tat org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:89)\r\n\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67)\r\n\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59)\r\n\tat org.springframework.boot.SpringApplication.<clinit>(SpringApplication.java:196)\r\n\tat com.example.demo.Rgh1148Application.main(Rgh1148Application.java:10)\r\nCaused by: java.lang.ExceptionInInitializerError\r\n\tat com.example.demo.MyAppender.<init>(MyAppender.java:38)\r\n\tat com.example.demo.MyAppender.create(MyAppender.java:52)\r\n\t... 25 more\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.commons.logging.LogAdapter$Log4jLog.<init>(LogAdapter.java:160) . <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\r\n\tat org.apache.commons.logging.LogAdapter$Log4jAdapter.createLog(LogAdapter.java:122)\r\n\tat org.apache.commons.logging.LogAdapter.createLog(LogAdapter.java:89)\r\n\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:67)\r\n\tat org.apache.commons.logging.LogFactory.getLog(LogFactory.java:59)\r\n\tat com.example.demo.SomeClass.<clinit>(MyAppender.java:64)\r\n\t... 27 more\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "Since Log4J seems to be internally capable of retrieving the `LoggerContext` even in circular scenarios, we could simply move the `LogManager.getContext` to the constructor as well - so that it is being reliably called before our `LoggerContext.getLogger` invocation. In order to retain our current context caching, we could also have a mixed scenario where we're lazily initializing the context in a volatile field.",
                    "With even less impact, it seems we can keep initializing our static field and simply let the constructor perform a local `LogManager.getContext` call if the field happens to be not initialized yet."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a null check for `loggerContext` before using it to retrieve a logger.  If `loggerContext` is null, it now creates a `LoggerContext` using `LogManager.getContext` with the class loader of `Log4jLog.class` and `false` for the `createIfNeeded` parameter.  This addresses a potential circular dependency issue during early initialization where the static `loggerContext` field might not be initialized yet",
            "avg_logprobs": -0.18459619522094728
        }
    },
    {
        "commit_hash": "8d17bcea5b06979cca48c9e3cd75420a75b7f267",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/sockjs/support/AbstractSockJsService.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\tif (\"websocket\".equalsIgnoreCase(request.getHeaders().getUpgrade())) {\n+\t\t\t\t\tresponse.setStatusCode(HttpStatus.BAD_REQUEST);\n+\t\t\t\t\treturn;\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Validate top-level SockJS URL",
        "commit_body": "Closes gh-26933\n",
        "linked_issues": [
            {
                "issue_id": "26933",
                "issue_title": "Exception in Tomcat when SockJS top URL is a WebSocket upgrade",
                "issue_body": "# Creating simple websocke/sompt server  \r\nSpring fails to parse HTTP request header, although it sends 200 response to the client and close the connection immediately.\r\n\r\n# How to reproduce\r\n\r\nDownload sample code from official [guides](https://spring.io/guides/gs/messaging-stomp-websocket/), then set log level to debug `logging.level.root=debug` on **application.properties**.\r\nRun the server, and try connecting with simple JS client code.\r\n\r\n**JS client**\r\n```const WebSocket = require('ws');\r\n\r\n\r\nconst ws = new WebSocket('ws://dev.contabo:8080/gs-guide-websocket')\r\nws.on('open', () => {\r\n  console.log(\"connection opened\");\r\n})\r\n\r\nws.on('message', () => {\r\n  console.log('message recieved');\r\n})\r\n\r\nws.on('close', () => {\r\n  console.log('connection closed');\r\n})\r\n\r\nws.on('error', (item) => {\r\n  console.log(item)\r\n})\r\n```\r\n\r\nIt gives the following error on the log:\r\n\r\n```\r\n2021-05-11 16:07:12.682 DEBUG 12588 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : GET \"/chatspace\", parameters={}\r\n2021-05-11 16:07:12.687 DEBUG 12588 --- [nio-8080-exec-1] o.s.w.s.s.s.WebSocketHandlerMapping      : Mapped to org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler@4a68cc76\r\n2021-05-11 16:07:12.693 DEBUG 12588 --- [nio-8080-exec-1] o.s.w.s.s.t.h.DefaultSockJsService       : Processing transport request: GET http://localhost:8080/chatspace\r\n2021-05-11 16:07:12.696 DEBUG 12588 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK\r\n2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] o.a.coyote.http11.Http11InputBuffer      : Before fill(): parsingHeader: [true], parsingRequestLine: [true], parsingRequestLinePhase: [0], parsingRequestLineStart: [0], byteBuffer.position(): [0], byteBuffer.limit(): [0], end: [232]\r\n2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] o.a.tomcat.util.net.SocketWrapperBase    : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Read from buffer: [0]\r\n2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] org.apache.tomcat.util.net.NioEndpoint   : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Read direct from socket: [0]\r\n2021-05-11 16:07:12.701 DEBUG 12588 --- [nio-8080-exec-1] o.a.coyote.http11.Http11InputBuffer      : Received []\r\n2021-05-11 16:07:12.702 DEBUG 12588 --- [nio-8080-exec-1] o.apache.coyote.http11.Http11Processor   : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Status in: [OPEN_READ], State out: [OPEN]\r\n2021-05-11 16:07:12.702 DEBUG 12588 --- [nio-8080-exec-1] org.apache.tomcat.util.net.NioEndpoint   : Registered read interest for [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]]\r\n2021-05-11 16:07:12.707 DEBUG 12588 --- [nio-8080-exec-2] o.a.coyote.http11.Http11InputBuffer      : Before fill(): parsingHeader: [true], parsingRequestLine: [true], parsingRequestLinePhase: [0], parsingRequestLineStart: [0], byteBuffer.position(): [0], byteBuffer.limit(): [0], end: [232]\r\n2021-05-11 16:07:12.707 DEBUG 12588 --- [nio-8080-exec-2] o.a.tomcat.util.net.SocketWrapperBase    : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Read from buffer: [0]\r\n2021-05-11 16:07:12.707 DEBUG 12588 --- [nio-8080-exec-2] o.apache.coyote.http11.Http11Processor   : Error parsing HTTP request header\r\n\r\njava.io.EOFException: null\r\n\tat org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.fillReadBuffer(NioEndpoint.java:1345) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1255) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:794) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:359) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:261) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na]\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]\r\n\r\n2021-05-11 16:07:12.708 DEBUG 12588 --- [nio-8080-exec-2] o.apache.coyote.http11.Http11Processor   : Error state [CLOSE_CONNECTION_NOW] reported while processing request\r\n\r\njava.io.EOFException: null\r\n\tat org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.fillReadBuffer(NioEndpoint.java:1345) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.read(NioEndpoint.java:1255) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.http11.Http11InputBuffer.fill(Http11InputBuffer.java:794) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:359) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:261) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) ~[na:na]\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) ~[na:na]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.45.jar:9.0.45]\r\n\tat java.base/java.lang.Thread.run(Thread.java:832) ~[na:na]\r\n\r\n2021-05-11 16:07:12.708 DEBUG 12588 --- [nio-8080-exec-2] o.apache.coyote.http11.Http11Processor   : Socket: [org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]], Status in: [OPEN_READ], State out: [CLOSED]\r\n2021-05-11 16:07:12.709 DEBUG 12588 --- [nio-8080-exec-2] o.apache.tomcat.util.threads.LimitLatch  : Counting down[http-nio-8080-exec-2] latch=1\r\n2021-05-11 16:07:12.709 DEBUG 12588 --- [nio-8080-exec-2] org.apache.tomcat.util.net.NioEndpoint   : Calling [org.apache.tomcat.util.net.NioEndpoint@2a267286].closeSocket([org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper@56fe2702:org.apache.tomcat.util.net.NioChannel@54ea376e:java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:50988]])\r\n2021-05-11 16:07:24.104 DEBUG 12588 --- [)-192.168.1.109] sun.rmi.transport.tcp                    : RMI TCP Connection(8)-192.168.1.109: (port 42343) connection closed\r\n\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "At the top URL, we respond with a 200 \"Welcome to SocketJS\" as required by the SockJS protocol. However, given the request is a WebSocket upgrade (rather than a regular HTTP GET), Tomcat seems to run into an exception. This is outside our control and we do not request for a WebSocket upgrade to be started, and in any case the upgrade doesn't succeed with a 200 response.\r\n\r\nThat said, given the possibility for confusion when experimenting and pointing to the top URL, we can set the response to 400 in this scenario which also seems to cause Tomcat to not run into the same exception.\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check to see if the request header `Upgrade` is \"websocket\".  If it is, a `BAD_REQUEST` status is set on the response, and the method immediately returns.  This effectively prevents websocket connections if the request isn\\'t explicitly requesting that protocol",
            "avg_logprobs": -0.16736318270365397
        }
    },
    {
        "commit_hash": "8eb618b480896092cae04d1c5e412f7a5dba0c9c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CoroutinesUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import kotlin.reflect.jvm.KCallablesJvm;\n+\t\tif (method.isAccessible() && !KCallablesJvm.isAccessible(function)) {\n+\t\t\tKCallablesJvm.setAccessible(function, true);\n+\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Make Kotlin functions accessible in CoroutinesUtils",
        "commit_body": "In order to allow using private classes like in Java\nfor example.\n\nCloses gh-23840\n",
        "linked_issues": [
            {
                "issue_id": "23840",
                "issue_title": "Make Kotlin functions accessible in CoroutinesUtils",
                "issue_body": "After updating to spring-webflux 5.2 i noticed that `@ExceptionHandler`'s in private Kotlin-Classes stopped working. \r\nAfter debbuging I found that this regression was introduced with kotlin-coroutines support for reactive Webflux and reactive Messaging handlers. \r\n\r\nThe Problem is that when converting Java methods to Kotlin functions the information if a method is accessible or not will not be copied and the Kotlin function has to be made accessible again via its `isAccessible` setter.\r\n\r\nFor this I introduced a new very simple `KotlinReflectionUtils` class which both `InvocableHandlerMethod's` use when Kotlin is available. I'm not 100% sure if this is the best solution and if its worth to introduce a new utils class for this. \r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "I'm wondering if these classes need to remain private, i.e. is this something we want to work?",
                    "> I'm wondering if these classes need to remain private, i.e. is this something we want to work?\r\n\r\n@rstoyanchev If you mean classe like `CoroutinesController` in the PR and if that works on Java, I would say yes.\r\n\r\nThat said, we can't modify `org.springframework.core.CoroutinesUtils#invokeSuspendingFunction` signature to use `KFunction` instead of `Method`, and `CoroutinesUtils` is now a Java class. So I think I would suggest to modify:\r\n\r\n```\r\npublic static Publisher<?> invokeSuspendingFunction(Method method, Object target, Object... args) {\r\n\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\r\n\t// ...\r\n}\r\n```\r\nTo\r\n```\r\npublic static Publisher<?> invokeSuspendingFunction(Method method, Object target, Object... args) {\r\n\tKFunction<?> function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method));\r\n\tif (method.isAccessible() && !kotlin.reflect.jvm.KCallablesJvm.isAccessible(function)) {\r\n\t\tkotlin.reflect.jvm.KCallablesJvm.setAccessible(function, true);\r\n\t}\r\n\t// ...\r\n}\r\n```\r\nThis will impact other `invokeSuspendingFunction` invocations as well (not just those from `InvocableHandlerMethod`), but implemented like that I tend to think that's ok.\r\n\r\n@rstoyanchev Do you agree? Is it ok to target 5.3.x for that fix?",
                    "We probably need to do the same thing on [`BeanUtils#instantiateClass`](https://github.com/spring-projects/spring-framework/blob/ec9ce5b4b0f948e510e5d958b5bcb60dc84476b3/spring-beans/src/main/java/org/springframework/beans/BeanUtils.java#L195) and try to detect similar other patterns by a search on `ReflectionUtils#makeAccessible` usage where `kotlin-reflect` is involved.",
                    "@sdeleuze I agree, as far as the changes to `CoroutinesUtils#invokeSuspendingFunction`.",
                    "I applied the discussed changes via 8eb618b480896092cae04d1c5e412f7a5dba0c9c on `5.3.x` and merged them to `main`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure both a Java method (`method`) and a Kotlin function (`function`) are accessible.  If the Java method is accessible but the Kotlin function isn't, the Kotlin function's accessibility is set to `true`. This likely addresses a potential issue where the Kotlin function's accessibility was preventing proper invocation, while the Java method was accessible",
            "avg_logprobs": -0.2274927907175832
        }
    },
    {
        "commit_hash": "8f0f5faf4d541df10db9b38e670bed83a1990b98",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/config/MessageBrokerBeanDefinitionParser.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tname = SCHEDULER_BEAN_NAME;\n-\t\tif (context.getRegistry().containsBeanDefinition(name)) {\n-\t\t\tbeanDef.getPropertyValues().add(\"sockJsTaskScheduler\", context.getRegistry().getBeanDefinition(name));\n-\t\t}\n+\t\tObject scheduler = WebSocketNamespaceUtils.registerScheduler(SCHEDULER_BEAN_NAME, context, source);\n+\t\tbeanDef.getPropertyValues().add(\"sockJsTaskScheduler\", scheduler);\n+",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "XML config properly initialize WS message broker stats",
        "commit_body": "Issue: SPR-14190\n",
        "linked_issues": [
            {
                "issue_id": "18763",
                "issue_title": "WebSocketMessageBrokerStats does not work unless SockJS is enabled with WebSocket XML namespace [SPR-14190]",
                "issue_body": "**[Joe Sweden](https://jira.spring.io/secure/ViewProfile.jspa?name=mandudeboy)** opened **[SPR-14190](https://jira.spring.io/browse/SPR-14190?redirect=false)** and commented\n\nIn the Spring reference documentation for Websockets it states:\n\nWhen using `@EnableWebSocketMessageBroker` or <websocket:message-broker> key infrastructure components automatically gather stats and counters that provide important insight into the internal state of the application. The configuration also declares a bean of type WebSocketMessageBrokerStats that gathers all available information in one place and **by default logs it at INFO level once every 30 minutes.**\n\nwe are using a <websocket:message-broker> but the INFO log is never performed. This was unexpected after reading the above documentation, but was fixed by adding sockJS. It probably should be clarified that this logging is actually ONLY performed if you have configured sockJS. The SockJS Task Scheduler is used to to the logging, and if the <websocket:sockjs/> tag is not in the websocket context file, this Scheduler is null. I don't know if this is unintended in the code or not, but at least the documentation should be clearer on this point.\n\n\n---\n\n**Affects:** 4.2.5, 4.3 RC1\n\n**Reference URL:** http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-stats\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9fa061431c0b16f933071997f0b57705966fbc25, https://github.com/spring-projects/spring-framework/commit/8f0f5faf4d541df10db9b38e670bed83a1990b98\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI'm changing this to a bug. It just happens that SockJS registers the TaskScheduler that the WebSocketMessageBrokerStats needs. However this should work regardless of whether SockJS is enabled or not. That's the way it works in the WebSocket Java config.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a direct bean lookup with a call to `WebSocketNamespaceUtils.registerScheduler`.  The original code checked if a bean with the name `SCHEDULER_BEAN_NAME` already existed and, if so, injected it into the `sockJsTaskScheduler` property.  The new code delegates the registration and retrieval of the scheduler to `WebSocketNamespaceUtils`, potentially handling more complex scenarios or external dependencies.  This change likely improves code modularity and reduces code duplication",
            "avg_logprobs": -0.19491964456986408
        }
    },
    {
        "commit_hash": "90268de9c0548a14893aa1c386f4de6e957e0948",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionReaderUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tString id = generatedBeanName;\n-\t\t\tid = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);\n+\t\t\treturn generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);\n-\t\telse {\n-\t\t\t// Top-level bean: use plain class name with unique suffix if necessary.\n-\t\t\treturn uniqueBeanName(generatedBeanName, registry);\n-\t\t}\n-\t\treturn id;\n+\n+\t\t// Top-level bean: use plain class name with unique suffix if necessary.\n+\t\treturn uniqueBeanName(generatedBeanName, registry);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish implementation of BeanDefinitionReaderUtils.generateBeanName()",
        "commit_body": "Closes gh-24739\n",
        "linked_issues": [
            {
                "issue_id": "24739",
                "issue_title": "Polish implementation of BeanDefinitionReaderUtils.generateBeanName()",
                "issue_body": "This is an invalid 'if'\r\n\r\n`BeanDefinitionReaderUtils.generateBeanName`\r\n\r\n```java\r\n\t\tString id = generatedBeanName;\r\n\t\tif (isInnerBean) {\r\n\t\t\t// Inner bean: generate identity hashcode suffix.\r\n\t\t\tid = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Top-level bean: use plain class name with unique suffix if necessary.\r\n\t\t\treturn uniqueBeanName(generatedBeanName, registry);\r\n\t\t}\r\n\t\treturn id;\r\n```\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Although the code in question is implemented slightly unusually, there is nothing invalid about the if-block technically speaking. \r\n\r\nHaving said that, I'll take this opportunity to improve the readability of that code.\r\n\r\nSo thanks for bringing this to our attention."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes a conditional statement (if/else) and a redundant variable assignment.  The original code assigned a value to `id` conditionally, then returned `id` or a result of a different function.  The updated code directly returns the result of the conditional logic, eliminating the unnecessary variable and the conditional block.  This change simplifies the code by directly returning the appropriate bean name based on the condition, without an intermediate variable",
            "avg_logprobs": -0.3937940979003906
        }
    },
    {
        "commit_hash": "90388e4701add18ec060e6b2fb219f54c9474429",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/support/CollectionToObjectConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (sourceCollection.size() == 0) {\n+\t\tif (sourceCollection.isEmpty()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Replace size() check with isEmpty()",
        "commit_body": "Closes gh-1333\n",
        "linked_issues": [
            {
                "issue_id": "1333",
                "issue_title": "CollectionToObjectConverter - Refactor with Collection#isEmpty()",
                "issue_body": "Replace `sourceCollection.size() == 0` by `sourceCollection.isEmpty()` in class `CollectionToObjectConverter`.",
                "issue_state": "closed",
                "issue_comment": [
                    "Merged, thanks."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `sourceCollection.size() == 0` with `sourceCollection.isEmpty()`.  This is a stylistic change, likely for conciseness and readability.  `isEmpty()` is generally preferred as it's more semantically clear.  No functional change is introduced",
            "avg_logprobs": -0.1481955687204997
        }
    },
    {
        "commit_hash": "90477b40a4b92c357184cc182f546ce742b1ffa1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\tprivate final List<Charset> availableCharsets;\n+\tprivate volatile List<Charset> availableCharsets;\n-\t\tthis.availableCharsets = new ArrayList<>(Charset.availableCharsets().values());\n+\t\tif (this.availableCharsets == null) {\n+\t\t\tthis.availableCharsets = new ArrayList<>(\n+\t\t\t\t\tCharset.availableCharsets().values());\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defer Charset.availableCharsets() call",
        "commit_body": "Change the `StringHttpMessageConverter` to defer calling\nCharset.availableCharsets() until absolutely necessary to help improve\nstartup times.\n\nIssue: SPR-15502\n",
        "linked_issues": [
            {
                "issue_id": "20061",
                "issue_title": "Defer StringHttpMessageConverter Charset.availableCharsets() call [SPR-15502]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-15502](https://jira.spring.io/browse/SPR-15502?redirect=false)** and commented\n\nThe `StringHttpMessageConverter` calls `Charset.availableCharsets()` which can be quite an expensive thing to do on startup. Switching it to obtain it on the first call may help improve startup times a little.\n\n\n---\n\n**Affects:** 4.3.8\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/90477b40a4b92c357184cc182f546ce742b1ffa1, https://github.com/spring-projects/spring-framework/commit/ee40310c926f3ce1a51f28b20ede096995a667f2\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nSomething like this: https://github.com/philwebb/spring-framework/commit/29594a7d2cf6ff7bc59f9886b5a59188ede0fb3c\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `StringHttpMessageConverter` class to use a `volatile` field for the `availableCharsets` list.  Previously, the list was initialized directly in the constructor.  The new code initializes the list only if it's `null`, ensuring it's only created once, likely to improve thread safety. This is a crucial change for multi-threaded environments where multiple threads might access and modify the `availableCharsets` list concurrently",
            "avg_logprobs": -0.2581598220332976
        }
    },
    {
        "commit_hash": "9064d38e4c77addbb5682e28e8c04df9fc8cd652",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t// Let the bean definition get re-merged now that we're actually creating\n-\t\t\t// the bean... just in case some of its metadata changed in the meantime.\n-\t\t\tclearMergedBeanDefinition(beanName);\n-\t\t\tthis.alreadyCreated.add(beanName);\n+\t\t\tsynchronized (this.mergedBeanDefinitions) {\n+\t\t\t\tif (this.alreadyCreated.add(beanName)) {\n+\t\t\t\t\t// Let the bean definition get re-merged now that we're actually creating\n+\t\t\t\t\t// the bean... just in case some of its metadata changed in the meantime.\n+\t\t\t\t\tclearMergedBeanDefinition(beanName);\n+\t\t\t\t}\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AbstractBeanFactory.markBeanAsCreated() reliably clears merged bean definition only once",
        "commit_body": "Issue: SPR-14269\n",
        "linked_issues": [
            {
                "issue_id": "18841",
                "issue_title": "markBeanAsCreated does not clear merged bean definition in a thread-safe fashion [SPR-14269]",
                "issue_body": "**[Marcin Piela](https://jira.spring.io/secure/ViewProfile.jspa?name=mpiela)** opened **[SPR-14269](https://jira.spring.io/browse/SPR-14269?redirect=false)** and commented\n\nWhen creating a context and then calling `getBean` on it from multiple threads we sometimes get a `BeanInitializationException` from `RequiredAnnotationBeanPostProcessor.postProcessPropertyValues`.\nAttached is a simple maven project to reproduce. In a loop it:\n1. creates a fresh spring context\n2. attempts to fetch some beans from it in parallel.\n   The number of threads and max number of loop iterations can be passed as the first and second argument to the Main class.\n   Usage:\n   `mvn clean package && java -jar target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar`\n   We never get any errors when the getBean method is called from a single thread, so:\n   `java -jar target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar 1`\n   always works.\n   We don't get any errors for spring version 4.1.9, but as long as we switch to 4.2.0 or later the errors start occuring.\n   Example exception:\n\n```\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'service-2' defined in class path resource [example-context.xml]: Cannot resolve reference to bean 'bean_0_1' while setting bean property 'bean_0_1'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bean_0_1' defined in URL [jar:file:/home/mpiela/devel/repo/spring-bug/target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar!/test/Bean_0_1.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Properties 'bean_1_0' and 'bean_1_1' are required for bean 'bean_0_1'\n\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:359)\n\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1481)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:325)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\n\tat org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1054)\n\tat test.Main.lambda$tryToGetBean$0(Main.java:75)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'bean_0_1' defined in URL [jar:file:/home/mpiela/devel/repo/spring-bug/target/spring-bug-1.0-SNAPSHOT-jar-with-dependencies.jar!/test/Bean_0_1.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanInitializationException: Properties 'bean_1_0' and 'bean_1_1' are required for bean 'bean_0_1'\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:325)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\n\tat org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:351)\n\t... 13 more\nCaused by: org.springframework.beans.factory.BeanInitializationException: Properties 'bean_1_0' and 'bean_1_1' are required for bean 'bean_0_1'\n\tat org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.postProcessPropertyValues(RequiredAnnotationBeanPostProcessor.java:156)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1214)\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543)\n\t... 17 more\n```\n\n---\n\n**Affects:** 4.2.6\n\n**Attachments:**\n- [spring-bug.tar.gz](https://jira.spring.io/secure/attachment/23392/spring-bug.tar.gz) (_2.25 kB_)\n\n**Issue Links:**\n- #16851 Reduce BeanDefinition cloning in AbstractBeanFactory.getMergedBeanDefinition\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9064d38e4c77addbb5682e28e8c04df9fc8cd652, https://github.com/spring-projects/spring-framework/commit/71463fb3991a2b7e8e79cafa91a824c51f4fc73a, https://github.com/spring-projects/spring-framework/commit/933bbf2de90c720e6ada08089c3401317230d3b0, https://github.com/spring-projects/spring-framework/commit/6efa0589170fbcdd7fc0fe850d5b55b75918fdb2\n\n**Backported to:** [4.2.7](https://github.com/spring-projects/spring-framework/milestone/144?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nthe method **markBeanAsCreated(String beanName)**  in AbstractBeanFactory is not thread safe.\nthread A and thread B try to call this method, A check **!this.alreadyCreated.contains(beanName)** return true, then call **this.alreadyCreated.add(beanName);** at this time B check **!this.alreadyCreated.contains(beanName)** return false, then B out of this method, but now A does not finish **clearMergedBeanDefinition(beanName);** then B call **getMergedLocalBeanDefinition(String beanName)** may return old BeanDefinition\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nI have a pull request, https://github.com/spring-projects/spring-framework/pull/1059, please help to review.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nMoving the `this.alreadyCreated.add(beanName)` call right after `clearMergedBeanDefinition(beanName)` seems to be the most efficient way out here: In case of a race condition, we'll clear the merged bean definition too often but that's acceptable; we'll at least guarantee that subsequent steps will always see an up-to-date bean definition then.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\n`@Juergen` Hoeller I have tried not adding synchronized (this.alreadyCreated), when running the test still throw the same exception with more attempts(one test happened after 239 attempts of 4 threads). You can have a try. I still do not know why it is happen, but it is actually happened.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nthe error just occurs just because the too ofter clear the merged bean definition in multi threads for method **protected RootBeanDefinition getMergedBeanDefinition(String beanName, BeanDefinition bd, BeanDefinition containingBd) throws BeanDefinitionStoreException** If thread A first clear merged bean then call **getMergedBeanDefinition** and create a new **RootBeanDefinition**, but thread B first clear the merged bean definition then call **getMergedBeanDefinition** and create another new **RootBeanDefinition**, there will be two different BeanDefinitions.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSince `getMergedBeanDefinition` operates within a full lock, there should never be two different bean definitions stored there. Temporary use of two different (but equivalent) merged bean definitions is not an issue; we do that in other scenarios as well.\n\nHave you tried to reproduce this against the latest `4.3.0.BUILD-SNAPSHOT`? It would help a lot to isolate failures against that re-ordered but non-synchronized scenario since there might be some related bug lurking in our merged bean definition handling.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nI have download latest code and running ./gradlew install then using 4.3.0.BUILD-SNAPSHOT, the issues can be reproduced.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nif there are two different merged bean definitions for same beanName, the method **InjectionMetadata.checkPropertySkipping(PropertyValues pvs)** will not work correctly because same InjectionMetadata cached from **CommonAnnotationBeanPostProcessor.findResourceMetadata** for same beanName but different PropertyValues.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! Thanks for the insight, I'll have another pass today.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've addressed this through synchronizing on `this.mergedBeanDefinitions` now, checking for `this.alreadyCreated.add(beanName)` within and clearing the merged bean definition if the `add` call returned `true`. We still do an non-synchronized `!this.alreadyCreated.contains(beanName)` first, so overall this should not cause any inefficiency in a fully initialized system.\n\nThe use of the `this.mergedBeanDefinitions` lock is in sync with `getMergedBeanDefinition`, in order to prevent interleaving with ongoing merge attempts as well (where an old version might get cached in certain race condition cases otherwise, e.g. with concurrent type matching attempts touching the same bean and the bean definition having been modified inbetween).\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\n`@Juergen` Do you test your code? I have test it and still can reproduce the issue. I have test my pull request via 8 thread and 40000 attempts without reproduce the issue.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt'd be great if you could run your tests against the latest `4.3.0.BUILD-SNAPSHOT` again... Please make sure that it's actually the latest, not a locally cached old snapshot.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOuch, there might indeed be a remaining issue since the `add` exposes itself for early `contains` checks again... I was just checking the re-merge behavior but not potential access to an old bean definition. Alright, one more pass coming here, moving the `add` to the end of the `synchronized` block.\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nnot the issue of add method, the issue in your commit is same with no synchronized because the method getMergedLocalBeanDefinition(String beanName) are not synchronized in line 1176.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs far as I can see, with the `add` moved, the code is analogous to your pull request now, just using a different lock to synchronize on.\n\n`getMergedLocalBeanDefinition` does not have to be synchronized from my perspective. As long as the `clearMergedBeanDefinition` call happens before we expose a bean as already created, any actual creation attempts will see the fresh bean definition. And for concurrent type matching purposes, an old bean definition is good enough.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nBTW, I'm currently working on a whole range of 4.2.x backports, so this fix will appear in the upcoming `4.2.7.BUILD-SNAPSHOT` as well (actually, there first).\n",
                    "**[andyjojo](https://jira.spring.io/secure/ViewProfile.jspa?name=andyjojo)** commented\n\nI do not mean getMergedLocalBeanDefinition need synchronized, I mean non-syncrhonzied getMergedLocalBeanDefinition case your commit not work.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThat's true but it isn't meant to cover that case: The common lock is just intended to cover `mergedBeanDefinitions` add/remove attempts, where a remove does not happen while another thread is currently doing a merge (e.g. from a type match attempt) based on potentially outdated metadata... so it rather happens right afterwards then.\n\nIn any case, I can't reproduce the reported issue anymore with the `add` moved to the end of the `synchronized (mergedBeanDefinitions)` block, not even with 8 threads and 40.000 attempts. So I guess we can consider your case covered now? The current `4.2.7.BUILD-SNAPSHOT` and the upcoming `4.3.0.BUILD-SNAPSHOT` contain that candidate state.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a synchronization block around the `alreadyCreated.add(beanName)` operation.  Previously, `clearMergedBeanDefinition(beanName)` was unconditionally called after adding the bean name to `alreadyCreated`.  The modification now ensures that the `clearMergedBeanDefinition` operation is only performed if the `alreadyCreated` set successfully adds the bean name (meaning it wasn't already present)",
            "avg_logprobs": -0.15804418563842773
        }
    },
    {
        "commit_hash": "90c9d96a4d432a31c6cfbb0c2e8f2ab83daeffef",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AutoProxyUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * Expose the given target class for the specified bean.\n+\t * Expose the given target class for the specified bean, if possible.\n-\t\tif (beanFactory.containsBeanDefinition(beanName)) {\n+\t\tif (beanName != null && beanFactory.containsBeanDefinition(beanName)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid exposeTargetClass attempt if bean name is null",
        "commit_body": "Issue: SPR-13650\n",
        "linked_issues": [
            {
                "issue_id": "18226",
                "issue_title": "@EventListener does not work if put it at method in class that implements interface [SPR-13650]",
                "issue_body": "**[Nazar Vishka](https://jira.spring.io/secure/ViewProfile.jspa?name=nazar%20vishka)** opened **[SPR-13650](https://jira.spring.io/browse/SPR-13650?redirect=false)** and commented\n\nSimple example:\n\n```\npublic interface Service{\n      @org.springframework.context.event.EventListener\n      void processEventA(EventA event);\n      \n      void processEventB(EventB event);\n}\n\n@Service\npublic class ServiceImpl implements Service{\n     @Override\n     public void void processEventA(EventA event){ \n          //do something \n     }\n\n     @Override\n     @org.springframework.context.event.EventListener\n     public void void processEventB(EventB event){ \n          //do something \n     }\n\n     @org.springframework.context.event.EventListener\n     public void void processEventC(EventC event){ \n          //do something \n     }\n}\n\n@Service\npublic class EventPublisher{\n       @Autowired\n       ApplicationEventPublisher eventPublisher;\n\n       public void publishEvents(){\n             eventPublisher.publishEvent(new EventA());\n             eventPublisher.publishEvent(new EventB());\n             eventPublisher.publishEvent(new EventC());\n       }\n}\n```\n\nWhen I call EventPublisher.publishEvents() only one method in ServiceImpl is triggered: processEventA(EventA event). But I expected that all three methods will be triggered.\n\n---\n\n**Affects:** 4.2.2\n\n**Issue Links:**\n- #18114 Spring incorrectly interprets a bean to be a spring eventlistener\n- #18153 Incorrect `@JmsListener` parameter matching when the listener is a JDK proxy\n- #18488 Scheduled method is not invoked via proxy\n- #18230 Consistent method selection for listeners and endpoint mappings\n- #18231 AbstractAutoProxyCreator.getCacheKey generate lots of String garbage\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/90c9d96a4d432a31c6cfbb0c2e8f2ab83daeffef, https://github.com/spring-projects/spring-framework/commit/d5efe4f9837134f7a6303515e79fd394082e3cfc\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're currently only looking at the proxy for `@EventListener` detection. There is a related issue with `@JmsListener` (#18153); I'll try to address both ASAP.\n\nJuergen\n",
                    "**[Nazar Vishka](https://jira.spring.io/secure/ViewProfile.jspa?name=nazar%20vishka)** commented\n\nThank you Juergen for such quick reaction. Looking forward for improvement.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis was not as straightforward as with `@JmsListener` and co, since `EventListenerMethodProcessor` introspects top-level beans by type and carefully avoids early initialization of those beans on startup, therefore not being able to take the actual AOP proxy (and its target class) into account. Instead, we're checking a new bean definition attribute now which stores the original target class for auto-proxied beans. This new attribute is being exposed by `AbstractAutoProxyCreator` and `AbstractBeanFactoryAwareAdvisingPostProcessor` through the common `AutoProxyUtils` delegate, like we do fo the preserve-target-class hint already. That hint is also take into account by `AbstractBeanFactoryAwareAdvisingPostProcessor` (previously just by `AbstractAutoProxyCreator`), which means that `AsyncAnnotationBeanPostProcessor` and co also participate in an enforced target-class proxy scenario for specific beans now.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for `beanName` before checking if the bean factory contains a definition for it.  This prevents a potential `NullPointerException` if `beanName` is null.  The original code unconditionally checked the bean factory, potentially leading to an error if `beanName` was not properly initialized. The addition of the null check makes the method more robust",
            "avg_logprobs": -0.18386368873791817
        }
    },
    {
        "commit_hash": "913cc079af07fbb58ea09e73d3fb538714b6a1dc",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/TagWriter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t}\n+\t\n+\t/**\n+\t * Write an empty HTML attribute with the specified name.\n+\t * <p>Be sure to write all attributes <strong>before</strong> writing\n+\t * any inner text or nested tags.\n+\t * @throws IllegalStateException if the opening tag is closed\n+\t */\n+\tpublic void writeAttribute(String attributeName) throws JspException {\n+\t\tif (currentState().isBlockTag()) {\n+\t\t\tthrow new IllegalStateException(\"Cannot write attributes after opening tag is closed.\");\n+\t\t}\n+\t\tthis.writer.append(\" \").append(attributeName);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "TagWriter can write empty attribute",
        "commit_body": "See gh-910\n",
        "linked_issues": [
            {
                "issue_id": "910",
                "issue_title": "Support empty attributes in TagWriter",
                "issue_body": "Support for empty HTML attributes (like \"required\", \"ng-disabled\"...)\nIf you want to use this tool for a custom tag in a project that is mainly Angular-oriented, you may want to write attributes without values.\nAnd since members are private, you cannot extend TagWriter (another proposal could be \"protecting\" fields).\n",
                "issue_state": "closed",
                "issue_comment": [
                    "@djechelon Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=910)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=910) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@djechelon Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=910)!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a new method `WriteAttribute` to the `TagWriter` class.  This method writes an empty HTML attribute to the output.  Crucially, it includes a check (`currentState().isBlockTag()`) to prevent writing attributes after the opening tag has been closed, throwing an `IllegalStateException` if that condition is met.  This change enforces the correct order of attribute and content writing in HTML tags",
            "avg_logprobs": -0.13988356754697603
        }
    },
    {
        "commit_hash": "92a48b72d77e4a377cfe31316fcbd5249ee4b34d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/support/GenericMessage.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (byte[].class.equals(this.payload.getClass())) {\n+\t\tif (this.payload instanceof byte[]) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish (minor)",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a class equality check (`byte[].class.equals(this.payload.getClass())`) with an instanceof check (`this.payload instanceof byte[]`).  This change is likely a performance improvement and/or a more idiomatic way to check if the payload is a byte array.  The instanceof operator is generally preferred for type checking in Java, as it avoids unnecessary class loading and reflection",
            "avg_logprobs": -0.16544436245429806
        }
    },
    {
        "commit_hash": "92c9b0dc9746ceac9ed0d60c64687247e5092ece",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t// Skip unsent CONNECT messages (likely auth issues)\n-\t\t\t\t\tif (!isConnect || sent) {\n-\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" + session.getId() +\n-\t\t\t\t\t\t\t\t\":\" + ex.getMessage());\n+\t\t\t\t\t// Skip for unsent CONNECT or SUBSCRIBE (likely authentication/authorization issues)\n+\t\t\t\t\tif (sent || !(isConnect || StompCommand.SUBSCRIBE.equals(command))) {\n+\t\t\t\t\t\tlogger.error(\"Failed to send message to MessageChannel in session \" +\n+\t\t\t\t\t\t\t\tsession.getId() + \":\" + ex.getMessage());",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduce logging for unsent SUBSCRIBE messages",
        "commit_body": "Closes gh-28252\n",
        "linked_issues": [
            {
                "issue_id": "28252",
                "issue_title": "Exclude authorization messages from ERROR logging in StompSubProtocolHandler",
                "issue_body": "**Affects:** 5.3.17\r\n\r\n---\r\n\r\nAs part of #26026 the logging in StompSubProtocolHandler was improved to prevent the logging of exceptions pertaining to failed authentication. More specifically, this suppression applies to STOMP CONNECT messages as per (https://github.com/spring-projects/spring-framework/commit/bcd2b9a8a7d4e0b8b6615787122d5f2a2d3eb70c#diff-624b9c9ccd9db4e56263e34b3e865fdce34e9b1dd00a00f956f919ede789265fR337). \r\n\r\nGiven that Spring Security allows for access decisions to be made at the topic level when users Subscribe (using `MessageSecurityMetaDataSourceRegistry.simpSubscribeDestMatchers(String... patterns)`) should the logging suppression be enhanced to apply to both CONNECT and SUBSCRIBE messages? This will therefore suppress the error level logging when a user fails authorization when subscribing to a topic.",
                "issue_state": "closed",
                "issue_comment": [
                    "For #26026 the concern was that a user that is not even authenticated could filling up the logs with stacktraces, while for a subscription to be sent, the user must have been authenticated already. Did you run into this from a specific use case or concern, and if so could you please elaborate? ",
                    "> This will therefore suppress the error level logging when a user fails authentication when subscribing to a topic.\r\n\r\nJust noticed this. Subscribing should trigger authorization, not authentication.",
                    "Thanks for your response. Apologies - you are correct. I've updated the original post to refer to authorization rather than authentication.\r\n\r\nIn the use case I am referring to, access decisions are made on a per topic basis so it's likely there could be authenticated users who are not authorized to access a range of topics. Ultimately, the concern here was similar #26026 in that authenticated users who are not authorized for a given topic could cause unnecessary errors to be logged. Is the expectation within Spring Messaging/Spring Security that an error be explicitly logged when a user is denied access? I believe in other areas (REST), this is typically logged at DEBUG level.",
                    "Thanks for clarifying. \r\n\r\nWe typically do log unhandled errors, which is how this looks from the perspective of `StompSubProtocolHandler`, and if I'm not mistaken after that an `ERROR` frame is sent and the connection is closed. If we did not log this, I'm pretty sure it would cause the opposite issue of not seeing anything to explain the error.\r\n\r\nNote that the interceptor can return true or false to skip the processing of the message but it chooses to reject it in a way that does not allow the user to use the connection further. I think that's justified since it's not clear why the user is trying to access subscriptions they're not allowed to access, and the logging of that exception at ERROR is in line with that.\r\n\r\nJust to be clear you are not suggesting that authenticated users in your use case could be intentionally doing this. In other words, it's more about noise in the logs rather than intentionally filling them up?\r\n",
                    "Yes, you are correct this is more about noise rather than the logs being intentionally filled up.\r\n\r\nI understand your point where an explanation is required for what has caused the error. Perhaps the auth issues here are different to other types of exception as it's arguable if an error has actually occurred, rather the system is functioning as expected and denying unauthorized requests. \r\n\r\nWould the `ERROR` frame back to the client/caller not provide sufficient details that an auth error has occurred? If more details were required on the server side, would it not be expected that DEBUG level logging be enabled to see why requests are being denied?\r\n\r\nPerhaps I am mistaken, but I believe this is the pattern used in Spring Web (Security). If a REST endpoint is hit and a user is unauthorized an HTTP 403 would be returned but to see the details on the server side you'd need to enable DEBUG logging on `org.springframework.security`.",
                    "The difference with a REST endpoint is that 403 communicates clearly the result. That said, I see that we do include the error in the \"message\" header, so I think we can refine the logic to exclude both authentication and authorization exception from ERROR level logging (in production)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the conditional logic to skip not only unsent CONNECT messages, but also unsent SUBSCRIBE messages.  The original check `if (!isConnect || sent)` is replaced with `if (sent || !(isConnect || StompCommand.SUBSCRIBE.equals(command)))`.  This change expands the scope of messages that are skipped when a send operation fails, potentially improving error handling for authentication/authorization issues related to SUBSCRIBE requests",
            "avg_logprobs": -0.251809280909849
        }
    },
    {
        "commit_hash": "93c8b7ab04af281a26d05c968fdb0ed03cf0b1c4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.util.ClassUtils;\n-\t\tif (!isConfigurationFrozen()  || type == null || !allowEagerInit) {\n+\t\tif (!isConfigurationFrozen() || type == null || !allowEagerInit) {\n-\t\tcache.put(type, resolvedBeanNames);\n+\t\tif (ClassUtils.isCacheSafe(type, getBeanClassLoader())) {\n+\t\t\tcache.put(type, resolvedBeanNames);\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DefaultListableBeanFactory only puts 'cache-safe' Class keys into its by-type cache",
        "commit_body": "Issue: SPR-11520\n",
        "linked_issues": [
            {
                "issue_id": "16145",
                "issue_title": "Memory leak when using annotation based auto-wiring in child context [SPR-11520]",
                "issue_body": "**[Robert Cohen](https://jira.spring.io/secure/ViewProfile.jspa?name=rcon16)** opened **[SPR-11520](https://jira.spring.io/browse/SPR-11520?redirect=false)** and commented\n\nI have a Spring Context hierarchy that is two levels where each node has it's own classloader. I load the child context using an XML bean definition and as an option, there may be a <context:component-scan> defined within the child context's XML to enable annotation style auto-wiring. When we have this component-scan, the child classloader is not garbage collected if the child context is closed. If we use XML for all of our bean definitions, then the classloader is collected properly.\n\nThe attached test project reproduces the leak consistently after creating/closing a child context about 318 times.\n\nUsing a profiler, I can see that the child classloader is being held due to child context Classes being left in the Parent's DefaultListableBeanFactory \"allBeanNamesByType\" variable:\n\n```\n/** Map of singleton and non-singleton bean names keyed by dependency type */\nprivate final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);\n```\n\nThey are added to the Parent DefaultListableBeanFactory allBeanNamesByType map by method DefaultListableBeanFactory. getBeanNamesForType(), however they are not removed when I close the context.\n\nAs the server is used an child contexts get redeployed, we eventually encounter OOM errors.\n\n---\n\n**Affects:** 3.2.8\n\n**Attachments:**\n- [parent child leak.zip](https://jira.spring.io/secure/attachment/21801/parent+child+leak.zip) (_2.23 MB_)\n\n**Issue Links:**\n- #16229 AbstractApplicationEventMulticaster can leak classes\n- #16494 Performance regression for custom autowireBean calls with many properties\n- #21255 Revise cache safety check to avoid performance regression in EAR packaged applications on WildFly\n\n**Backported to:** [3.2.9](https://github.com/spring-projects/spring-framework/milestone/97?closed=1)\n\n0 votes, 6 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWhat kind of Class references can you see in that parent's allBeanNamesByType Map? Why are they different between the component-scan vs XML case?\n\nJuergen\n",
                    "**[Robert Cohen](https://jira.spring.io/secure/ViewProfile.jspa?name=rcon16)** commented\n\nThe Class references in the parent's allBeanNamesByType Map are any child classes (annotated with `@Component`) that have been auto-wired. In the example code the Child context contains `@Component`'s Crib, Child and Toy. Toy gets wired to Child and Child gets wired to Crib. In the parent's allBeanNamesByType map, i see references to Child.class and Toy.class, but not Crib.class.\n\nThe following stack trace shows when one of the child classes gets added to the parent's allBeanNamesByType map:\n\n```\nThread [main] (Suspended (breakpoint at line 335 in DefaultListableBeanFactory))\t\n\towns: ConcurrentHashMap<K,V>  (id=25)\t\n\towns: Object  (id=26)\t\n\tDefaultListableBeanFactory.getBeanNamesForType(Class<?>, boolean, boolean) line: 335\t\n\tBeanFactoryUtils.beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class<?>, boolean, boolean) line: 187\t\n\tBeanFactoryUtils.beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class<?>, boolean, boolean) line: 191\t\n\tDefaultListableBeanFactory.findAutowireCandidates(String, Class<?>, DependencyDescriptor) line: 897\t\n\tDefaultListableBeanFactory.doResolveDependency(DependencyDescriptor, Class<?>, String, Set<String>, TypeConverter) line: 855\t\n\tDefaultListableBeanFactory.resolveDependency(DependencyDescriptor, String, Set<String>, TypeConverter) line: 770\t\n\tAutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(Object, String, PropertyValues) line: 489\t\n\tInjectionMetadata.inject(Object, String, PropertyValues) line: 87\t\n\tAutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(PropertyValues, PropertyDescriptor[], Object, String) line: 286\t\n\tDefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1146\t\n\tDefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 519\t\n\tDefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 458\t\n\tAbstractBeanFactory$1.getObject() line: 296\t\n\tDefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory<?>) line: 223\t\n\tDefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<T>, Object[], boolean) line: 293\t\n\tDefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 194\t\n\tDefaultListableBeanFactory.preInstantiateSingletons() line: 628\t\n\tGenericApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 932\t\n\tGenericApplicationContext(AbstractApplicationContext).refresh() line: 479\t\n\tMain.main(String[]) line: 39\t\n```\n\nSpecifically, here in DefaultListableBeanFactory:\n\n```\npublic String[] getBeanNamesForType(Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {\n     if (!isConfigurationFrozen()  || type == null || !allowEagerInit) {\n          return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n     }\n     Map<Class<?>, String[]> cache =\n               (includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);\n     String[] resolvedBeanNames = cache.get(type);\n     if (resolvedBeanNames != null) {\n          return resolvedBeanNames;\n     }\n     resolvedBeanNames = doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);\n     cache.put(type, resolvedBeanNames);\n     return resolvedBeanNames;\n}\n```\n\nIt's interesting because first this method is called on the child context and the bean names being looked up are found and cached in the child. But then this logic is also called on the parent context which creates the issue.\n\nIf i remove the component scan and define the beans in XML, then BeanFactoryUtils.beanNamesForTypeIncludingAncestors() does not get called and the child class references are never added to the parent allBeanNamesByType map.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThanks for sharing those details...\n\nSo it looks like the actual cause is the use of autowiring (`@Autowired` and co), not the use of component scanning. You'd probably see the same effect if you took your annotated components as-is but defined them in \\<bean class=\"...\"/> one-liners instead of using <context:component-scan>.\n\nWe're indeed caching lookup results at all factory levels, independent from where those classes originate. I suppose we need to either use weak references there or clear the parent's cache if a child factory is being closed... covering scenarios like yours where child factories are being closed and reopened while the parent stays alive all the time.\n\nJuergen\n",
                    "**[Robert Cohen](https://jira.spring.io/secure/ViewProfile.jspa?name=rcon16)** commented\n\nI tried removing the component scan and adding the bean one liners and confirmed that I still see the leak. So I have changed the title of the issue to reflect this is and issue with annotation based auto-wiring.\n",
                    "**[Robert Cohen](https://jira.spring.io/secure/ViewProfile.jspa?name=rcon16)** commented\n\nAdditionally, I can confirm that using a soft reference map for allBeanNamesByType does fix the leak. However, I'm am not the best to determine the consequences of this change.\n\n```\nprivate final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentReferenceHashMap<Class<?>, String[]>(64, ConcurrentReferenceHashMap.ReferenceType.SOFT);\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI eventually opted for a different approach:\n\nDefaultListableBeanFactory only puts 'cache-safe' Class keys into its by-type cache now, as determined by our ClassUtils.isCacheSafe method which is also being used by our JavaBeans CachedIntrospectionResults.\n\nEffectively, DefaultListableBeanFactory will now only cache retrieval results for classes loaded by that factory's bean ClassLoader or a parent thereof, ignoring classes from child ClassLoaders completely.\n\nIn a regular scenario, this won't make a difference since the entire application typically lives within the same ClassLoader anyway. However, in a scenario like yours, it will prevent memory leaks through (always empty but nevertheless cached) retrieval results in a parent factory.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis is available in the latest 4.0.3 snapshot already, and will be available in the immediately upcoming 3.2.9 snapshot as well (see http://projects.spring.io/spring-framework/ for Maven coordinates). Please give it a try and let us know whether it works for you...\n\nJuergen\n",
                    "**[Robert Cohen](https://jira.spring.io/secure/ViewProfile.jspa?name=rcon16)** commented\n\nMy project uses 3.2.6 so I patched that version with your fix and tested it. It works perfectly to solve the problem. Thanks a ton for the quick turnaround!\n-Rob\n",
                    "**[Matthias M\u00fcller](https://jira.spring.io/secure/ViewProfile.jspa?name=matthias.mueller)** commented\n\nWow, this was a hard nut to crack, I had the exact problem in my application.\nI was looking for a selfmade memory leak in the first place before I found this ticket.\nI had a DefaultListableBeanFactory consuming ~700MB of Memory....but now everthing works fine!\nTnx for finding and fixing this!\n",
                    "After browsing through the issues related to the bean name caching I though this one here might be a good one to leave a comment.\r\n\r\nAs far as we understood the isCacheSafe method of the ClassUtils was modified because of this issue to check whether a particular class can be loaded through its beanclassloader (or one of its parents) or not. If the class can be loaded through the classloader it is going to be cached and in case it cannot be loaded there is no caching.\r\n\r\nRelated to this we\u2019ve noticed some performance problems linked to request scoped beans. Because the information that the bean type cannot be resolved by one of the parents it is not cached, spring is doing the lookup for each request again which slows down the performance measurably. To solve the issue we\u2019re currently caching an empty string array if the parent classloader is not able to load a particular type of class.\r\n\r\nPlease let us know what you think regarding this.\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `DefaultListableBeanFactory` class to add a check for `ClassUtils.isCacheSafe(type, getBeanClassLoader())` before caching the `resolvedBeanNames` for a given `type`.  Previously, the cache was populated unconditionally if `isConfigurationFrozen()`, `type` was null, or `allowEagerInit` was false.  The new condition ensures that only types deemed safe for caching by the classloader are added to the cache",
            "avg_logprobs": -0.149338436126709
        }
    },
    {
        "commit_hash": "93de5f407e394b70b9a3fa89e35340008d340cbc",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tif (RequestBodyAdvice.class.isAssignableFrom(beanType)) {\n-\t\t\t\trequestResponseBodyAdviceBeans.add(adviceBean);\n-\t\t\t}\n-\t\t\tif (ResponseBodyAdvice.class.isAssignableFrom(beanType)) {\n+\t\t\tif (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid duplicate registration of [RequestBody|ResponseBody]Advice @ControllerAdvice",
        "commit_body": "Prior to this commit, if a @ControllerAdvice implemented both\nRequestBodyAdvice and ResponseBodyAdvice, it was registered twice in\nRequestMappingHandlerAdapter.\n\nThis commit ensures that such instances are only registered once.\n\nCloses gh-22638\n",
        "linked_issues": [
            {
                "issue_id": "22638",
                "issue_title": "Avoid duplicate registration of @ControllerAdvice implementing both RequestBodyAdvice and ResponseBodyAdvice",
                "issue_body": "fixbug: duplicate add on ControllerAdvice both RequestBodyAdvice and ResponseBodyAdvice",
                "issue_state": "closed",
                "issue_comment": [
                    "@liquanchen9 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22638)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22638) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@liquanchen9 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22638)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22638) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "Good catch. I'm not sure how often people implement `RequestBodyAdvice` and `ResponseBodyAdvice` in the same class, but it's certainly possible.\r\n\r\nIf you could sign the CLA and submit a test that was failing before the change that would be greatly appreciated.",
                    "Since this is a trivial change, @liquanchen9, we have decided to forgo the requirement to sign the CLA.\r\n\r\nThanks for your contribution!",
                    "@liquanchen9 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=22638)!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change combines two separate `if` statements checking for `RequestBodyAdvice` and `ResponseBodyAdvice` types into a single `if` statement using the `||` (OR) operator.  This reduces code duplication by checking both types in a single condition.  The effect is functionally identical, but more concise",
            "avg_logprobs": -0.12469841883732723
        }
    },
    {
        "commit_hash": "946082f8062cf859a30c461ace18ccc6e5dd2872",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CoroutinesUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\telse if (KTypes.isSubtypeOf(returnType, monoType)) {\n-\t\t\treturn mono.flatMap(o -> ((Mono<?>)o));\n-\t\t}\n-\t\telse if (KTypes.isSubtypeOf(returnType, publisherType)) {\n+\t\tif (KTypes.isSubtypeOf(returnType, publisherType)) {\n+\t\t\tif (KTypes.isSubtypeOf(returnType, monoType)) {\n+\t\t\t\treturn mono.flatMap(o -> ((Mono<?>)o));\n+\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine publisher type check in CoroutinesUtils",
        "commit_body": "See gh-32390\n",
        "linked_issues": [
            {
                "issue_id": "32390",
                "issue_title": "Optimize Coroutine invocations",
                "issue_body": "`KClass` instantiation in `CoroutinesUtils` is suboptimal, and should be replaced by `KTypes#isSubtypeOf` checks using pre-instantiated types for `Flow`, `Mono` and `Publisher`.",
                "issue_state": "closed",
                "issue_comment": [
                    "This commit impact on performances is significant since **a throughput increase between 2x and 3x** has been measured on basic endpoints.",
                    "@koo-taejin @efemoney Please test the latest `6.1.5-SNAPSHOT` builds and report if you see some unexpected side effects.",
                    "Tested from my side & passes all my tests \ud83d\udc4d\ud83c\udffe just like the previous snapshot",
                    "I am going to test it. \ud83d\udc4d thanks :)  ",
                    "Unfortunately, I don't think the situation has changed much. \r\nIt would be accurate to put it into production and test it, but I apologize for not being able to do this. \r\n\r\nMethod of `getClassifier() `has been replaced by method of `getJvmErasure()`.\r\nI had checked that `getClassifier()` is called from `getJvmErasure()`. \r\n(in `org.springframework.core.CoroutinesUtils.lambda$invokeSuspendingFunction$2(Object[], KFunction, Object, CoroutineScope, Continuation)`)\r\n- spring-boot 3.2.0\r\n![image](https://github.com/spring-projects/spring-framework/assets/10057874/6218e28e-2eb2-4a61-b6f1-ae90959ff079)\r\n\r\n- spring-boot 3.2.1 with `6.1.5-SNAPSHOT-p1`\r\n![image](https://github.com/spring-projects/spring-framework/assets/10057874/c2846de2-e196-47ce-9f13-db63a0d13f24)\r\n\r\n- spring-boot 3.2.1 with `6.1.5-SNAPSHOT-p2`\r\n![image](https://github.com/spring-projects/spring-framework/assets/10057874/ae384d8d-b58b-45f3-9bd5-14e2ad754e18)\r\n\r\nAlso, in the latest version, the isSubTypeOf() method uses resources. \r\n(in `org.springframework.core.CoroutinesUtils#invokeSuspendingFunction(kotlin.coroutines.CoroutineContext, java.lang.reflect.Method, java.lang.Object, java.lang.Object...)`)\r\n- spring-boot 3.2.1 with `6.1.5-SNAPSHOT-p1`\r\n![image](https://github.com/spring-projects/spring-framework/assets/10057874/30e834ed-f511-4c38-80f0-1d93352f5a44)\r\n\r\n- spring-boot 3.2.1 with `6.1.5-SNAPSHOT-p2`\r\n![image](https://github.com/spring-projects/spring-framework/assets/10057874/45fd9daf-c889-4fcf-bec7-053f1ba3fe56)\r\n\r\nThis is called for every `suspend` function, so more use Coroutines, the bigger the impact seems to be.\r\n\r\nIf there is anything I can do to help, please let me know.\r\n\r\nThank you so much. \ud83d\ude47 ",
                    "See [this related comment](https://github.com/spring-projects/spring-framework/issues/32334#issuecomment-1988554701)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change reorders and adds a nested `if` statement to the conditional logic for determining the return type.  The original `else if` blocks for `monoType` and `publisherType` are now combined into a single `if` block for `publisherType` that checks for `monoType` as a *nested* condition.  This means the `mono.flatMap` operation is only performed if the return type is a `Mono` *and* also a `Publisher`.",
            "avg_logprobs": -0.273438549041748
        }
    },
    {
        "commit_hash": "947255e3774fe6248c59d2cdd6a1b06b9f6b5d9b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.core.KotlinDetector;\n-\t\t\t\tif (ReflectionUtils.declaresException(getMethod(), ex.getClass())) {\n+\t\t\t\tif (ReflectionUtils.declaresException(getMethod(), ex.getClass()) ||\n+\t\t\t\t\t\tKotlinDetector.isKotlinType(getMethod().getDeclaringClass())) {\n+\t\t\t\t\t// Propagate original exception if declared on the target method\n+\t\t\t\t\t// (with callers expecting it). Always propagate it for Kotlin code\n+\t\t\t\t\t// since checked exceptions do not have to be explicitly declared there.\n+\t\t\t\t\t// Checked exception thrown in the interceptor but not declared on the\n+\t\t\t\t\t// target method signature -> apply an UndeclaredThrowableException,\n+\t\t\t\t\t// aligned with standard JDK dynamic proxy behavior.",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Always propagate checked exceptions from Kotlin code behind CGLIB proxies",
        "commit_body": "Closes gh-23844\n",
        "linked_issues": [
            {
                "issue_id": "23844",
                "issue_title": "Spring AOP should not apply UndeclaredThrowableException to checked exceptions from Kotlin methods",
                "issue_body": "Currently, when using Spring AOP with Kotlin, `UndeclaredThrowableException` is thrown when a method with advice throws a checked exception. There is a **_workaround_** in Kotlin in that you can add `@Throws` annotations to methods, but this is not really feasible as it would require annotating every method of every project, and methods in other libraries might not be under your control.\r\n\r\nWhat would solve this problem would be to have an option in Spring to disable the throwing of `UndeclaredThrowableException` and simply throw the original exception.",
                "issue_state": "closed",
                "issue_comment": [
                    "Looks like the relevant code is here:\r\nhttps://github.com/spring-projects/spring-framework/blob/9bd3a535cd524cf771423e67feeea523ac985f87/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L752-L759\r\n",
                    "This issue is also impacting me when using resilience4j circuit breaker. The AOP is encapsulating the real exception so the circuit breaker is never switched to OPEN.",
                    "The reason for that custom `UndeclaredThrowableException` throwing logic in `CglibAopProxy` is that interface-based proxies unavoidably get such a `UndeclaredThrowableException` out of the JDK implementation, so for consistency with `JdkDynamicAopProxy`, we manually enforce it in the CGLIB variant.\r\n\r\nSo whatever we do about it, we can only do it for CGLIB proxies. @sdeleuze what's your take on this? Is CGLIB+Kotlin a common enough case to be handled specifically - or on the inverse, are JDK proxies with Kotlin uncommon enough? Are checked exceptions without explicit declaration common enough in Kotlin?\r\n\r\nGenerally speaking for the scenarios above, why the need for checked exceptions coming out of an interceptor to begin with? From my perspective, this is bad practice with Java-based AOP, even more so with Kotlin-based AOP, and it's also a general Java interoperability issue when used in Kotlin-based arrangements.",
                    "@jhoeller \r\n\r\n> why the need for checked exceptions coming out of an interceptor to begin with?\r\n\r\nIn our case, we wanted to add logging around `@Service` methods with AOP. And in this scenario, the logging code should not change the behavior of the methods being logged.\r\n\r\nAdditionally, this method of logging would allow us to:\r\n\r\n- Avoid manual modification of dozens of methods with identical boilerplate code to add logging\r\n- Avoid modification of each of these again later if we want to change how the logging works\r\n- Have cleaner code by not mixing the logging aspect with the business logic",
                    "@jhoeller \r\n> Are checked exceptions without explicit declaration common enough in Kotlin?\r\n\r\nThis is what happens the majority of the time as Kotlin does not require declaration of checked exceptions.",
                    "I've just realized that - within Spring AOP - we'd even turn a checked exception thrown from a Kotlin *target method* into an `UndeclaredThrowableException`, not just a checked exception thrown from an *interceptor* (which is the primary purpose of that check). While this works fine with Java code that explicitly declares those exceptions on the target method (so undeclared exceptions can only really come out of the interceptor), it's really not appropriate for Kotlin code since it enforces a non-idiomatic `@Throws` declaration there. Thanks for raising this, and I'm sorry that we missed it the first time around.\r\n\r\nFor 5.3.3, I'll add a bypass that we'll always propagate the original exception for methods declared on Kotlin types.",
                    "This is committed now, as default behavior for Kotlin code behind CGLIB proxies.\r\n\r\nPlease give the upcoming 5.3.3 snapshot a try and let me know whether it works for your scenario:\r\nhttps://repo.spring.io/snapshot/org/springframework/spring-framework-bom/5.3.3-SNAPSHOT/",
                    "Thanks @jhoeller for those changes.",
                    "@jhoeller Thanks for the change!",
                    "@jhoeller Would it be possible to also get this fix in 5.2.15?",
                    "It's proven itself in 5.3.x for several months already, without any backlash, so let's schedule a backport for 5.2.15 indeed.",
                    "Great. Thanks!\n\n> On 21 Apr 2021, at 11:13, Juergen Hoeller ***@***.***> wrote:\n> \n> \n> It's proven itself in 5.3.x for several months already, without any backlash, so let's schedule a backport for 5.2.15 indeed.\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub <https://github.com/spring-projects/spring-framework/issues/23844#issuecomment-823910448>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAQ4FIDM465VIRUXSFGLAWLTJ2JNNANCNFSM4JDJFPUQ>.\n> \n\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a check for Kotlin types to the exception handling logic within `CglibAopProxy`.  Previously, exceptions were only propagated if declared on the target method.  Now, if the exception type is declared on the method *or* if the method's declaring class is a Kotlin type, the original exception is propagated",
            "avg_logprobs": -0.17556364059448243
        }
    },
    {
        "commit_hash": "949c3d450c35b676b82a4a56ada997cf9a552f1d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t!readMethodNames.contains((method.getName())) && isPlainAccessor(method)) {\n+\t\t\t\t\t!readMethodNames.contains(method.getName()) && isPlainAccessor(method)) {\n-\t\tif (method.getParameterCount() > 0 || method.getReturnType() == void.class ||\n-\t\t\t\tmethod.getDeclaringClass() == Object.class || Modifier.isStatic(method.getModifiers())) {\n+\t\tif (Modifier.isStatic(method.getModifiers()) ||\n+\t\t\t\tmethod.getDeclaringClass() == Object.class || method.getDeclaringClass() == Class.class ||\n+\t\t\t\tmethod.getParameterCount() > 0 || method.getReturnType() == void.class ||\n+\t\t\t\tClassLoader.class.isAssignableFrom(method.getReturnType()) ||\n+\t\t\t\tProtectionDomain.class.isAssignableFrom(method.getReturnType())) {",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Align plain accessor check",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the condition under which a method is considered a plain accessor.\\n\\n**Original Condition (removed):**\\n\\nChecked if the method name was *not* in `readMethodNames` *and* it was a plain accessor.  Then, it checked if the method had parameters, returned void, was static, or declared in `Object`",
            "avg_logprobs": -0.17467845916748048
        }
    },
    {
        "commit_hash": "9528c3532d4bb7eb62514418e32c0c5687722564",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/result/HandlerResultHandlerSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tfor (MediaType mediaType : compatibleMediaTypes) {\n+\t\tfor (MediaType mediaType : result) {",
        "change_count": 2,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Fix typo",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces the loop iterating over a `compatibleMediaTypes` list with a loop iterating over a `result` list.  This suggests a fundamental change in how the handler selects the appropriate media type.  Previously, the code was checking for compatibility; now, it's directly using the `result` list as the source of media types to be considered.  The original `compatibleMediaTypes` list is no longer used",
            "avg_logprobs": -0.21120156182183158
        }
    },
    {
        "commit_hash": "963cc09c2e742321413b29d94f390ce3f60a4799",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AutowireUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tboolean p1 = Modifier.isPublic(e1.getModifiers());\n-\t\tboolean p2 = Modifier.isPublic(e2.getModifiers());\n-\t\tif (p1 != p2) {\n-\t\t\treturn (p1 ? -1 : 1);\n-\t\t}\n-\t\tint c1pl = e1.getParameterCount();\n-\t\tint c2pl = e2.getParameterCount();\n-\t\treturn Integer.compare(c2pl, c1pl);\n+\t\tint result = Boolean.compare(Modifier.isPublic(e2.getModifiers()), Modifier.isPublic(e1.getModifiers()));\n+\t\treturn result != 0 ? result : Integer.compare(e2.getParameterCount(), e1.getParameterCount());",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish AutowireUtils.EXECUTABLE_COMPARATOR",
        "commit_body": "Closes gh-22283\n",
        "linked_issues": [
            {
                "issue_id": "22283",
                "issue_title": "Polish AutowireUtils.EXECUTABLE_COMPARATOR",
                "issue_body": "This PR polishes `AutowireUtils.EXECUTABLE_COMPARATOR` a bit.",
                "issue_state": "closed",
                "issue_comment": [
                    "Nice one, thanks again @izeye "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code refactored the comparison logic for two `Executable` objects (`e1` and `e2`).  The original code used an `if` statement to compare public modifier status and then compared parameter counts.  The revised code uses `Boolean.compare` for the public modifier check, which is more concise and potentially more efficient.  The result of the public modifier comparison is used as the primary sort criteria",
            "avg_logprobs": -0.3017477607727051
        }
    },
    {
        "commit_hash": "964467d2691180a7f01de441a190fb998801df91",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/DatabaseStartupValidator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tDataSource dataSource = this.dataSource;\n-\t\tif (dataSource == null) {\n+\t\tif (this.dataSource == null) {\n-\t\t\t\t\tcon = dataSource.getConnection();\n+\t\t\t\t\tcon = this.dataSource.getConnection();\n-\t\t\t\t\t\t\t\t\"DataSource returned null from getConnection(): \" + dataSource);\n+\t\t\t\t\t\t\t\t\"DataSource returned null from getConnection(): \" + this.dataSource);\n-\t\t\t\t\tThread.sleep(TimeUnit.SECONDS.toMillis(this.interval));\n+\t\t\t\t\tTimeUnit.SECONDS.sleep(this.interval);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish DatabaseStartupValidator.afterPropertiesSet()",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `DatabaseStartupValidator` modifies the way the `dataSource` is accessed and the error message is constructed.  The original code used a local variable `dataSource` and then used it in the `if` statement and the error message.  The change now directly uses `this.dataSource` throughout, eliminating the local variable and improving clarity.  Additionally, the error message now correctly references `this.dataSource` instead of the local variable.  Finally, the `Thread",
            "avg_logprobs": -0.3024435615539551
        }
    },
    {
        "commit_hash": "967a2ef2d20b7bc6f6bf79463ee15d7c3e2ec607",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (method.getReturnType() == Class.class) {\n+\t\t\tClass<?> returnType = method.getReturnType();\n+\t\t\tif (returnType == Class.class || returnType == Class[].class) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Validate Class attributes as well as Class array attributes",
        "commit_body": "Issue: SPR-16564\n",
        "linked_issues": [
            {
                "issue_id": "21106",
                "issue_title": "Reading annotations in ConfigurationClassParser does not fall back to ASM on Google App Engine [SPR-16564]",
                "issue_body": "**[Madhura Bhave](https://jira.spring.io/secure/ViewProfile.jspa?name=mbhave)** opened **[SPR-16564](https://jira.spring.io/browse/SPR-16564?redirect=false)** and commented\n\n`ConfigurationClassParser` has a sanity test to ensure that annotations can be read and in case of an Exception, it falls back to ASM. On Google App Engine `classType.getAnnotations()` does not throw an Exception if a class is not found and instead the annotation value looks something like this `value=sun.reflect.annotation.TypeNotPresentExceptionProxy`.\n\nThis causes unexpected behavior in Spring Boot's `OnClassCondition` as the metadata is not an `AnnotationMetadataReadingVisitor`.\n\n---\n\n**Affects:** 4.3.14, 5.0.4\n\n**Issue Links:**\n- #15712 `@PropertySources` fails on JDK 7 due to `@Repeatable`\n- #15274 Support `@Configuration` class parsing fallback to ASM\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/7cafa6764ce12191bd824da06b88729dffc20e69, https://github.com/spring-projects/spring-framework/commit/967a2ef2d20b7bc6f6bf79463ee15d7c3e2ec607, https://github.com/spring-projects/spring-framework/commit/50e980c02f0dba610303e064289be0420d1f6ce1\n\n**Backported to:** [4.3.15](https://github.com/spring-projects/spring-framework/milestone/164?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSo `classType.getAnnotations()` would return concrete `Annotation` instances here (of the declared annotation type), but some of the `Class` attributes of those annotations would not contains an actual `Class` value but rather a `TypeNotPresentExceptionProxy` stub?\n",
                    "**[Madhura Bhave](https://jira.spring.io/secure/ViewProfile.jspa?name=mbhave)** commented\n\nYes exactly. For example, for a nested class that looks like this (where `FooClass` is not present):\n\n```java\n@Configuration\n@ConditionalOnClass(FooClass.class)\nprotected static class Test {\n}\n```\n\nthis is the log for `classType.getAnnotations()`:\n\n```java\n@org.springframework.context.annotation.Configuration(value=)\n@org.springframework.boot.autoconfigure.condition.ConditionalOnClass(name=[], value=sun.reflect.annotation.TypeNotPresentExceptionProxy)\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nHmm that's rather awkward to find out though: We'd have to iterate over all attributes of all declared annotations and see whether any of them is a `TypeNotPresentExceptionProxy`... which isn't even a proper API type. And we'd have to do that for every such declared annotation on a configuration class.\n\nIn what way does this break Boot's `OnClassCondition`? Which specific assumptions about `AnnotationMetadataReadingVisitor` do you have there? Could we adapt those to find about the `TypeNotPresentExceptionProxy` within `OnClassCondition` specifically, rather than making it a part of core configuration class processing?\n",
                    "**[Madhura Bhave](https://jira.spring.io/secure/ViewProfile.jspa?name=mbhave)** commented\n\nWhen `OnClassCondition` checks for the presence of `@ConditionalOnClass`, it calls `metadata.getAllAnnotationAttributes` which, for `StandardAnnotationMetadata` returns `null` due to:\n\n```java\nFailed to introspect annotations on [class Foo]: java.lang.IllegalStateException: Could not obtain annotation attribute value for public abstract java.lang.Class[] org.springframework.boot.autoconfigure.condition.ConditionalOnClass.value()\n```\n\nBoot then assumes that this class is not a candidate for `@ConditionalOnClass` (since the attributes are null). This is the original issue https://github.com/spring-projects/spring-boot/issues/10553\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've introduced an `AnnotationUtils.validateAnnotation(Annotation)` method which we're applying in `ConfigurationClassParser.asSourceClass` to all declared annotations now before making a decision on reflection versus ASM. We check every declared `Class` attribute there, trying to read its value... which should fail on Google App Engine at that very point, otherwise indicating that `getAnnotationAttributes` calls will work fine later on.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Madhura Bhave](https://jira.spring.io/secure/ViewProfile.jspa?name=mbhave), this is included in the upcoming 5.0.5 snapshot now. Please give it a try and let me know whether it actually helps on GAE... If it doesn't, it'd be great to debug `AnnotationUtils.validateAnnotation` in terms of why it doesn't fail when invoking the affected attribute. In any case, this should be solvable at that level.\n",
                    "**[Madhura Bhave](https://jira.spring.io/secure/ViewProfile.jspa?name=mbhave)** commented\n\nThanks, Juergen. I tested it on GAE. Looks like it didn't work because `AnnotationUtils.validateAnnotation` checks for `method.getReturnType() == Class.class` and `@ConditionalOnClass` has a `Class<?>[] value`.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOops, indeed. I've extended that check to include Class arrays as well... Give it one more try with the upcoming snapshot please, hopefully it works for your purposes now!\n",
                    "**[Madhura Bhave](https://jira.spring.io/secure/ViewProfile.jspa?name=mbhave)** commented\n\nIt works as expected now. thank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the conditional check for `method.getReturnType()`.  Instead of directly comparing `method.getReturnType()` to `Class.class`, it now stores the return type in a variable `returnType` and checks if it's either `Class.class` or `Class[].class`.  This improves code readability and potentially allows for future expansion to handle other related types",
            "avg_logprobs": -0.12076892852783203
        }
    },
    {
        "commit_hash": "96bfc14dba7691f0f8cd893ac90b39e09ac8ae1a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ExceptionHandlerExceptionResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t// Any other than the original exception is unintended here,\n+\t\t\t// probably an accident (e.g. failed assertion or the like).\n+\t\t\tif (invocationEx != exception && logger.isWarnEnabled()) {\n+\t\t\t// Continue with default processing of the original exception...",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "No warn logging for propagated original exception",
        "commit_body": "Issue: SPR-14907\n",
        "linked_issues": [
            {
                "issue_id": "19473",
                "issue_title": "ExceptionHandlerExceptionResolver should not log propagated exceptions at warn level [SPR-14907]",
                "issue_body": "**[Eric Deandrea](https://jira.spring.io/secure/ViewProfile.jspa?name=edeandrea)** opened **[SPR-14907](https://jira.spring.io/browse/SPR-14907?redirect=false)** and commented\n\nIn spring-webmvc - org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver line 386 was changed from a logger.debug in version 4.3.3 (line 384 in version 4.3.3) to logger.warn in version 4.3.4. This might not seem like a big deal but is causing lots of non-necessary stack traces in our applications.\n\nWe have a FaultBarrier implemented as a SpringMVC `@ExceptionHandler` method, implemented as below. Basically its a generic handler that catches all exceptions. If the exception itself is annotated with `@ResponseStatus`, we simply re-throw it & let SpringMVC handle it. Now as of version 4.3.4 this is logging warning exception stack traces to our logs which is triggering out paging system to page people (our system pages out if any stack traces appear as WARN or ERROR levels), even though most of the exception codes in the `@ResponseStatus` are 400 series exceptions and are not error conditions at all. Our only fix so far is to downgrade back to 4.3.3.\n\n```java\n@ExceptionHandler(Exception.class)\npublic ResponseEntity<Object> defaultErrorHandler(Exception ex) throws Exception {\n\tResponseStatus responseStatusAnnotation = AnnotationUtils.findAnnotation(ex.getClass(), ResponseStatus.class);\n\n\tif (responseStatusAnnotation != null) {\n\t\t// If the exception is annotated with @ResponseStatus, rethrow it and let the framework handle it\n\t\tthrow ex;\n\t}\n\telse {\n\t\t// Do some other stuff here which isn't important to this issue\n\t}\n}\n```\n\nHere's the stack trace it generates:\n\n```\n[11/14/2016 16:54:24.101 | WARN](http-nio-8080-exec-1 | org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver:386): Failed to invoke @ExceptionHandler method: public org.springframework.http.ResponseEntity<java.lang.Object> my.app.common.api.FaultBarrier.defaultErrorHandler(java.lang.Exception) throws java.lang.Exception\nmy.app.model.NotFoundException: Policy 1000 was not found\n\tat my.app.api.PoliciesApi.convert(PoliciesApi.java:126)\n\tat my.app.api.PoliciesApi.getPolicy(PoliciesApi.java:100)\n\tat my.app.api.PoliciesApi$$FastClassBySpringCGLIB$$b9887c8b.invoke(<generated>)\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:720)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)\n\tat org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:133)\n\tat org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:121)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:655)\n\tat my.app.api.PoliciesApi$$EnhancerBySpringCGLIB$$2c76a269.getPolicy(<generated>)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:220)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:116)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:687)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:790)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:230)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:105)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:89)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:77)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:107)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:108)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:349)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:784)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:802)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1410)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: my.app.model.PolicyNotFoundException: Policy 1000 was not found\n```\n\n---\n\n**Affects:** 4.3.4\n\n**Issue Links:**\n- #19427 Log exception from `@ExceptionHandler` at higher level than debug\n- #19461 Allow HTTP status exceptions to be easily thrown from Controllers\n- #21916 ExceptionHandlerExceptionResolver started to log on WARN level\n- #18504 Exclude an exception from `@ExceptionHandler`\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/96bfc14dba7691f0f8cd893ac90b39e09ac8ae1a, https://github.com/spring-projects/spring-framework/commit/f22a4a4e807aaa673e7290835766052974c5eb47\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point, rethrowing the original exception is indeed a valid use case. Note, however, that we're not going to process the actual rethrown exception; we just take it as an indication that default processing needs to be applied to the original exception. So if any other than the original exception comes out of such a handler method, we're going to log a warning still... but not for the original exception itself anymore.\n",
                    "**[Eric Deandrea](https://jira.spring.io/secure/ViewProfile.jspa?name=edeandrea)** commented\n\nThat sounds ok as long as at the end of the day if my application throws some RuntimeException that is annotated with `@ResponseStatus` that there is no warning nor stack trace logged then that satisfies this requirement.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThat is certainly the case now. We only really intended to log a warning for accidental exceptions coming out of a handler method, e.g. assertion failures within the exception handler method itself. Rethrowing the original exception (no matter whether with or without `@ResponseStatus`) is the only valid case here, triggering the rest of the exception resolver chain, so we're explicitly letting it through without any logging now.\n",
                    "**[Eric Deandrea](https://jira.spring.io/secure/ViewProfile.jspa?name=edeandrea)** commented\n\nThanks a bunch!\n",
                    "**[dfreudenberger](https://jira.spring.io/secure/ViewProfile.jspa?name=dfreudenberger)** commented\n\nIt seems like we have the same issue again since spring-webmvc-5.0.9.RELEASE. The regression was introduced with this commit https://github.com/spring-projects/spring-framework/commit/04141dee65ff5e078e2a9137ff7052351f6ab66c#diff-4386c732a724a039db2007b1bac7d3d5R141. Happy to be wrong but as of right now I don't see how I can get rid of the warning without raising the logging threshold for the package / class to error.\n",
                    "**[pebo](https://jira.spring.io/secure/ViewProfile.jspa?name=pebo)** commented\n\nI face the same issue in spring boot 2.0.6 (5.0.10.RELEASE of web mvc)\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[pebo](https://jira.spring.io/secure/ViewProfile.jspa?name=pebo), this is an unfortunate regression that we're tracking in #21916. Should be fixed in the latest `5.0.11.BUILD-SNAPSHOT` already.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure that the `invocationEx` (presumably an exception from the invocation) is the same as the `exception` being handled.  If they are different, a warning is logged, indicating a potential unintended or accidental exception handling situation.  This suggests a change to prevent unexpected behavior when a different exception is caught than the one the handler was designed for. The original `if (logger.isWarnEnabled())` block now only executes if the exceptions match",
            "avg_logprobs": -0.29206501007080077
        }
    },
    {
        "commit_hash": "9728b8cefd1adb2ad92772a3015150eac19a5d7f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ReflectionUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (!Modifier.isAbstract(ifcMethod.getModifiers())) {\n+\t\t\t\tif (ifcMethod.isDefault()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use Method#isDefault to find default methods in interfaces",
        "commit_body": "Closes gh-31197\n",
        "linked_issues": [
            {
                "issue_id": "31197",
                "issue_title": "Use `Method#isDefault` to find default methods in interfaces",
                "issue_body": "Use `Method#isDefault` to replace the logic in `ReflectionUtils#findConcreteMethodsOnInterfaces`.\r\n\r\n- see #31198 ",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `main`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a check for `Modifier.isAbstract` with a check for `ifcMethod.isDefault()`.  This suggests a refactoring to handle default methods differently.  The original check likely determined if a method was abstract, while the new check targets methods with default implementations in interfaces",
            "avg_logprobs": -0.2660462061564128
        }
    },
    {
        "commit_hash": "976d32fc5943a11668b12e83621feaa197677ec4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (msg != null && msg.startsWith(event.getClass().getName())) {\n+\t\t\t\tif (msg == null || msg.startsWith(event.getClass().getName())) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SimpleApplicationEventMulticaster defensively swallows ClassCastException without message",
        "commit_body": "Issue: SPR-15145\n",
        "linked_issues": [
            {
                "issue_id": "19711",
                "issue_title": "SimpleApplicationEventMulticaster should not rely on ClassCastException having a message [SPR-15145]",
                "issue_body": "**[Mariusz Luciow](https://jira.spring.io/secure/ViewProfile.jspa?name=mariusz.luciow)** opened **[SPR-15145](https://jira.spring.io/browse/SPR-15145?redirect=false)** and commented\n\nSimpleApplicationEventMulticaster in [this commit](https://github.com/spring-projects/spring-framework/commit/13001b9affad668479ebdb924f2bd491745232a8#diff-2434dcbaad29ced6a104bb6523c4f67e) driven by #19412 changed the **ClassCastException** catch logic to:\n\n```java\ncatch (ClassCastException ex) {\n  if (ex.getMessage().startsWith(event.getClass().getName())) {\n    // Possibly a lambda-defined listener which we could not resolve the generic event type for\n    LogFactory.getLog(getClass()).debug(\"Non-matching event type for listener: \" + listener, ex);\n  } else {\n    throw ex;\n  }\n}\n```\n\nNote that if **ex.getMessage()** returns NULL whole method will throw NPE.\n\nTo speed up execution of methods that frequently throw exceptions, the C2 compiler generates code that uses a pre-built exception (pre-built at compile time). The pre-built exception does not contain neither a stack trace nor a message detailing the exception.\n\nThis means that after some time the compiler can replace normal ClassCastException with empty one, without message nor stack trace.\n\nMore detailed explanation of this behaviour can be found here:\n* [openjdk jira](https://bugs.openjdk.java.net/browse/JDK-8169685?focusedCommentId=14024750&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14024750)\n* [oracle release notes](http://www.oracle.com/technetwork/java/javase/relnotes-139183.html)\n\nThere should be a check in place to ensure that message is not null.\n\n---\n\n**Affects:** 4.3.5\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/commit/13001b9affad668479ebdb924f2bd491745232a8#diff-2434dcbaad29ced6a104bb6523c4f67e\n\n**Issue Links:**\n- #19412 SimpleApplicationEventMulticaster should not generally suppress ClassCastException\n- #20393 SimpleApplicationEventMulticaster does not deal with lambda-defined listeners when ErrorHandler is set\n- #20981 Lambda error detection might not work on JDK 9\n- #21630 Classification of ClassCastExceptions doesn't work in JDK 11 (OpenJDK)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/976d32fc5943a11668b12e83621feaa197677ec4, https://github.com/spring-projects/spring-framework/commit/153fd82946c350a0c42be2dbd13774d5ee9ffc0c, https://github.com/spring-projects/spring-framework/commit/64d4afad9f3cd06d5b911aab9d0656974310a79c, https://github.com/spring-projects/spring-framework/commit/0655d73f8e249b5f053cc10fe36f2d258acad104\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch! Fixed in master and to be backported to 4.3.6.\n",
                    "**[Mariusz Luciow](https://jira.spring.io/secure/ViewProfile.jspa?name=mariusz.luciow)** commented\n\nHi Juergen,\n\nI'm not convinced if the check you've made is a good idea:\n\n```java\ncatch (ClassCastException ex) {\n  String msg = ex.getMessage();\n  if (msg != null && msg.startsWith(event.getClass().getName())) {\n    // Possibly a lambda-defined listener which we could not resolve the generic event type for\n    Log logger = LogFactory.getLog(getClass());\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Non-matching event type for listener: \" + listener, ex);\n    }\n  } else {\n    throw ex;\n  }\n}\n```\n\nCurrent behaviour will work only until compiler decides to start throwing pre-build exception. After that the catch logic will completely change, throwing exception instead of swallowing it, which may be even harder to debug.\nHonestly I'm not sure if this issue can be solved here. Maybe Spring should prohibit registration of **ApplicationListener<?>** and throw exceptions during startup instead? For example, the correct way to register listener could look like this, if possible:\n\n```java\n@Bean\n@EventListener(ContextRefreshedEvent.class)\nApplicationListener<ContextRefreshedEvent> contextRefreshedEventApplicationListener() {\n    return System.err::print;\n}\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point. It's actually closer to our intentions if we turn that check into `(msg == null || msg.startsWith(event.getClass().getName()))`, rather over-swallowing than under-swallowing, closer to how we had it originally. If there is some unrelated `ClassCastException` involved, developers are going to notice it on first appearance anyway. I'll do that right away.\n\nAs for other ways of identifying lambda-defined listeners, we got a few related JIRA tickets already. For the time being, we cannot change the rules there since we're in the middle of the 4.3.x line. I'm afraid we can only fine-tune the current approach.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change reverses the condition in the `if` statement.  The original code checked if `msg` was not null *and* started with the event class name.  The updated code checks if `msg` is either null *or* starts with the event class name.  This effectively negates the previous requirement that `msg` not be null",
            "avg_logprobs": -0.20292179107666017
        }
    },
    {
        "commit_hash": "977550f9560f6ce7670aae883261f412fbba02f4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tLifecycle bean = getBeanFactory().getBean(beanNameToCheck, Lifecycle.class);\n-\t\t\t\tif (bean != this) {\n-\t\t\t\t\tbeans.put(beanNameToRegister, bean);\n+\t\t\t\tObject bean = getBeanFactory().getBean(beanNameToCheck);\n+\t\t\t\tif (bean != this && bean instanceof Lifecycle) {\n+\t\t\t\t\tbeans.put(beanNameToRegister, (Lifecycle) bean);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Properly handle null bean instance in getLifecycleBeans",
        "commit_body": "Issue: SPR-16343\n",
        "linked_issues": [
            {
                "issue_id": "20890",
                "issue_title": "DefaultLifecycleProcessor throws BeanNotOfRequiredType for null beans (cause of NullBean instance cannot be converted) [SPR-16343]",
                "issue_body": "**[Stefan Mueller](https://jira.spring.io/secure/ViewProfile.jspa?name=stefan.mueller@zkb.ch)** opened **[SPR-16343](https://jira.spring.io/browse/SPR-16343?redirect=false)** and commented\n\nWhen initializing applications with null-beans of type `Lifecycle`, `DefaultLifecycleProcessor.getLifecycleBeans` throws a `BeanNotOfRequiredType` exception rather then ignoring null-beans like in previous spring versions.\n\n`DefaultLifecycleProcessor` should be fixed to not call the `ctx.getBean(name, type)` method but rather getBean(name) and check for type explicitely.\n\nReason/Background: In earlier versions of Spring the `ctx.getBean(name, type)` method returned null for null-beans. Since Spring 5, Spring returns the `NullBean` instance but that cannot be converted to required type.\n\nSee as well #20582, #20711 and #20889.\n\n---\n\n**Affects:** 5.0.2\n\n**Issue Links:**\n- #20889 BeanNotOfRequiredTypeException (NullBean instead of null) when calling ApplicationContext.getBean(name, type)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/977550f9560f6ce7670aae883261f412fbba02f4\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe can indeed do a manual `instanceof Lifecycle` check there in the subsequent `if` condition. Fixed for 5.0.3 now.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the retrieval and registration of `Lifecycle` beans.  Previously, a `getBean` call was explicitly typed to `Lifecycle`.  Now, it retrieves the bean as an `Object`, then checks if it's both not `this` *and* an instance of `Lifecycle`.  If both conditions are true, it casts the `Object` to `Lifecycle` and registers it.  This change improves type safety and potentially reduces unnecessary casts",
            "avg_logprobs": -0.1892189628199527
        }
    },
    {
        "commit_hash": "980f971236eb496008a6f8f9c657180c0974d47b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/SelectedValueComparator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (boundValue.getClass().isEnum()) {\n+\t\tif (boundValue != null && boundValue.getClass().isEnum()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SelectedValueComparator defensively handles null values in exhaustiveCompare",
        "commit_body": "Issue: SPR-12001\n",
        "linked_issues": [
            {
                "issue_id": "16617",
                "issue_title": "NPE in SelectedValueComparator with null bound value [SPR-12001]",
                "issue_body": "**[Sebastian Anzani](https://jira.spring.io/secure/ViewProfile.jspa?name=sebastiananzani)** opened **[SPR-12001](https://jira.spring.io/browse/SPR-12001?redirect=false)** and commented\n\nIn case the collection, used to preselect checkboxes values, contains some null values  the following exception is thrown:\n\n```\njava.lang.NullPointerException\n\torg.springframework.web.servlet.tags.form.SelectedValueComparator.exhaustiveCompare(SelectedValueComparator.java:151)\n\torg.springframework.web.servlet.tags.form.SelectedValueComparator.exhaustiveCollectionCompare(SelectedValueComparator.java:140)\n\torg.springframework.web.servlet.tags.form.SelectedValueComparator.collectionCompare(SelectedValueComparator.java:112)\n\torg.springframework.web.servlet.tags.form.SelectedValueComparator.isSelected(SelectedValueComparator.java:89)\n\torg.springframework.web.servlet.tags.form.AbstractCheckedElementTag.isOptionSelected(AbstractCheckedElementTag.java:61)\n\torg.springframework.web.servlet.tags.form.AbstractCheckedElementTag.renderFromValue(AbstractCheckedElementTag.java:51)\n\torg.springframework.web.servlet.tags.form.AbstractCheckedElementTag.renderFromValue(AbstractCheckedElementTag.java:40)\n\torg.springframework.web.servlet.tags.form.CheckboxTag.writeTagDetails(CheckboxTag.java:90)\n\torg.springframework.web.servlet.tags.form.AbstractSingleCheckedElementTag.writeTagContent(AbstractSingleCheckedElementTag.java:87)\n\torg.springframework.web.servlet.tags.form.CheckboxTag.writeTagContent(CheckboxTag.java:53)\n\torg.springframework.web.servlet.tags.form.AbstractFormTag.doStartTagInternal(AbstractFormTag.java:84)\n\torg.springframework.web.servlet.tags.RequestContextAwareTag.doStartTag(RequestContextAwareTag.java:80)\n\torg.apache.jsp.page1_jsp._jspx_meth_form_005fcheckbox_005f0(page1_jsp.java:1505)\n```\n\n\n\n---\n\n**Affects:** 3.2.10, 4.0.5, 4.0.6\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/a3ebf135798bc9c27c3fb757d962666db4618862, https://github.com/spring-projects/spring-framework/commit/5f77dce1eeb28e9e1965c0d07046f0c4038617da, https://github.com/spring-projects/spring-framework/commit/980f971236eb496008a6f8f9c657180c0974d47b\n\n**Backported to:** [3.2.11](https://github.com/spring-projects/spring-framework/milestone/99?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSelectedValueComparator defensively handles null values in exhaustiveCompare now. This will be in the upcoming 4.1 RC1; to be backported to 4.0.7 and 3.2.11 as well.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for `boundValue` before checking if it's an enum type.  Previously, attempting to call `boundValue.getClass().isEnum()` on a null `boundValue` would have thrown a `NullPointerException`.  The addition of `boundValue != null` prevents this exception",
            "avg_logprobs": -0.056665236299688164
        }
    },
    {
        "commit_hash": "9820e3341d8691eddcadc0adc33e2a90bde1b37e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/aot/InstanceSupplierCodeGenerator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (accessVisibility == Visibility.PUBLIC\n-\t\t\t\t|| accessVisibility == Visibility.PACKAGE_PRIVATE) {\n+\t\tif (accessVisibility != Visibility.PRIVATE) {\n-\t\tif (accessVisibility == Visibility.PUBLIC\n-\t\t\t\t|| accessVisibility == Visibility.PACKAGE_PRIVATE) {\n+\t\tif (accessVisibility != Visibility.PRIVATE) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix handling of protected visibility",
        "commit_body": "Previously, InstanceSupplierCodeGenerator used reflection if the target\nvisibility is either protected or private, and use direct access if the\ntarget visibility is public or package private.\n\nThe previous arrangement already assumed that the code is generateed in\nthe same package as the target type. This means that protected can be\nused as well so this commit only use reflection if the target visibility\nis private.\n\nCloses gh-29253\n",
        "linked_issues": [
            {
                "issue_id": "29253",
                "issue_title": "Code generator should not use reflection for protected artifacts",
                "issue_body": "Right now we assume that the generated code is in the same package of the target object. If the visibility is public or package private, then we generate code that uses the members directly. If they are protected or private, we use reflection.\r\n\r\nWe don't need to use reflection for protected cases as those members can be access within the same package.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional logic for `accessVisibility`.  It replaces a check for `PUBLIC` or `PACKAGE_PRIVATE` with a check for *not* `PRIVATE`. This results in a more concise and potentially slightly faster check.  The original code had redundant checks",
            "avg_logprobs": -0.19152062514732623
        }
    },
    {
        "commit_hash": "9877a9e6b7d299dc32a447340bbbd0ee6a1076b5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tallInterceptors.addAll(Arrays.asList(specificInterceptors));\n+\t\t\tif (specificInterceptors.length > 0) {\n+\t\t\t\t// specificInterceptors may equals PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS\n+\t\t\t\tallInterceptors.addAll(Arrays.asList(specificInterceptors));\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduce memory consumption",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to prevent unnecessary copying of interceptors.  Previously, `specificInterceptors` were always added to `allInterceptors`.  Now, if `specificInterceptors` is empty, the addition is skipped, improving efficiency.  The code now gracefully handles the case where `specificInterceptors` might be an empty array or `PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS`",
            "avg_logprobs": -0.15215186374943432
        }
    },
    {
        "commit_hash": "988aae4f2e41ee4d23e827c09095cde1fc07d201",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tMethod key = method;\n-\t\t\t\tif (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(key)) {\n+\t\t\t\tif (isStatic && isFrozen && this.fixedInterceptorMap.containsKey(method)) {\n-\t\t\t\t\tint index = this.fixedInterceptorMap.get(key);\n+\t\t\t\t\tint index = this.fixedInterceptorMap.get(method);",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unnecessary variable declaration in ProxyCallbackFilter",
        "commit_body": "Closes gh-24675",
        "linked_issues": [
            {
                "issue_id": "24675",
                "issue_title": "Remove unnecessary variable declaration in ProxyCallbackFilter",
                "issue_body": "The var `key` declaration seems unnecessary. Suggest remove it. ",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change simplifies the lookup of an `index` from the `fixedInterceptorMap` by directly using the `method` object instead of creating a new `Method` object.  Previously, a new `Method` object (`key = method;`) was created, and then used for the map lookup.  The updated code now uses the `method` object itself for the lookup, eliminating the unnecessary object creation. This change improves efficiency by avoiding the overhead of creating a new `Method` object.",
            "avg_logprobs": -0.2450567626953125
        }
    },
    {
        "commit_hash": "990a9c74b93b3124dae554e6246b9b75504a5d23",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tint slashIndex = requestUri.indexOf('/', semicolonIndex);\n-\t\t\tif (slashIndex >= 0) {\n-\t\t\t\tsb.delete(semicolonIndex, slashIndex);\n+\t\t\tint slashIndex = requestUri.indexOf('/', semicolonIndex + 1);\n+\t\t\tif (slashIndex == -1) {\n+\t\t\t\tslashIndex = sb.length();\n+\t\t\tsb.delete(semicolonIndex, slashIndex);",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Restore removal of trailing semicolon content",
        "commit_body": "See gh-26012\n",
        "linked_issues": [
            {
                "issue_id": "26012",
                "issue_title": "Improve URI/query strings sanitization",
                "issue_body": "Use `StringBuilder.deleteCharAt(int)` and `StringBuilder.delete(int, int)` to handle sanitization more effectively",
                "issue_state": "closed",
                "issue_comment": [
                    "@rstoyanchev done.\r\n\r\nI've also measured performance impact with simple benchmark\r\n```java\r\n@BenchmarkMode(Mode.AverageTime)\r\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\n@Fork(jvmArgsAppend = {\"-Xms2g\", \"-Xmx2g\"})\r\npublic class DropDoubleSlashBenchmark {\r\n\r\n  @Benchmark\r\n  public String ineffective(Data data) {\r\n    String path = data.path;\r\n    while (true) {\r\n      int index = path.indexOf(\"//\");\r\n      if (index == -1) {\r\n        break;\r\n      }\r\n      path = path.substring(0, index) + path.substring(index + 1);\r\n    }\r\n    return path;\r\n  }\r\n\r\n  @Benchmark\r\n  public String effective(Data data) {\r\n    StringBuilder path = new StringBuilder(data.path);\r\n    while (true) {\r\n      int index = path.indexOf(\"//\");\r\n      if (index == -1) {\r\n        break;\r\n      }\r\n      path.deleteCharAt(index);\r\n    }\r\n    return path.toString();\r\n  }\r\n\r\n  @State(Scope.Thread)\r\n  public static class Data {\r\n    private final String path = \"/home/\" + \"/path\";\r\n  }\r\n}\r\n```\r\nand got the following results on my machine\r\n```\r\nJDK 8\r\n\r\neffective                          avgt    47.882 \u00b1   1.801   ns/op\r\nineffective                        avgt    51.620 \u00b1   0.907   ns/op\r\neffective:\u00b7gc.alloc.rate.norm      avgt   136.000 \u00b1   0.001    B/op\r\nineffective:\u00b7gc.alloc.rate.norm    avgt   224.000 \u00b1   0.001    B/op\r\n\r\nJDK 11\r\n\r\neffective                          avgt    33.949 \u00b1   0.188   ns/op\r\nineffective                        avgt    47.735 \u00b1   0.519   ns/op\r\neffective:\u00b7gc.alloc.rate.norm      avgt   104.000 \u00b1   0.001    B/op\r\nineffective:\u00b7gc.alloc.rate.norm    avgt   152.000 \u00b1   0.001    B/op\r\n```\r\nOn longer strings I think we'll have even better improvement."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of path segments in a URL.  The original code searched for the next forward slash (`/`) after a semicolon (`;`).  The updated code now searches for the next forward slash after the semicolon *plus one*.  Crucially, it now handles the case where no forward slash is found after the semicolon by setting `slashIndex` to the end of the string (`sb.length()`). This prevents an exception or incorrect deletion if no slash follows the semicolon.",
            "avg_logprobs": -0.23556129455566407
        }
    },
    {
        "commit_hash": "99399084a6b1960d152ee46aa59da5304a019439",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/concurrent/ExecutorConfigurationSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import java.util.concurrent.Future;\n- * Base class for classes that are setting up a\n- * {@code java.util.concurrent.ExecutorService}\n- * (typically a {@link java.util.concurrent.ThreadPoolExecutor}).\n+ * Base class for setting up a {@link java.util.concurrent.ExecutorService}\n+ * (typically a {@link java.util.concurrent.ThreadPoolExecutor} or\n+ * {@link java.util.concurrent.ScheduledThreadPoolExecutor}).\n+ * @see java.util.concurrent.ScheduledThreadPoolExecutor\n-\t * @param task the task to cancel (potentially a {@link RunnableFuture})\n+\t * @param task the task to cancel (typically a {@link RunnableFuture})\n-\t\tif (task instanceof RunnableFuture) {\n-\t\t\t((RunnableFuture<?>) task).cancel(true);\n+\t\tif (task instanceof Future) {\n+\t\t\t((Future<?>) task).cancel(true);",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Consistent Future check (even if typically encountering RunnableFuture)",
        "commit_body": "Issue: SPR-16607\n",
        "linked_issues": [
            {
                "issue_id": "21148",
                "issue_title": "ThreadPoolTaskExecutor should cancel all remaining Future handles on shutdown [SPR-16607]",
                "issue_body": "**[Nicolas Labrot](https://jira.spring.io/secure/ViewProfile.jspa?name=nithril)** opened **[SPR-16607](https://jira.spring.io/browse/SPR-16607?redirect=false)** and commented\n\n`ThreadPoolTaskExecutor#submitListenable` returns a future that will not be canceled when the executor is `shutdown`. By consequence `Future#get` will block indefinitely.\n\nI would like to propose that the list of `Runnable` returned by `this.executor.shutdownNow();` is used to cancel the `ListenableFuture`.\n\n---\n\n**Affects:** 5.0.4\n\n**Issue Links:**\n- #21079 DefaultMessageListenerContainer should interrupt worker threads when not returning on shutdown\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/3c1adf7f6af0dff9bda74f40dabe8cf428a62003, https://github.com/spring-projects/spring-framework/commit/99399084a6b1960d152ee46aa59da5304a019439\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis seems to apply not only to `submitListenable` but also to regular `submit` calls: All such tasks remain uncancelled if not executed yet and therefore returned from `shutdownNow`. It looks like we should generally cancel all such remaining `Future` tasks at that point.\n",
                    "**[Nicolas Labrot](https://jira.spring.io/secure/ViewProfile.jspa?name=nithril)** commented\n\n+1.\n\nYou may have note that the `TaskDecorator` may break the logic. A `FutureTaskAwareTaskDecorator` helper that decorate and still returns a `FutureTask` may be interesting.\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, we need to track decorated tasks in order to cancel the user-level `Future` handles if necessary. We're using a weak `ConcurrentReferenceHashMap` to track those while active: but only if actually necessary, i.e. if a `TaskDecorator` is configured and returns a different `Runnable` for a given task, avoiding any unnecessary storage of such task handles.\n\nA similar problem arises in `ThreadPoolTaskScheduler` where user-level `ListenableFuture` handles are covered by a `ScheduledFutureTask` at runtime. We're tracking the user-level handles in the same way there, delivering consistent behavior for `submitListenable` next to plain `submit` calls (both of which are unusual on a `ThreadPoolTaskScheduler` in any case).\n",
                    "**[Nicolas Labrot](https://jira.spring.io/secure/ViewProfile.jspa?name=nithril)** commented\n\nThank you. I will be able to reuse it for a project using Spring 4.3.\n\nIn `ExecutorConfigurationSupport#cancelRemainingTask` is it normal to instanceof on `RunnableFuture` but in `ThreadPoolTaskExecutor#cancelRemainingTask` instanceof on `Future` ?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point, even if `ExecutorConfigurationSupport` is always going to see a `RunnableFuture` with the current `java.util.concurrent` implementation (since the incoming parameter is a raw `Runnable` returned from `shutdownNow`), I've relaxed that check to just `Future` so that it looks consistent with the subclass.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ExecutorConfigurationSupport` broadens the supported executor types from just `ThreadPoolExecutor` to include `ScheduledThreadPoolExecutor`.  It also modifies the `cancel` method to handle `Future` objects instead of just `RunnableFuture` objects, reflecting the broader scope of executor types now supported.  This change likely improves the flexibility and applicability of the base class",
            "avg_logprobs": -0.21746754336666752
        }
    },
    {
        "commit_hash": "99d9dacc4f6a95220ebe90455dac6410f2ffa649",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\telse if (logger.isWarnEnabled()) {\n+\t\t\t\t\tlogger.debug(\"Terminating '\" + session + \"': \" + ex.getMessage());\n+\t\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log sendBufferSizeLimit exceeded at warn",
        "commit_body": "Closes gh-23534\n",
        "linked_issues": [
            {
                "issue_id": "23534",
                "issue_title": "sendBufferSizeLimit exceeded should be logged at warn level",
                "issue_body": "SubProtocolWebSocketHandler catches SessionLimitExceededException exceptions, logs them at debug level and closes the session. The client sees a randomly closed socket and there is nothing in the server logs. These exceptions should be logged as a warning as they indicate a serious issue with the application that needs to be addressed.\r\n\r\n    catch (SessionLimitExceededException ex) {\r\n        try {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Terminating '\" + session + \"'\", ex);\r\n\t    }\r\n            this.stats.incrementLimitExceededCount();\r\n            clearSession(session, ex.getStatus()); // clear first, session may be unresponsive\r\n            session.close(ex.getStatus());\r\n\r\n[SubProtocolWebSocketHandler.java](https://github.com/spring-projects/spring-framework/blob/14558844bc4dba5586f6f9e27731bf52e802dcc5/spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java#L368-L379)",
                "issue_state": "closed",
                "issue_comment": [
                    "> the client sees a randomly closed socket\r\n\r\nThe session should be getting closed with an [error status](https://github.com/spring-projects/spring-framework/blob/bba3553dfb2561b9e779a6ca13b080c12b5940b1/spring-websocket/src/main/java/org/springframework/web/socket/CloseStatus.java#L136-L143). Is that not the case? \r\n\r\nWhen this error occurs, the idea is that the server is far behind in writing and the client may have become even unreachable. That said it's true on the server side we can at least log a one line message at warn level.",
                    "Yes the client does get an error status but its not easy to figure out why from that alone. I had to grep the Spring source code for the error number. Would have been much easier if there had been a warning in the server logs. Tx."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new `else if` block to the existing conditional logic.  If logging is enabled at the warn level, it now logs a debug message containing the session and exception message.  This suggests a refinement in the logging strategy, potentially to provide more detailed information in warning scenarios",
            "avg_logprobs": -0.23202009201049806
        }
    },
    {
        "commit_hash": "99dc96b1a47394740b0db4bf15e67d9abd27a25a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/ResourceHttpMessageConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "- * Implementation of {@link HttpMessageConverter} that can read and write {@link Resource Resources}\n+ * Implementation of {@link HttpMessageConverter} that can read/write {@link Resource Resources}\n- *\n+\n-\t * Create a new instance of the {@code ResourceHttpMessageConverter}\n+\t * Create a new instance of the {@code ResourceHttpMessageConverter}.\n-\t * read streaming, i.e. convert to {@code InputStreamResource}.\n+\t * read streaming, i.e. convert to {@code InputStreamResource}\n-\t\tif (supportsReadStreaming && InputStreamResource.class == clazz) {\n+\t\tif (this.supportsReadStreaming && InputStreamResource.class == clazz) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ResourceHttpMessageConverter` removes unnecessary comments and slightly refactors the Javadoc.  Specifically, the Javadoc for the constructor is made more concise and consistent in style.  The most significant change is the removal of a blank line in the Javadoc, and a minor stylistic change in the `if` statement condition, replacing `supportsReadStreaming` with `this.supportsReadStreaming`.  No changes were made to the conditional logic itself",
            "avg_logprobs": -0.2980260347065173
        }
    },
    {
        "commit_hash": "9a513cfdea9020c6ed2cf3f37711ed4e31d7c310",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\telse {\n+\t\telse if (void.class == returnType) {\n+\t\telse {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Invalid return type for async method (only Future and void supported): \" + returnType);\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Enforce Future/void return declaration for async methods",
        "commit_body": "Closes gh-27734\n",
        "linked_issues": [
            {
                "issue_id": "27734",
                "issue_title": "Enforce Future or void return declaration for each asynchronously executed method (e.g. with class-level @Async)",
                "issue_body": "https://github.com/spring-projects/spring-framework/blob/79d3f5c64c94a356831916ec78be4296fba92b18/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java#L113-L127\r\n\r\nI have found an odd behaviour working with `@Async`-annotated classes in Spring. Please note that **there is** a fundamental error in my code. Unfortunately, this post has to be long and detailed.\r\n\r\nLet's say I have already made a synchronous REST API generated by Swagger generator. Following code omits all documentation-level annotations\r\n\r\n```java\r\n\r\npublic interface TaxonomiesApi {\r\n   \r\n    ResponseEntity<GenericTaxonomyItem> disableItem(Integer idTaxonomyType, String idTaxonomy, String appSource);\r\n\r\n}\r\n```\r\n\r\nThis API is easily implemented via `RestTemplate`, but I won't discuss the inner details.\r\n\r\nNow, suppose I want to provide an async version to developers consuming the API. What I have done is to create another interface with some search&replace-fu \ud83e\udd4b\ud83e\udd4b\r\n\r\n```java\r\n@Async\r\npublic interface TaxonomiesApiAsync extends TaxonomyApi {\r\n   \r\n    default CompletableFuture<ResponseEntity<GenericTaxonomyItem>> disableItemAsync(Integer idTaxonomyType, String idTaxonomy, String appSource) {\r\n        try {\r\n            return completedFuture(this.disableItem(idTaxonomyType, idTaxonomy, appSource));\r\n        } catch (Exception ex) {\r\n            return failedFuture(ex);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWith the search&replace, I basically created an async-ish version of every method that should be backed by Spring's `@Async` annotation. My original idea was that synchronous methods can be invoked as they are, but if you instantiate `TaxonomiesApiAsync` you also have access to the async version.\r\n\r\nI have discovered I made **a fundamental mistake** by applying the `@Async` annotation at interface level when the class contains both sync and async methods. I found that synchronous `disableItem` was performed in the same `@Async` context. Accoding to design (correctly), Spring found the `@Async` annotation at interface level so **every method**, including inherited ones, was invoked asynchronously.\r\n\r\nBut the method always returned null. By debugging and looking at the code, I found that Spring tries to resolve the return value of the invoked method **only** if it's a `Future`. What if the returned value is a _Present_ object?\r\n\r\nThat means that if the returned value is not a `Future<ResponseEntity<GenericTaxonomyItem>>` but rather just a `ResponseEntity<GenericTaxonomyItem>` Spring neither throws an exception nor returns that value directly.\r\n\r\nExample of working calling code (invoking a different method)\r\n\r\n```java\r\n    protected CompletableFuture<Set<TaxonomyLegalEntityDTO>> importTaxonomyLegalEntities(int userId) {\r\n        TaxonomySearchParameters searchParameters = new TaxonomySearchParameters();\r\n        searchParameters.setIdTaxonomyType(amlcProperties.getTaxonomies().getTaxonomyLegalEntitiesId());\r\n        searchParameters.setLogicalState(1);\r\n        return taxonomiesApiAsync.getAllTaxonomyItemsAsync(searchParameters)\r\n                .thenApply(ResponseEntity::getBody)\r\n                .thenApply(taxonomyLegalEntityMasterDbMapping::toLegalEntity) // Costruisco i DTO che voglio utilizzare\r\n                .whenComplete(traceLoggerConsumer(\"Legal entity\"))\r\n                .thenApply(dtos -> taxonomyLegalEntityManager.mergeFromMasterDb(dtos, userId))\r\n                .whenComplete((ignored, ex) -> {\r\n                    if (ex != null)\r\n                        log.error(\"Error importing legal entities: \" + ex.getMessage(), ex);\r\n                })\r\n                .thenApply(TaxonomyMasterDbMergeDTO::getSnapshot);\r\n    }\r\n```\r\n\r\nExample of non-working code; the result of the CompletableFuture is always null.\r\nIn this code, I decided not to use the executor _embedded_ in the API service, but rather the executor injected in the consuming service. So I ran a sync method in an executor, expecting the same result.\r\n\r\n```java\r\n    protected CompletableFuture<Set<TaxonomyLegalEntityDTO>> importTaxonomyLegalEntities(int userId) {\r\n        TaxonomySearchParameters searchParameters = new TaxonomySearchParameters();\r\n        searchParameters.setIdTaxonomyType(amlcProperties.getTaxonomies().getTaxonomyLegalEntitiesId());\r\n        searchParameters.setLogicalState(1);\r\n        return CompletableFuture.supplyAsync(() -> taxonomiesApi.getAllTaxonomyItems(searchParameters), taxonomyBatchImportServiceExecutor)\r\n                .thenApply(ResponseEntity::getBody)\r\n                .thenApply(taxonomyLegalEntityMasterDbMapping::toLegalEntity)\r\n                .whenComplete(traceLoggerConsumer(\"Legal entity\"))\r\n                .thenApplyAsync(dtos -> taxonomyLegalEntityManager.mergeFromMasterDb(dtos, userId))\r\n                .whenComplete((ignored, ex) -> {\r\n                    if (ex != null)\r\n                        log.error(\"Error importing legal entities: \" + ex.getMessage(), ex);\r\n                })\r\n                .thenApply(TaxonomyMasterDbMergeDTO::getSnapshot);\r\n    }\r\n```\r\n\r\n\r\nSince I spent one hour debugging that problem, I decided to spend more of my after-work time to document the issue here.\r\n\r\n**Proposed fix**\r\n\r\nIn the code I linked, if the `instanceof` check fails the returned value is simply null. I don't yet understand the implications, but what about not unwrapping the value from Future if that's not a future? I mean `return result`",
                "issue_state": "closed",
                "issue_comment": [
                    "> In terms of target method signatures, any parameter types are supported. However, the return type is constrained to either `void` or `Future`. In the latter case, you may declare the more specific `ListenableFuture` or `CompletableFuture` types which allow for richer interaction with the asynchronous task and for immediate composition with further processing steps.\r\n\r\nThe documentation states the limitations in the return types only `void` or `Future`. It doesn't really make sense to allow for a return of a specific type as that would make the method call synchronous again as one would need to do a `Future.get` which is blocking and thus renders the `@Async` useless. \r\n\r\nSo I the return type isn't a `Future` it can return `null` because the other allowed return value is `void`. \r\n\r\nAs a solution an exception would be better imho with a clear message stating that only `void` or `Future` is supported as a return type. ",
                    "As the documentation states and as @mdeinum pointed out, the return type must `Future` or `void`, or otherwise the calling code has to block anyway, making it pointless to involve an Executor thread, and making asynchronous methods that are meant to be synchronous.\r\n\r\nI think this can be closed, unless @jhoeller you see some opportunity to bypass methods that don't return void or Future.\r\n",
                    "I'm inclined to explicitly throw an exception for non-Future/void return type declarations whenever we attempt to execute a method asynchronously. While this may not be much of an issue with an explicit annotated method, a class-level `@Async` declaration is certainly harder to track when some specific method mismatches then.",
                    "Noob question @jhoeller since I assume you systematically do an instanceof/reflection check, and that *could* incur a slowdown, wouldn't it be better to have this check only enabled on dev/debug mode et disabled on release mode? ",
                    "@LifeIsStrange as you can see in the code, what is done is a `==` check on the `returnType`, which is already available (already reflected). So, it's not going to add any overhead.\r\n\r\nAs for your question about the `instanceof` performance, I found an [interesting reading](https://stackoverflow.com/questions/103564/the-performance-impact-of-using-instanceof-in-java) and the **tl;dr** says\r\n\r\n> In Java 1.8 instanceof is the fastest approach, although getClass() is very close.\r\n\r\nNevertheless, it doesn't apply to this fix."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new `else if` condition to the existing `else` block.  This new condition checks if the `returnType` is `void.class`.  If it is, the original `else` block's behavior is maintained.  Otherwise, an `IllegalArgumentException` is thrown, indicating that the return type is not supported (only `Future` and `void` are allowed)",
            "avg_logprobs": -0.13539909362792968
        }
    },
    {
        "commit_hash": "9a618dc7a1527ac02fff9fd1385a277ebd3736ed",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/filter/ShallowEtagHeaderFilter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!isAsyncDispatch(request) && !(response instanceof ContentCachingResponseWrapper)) {\n+\t\tif (!isAsyncDispatch(request) && !(response instanceof ConditionalContentCachingResponseWrapper)) {\n-\n-\t\tContentCachingResponseWrapper wrapper =\n-\t\t\t\tWebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);\n-\n+\t\tConditionalContentCachingResponseWrapper wrapper =\n+\t\t\t\tWebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);\n-",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Enforce ConditionalContentCachingResponseWrapper in ShallowEtagHeaderFilter",
        "commit_body": "Closes gh-24976\n",
        "linked_issues": [
            {
                "issue_id": "24976",
                "issue_title": "Don't get ContentCachingResponseWrapper in ShallowEtagHeaderFilter so that users can extend this wrapper",
                "issue_body": "Issue Description:\r\nCode in `ShallowEtagHeaderFilter`:\r\n[`WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);`](https://github.com/spring-projects/spring-framework/blob/c237338d8f4b0100c8432c48acc2cabc8305a651/spring-web/src/main/java/org/springframework/web/filter/ShallowEtagHeaderFilter.java#L116)\r\nshould be replaced into \r\n`WebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);` so that users can implement their own business logic based on `ContentCachingResponseWrapper`.\r\n\r\nChange `ContentCachingResponseWrapper` to `ConditionalContentCachingResponseWrapper` so that it gets the right one.\r\n```\r\nprivate void updateResponse(HttpServletRequest request, HttpServletResponse response) throws IOException {\r\n\r\n\tContentCachingResponseWrapper wrapper = \r\n// WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);\r\n   WebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);\r\n\r\n\t\tAssert.notNull(wrapper, \"ContentCachingResponseWrapper not found\");\r\n\t\tHttpServletResponse rawResponse = (HttpServletResponse) wrapper.getResponse();\r\n\r\n\t\tif (isEligibleForEtag(request, wrapper, wrapper.getStatus(), wrapper.getContentInputStream())) {\r\n\t\t\tString eTag = wrapper.getHeader(HttpHeaders.ETAG);\r\n\t\t\tif (!StringUtils.hasText(eTag)) {\r\n\t\t\t\teTag = generateETagHeaderValue(wrapper.getContentInputStream(), this.writeWeakETag);\r\n\t\t\t\trawResponse.setHeader(HttpHeaders.ETAG, eTag);\r\n\t\t\t}\r\n\t\t\tif (new ServletWebRequest(request, rawResponse).checkNotModified(eTag)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twrapper.copyBodyToResponse();\r\n\t}\r\n```\r\n\r\nI have implemented my own Filter, and in my own Filter, i have implemented my own ResponseWrapper which extends `ContentCachingResponseWrapper`, everything works fine if `ShallowEtagHeaderFilter` is not loaded, but when it works with `ShallowEtagHeaderFilter`, when `ShallowEtagHeaderFilter.updateResponse` is invoked, the real HttpServletResponse get through `WebUtils.getNativeResponse(response, ContentCachingResponseWrapper.class);` become my own ResponseWrapper, so my own logic will be invoked inside `ShallowEtagHeaderFilter`, which is a mistake. \r\nBy changing the code to `WebUtils.getNativeResponse(response, ConditionalContentCachingResponseWrapper.class);`, everything will be fine.\r\n\r\n\r\n**Affects:** \\<5.2.5.RELEASE and others>\r\n\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `ShallowEtagHeaderFilter` to use `ConditionalContentCachingResponseWrapper` instead of `ContentCachingResponseWrapper`.  This change affects the conditional logic that determines whether to wrap the response object.  Previously, a `ContentCachingResponseWrapper` was used; now, a `ConditionalContentCachingResponseWrapper` is used if the response is not an asynchronous dispatch and not already a `ContentCachingResponseWrapper`",
            "avg_logprobs": -0.19736040115356446
        }
    },
    {
        "commit_hash": "9a722b4558ca7985fb54a06ff76e3934abe898cb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {\n+\t\tif (sqlType == SqlTypeValue.TYPE_UNKNOWN || (sqlType == Types.OTHER && typeName == null)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Pass type name into PreparedStatement.setNull in case of Types.OTHER",
        "commit_body": "Issue: SPR-16669\n",
        "linked_issues": [
            {
                "issue_id": "21210",
                "issue_title": "Unable to bind a null value for UUID column with PostgreSQL [SPR-16669]",
                "issue_body": "**[R\u00e9mi Aubel](https://jira.spring.io/secure/ViewProfile.jspa?name=r%C3%A9mi)** opened **[SPR-16669](https://jira.spring.io/browse/SPR-16669?redirect=false)** and commented\n\nPostgreSQL database defines the type UUID (this type does not exist in `java.sql.Types`).\n\nI want to use this kind of PreparedStatement:\n\n```\nSELECT ... WHERE :VAL IS NOT NULL AND :VAL = <my_uuid_column>\n```\n\nAnd I want to bind a null value for `VAL`.\nIn this specific case, PostgreSQL JDBC driver requires the data type to be specified. And since the UUID data type does not exist in `java.sql.Types`, we must specify the type name as well, by calling `PreparedStatement.setNull(\\_, java.sql.Types.OTHER, \"uuid\")`.\nWith plain old java (`Connection` and `PreparedStatement`), this works fine.\n\nUsing `NamedParameterJdbcTemplate` (and providing the \"data type\" and \"data type name\" in a `MapSqlParameterSource`), I'm not able to make it work.\nUnder the hood, `StatementCreatorUtils.setNull(\\_, \\_, type, typeName)` delegates to `PreparedStatement.setNull(\\_, type)` (with no type name) when type is `Types.OTHER`.\n\nShouldn't it call `PreparedStatement.setNull(_, type, typeName)` when `typeName` is provided (non null) instead?\n\n---\n\n**Affects:** 4.3.14, 5.0.4\n\n**Issue Links:**\n- #13215 Can't insert into nvarchar2 using SimpleJdbcInsert whereas it works with SimpleJdbcTemplate\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9a722b4558ca7985fb54a06ff76e3934abe898cb, https://github.com/spring-projects/spring-framework/commit/5629fa2c9f94ed43aedfd87181164fcbc154fffc\n\n**Backported to:** [4.3.15](https://github.com/spring-projects/spring-framework/milestone/164?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis seems to be a regression introduced in Spring Framework 4.1 (#13215). I'll revise this for the upcoming 5.0.5 and 4.3.14 releases.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've resolved this through not entering our fallback block in case of `Types.OTHER` with a non-null `typeName`, going to the usual `PreparedStatement.setNull` variant with a type name again.\n",
                    "**[R\u00e9mi Aubel](https://jira.spring.io/secure/ViewProfile.jspa?name=r%C3%A9mi)** commented\n\nThank you very much!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `if` statement.  Previously, it checked if `sqlType` was `SqlTypeValue.TYPE_UNKNOWN` or `Types.OTHER`.  The modification now requires that `typeName` be `null` in addition to `sqlType` being `Types.OTHER` for the condition to be true.  This suggests a change in how `typeName` is used or handled in the surrounding code, potentially to handle cases where `Types",
            "avg_logprobs": -0.209482421875
        }
    },
    {
        "commit_hash": "9b3131ffbaa7a4bb312dfad66d685a348ee7e61f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/AbstractHttpMessageConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tAssert.notEmpty(supportedMediaTypes, \"'supportedMediaTypes' must not be empty\");\n+\t\tAssert.notEmpty(supportedMediaTypes, \"MediaType List must not be empty\");\n-\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n-\t * type was not provided, set if necessary the default character set, calls\n+\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a\n+\t * content type was not provided, set if necessary the default character set, calls\n-\t\tif (headers.getContentLength() < 0) {\n+\t\tif (headers.getContentLength() < 0 && !headers.containsKey(HttpHeaders.TRANSFER_ENCODING)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip default Content-Length if Transfer-Encoding header has been set",
        "commit_body": "Issue: SPR-15212\n",
        "linked_issues": [
            {
                "issue_id": "19776",
                "issue_title": "HTTP Response should not contain both Transfer-Encoding and Content-Length headers [SPR-15212]",
                "issue_body": "**[Stefanie Loiseleur](https://jira.spring.io/secure/ViewProfile.jspa?name=sloiseleur)** opened **[SPR-15212](https://jira.spring.io/browse/SPR-15212?redirect=false)** and commented\n\nDear Spring Framework Team,\n\nI'm currently building an MvcEndpoint in a SpringBoot Application to return the result of an Http GET call to another service. This service returns a JSON content, which has the header _Transfer-Encoding_ valued to \"chunked\".\n\nMy endpoint is then consumed by a Node.js server. This Node.js server returns a parse error with code _HPE_UNEXPECTED_CONTENT_LENGTH_ when consuming the endpoint, because the response headers contains both _Transfer-encoding:chunked_ and _Content-Length_ values.\n\nThis is considered has an error as specified in RFC 7230 section 3.3.3.3 :\n\n??If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length.  Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error.  A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.??\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.3\n\nThis header is added in org.springframework.http.converter.AbstractHttpMessageConverter.addDefaultHeaders at line 259 for the 4.3.3.RELEASE I'm using.\n\nI think the Content-Length header should be added only if the Transfer-Encoding header is not already set.\n\nDo you think AbstractHttpMessageConverter should be updated ?\n\nThank you all.\n\n---\n\n**Affects:** 4.3.3, 4.3.6\n\n**Issue Links:**\n- #17408 Make `@ResponseBody` method return type available to message converters\n- #18147 resttemplate multipart post with InputStreamResource not working\n- #21523 Spring adding 'chunked' transfer encoding even if this header already exists\n- #19826 HEAD response has \"Content-Length: 0\" for `@RestController` `@GetMapping` methods\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9b3131ffbaa7a4bb312dfad66d685a348ee7e61f, https://github.com/spring-projects/spring-framework/commit/d5daa8e3a70ebbe2f8fb429460c818a9e3958184\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point. I've revised `AbstractHttpMessageConverter.addDefaultHeaders` to only set the `Content-Length` header if no `Transfer-Encoding` header was set before.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the assertion message for an empty `supportedMediaTypes` list.  It replaces the generic \"must not be empty\" message with a more specific \"MediaType List must not be empty\".  Additionally, a conditional check (`if (headers.getContentLength() < 0 && !headers.containsKey(HttpHeaders.TRANSFER_ENCODING))`) has been added, which was likely previously part of a larger conditional block, and now appears as a standalone check",
            "avg_logprobs": -0.28353506088256836
        }
    },
    {
        "commit_hash": "9b615ed8c669c272530733b17d11b852fed8e3b9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/ReactorServerHttpRequest.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import io.netty.channel.Channel;\n-\t\tSslHandler sslHandler = ((Connection) this.request).channel().pipeline().get(SslHandler.class);\n+\t\tChannel channel = ((Connection) this.request).channel();\n+\t\tSslHandler sslHandler = channel.pipeline().get(SslHandler.class);\n+\t\tif (sslHandler == null && channel.parent() != null) { // HTTP/2\n+\t\t\tsslHandler = channel.parent().pipeline().get(SslHandler.class);\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix missing sslInfo with Reactor Netty and http/2",
        "commit_body": "Prior to this commit, the `SslInfo` would be missing for WebFlux apps\nwhen deployed on Reactor Netty with http/2.\n\nThis commit ensures that the request adapter checks the current channel\nand the parent channel for the presence of the `SslHander`.\nIn the case of http/2, the `SslHander` is tied to the parent channel.\n\nFixes gh-25278\n",
        "linked_issues": [
            {
                "issue_id": "25278",
                "issue_title": "ServerHttpRequest.getSslInfo() always returns null for reactor-netty HTTP/2 requests",
                "issue_body": "**Affects:** 5.2.7.RELEASE\r\n\r\n---\r\nReactorServerHttpRequest.initSslInfo() works only for HTTP1.1 requests\r\nbecause the code looks for SslHandler in the channel().pipeline().\r\n\r\nFor HTTP/2 request SslHandler is locate in the channel().parent().pipeline()\r\nExample how to access: Http2StreamBridgeHandler.channelRead() (reactor-netty)\r\n\r\nOr, maybe, you have some other elegant solution?",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how an `SslHandler` is retrieved from a Netty `Channel`.  Previously, it directly accessed the `SslHandler` from the `channel` of the `Connection`.  The updated code now first checks if the `SslHandler` is null.  If it is, and the `channel` has a `parent`, it attempts to retrieve the `SslHandler` from the `parent` channel's pipeline",
            "avg_logprobs": -0.1624928283691406
        }
    },
    {
        "commit_hash": "9b662e8244905da618b96c9b73fa11f59d1ab343",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/client/JdkClientHttpRequest.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate final Duration timeOut;\n+\tprivate final Duration timeout;\n-\t\tthis.timeOut = readTimeout;\n+\t\tthis.timeout = readTimeout;\n-\t\tif (this.timeOut != null) {\n-\t\t\tbuilder.timeout(this.timeOut);\n+\t\tif (this.timeout != null) {\n+\t\t\tbuilder.timeout(this.timeout);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Typo",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `JdkClientHttpRequest` renames the `timeOut` field to `timeout` and updates all references accordingly.  This is a simple renaming of a variable used to store a `Duration` object representing a timeout.  The `if` statement checking for a non-null `timeOut` is updated to use the new `timeout` variable.  No functional change to the conditional logic or iteration constructs is present",
            "avg_logprobs": -0.2460992791679468
        }
    },
    {
        "commit_hash": "9b7a492bc95c8c1f3e3abfe055defa3722a0aa45",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/ReactiveAdapterRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (ClassUtils.isPresent(\"rx.Observable\", classLoader)) {\n+\t\tif (ClassUtils.isPresent(\"rx.Observable\", classLoader) &&\n+\t\t\t\tClassUtils.isPresent(\"rx.RxReactiveStreams\", classLoader)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Test RxReactiveStreams presence in ReactiveAdapterRegistry",
        "commit_body": "Issue: SPR-17000\n",
        "linked_issues": [
            {
                "issue_id": "21538",
                "issue_title": "Perform explicit class checks in ReactiveAdapterRegistry [SPR-17000]",
                "issue_body": "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** opened **[SPR-17000](https://jira.spring.io/browse/SPR-17000?redirect=false)** and commented\n\nIn order to allow Spring Framework applications running as GraalVM native images, we should perform explicit class checks instead of catching `Throwable` in order to avoid `UnsupportedFeatureError: Unresolved element found`\u00a0errors.\n\n---\n\n**Issue Links:**\n- #21529 Initial GraalVM native images (Substrate VM) support (_**\"is depended on by\"**_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/9b7a492bc95c8c1f3e3abfe055defa3722a0aa45, https://github.com/spring-projects/spring-framework/commit/dcbaecea2a73c10580e184b927c3747a6c6fd900\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a dependency check for `rx.RxReactiveStreams` in addition to `rx.Observable`.  Previously, the code only checked for `rx.Observable`.  The new condition ensures both classes are present, indicating a complete RxJava dependency is available. This likely prevents issues if only part of the RxJava library is present",
            "avg_logprobs": -0.13822838919503347
        }
    },
    {
        "commit_hash": "9b85a246d83dd9386889c0edc47dfeffbbc8b6f8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/concurrent/SimpleAsyncTaskScheduler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (this.scheduledExecutor.isTerminated()) {\n+\t\tif (this.scheduledExecutor.isShutdown()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SimpleAsyncTaskScheduler stops accepting new tasks when isShutdown",
        "commit_body": "This changes the criteria for simplified task rejection logging from\nto be that the executor is in the shutdown phase, not fully terminated.\n\nSee gh-33334\nCloses gh-33336\n",
        "linked_issues": [
            {
                "issue_id": "33336",
                "issue_title": "SimpleAsyncTaskScheduler stops accepting new tasks when isShutdown",
                "issue_body": "Fixes #33334\r\n\r\nI didn't find specific tests for this call and I believe the proper ones would be too cumbersome to write. Hope you don't mind, @simonbasle ",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for the detailed analysis @genuss. I think what you propose for `SimpleAsyncTaskScheduler#shutdownAwareErrorHandler` makes sense. The `ExecutorLifecycleDelegate` should be reviewed separately though.",
                    "Should I create a PR for the change?",
                    "@genuss if you have something ready, please go ahead :) ",
                    "Sounds sensible to use `isShutdown()` there, suppressing the log entry even before full termination there.\r\n\r\nAs for `ExecutorLifecycleDelegate`, the use of `isTerminated()` seems correct there since `isRunning()` is expected to return `true` up until actual termination.",
                    "Superseded by PR #33336."
                ]
            },
            {
                "issue_id": "33334",
                "issue_title": "SimpleAsyncTaskScheduler should ignore scheduled exceptions after shutdown (not termination)",
                "issue_body": "Basically my issue is described in #32381. The implemented solution works in almost all cases, but I still experience `TaskRejectedException` logged as errors in the following case:\r\n* application context is stopping;\r\n* `ContextClosedEvent` is already published;\r\n* `SimpleAsyncTaskScheduler#scheduledExecutor` is shut down, but didn't yet terminated;\r\nI couldn't create a minimal reproducible example, but I'd like to show an excerpt from logs.\r\n```\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [cheduling-19424] c.c.MyTaskBean          : Task working\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.b.a.ApplicationAvailabilityBean      : Application availability state ReadinessState changed from ACCEPTING_TRAFFIC to REFUSING_TRAFFIC\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [ionShutdownHook] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@28a2a3e7, started on Wed Aug 07 09:59:00 CEST 2024\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [cheduling-19425] c.c.MyTaskBean          : Task working\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [cheduling-19426] c.c.MyTaskBean          : Task working\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [cheduling-19427] c.c.MyTaskBean          : Task working\r\n2024-08-07T09:59:05.977+02:00 DEBUG 65937 --- [cheduling-19428] c.c.MyTaskBean          : Task working\r\n2024-08-07T09:59:05.977+02:00 ERROR 65937 --- [cheduling-19428] o.s.s.s.TaskUtils$LoggingErrorHandler    : Unexpected error occurred in scheduled task\r\n\r\norg.springframework.core.task.TaskRejectedException: ExecutorService in shutdown state did not accept task: com.company.MyTaskBean$$Lambda/0x000003ff01a10ed0@3c00151f\r\n\tat org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler.schedule(SimpleAsyncTaskScheduler.java:234)\r\n\tat com.company.MyTaskBean.task(MyTaskBean.kt:87)\r\n\tat com.company.MyTaskBean.task$lambda$1(MyTaskBean.kt:87)\r\n\tat org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)\r\n\tat java.base/java.lang.VirtualThread.run(VirtualThread.java:329)\r\nCaused by: java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@93d3468[Not completed, task = java.util.concurrent.Executors$RunnableAdapter@74f27d38[Wrapped task = org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler$$Lambda/0x000003ff019a8f70@53630565]] rejected from org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler$1@1d884a19[Shutting down, pool size = 1, active threads = 0, queued tasks = 2, completed tasks = 19427]\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2081)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:841)\r\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:340)\r\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:562)\r\n\tat org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler.schedule(SimpleAsyncTaskScheduler.java:231)\r\n\t... 4 common frames omitted\r\n\r\n2024-08-07T09:59:05.978+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647\r\n2024-08-07T09:59:05.978+02:00 TRACE 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Asking bean 'taskScheduler' of type [org.springframework.scheduling.concurrent.SimpleAsyncTaskScheduler] to stop\r\n2024-08-07T09:59:05.978+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Bean 'taskScheduler' completed its stop procedure\r\n2024-08-07T09:59:05.978+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147482623\r\n2024-08-07T09:59:05.978+02:00 TRACE 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Asking bean 'webServerGracefulShutdown' of type [org.springframework.boot.web.context.WebServerGracefulShutdownLifecycle] to stop\r\n2024-08-07T09:59:05.979+02:00  INFO 65937 --- [ionShutdownHook] o.s.b.w.e.tomcat.GracefulShutdown        : Commencing graceful shutdown. Waiting for active requests to complete\r\n2024-08-07T09:59:05.980+02:00  INFO 65937 --- [tomcat-shutdown] o.s.b.w.e.tomcat.GracefulShutdown        : Graceful shutdown complete\r\n2024-08-07T09:59:05.980+02:00 DEBUG 65937 --- [tomcat-shutdown] o.s.c.support.DefaultLifecycleProcessor  : Bean 'webServerGracefulShutdown' completed its stop procedure\r\n2024-08-07T09:59:05.981+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147481599\r\n2024-08-07T09:59:05.981+02:00 TRACE 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Asking bean 'webServerStartStop' of type [org.springframework.boot.web.servlet.context.WebServerStartStopLifecycle] to stop\r\n2024-08-07T09:59:05.981+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Bean 'webServerStartStop' completed its stop procedure\r\n2024-08-07T09:59:05.981+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase -2147483647\r\n2024-08-07T09:59:05.981+02:00 TRACE 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Asking bean 'springBootLoggingLifecycle' of type [org.springframework.boot.context.logging.LoggingApplicationListener$Lifecycle] to stop\r\n2024-08-07T09:59:05.981+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.c.support.DefaultLifecycleProcessor  : Bean 'springBootLoggingLifecycle' completed its stop procedure\r\n2024-08-07T09:59:05.982+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.s.c.ThreadPoolTaskScheduler          : Shutting down ExecutorService\r\n2024-08-07T09:59:05.985+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown\r\n2024-08-07T09:59:05.985+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans\r\n2024-08-07T09:59:05.986+02:00  INFO 65937 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : read-only - Shutdown initiated...\r\n2024-08-07T09:59:05.988+02:00  INFO 65937 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : read-only - Shutdown completed.\r\n2024-08-07T09:59:05.988+02:00  INFO 65937 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : read-write - Shutdown initiated...\r\n2024-08-07T09:59:05.989+02:00  INFO 65937 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : read-write - Shutdown completed.\r\n2024-08-07T09:59:05.989+02:00 DEBUG 65937 --- [ionShutdownHook] o.s.b.f.support.DisposableBeanAdapter    : Custom destroy method 'close' on bean with name 'simpleclientPrometheusMeterRegistry' completed\r\n```\r\n\r\nI suppose, the reason can be explained as follows.\r\n* `SimpleAsyncTaskScheduler#onApplicationEvent` calls `ExecutorService#shutdown` thus switching its running state to `SHUTDOWN`.\r\n* `SimpleAsyncTaskScheduler#shutdownAwareErrorHandler` checks for `ExecutorService#isTerminated` which only returns `true` if an executor is in `TERMINATED` running state.\r\n\r\nThe proposed solution: use `ExecutorService#isShutdown` instead.\r\n\r\nI hesitated to create a PR as I also found a call to `isTerminated` to `ExecutorLifecycleDelegate` and not sure if it should be changed too.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for the detailed analysis @genuss. I think what you propose for `SimpleAsyncTaskScheduler#shutdownAwareErrorHandler` makes sense. The `ExecutorLifecycleDelegate` should be reviewed separately though.",
                    "Should I create a PR for the change?",
                    "@genuss if you have something ready, please go ahead :) ",
                    "Sounds sensible to use `isShutdown()` there, suppressing the log entry even before full termination there.\r\n\r\nAs for `ExecutorLifecycleDelegate`, the use of `isTerminated()` seems correct there since `isRunning()` is expected to return `true` up until actual termination.",
                    "Superseded by PR #33336."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `isTerminated()` with `isShutdown()` in the `SimpleAsyncTaskScheduler` class.  This likely alters the condition under which the scheduler considers itself finished, potentially changing the behavior when shutting down the executor.  `isShutdown()` indicates the executor has been asked to shut down, while `isTerminated()` indicates it has fully completed shutdown.  The change suggests a preference for detecting the shutdown request, rather than waiting for the full termination process to complete",
            "avg_logprobs": -0.2483250364965322
        }
    },
    {
        "commit_hash": "9cbac985fbe20df1b0cce399dd238183de9befbc",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/AntPathMatcher.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (cachePatterns == null && this.stringMatcherCache.size() == CACHE_TURNOFF_THRESHOLD) {\n+\t\t\tif (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refined check for cache turnoff threshold",
        "commit_body": "Issue: SPR-10803\n",
        "linked_issues": [
            {
                "issue_id": "15429",
                "issue_title": "MemoryLeak in AntPathMatcher during caching AntPathStringMatcher instances [SPR-10803]",
                "issue_body": "**[Pawel Bobruk](https://jira.spring.io/secure/ViewProfile.jspa?name=pboburk)** opened **[SPR-10803](https://jira.spring.io/browse/SPR-10803?redirect=false)** and commented\n\nImplementation matchStrings:\n\n```\nprivate boolean matchStrings(String pattern, String str, Map<String, String> uriTemplateVariables) {\n     AntPathStringMatcher matcher = this.stringMatcherCache.get(pattern);\n     if (matcher == null) {\n          matcher = new AntPathStringMatcher(pattern);\n          this.stringMatcherCache.put(pattern, matcher);\n     }\n     return matcher.matchStrings(str, uriTemplateVariables);\n}\n```\n\nis adding unlimited number of AntPathStringMatcher to \"cache\".\n\nIn applications with SEO friendly addresses with lots of combinations of parameters causes a problem with the heap memory, every url pattern are stored in cache.\n\n---\n\n**Issue Links:**\n- #14383 Avoid per-request Pattern.compile() calls.\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/326154270fa6338010a1c047044fc4a9f21e910b, https://github.com/spring-projects/spring-framework/commit/d4f4225e53c3af7208b7928bd3ba799249b6875d, https://github.com/spring-projects/spring-framework/commit/9cbac985fbe20df1b0cce399dd238183de9befbc, https://github.com/spring-projects/spring-framework/commit/7a5a6893e3024c9f06a5473788fe731eb6efc380, https://github.com/spring-projects/spring-framework/commit/a7af9505dee01340ac225814f9f90252bb7d725e, https://github.com/spring-projects/spring-framework/commit/4bcfbc3ba3eced91bd833eb2b4d4620c94c611ba\n\n0 votes, 8 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Maciej Zasada](https://jira.spring.io/secure/ViewProfile.jspa?name=mzasada)** commented\n\nTo be precise - in our scenario, we have specific SEO requirements for our search page - all of the attributes must be included in as a part of the URL, not as a parameter, e.g.\n\n```\nexample.com/man/brand+nike,adidas\n```\n\nWe have one annotated catch-all-requests controller. We also have a mvc interceptor, which does URL parsing and transforms path tokens into set of parameters, e.g.\n\n```\nexample.com/man/brand+nike,adidas => [category: [man], brand: [nike,adidas]]\n```\n\nDoing that, we have dynamic URLs based on product attributes and we can handle all of the defined attributes in one fashion. The downside is heavy memory use of AntPathMatcher cache, because we can produce as many unique URLs as cartesian product of all attributes. In our production env, this Map grown into >50% of the total heap size.\n\nWhat would be nice to have is a plugable definition of cache strategy (e.g. fixed-sized LRU) for org.springframework.util.AntPathMatcher\n",
                    "**[Pawel Bobruk](https://jira.spring.io/secure/ViewProfile.jspa?name=pboburk)** commented\n\nCreated [pull#343](https://github.com/SpringSource/spring-framework/pull/343).\n",
                    "**[Andrzej Wis\u0142owski](https://jira.spring.io/secure/ViewProfile.jspa?name=awislowski)** commented\n\nAs a temporary workaround we just added one fixed java class to our application in the /WEB-INF/classes of our web application. Due to tomcat class loading priority our application loads fixed AntPathMatcher java class before class from jar in the /WEB-INF/lib directory\n\nTomcat class-loader documentation : http://tomcat.apache.org/tomcat-7.0-doc/class-loader-howto.html\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've addressed this with a general overhaul of AntPathMatcher's caching. In particular, I've introduced:\n* a \"setCachePatterns(boolean)\" method for explicit configuration (turning on an unlimited cache or turning it off completely)\n* a default turnoff threshold at 65536 entries (at which point we're deciding that caching isn't worthwhile because patterns are unlikely to be reoccurring often enough, so we're clearing the cache and deactivating it)\n* and an \"AntPathStringMatcher getStringMatcher(String pattern)\" template method which can be overridden in subclasses for a custom caching strategy.\n\nThat said, I am wondering where all those pattern entries come from in your scenario. After all, in a regular dispatcher arrangement, there is a finite number of mapped handler methods with an equally finite number of path patterns that they are mapped to. It's just the incoming requests that may have all sorts of path permutations. However, what we're caching is the mapped patterns, not the incoming paths...\n\nI would argue that AntPathMatcher's caching is only worthwhile with a limited number of path patterns. Once you go beyond a certain limit (and the default 65536 is rather generous there anyway), it's not worth synchronizing access to the entire cache just in order to be able to drop the oldest entries from a LinkedHashMap. Instead, it's appropriate to turn off the cache completely.\n\nJuergen\n",
                    "**[Andrzej Wis\u0142owski](https://jira.spring.io/secure/ViewProfile.jspa?name=awislowski)** commented\n\nIn the class RequestMappingInfoHandlerMapping in the method handleMatch if no matching handler method for the current request was found then lookupPath is used as a pattern.\n\nhttps://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.java#L101\n\nWe just stressed application with url (/unmapped_path/{i}) incrementing {i} to generate OutOfMemeryException.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThe lookupPath is used as a pattern if the matched request mapping does not have any patterns, i.e. an `@RequestMapping` with no patterns but possibly other mapping attributes (params, headers, etc).\n\nI'm fixing this regardless but just confirming my understanding that it seems to be a very specific case that triggers this.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGiven that we fixed the hotspot that previously filled AntPathMatcher's cache beyond any limits, I'm inclined to only backport that fix to 3.2.5 and leave the general AntPathMatcher overhaul to the 4.0 line. After all, any such overhaul may also introduce subtle side effects; so if there's no strong need, I'd rather not backport it.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the condition for turning off the pattern caching mechanism in `AntPathMatcher`.  The original code checked if the cache was `null` *and* its size was exactly equal to the `CACHE_TURNOFF_THRESHOLD`.  The updated code changes the comparison to `>=`, meaning the cache will now be turned off if its size is equal to or greater than the threshold.  This is a subtle but important change, as it prevents the cache from being turned off prematurely.",
            "avg_logprobs": -0.19860971450805665
        }
    },
    {
        "commit_hash": "9ccbeec94748e825b438dce2acad7da44ed82b3d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/reactive/TransactionalOperatorImpl.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tif (ex instanceof RuntimeException &&\n-\t\t\t\tex.getCause() != null &&\n-\t\t\t\tex.getMessage().startsWith(\"Async resource cleanup failed\")) {\n-\t\t\treturn ex.getCause();\n+\t\tif (ex instanceof RuntimeException && ex.getCause() != null) {\n+\t\t\tString msg = ex.getMessage();\n+\t\t\tif (msg != null && msg.startsWith(\"Async resource cleanup failed\")) {\n+\t\t\t\treturn ex.getCause();\n+\t\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ignore null message when introspecting resource cleanup failure",
        "commit_body": "This commit fixes a regression introduced in conjunction with gh-27572.\n\nSee gh-30597\nCloses gh-30729\n",
        "linked_issues": [
            {
                "issue_id": "30597",
                "issue_title": "NPE in `ReactiveTransactionSupport.unwrapIfResourceCleanupFailure`",
                "issue_body": "**Affects:** spring boot 3.0.7\r\n\r\n---\r\nin method unwrapIfResourceCleanupFailure of org.springframework.transaction.interceptor.TransactionAspectSupport.ReactiveTransactionSupport class\r\nif ex.getMessage() returns null then we get NullPointerException:\r\n\r\n```java\r\n\t\t\tif (ex instanceof RuntimeException &&\r\n\t\t\t\t\tex.getCause() != null &&\r\n\t\t\t\t\tex.getMessage().startsWith(\"Async resource cleanup failed\")) {\r\n\t\t\t\treturn ex.getCause();\r\n\t\t\t}\r\n```\r\nhttps://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L1088",
                "issue_state": "closed",
                "issue_comment": [
                    "@mp911de Could you please review the latest version of this PR and confirm (or not) you are ok for merging it (I will also have a deeper look after your confirmation)?",
                    "@EnricSala I have rebased the branch on top of `main` in https://github.com/sdeleuze/spring-framework/tree/gh-27523, but I see an error in `CoroutinesTransactionInterceptorTests`, could you please have a look and maybe rebased this PR on top of `main` potentially using my branch as a basis?",
                    "@sdeleuze I have rebased this PR on top of `main` and added a commit to fix `CoroutinesTransactionInterceptorTests`. Please check if this small fix makes sense :)",
                    "Merged via edf0ae77e502dd0e5b85a4fa8fc08d3e516d990a after @simonbasle and @mp911de green light. Thanks for contributing this and for your patience @EnricSala. Please test snapshots to check everything looks fine for your use cases."
                ]
            },
            {
                "issue_id": "30729",
                "issue_title": "`NullPointerException` in reactive `TransactionalOperatorImpl`",
                "issue_body": "I have used spring-tx for a while. I just upgraded the version into 6.0.9. But some of my tests, which were passed before, about transaction are failed.\r\nSo, I tried to find the reason.\r\n\r\nIn the below code, the test failed, but the exception type are not \"NoSuchElementException\". It is \"NullPointerException\".\r\n\r\nThis code is not what my real test, but it is just a sample code.\r\n\r\n```kt\r\n@DataR2dbcTest\r\nclass TestTransaction {\r\n    @Autowired\r\n    private lateinit var txManager: ReactiveTransactionManager\r\n\r\n    @OptIn(ExperimentalCoroutinesApi::class)\r\n    @Test\r\n    fun test1() = runTest {\r\n        TransactionalOperator.create(txManager).executeAndAwait {\r\n            Mono.error<NoSuchElementException>(NoSuchElementException())\r\n                .awaitSingle()\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\nCannot invoke \"String.startsWith(String)\" because the return value of \"java.lang.Throwable.getMessage()\" is null\r\njava.lang.NullPointerException: Cannot invoke \"String.startsWith(String)\" because the return value of \"java.lang.Throwable.getMessage()\" is null\r\n\tat org.springframework.transaction.reactive.TransactionalOperatorImpl.unwrapIfResourceCleanupFailure(TransactionalOperatorImpl.java:117)\r\n\tat reactor.core.publisher.Flux.lambda$onErrorMap$27(Flux.java:7099)\r\n\tat reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:94)\r\n\tat reactor.core.publisher.FluxUsingWhen$UsingWhenSubscriber.deferredError(FluxUsingWhen.java:398)\r\n\tat reactor.core.publisher.FluxUsingWhen$RollbackInner.onComplete(FluxUsingWhen.java:475)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2205)\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:250)\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:324)\r\n\tat reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209)\r\n\tat reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209)\r\n\tat reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2205)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2205)\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:250)\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:324)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)\r\n\tat reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2205)\r\n\tat reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209)\r\n\tat reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209)\r\n\tat reactor.pool.SimpleDequePool.maybeRecycleAndDrain(SimpleDequePool.java:531)\r\n```\r\n\r\nI found code was changed 2 months ago. And the below is what was added or modified.\r\n\r\n```kt\r\n//In \"TransactionalOperatorImpl\"\r\n        @Override\r\n\tpublic <T> Flux<T> execute(TransactionCallback<T> action) throws TransactionException {\r\n\t\treturn TransactionContextManager.currentContext().flatMapMany(context ->\r\n\t\t\tFlux.usingWhen(\r\n\t\t\t\tthis.transactionManager.getReactiveTransaction(this.transactionDefinition),\r\n\t\t\t\taction::doInTransaction,\r\n\t\t\t\tthis.transactionManager::commit,\r\n\t\t\t\tthis::rollbackOnException,\r\n\t\t\t\tthis.transactionManager::rollback)\r\n\t\t\t.onErrorMap(this::unwrapIfResourceCleanupFailure))\r\n\t\t.contextWrite(TransactionContextManager.getOrCreateContext())\r\n\t\t.contextWrite(TransactionContextManager.getOrCreateContextHolder());\r\n\t}\r\n\r\n\tprivate Throwable unwrapIfResourceCleanupFailure(Throwable ex) {\r\n\t\tif (ex instanceof RuntimeException &&\r\n\t\t\t\tex.getCause() != null &&\r\n\t\t\t\tex.getMessage().startsWith(\"Async resource cleanup failed\")) {\r\n\t\t\treturn ex.getCause();\r\n\t\t}\r\n\t\treturn ex;\r\n\t}\r\n```\r\n\r\nBut if I do not use `awaitSingle` like the below code, the test works what I have expected.\r\n\r\n```kt\r\n@DataR2dbcTest\r\nclass TestTransaction {\r\n    @Autowired\r\n    private lateinit var txManager: ReactiveTransactionManager\r\n\r\n    @OptIn(ExperimentalCoroutinesApi::class)\r\n    @Test\r\n    fun test1() = runTest {\r\n        TransactionalOperator.create(txManager).executeAndAwait {\r\n            f1()\r\n        }\r\n    }\r\n\r\n    suspend fun f1(){\r\n        throw NoSuchElementException()\r\n    }\r\n}\r\n```\r\n\r\nShould I not use `Mono.awaitSingle` in ReactiveTransactionManager?",
                "issue_state": "closed",
                "issue_comment": [
                    "@mp911de Could you please review the latest version of this PR and confirm (or not) you are ok for merging it (I will also have a deeper look after your confirmation)?",
                    "@EnricSala I have rebased the branch on top of `main` in https://github.com/sdeleuze/spring-framework/tree/gh-27523, but I see an error in `CoroutinesTransactionInterceptorTests`, could you please have a look and maybe rebased this PR on top of `main` potentially using my branch as a basis?",
                    "@sdeleuze I have rebased this PR on top of `main` and added a commit to fix `CoroutinesTransactionInterceptorTests`. Please check if this small fix makes sense :)",
                    "Merged via edf0ae77e502dd0e5b85a4fa8fc08d3e516d990a after @simonbasle and @mp911de green light. Thanks for contributing this and for your patience @EnricSala. Please test snapshots to check everything looks fine for your use cases."
                ]
            },
            {
                "issue_id": "27572",
                "issue_title": "Avoid rollback after a commit failure in `TransactionalOperator`",
                "issue_body": "A failure to commit a reactive transaction will complete the transaction and clean up resources. Executing a rollback at that point is invalid, which causes an `IllegalTransactionStateException` that masks the cause of the commit failure.\r\n\r\nThis change restructures `TransactionalOperatorImpl` and `ReactiveTransactionSupport` to avoid executing a rollback after a failed commit. While there, the `Mono` transaction handling in `TransactionalOperator` is simplified by moving it to a default method on the interface.\r\n\r\nSee gh-27523",
                "issue_state": "closed",
                "issue_comment": [
                    "@mp911de Could you please review the latest version of this PR and confirm (or not) you are ok for merging it (I will also have a deeper look after your confirmation)?",
                    "@EnricSala I have rebased the branch on top of `main` in https://github.com/sdeleuze/spring-framework/tree/gh-27523, but I see an error in `CoroutinesTransactionInterceptorTests`, could you please have a look and maybe rebased this PR on top of `main` potentially using my branch as a basis?",
                    "@sdeleuze I have rebased this PR on top of `main` and added a commit to fix `CoroutinesTransactionInterceptorTests`. Please check if this small fix makes sense :)",
                    "Merged via edf0ae77e502dd0e5b85a4fa8fc08d3e516d990a after @simonbasle and @mp911de green light. Thanks for contributing this and for your patience @EnricSala. Please test snapshots to check everything looks fine for your use cases."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the conditional logic for handling exceptions.  The original code checked for a specific exception message *and* a non-null cause.  The revised code first checks for a `RuntimeException` and a non-null cause.  It then extracts the exception message and checks if it starts with \"Async resource cleanup failed\".  This change improves readability and potentially performance by separating the checks for the cause and the specific message",
            "avg_logprobs": -0.24825267791748046
        }
    },
    {
        "commit_hash": "9dfa46f6902b7b134847ae20bc88b4a3968a99bb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t// If the URI is for a \"resource\" in the GraalVM native image file system, we have to\n-\t\t\t// ensure that the root directory does not end in a slash while simultaneously ensuring\n-\t\t\t// that the root directory is not an empty string (since Path#resolve throws an\n-\t\t\t// ArrayIndexOutOfBoundsException in a native image if the initial Path is created\n-\t\t\t// from an empty string).\n-\t\t\tString scheme = rootDirUri.getScheme();\n-\t\t\tString path = rootDirUri.getPath();\n-\t\t\tif (\"resource\".equals(scheme) && (path.length() > 1) && path.endsWith(\"/\")) {\n-\t\t\t\tpath = path.substring(0, path.length() - 1);\n-\t\t\t\t// Retain the fragment as well, since root folders in the native image\n-\t\t\t\t// file system are indexed via the fragment (e.g., resource:/#1).\n-\t\t\t\trootDirUri = new URI(scheme, path, rootDirUri.getFragment());\n-\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove GraalVM workaround in PathMatchingResourcePatternResolver",
        "commit_body": "Tested successfully using the following locally built GraalVM dev build.\n\nOpenJDK Runtime Environment GraalVM 22.3.0-dev (build 17.0.5+5-jvmci-22.3-b07)\n\nCloses gh-29214\n",
        "linked_issues": [
            {
                "issue_id": "29214",
                "issue_title": "Remove GraalVM workaround in PathMatchingResourcePatternResolver",
                "issue_body": "This is a follow up to #29163.\r\n\r\nOnce https://github.com/oracle/graal/issues/5080 and https://github.com/oracle/graal/issues/5081 have been resolved (tentatively in GraalVM 22.3), we should be able to remove the following workaround in `PathMatchingResourcePatternResolver`.\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/6cb131ac7629cfda489d4d2367a36d44ee7b5ed2/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java#L744-L750",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `PathMatchingResourcePatternResolver` addresses a potential issue with GraalVM native image handling of \"resource\" URIs.  It modifies the `rootDirUri` if it\\'s a \"resource\" URI and its path ends with a slash.  The original path is trimmed to remove the trailing slash, and the fragment is preserved, ensuring compatibility with the native image file system\\'s indexing mechanism",
            "avg_logprobs": -0.22541799545288085
        }
    },
    {
        "commit_hash": "9f2970bc5c06b443c12b7825a3180ef2fa292474",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaVendorAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.hibernate.dialect.MySQLDialect;\n-\t\telse {  // Hibernate 6.2 aligned\n+\t\telse {  // Hibernate 6.2+ aligned\n-\t\t\t\tcase MYSQL -> MySQL57Dialect.class;\n+\t\t\t\tcase MYSQL -> MySQLDialect.class;",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use non deprecated MySQL dialect for Hibernate 6+",
        "commit_body": "This commit fixes the Hibernate dialect lookup for MySQL as it was\npreviously using a deprecated dialect that has been removed in the most\nrecent Hibernate version.\n\nCloses gh-31889\n",
        "linked_issues": [
            {
                "issue_id": "31889",
                "issue_title": "ClassNotFoundException: org.hibernate.dialect.MySQL57Dialect with Hibernate 6.4",
                "issue_body": "After updating my project from Spring Boot Version 3.2.0 to 3.2.1, I am no longer able to start my application.\r\nMy application uses Spring JPA (via `spring-boot-starter-data-jpa`) and a MySQL 8.2 database.\r\n\r\nDuring start-up, I receive the following error message:\r\n```\r\n[ERROR] 2023-12-22 10:44:44 SpringApplication - Application run failed\r\njava.lang.ClassNotFoundException: org.hibernate.dialect.MySQL57Dialect\r\n        at java.base/java.net.URLClassLoader.findClass(Unknown Source) ~[na:na]\r\n        at java.base/java.lang.ClassLoader.loadClass(Unknown Source) ~[na:na]\r\n        at org.springframework.boot.loader.net.protocol.jar.JarUrlClassLoader.loadClass(JarUrlClassLoader.java:104) ~[XXX]\r\n        at org.springframework.boot.loader.launch.LaunchedClassLoader.loadClass(LaunchedClassLoader.java:91) ~[XXX]\r\n        at java.base/java.lang.ClassLoader.loadClass(Unknown Source) ~[na:na]\r\n        ... 28 common frames omitted\r\nWrapped by: java.lang.NoClassDefFoundError: org/hibernate/dialect/MySQL57Dialect\r\n        at org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter.determineDatabaseDialectClass(HibernateJpaVendorAdapter.java:203) ~[spring-orm-6.1.2.jar!/:6.1.2]\r\n        at org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter.buildJpaPropertyMap(HibernateJpaVendorAdapter.java:148) ~[spring-orm-6.1.2.jar!/:6.1.2]\r\n        at org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter.getJpaPropertyMap(HibernateJpaVendorAdapter.java:132) ~[spring-orm-6.1.2.jar!/:6.1.2]\r\n        at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:365) ~[spring-orm-6.1.2.jar!/:6.1.2]\r\n        at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:352) ~[spring-orm-6.1.2.jar!/:6.1.2]\r\n        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[spring-boot-3.2.1.jar!/:3.2.1] [11 skipped]\r\n        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:762) ~[spring-boot-3.2.1.jar!/:3.2.1]\r\n        ... 21 common frames omitted\r\nWrapped by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource [XXX/MySqlConfig.class]: org/hibernate/dialect/MySQL57Dialect\r\n        at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[spring-boot-3.2.1.jar!/:3.2.1] [10 skipped]\r\n        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:762) ~[spring-boot-3.2.1.jar!/:3.2.1]\r\n        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:464) ~[spring-boot-3.2.1.jar!/:3.2.1]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.1.jar!/:3.2.1]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1358) ~[spring-boot-3.2.1.jar!/:3.2.1]\r\n        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1347) ~[spring-boot-3.2.1.jar!/:3.2.1]\r\n        at XXX.Main.main(Main.java:53) ~[!/:na]\r\n        at org.springframework.boot.loader.launch.Launcher.launch(Launcher.java:91) ~[XXX] [2 skipped]\r\n        at org.springframework.boot.loader.launch.Launcher.launch(Launcher.java:53) ~[XXX]\r\n        at org.springframework.boot.loader.launch.JarLauncher.main(JarLauncher.java:58) ~[XXX]\r\n```\r\n\r\nI looks like Hibernate 6.4 removed the `MySQL57Dialect` class (or at least moved it to the `hibernate-community-dialects` artifact). When I set the property `<hibernate.version>6.3.2.Final</hibernate.version>` in my pom.xml file, my application starts without errors.\r\n\r\nI created a repository with a test case to reproduce this issue: https://github.com/HennyWilly/springboot321-hibernate64-bug\r\n\r\nPS: This is my first issue, so I am not sure if this is the right repository or if I should have opened this issue inside the spring-framework repository.",
                "issue_state": "closed",
                "issue_comment": [
                    "Running your sample with Hibernate 6.3.2 shows the following:\r\n\r\n```\r\n[main] WARN org.hibernate.orm.deprecation -- HHH90000025: MySQL57Dialect does not need to be specified explicitly using 'hibernate.dialect' (remove the property setting and it will be selected by default)\r\n[main] WARN org.hibernate.orm.deprecation -- HHH90000026: MySQL57Dialect has been deprecated; use org.hibernate.dialect.MySQLDialect instead\r\n```\r\n\r\nIt seems Spring Framework is still referring to this class in `HibernateJpaVendorAdapter` and does not handle Hibernate 6.4  compatibility on dialects. I'll transfer the issue to the Framework project for consideration.\r\n\r\n",
                    "Thanks for the report.\r\n\r\nIn the `MainTests` you are creating the EMF manually, which disables some of Spring Boot's auto-configuration. For quite some time now, Spring Boot configures the JPA infrastructure so that the provider is responsible for looking up the proper dialect. By forcing the database platform to be `MYSQL` you're opting out of that.\r\n\r\nThere are two ways to fix this. You can either remove the explicit platform in `jpaVendorAdapter`, or you can fix the wrong dialect lookup by adding the following to the `jpaVendorAdaptor` method:\r\n\r\n```java\r\nhibernateJpaVendorAdapter.setDatabasePlatform(\"org.hibernate.dialect.MySQLDialect\");\r\n```\r\n\r\nArguably, the former is preferred as it is more in line with what the application does (let the JPA provider detect the infrastructure). We'll fix the MySQL dialect in the next maintenance release.",
                    "> Thanks for the report.\r\n> \r\n> In the `MainTests` you are creating the EMF manually, which disables some of Spring Boot's auto-configuration. For quite some time now, Spring Boot configures the JPA infrastructure so that the provider is responsible for looking up the proper dialect. By forcing the database platform to be `MYSQL` you're opting out of that.\r\n> \r\n> There are two ways to fix this. You can either remove the explicit platform in `jpaVendorAdapter`, or you can fix the wrong dialect lookup by adding the following to the `jpaVendorAdaptor` method:\r\n> \r\n> ```java\r\n> hibernateJpaVendorAdapter.setDatabasePlatform(\"org.hibernate.dialect.MySQLDialect\");\r\n> ```\r\n> \r\n> Arguably, the former is preferred as it is more in line with what the application does (let the JPA provider detect the infrastructure). We'll fix the MySQL dialect in the next maintenance release.\r\n\r\nThis didn't resolve the problem for the Oracle12cDialect for me.\r\n\r\n\r\nI have specified:\r\n`  datasource:\r\n      type: com.zaxxer.hikari.HikariDataSource\r\n      driver-class-name: oracle.jdbc.OracleDriver`\r\n\r\nand\r\n`spring: \r\n    jpa:\r\n      properties:\r\n        hibernate:\r\n          dialect: org.hibernate.dialect.OracleDialect`\r\n\r\n\r\nI'm not creating any custom HibernateJpaVendorAdapter and I also don't see the warning [bclozel](https://github.com/bclozel) posted. \r\n\r\nI've also tried running without those properties, to no avail.",
                    "@barbetb the arrangement that you've quoted is quite specific so commenting with a different arrangement and stating \"didn't resolve the problem\" is not very helpful. The warning that Brian referenced is about MySQL for a start, and for an older Hibernate version. \r\n\r\nAll in all, this is confusing and you probably want to ask for support on StackOverflow first. If you believe you've found a different bug, then a separate issue is needed with a small sample that demonstrates the problem you're experiencing.",
                    "@snicoll my apologies. I got a bit confused with all the tickets opened for this issue. \r\n\r\nI had the same issue as https://github.com/spring-projects/spring-framework/issues/31892 and that issue refered to this one. I now see you made fix for the oracle one here https://github.com/spring-projects/spring-framework/commit/03907095776eadf67a04dbaf62ffb3fe32125232  , but it hasn't been released yet.\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change updates the conditional logic for selecting the MySQL dialect class.  Previously, the code used `MySQL57Dialect` for MySQL.  The update now uses `MySQLDialect`, aligning with Hibernate 6.2 or later.  This likely resolves a compatibility issue with newer Hibernate versions",
            "avg_logprobs": -0.2747161865234375
        }
    },
    {
        "commit_hash": "9fec516560741a01c9049b5526113f2a94c72387",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.core.NativeDetector;\n-\t\tif (ClassUtils.isPresent(\"org.crac.Core\", getClass().getClassLoader())) {\n+\t\tif (!NativeDetector.inNativeImage() && ClassUtils.isPresent(\"org.crac.Core\", getClass().getClassLoader())) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip CRaC support with native images",
        "commit_body": "Skip CRaC support with native images to avoid compiling related\ninfrastructure to the native image and to fix tests via\ngh-30422.\n\nSee gh-30242\n",
        "linked_issues": [
            {
                "issue_id": "30422",
                "issue_title": "Update `RuntimeHintsAgentPlugin` to use the native image code path",
                "issue_body": "`RuntimeHintsAgentPlugin` purpose is to verify that reflective invocations expected match the ones performed.\r\n\r\ngh-30242 introduces a code path where the reflective invocation is skipped when running on native.\r\n\r\nThis issue set the system property `org.graalvm.nativeimage.imagecode` to `runtime` when running runtime tests with the agent in order to make sure the code path tested for those tests is the native one.",
                "issue_state": "closed",
                "issue_comment": []
            },
            {
                "issue_id": "30242",
                "issue_title": "CRaC Resource adapter for bean lifecycle in application context",
                "issue_body": "In addition to our CRaC-oriented revisiting of the existing contracts for the bean lifecycle in an application context (#29921), we consider providing an `org.crac.Resource` adapter for Spring's `DefaultLifecycleProcessor` out of the box - e.g. as an implicit optional part of the `DefaultLifecycleProcessor` implementation or as a dedicated subclass of it. This allows for stopping/restarting of beans in an application context on a fine-grained basis, with some tightening of the `Lifecycle` contract and possibly even some dedicated extensions in `SmartLifecycle` that participating component implementations may rely on.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `NativeDetector.inNativeImage()`.  The original code conditionally loaded a class (`org.crac.Core`) only if it was present.  The updated code now *only* loads `org.crac.Core` if it's present *and* the application is *not* running in a native image environment.  This prevents loading the class in native image builds, likely to avoid conflicts or unnecessary dependencies",
            "avg_logprobs": -0.15272938577752365
        }
    },
    {
        "commit_hash": "a02fd7c9953b8e7f629f4d3a66a450a13341576b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tModelAndView mav = null;\n+\t\tModelAndView mav;\n+\t\t\telse {\n+\t\t\t\t// No HttpSession available -> no mutex necessary\n+\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n+\t\t\t}\n+\t\t\t// No synchronization on session demanded at all...",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "RequestMappingHandlerAdapter properly invokes handler method in case of no session as well",
        "commit_body": "Issue: SPR-13999\n",
        "linked_issues": [
            {
                "issue_id": "18572",
                "issue_title": "Regression: RequestMappingHandlerAdapter with synchronizeOnSession=true calls invokeHandlerMethod twice [SPR-13999]",
                "issue_body": "**[Isto Nikula](https://jira.spring.io/secure/ViewProfile.jspa?name=iston)** opened **[SPR-13999](https://jira.spring.io/browse/SPR-13999?redirect=false)** and commented\n\nFirst call on line 726, second 731.\n\nhttps://github.com/spring-projects/spring-framework/blob/4.2.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L723;L731\n\n---\n\n**Affects:** 4.2.5\n\n**Issue Links:**\n- #18555 Regression: `@ResponseBody` with Map result returns JSON array twice in case of synchronizeOnSession=true (_**\"is duplicated by\"**_)\n- #18708 Handler method is called twice when synchronizeOnSession is true in RequestMappingHandlerAdaptor (_**\"is duplicated by\"**_)\n- #18440 ResponseEntity CacheControl ignored / extended by RequestMappingHandlerAdapter\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis turns out to be a regression caused by the revised HTTP header handling introduced in 4.2.5 (#18440). Fixed for 4.2.6 now.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes unnecessary synchronization on `HttpSession` when invoking a handler method.  Previously, a `ModelAndView` was initialized as `null` and then potentially assigned a value.  The change now initializes `mav` directly, eliminating the need for a conditional check and subsequent synchronization block if no `HttpSession` is available.  This optimization improves performance by removing unnecessary locking",
            "avg_logprobs": -0.33612411499023437
        }
    },
    {
        "commit_hash": "a1529d498e004b3e3b1aa123b57a07435e6d644d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/core/GenericMessagingTemplate.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t@SuppressWarnings(\"unchecked\")\n+\t\t\tboolean alreadyReceivedReply = this.hasReceived;\n-\t\t\telse if (this.hasReceived) {\n+\t\t\telse if (alreadyReceivedReply) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix possible GenericMsgTemplate race condition",
        "commit_body": "Fix a potential race condition with GenericMessagingTemplate's inner\nTemporaryReplyChannel class.\n\nPrior to this commit the `hasReceived` member variable was read after\ncalling `replyLatch.countDown()`.\n\nIssue: SPR-11206\n",
        "linked_issues": [
            {
                "issue_id": "15831",
                "issue_title": "Potential race conditional with GenericMessagingTemplate [SPR-11206]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-11206](https://jira.spring.io/browse/SPR-11206?redirect=false)** and commented\n\nA potential concurrency issue has been fixed in SI and should be ported:\n\nhttps://github.com/spring-projects/spring-integration/pull/991/files?w=1\n\n\n---\n\n**Affects:** 4.0 RC2\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/a1529d498e004b3e3b1aa123b57a07435e6d644d\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an unnecessary `else if` block.  The original code had an `else if (this.hasReceived)` block that was redundant because the `@SuppressWarnings(\"unchecked\")` statement likely preceded a check for `this.hasReceived`.  The change renames a temporary variable to `alreadyReceivedReply` for clarity, but the core change is the removal of the redundant conditional. This improves code readability and potentially minor performance by avoiding an extra comparison",
            "avg_logprobs": -0.3977190921181127
        }
    },
    {
        "commit_hash": "a2af5a90dc14217b02246b2d733f9c4d25b17600",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/UrlFilenameViewController.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tString viewName = this.viewNameCache.get(uri);\n-\t\tif (viewName == null) {\n-\t\t\tviewName = extractViewNameFromUrlPath(uri);\n-\t\t\tviewName = postProcessViewName(viewName);\n-\t\t\tthis.viewNameCache.put(uri, viewName);\n-\t\t}\n-\t\treturn viewName;\n+\t\treturn this.viewNameCache.computeIfAbsent(uri, u -> postProcessViewName(extractViewNameFromUrlPath(u)));",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify UrlFileNameViewController#getViewNameForUrlPath()",
        "commit_body": "Closes gh-24419",
        "linked_issues": [
            {
                "issue_id": "24419",
                "issue_title": "Simplify UrlFileNameViewController#getViewNameForUrlPath()",
                "issue_body": "It can be simplify",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a conditional `if` statement with a `computeIfAbsent` method call.  The original code retrieved the view name from the cache, and if not found, extracted it from the URL, processed it, and then stored it in the cache.  The new code uses a single, more concise operation to retrieve or compute the view name, storing the result directly in the cache.  This change is more efficient and readable",
            "avg_logprobs": -0.2754518487951258
        }
    },
    {
        "commit_hash": "a2f5e1254e3ccf190ec559492a33ca87c47e54d3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\t\tint prefixIndex = filePath.indexOf(':');\n+\t\t\t\t\tif (prefixIndex == 1) {\n+\t\t\t\t\t\t// Possibly \"c:\" drive prefix on Windows, to be upper-cased for proper duplicate detection\n+\t\t\t\t\t\tfilePath = filePath.substring(0, 1).toUpperCase() + filePath.substring(1);\n+\t\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Drive letter case alignment in addClassPathManifestEntries",
        "commit_body": "Issue: SPR-16117\n",
        "linked_issues": [
            {
                "issue_id": "20665",
                "issue_title": "`PathMatchingResourcePatternResolver` returns duplicate resources when using `classpath*:` prefix [SPR-16117]",
                "issue_body": "**[Udayakumar](https://jira.spring.io/secure/ViewProfile.jspa?name=udaikumar26)** opened **[SPR-16117](https://jira.spring.io/browse/SPR-16117?redirect=false)** and commented\n\nI am working on a drools project. The goal is to search all the rules(*.rdrl) files in the classpath and write it into the KieFileSystem. The rules file(.rdrl) will be present under multiple jar files. These jar files were added as a dependency in the drools project.\nBelow is the code that is used to find all the .rdrl files.\n\nClassLoader classloader = this.getClass().getClassLoader();\nResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver(classloader);\n\nfor (Resource file : resourcePatternResolver.getResources(\"classpath*:/**/*.rdrl\")) {\nSystem.out.println(\"name: \" + file.getURL());\nkieFileSystem.write(ResourceFactory.newUrlResource(file.getURL()));\n}\n\nBelow is the sample output printed by the above code\n\nname: jar:file:/C:/mvn_repo/com/myteam/OOP_Modular/1.0.0/OOP_Modular-1.0.0.jar!/com/myteam/oop_modular/OOP_MOD_Network_In_Network.rdrl\n\nname: jar:file:/C:/mvn_repo/com/myteam/OOP_Modular/1.0.0/OOP_Modular-1.0.0.jar!/com/myteam/oop_modular/OOP_MOD_Individual1.rdrl\n\nname: jar:file:c:\\mvn_repo\\com\\myteam\\OOP_Modular\\1.0.0\\OOP_Modular-1.0.0.jar!/com/myteam/oop_modular/OOP_MOD_Network_In_Network.rdrl\n\nname: jar:file:c:\\mvn_repo\\com\\myteam\\OOP_Modular\\1.0.0\\OOP_Modular-1.0.0.jar!/com/myteam/oop_modular/OOP_MOD_Individual1.rdrl\n\nAs seen from the above output there are two entries for the same files OOP_MOD_Network_In_Network.rdrl and OOP_MOD_Individual1.rdrl. When you look at the output, the path is exactly same except that one starts with /C: and other with c:\n\nBecause of this issue, since i am trying to write each rule twice into kiefilesystem, it throws an exception saying \"Duplicate rule name\".\n\nNote: When using pattern such as (\"classpath*:com/**/*.rdrl\"), the resources are returned only once but we are not sure if the rules file will be present only under 'com', it can also be under 'org' or anything else.\n\nSystem: Windows 7, JDK 1.8\n\n---\n\n**Affects:** 4.3.12, 5.0.1\n\n**Issue Links:**\n- #20539 PathMatchingResourcePatternResolver provides duplicate resources when using classpath* prefix combined with ant-style\n- #18260 PathMatchingResourcePatternResolver does not consider manifest based classpaths\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/8904de2149ef315e39d2464fa4283322d6137130, https://github.com/spring-projects/spring-framework/commit/a2f5e1254e3ccf190ec559492a33ca87c47e54d3\n\n**Backported to:** [4.3.13](https://github.com/spring-projects/spring-framework/milestone/162?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nLooks like it's not the difference in slashes but the lower-case \"c:\" versus upper-case \"C:\" that's causing `UrlResource.equals` to not match here... Let's see what we can do about it.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're upper-casing drive letter prefixes in `addClassPathManifestEntries` for proper duplicate detection now. Please give the upcoming `5.0.2.BUILD-SNAPSHOT` a try; I'll backport it to 4.3.13 if it works for you.\n",
                    "**[Udayakumar](https://jira.spring.io/secure/ViewProfile.jspa?name=udaikumar26)** commented\n\nHello,\nThanks for the prompt fix. i am stuck with downloading the artifactory. I tried by defining spring repo into the settings.xml however i got the following error,\n\nNon-resolvable import POM: Could not transfer artifact org.springframework:spring-framework-bom:pom:5.0.2.BUILD-SNAPSHOT from/to repository.spring.snapshot (http://repo.spring.io/snapshot): connect timed out\n\nCan you help.\n",
                    "**[Udayakumar](https://jira.spring.io/secure/ViewProfile.jspa?name=udaikumar26)** commented\n\nFound a strange thing. This issue do not exist in 4.2.5.RELEASE\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThe above looks like a temporary problem with the snapshot repository. Trying at a later point might work...\n\nAs for this not occurring with 4.2.5, this is expect since Spring's evaluation of the \"java.class.path\" manifest entry only came in 4.3: #18260\n",
                    "**[Udayakumar](https://jira.spring.io/secure/ViewProfile.jspa?name=udaikumar26)** commented\n\nI was able to download the artifact and install into local maven repo. I am finding it hard to test because we are using spring boot and versions are getting messed up. I am not able to use the downloaded artifact standalone.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll), overriding the Spring Framework version underneath Boot to a snapshot should work under normal circumstances? Any advice?\n",
                    "**[Udayakumar](https://jira.spring.io/secure/ViewProfile.jspa?name=udaikumar26)** commented\n\nspring-framework-bom-5.0.2.BUILD-SNAPSHOT is missing\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've noticed that the last build hasn't properly completed, so would have received an outdated snapshot in any case. Maybe that's also the reason why the last published snapshot appears inconsistent. In any case, I've triggered a new build which should be ready and published in about half an hour.\n",
                    "**[Udayakumar](https://jira.spring.io/secure/ViewProfile.jspa?name=udaikumar26)** commented\n\nHi Hoeller,\nThanks for the support. Finally i was able to test with the snapshot. It seem to be working. Hope it works for all scenarios.\nKindly let me know if it will be available in 4.3.12.RELEASE version. Please make it available as part of spring boot versions as well.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood to hear, thanks for the feedback!\n\nI'll backport this to 4.3.13 tomorrow, along with a few other refinements. Both 5.0.2 and 4.3.13 are scheduled for release on November 15th, with corresponding Boot 2.0 RC1 and Boot 1.5.9 releases following soon thereafter.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a check for a potential \"c:\" drive prefix (Windows) in a file path.  If found, it converts the first character to uppercase to ensure consistent handling during duplicate detection. This change addresses potential issues with case sensitivity on Windows file systems",
            "avg_logprobs": -0.22810642807571976
        }
    },
    {
        "commit_hash": "a434903a2a5483b4d0f7976cb37957e4771b1e88",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/handler/LoggingWebSocketHandlerDecorator.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(\"Transport error for \" + session + \": \" + exception);\n-\t\t}\n-\t\telse if (logger.isTraceEnabled()) {\n-\t\t\tlogger.debug(\"Transport error for \" + session, exception);\n+\t\tif (logger.isErrorEnabled()) {\n+\t\t\tlogger.error(\"Transport error for \" + session, exception);",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Adjust log level in LoggingWebSocketHandlerDecorator",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging of transport errors.  Previously, the code used `isDebugEnabled()` and `isTraceEnabled()` to determine the logging level, falling back to `debug` if `trace` was not enabled.  The updated code now directly uses `isErrorEnabled()` to log at the `error` level, eliminating the conditional checks and the previous fallback to `debug`.  This change likely improves logging consistency and clarity, as `error` is a more appropriate level for transport errors",
            "avg_logprobs": -0.27240333557128904
        }
    },
    {
        "commit_hash": "a4968b9015217ee8116bef7f77f5da4d776047fd",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tBeanDefinition oldBeanDefinition;\n+\n-\t\t\tBeanDefinition oldBeanDefinition = this.beanDefinitionMap.get(beanName);\n+\t\t\toldBeanDefinition = this.beanDefinitionMap.get(beanName);\n-\t\tresetBeanDefinition(beanName);\n+\t\tif (oldBeanDefinition != null || containsSingleton(beanName)) {\n+\t\t\tresetBeanDefinition(beanName);\n+\t\t}\n-\t\t// Remove any assumptions about by-type mappings.\n-\t\tclearByTypeCache();\n-",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DefaultListableBeanFactory's registerBeanDefinition only calls resetBeanDefinition in case of pre-existing bean definition or pre-existing singleton instance",
        "commit_body": "Issue: SPR-8318\n",
        "linked_issues": [
            {
                "issue_id": "12966",
                "issue_title": "XmlBeanDefinitionReader runs 10x slower due to resetBeanDefinition check [SPR-8318]",
                "issue_body": "**[Matt McQuarrie](https://jira.spring.io/secure/ViewProfile.jspa?name=mattmcq)** opened **[SPR-8318](https://jira.spring.io/browse/SPR-8318?redirect=false)** and commented\n\nWhen trying to load 700+ beans using:\norg.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions\n\nit takes over 5 min using the 2.5.3 (or 3.0.5) library, but only 24 sec using the 2.0.4 library. This seems to only occur on the AIX JVM.\n\nPlease see the attached zip with example scripts loadbeans256.sh and loadbeans204.sh\n\nWe have also tested with spring 3.0.5 and the results are similar to 2.5.6.\n\nThanks for your help with this. This is the first time I've filed a defect so please let me know if I'm missing anything.\n\n- Matt\n\n\n\n---\n\n**Affects:** 2.5.6, 3.0.5\n\n**Attachments:**\n- [DefaultListableBeanFactory.java.diff](https://jira.spring.io/secure/attachment/18236/DefaultListableBeanFactory.java.diff) (_2.78 kB_)\n- [LoadBeansExample.zip](https://jira.spring.io/secure/attachment/18134/LoadBeansExample.zip) (_8.46 MB_)\n- [LoadBeansExamplePatched.zip](https://jira.spring.io/secure/attachment/22110/LoadBeansExamplePatched.zip) (_9.91 MB_)\n- [Spring XML Parsing.png](https://jira.spring.io/secure/attachment/18235/Spring+XML+Parsing.png) (_55.75 kB_)\n\n**Backported to:** [3.2.11](https://github.com/spring-projects/spring-framework/milestone/99?closed=1)\n\n1 votes, 6 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Matt McQuarrie](https://jira.spring.io/secure/ViewProfile.jspa?name=mattmcq)** commented\n\nAfter further testing this issue seems to occur on all JVMs. HotSpot, JRockit, and IBM's JVM seem to have this issue with varying severities. For example, HotSpot takes 10x longer to load the example project's beans while IBM's JVM takes 20x longer.\n",
                    "**[Jonathan Keller](https://jira.spring.io/secure/ViewProfile.jspa?name=kellerj)** commented\n\nAdding some more information on this one:\n\nI also just did a little research into the startup time problem of KFS and the difference between Spring 2.0.4 and 2.5.6.  The problem comes partially in that we have almost 100,000 beans defined between all our XML files, not counting those which are in the Rice jars.  But more than that is some code that Spring added by 2.5.6 which is intended to improve the handling of parent beans.  (They seemed to be working before, so I don't know what changed that made this necessary.)\n\nThe problem is a new line at the end of the registerBeanDefinition() method:\n\nresetBeanDefinition(beanName);\n\nThis method is designed to find any beans for which the current bean is a parent and \"reset\" the definition in order to ensure that the proper values are being inherited.  This unfortunately requires iterating over **all** beans previously defined.  In the selection of the parsing I traced below, which processed about 6,000 bean definitions, there were almost 17,000,000 retrievals of beans simply to check if the current bean was its parent.  This method is recursive, so if there is a parent, then it does the iteration all over again.\n\nSo, it seems that the more beans which use the inheritance which makes Spring so useful, the more we impact performance.  It seems to be that a fix for this would be for Spring to index the beans by their parents (another HashMap?) so such extensive iteration would not be necessary.  It seems it would be fairly easy to update this method (and a couple others) to maintain/check this new cache to greatly reduce the application startup time.\n",
                    "**[Jonathan Keller](https://jira.spring.io/secure/ViewProfile.jspa?name=kellerj)** commented\n\nI'm attaching a diff file containing the changes I made locally to the DefaultListableBeanFactory class to implement a possible solution.  This did immediately decrease the time needed to process all our beans.\n\nIt seems to work for the use case which we have for Spring.  I don't know if there are other edge cases that may exist for which it could break, but it may be a start.\n\nThanks.\n\ndiff DefaultListableBeanFactory-original-spring-2.5.6.txt DefaultListableBeanFactory.java -b -u\n",
                    "**[John Walker](https://jira.spring.io/secure/ViewProfile.jspa?name=john.a.walker@colostate.edu)** commented\n\nVM Ware has requested to become a Commercial Affliate for Kuali Open Source. It would be helpful to the Kuali Community if someone at VMWare/Spring could address the slowness problem experienced/witnessed between versions 2.0.4 and 2.5.6. Thanks.\n",
                    "**[Kristina Taylor](https://jira.spring.io/secure/ViewProfile.jspa?name=kbit)** commented\n\nKuali Rice has recently done a Spring 4.0.5 upgrade but is still experiencing this problem.  We verified that the patch submitted by Jonathan Keller, when merged with the Spring 4.0.5 version, brings our times back to normal from the 10x slowdown we were experiencing.  Please reconsider applying this patch as it is a pretty major issue with performance.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSorry that this issue remained unnoticed for so long... We'll pick it up again now for the 4.1 RC phase, with backports possibly following.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've optimized registerBeanDefinition to only call resetBeanDefinition in case of a pre-existing bean definition or a pre-existing singleton instance. This means that resetBeanDefinition won't be called at all for regular early bean definition registration phases (such as with XML file parsing).\n\nIntroducing a parent-children association cache would be an option as well but requires clean management of both ends of that association, i.e. if a parent gets removed or one of the children gets removed... That didn't seem to be worth it, if the 90% case can be addressed as above.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant retrieval of `oldBeanDefinition` and adds a conditional check.  Previously, `oldBeanDefinition` was retrieved and then used.  Now, it's retrieved only once, and the `resetBeanDefinition` method is called only if `oldBeanDefinition` is not null *or* if the bean with the given name is a singleton",
            "avg_logprobs": -0.22962251663208008
        }
    },
    {
        "commit_hash": "a4c157fc09d3169f44901ee8969f3dacc73aaccb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/NettyWebSocketSessionSupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (message.getNativeMessage() != null) {\n+\t\t\treturn message.getNativeMessage();\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Check for native WebSocket message",
        "commit_body": "In addition to the changes in\n313a7836b091d20dbb9763b3677d559fea32d13d to support passing on a\nthe underlying WebSocket message, this commits checks for its\navailability.\n\nCloses gh-25099\n",
        "linked_issues": [
            {
                "issue_id": "25099",
                "issue_title": "WebSocketMessage's methods `fromMessage` and `toFrames` ignore  Netty WebSocketFrame metadata ",
                "issue_body": "**Affects:** LATEST (since ReactorNettyWebSocketSession introduced)\r\n\r\n## Expected Behavior\r\nAdd metadata property to the WebSocketMessage POJO. And by-pass Netty WebSocketFrame metadata in ReactorNettyWebSocketSession implementation.\r\n\r\n## Motivation\r\nTo allow proxy compressed WebSocket frames through Spring Cloud Gateway metadata of the [WebSocketFrame](https://github.com/netty/netty/blob/f66412c84c57f77915accb003dec8dc9b3896afe/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java#L31-L36)  (`rsv` and  `finalFragment`) should be processed. This will open the possibility to proxy frames \"as is\" and avoid unwanted decompress\\compress cycles inside the proxy service.\r\n\r\nThis will be also useful for the Undertow implementation soon since the migration to Netty was announced(http://undertow.io/blog/2019/04/15/Undertow-3.html)\r\nMetadata can be useful for other implementation in the future.\r\n \r\n## Possible Solution\r\nSince internal Spring WebSocketMessage is the generic POJO for the multiple servers I'd propose adding some metadata to the WebSocketMessage which and use it for any metadata needs to be passed through the `toMessage` and `toFrame` methods. \r\n\r\nFor the specific ReactorNettyWebSocketSession implementation it may looks like:\r\n```java\r\n//avoided constants similar extractions\r\n    protected WebSocketMessage toMessage(WebSocketFrame frame) {\r\n        DataBuffer payload = bufferFactory().wrap(frame.content());\r\n\r\n        return new WebSocketMessage(messageTypes.get(frame.getClass()), payload,extractFrameMetadata(frame));\r\n    }\r\n\r\n    private void extractFrameMetadata(WebSocketFrame frame) {\r\n        Map<String,Object> frameMetadata = new HashMap<>();\r\n        frameMetadata.put(\"rsv\",frame.rsv());\r\n        frameMetadata.put(\"finalFragment\", frame.isFinalFragment());\r\n    }\r\n\r\n    protected WebSocketFrame toFrame(WebSocketMessage message) {\r\n        ByteBuf byteBuf = NettyDataBufferFactory.toByteBuf(message.getPayload());\r\n        if (WebSocketMessage.Type.TEXT.equals(message.getType())) {\r\n            return new TextWebSocketFrame(byteBuf,message.getMetadataEntry(\"rsv\"), message.getMetadataEntry(\"finalFragment\"));\r\n        }\r\n        else if (WebSocketMessage.Type.BINARY.equals(message.getType())) {\r\n            return new BinaryWebSocketFrame(byteBuf,message.getMetadataEntry(\"rsv\"), message.getMetadataEntry(\"finalFragment\"));\r\n        }\r\n        else if (WebSocketMessage.Type.PING.equals(message.getType())) {\r\n            return new PingWebSocketFrame(byteBuf,message.getMetadataEntry(\"rsv\"), message.getMetadataEntry(\"finalFragment\"));\r\n        }\r\n        else if (WebSocketMessage.Type.PONG.equals(message.getType())) {\r\n            return new PongWebSocketFrame(byteBuf,message.getMetadataEntry(\"rsv\"), message.getMetadataEntry(\"finalFragment\"));\r\n        }\r\n        else {\r\n            throw new IllegalArgumentException(\"Unexpected message type: \" + message.getType());\r\n        }\r\n    }\r\n```\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "We could pass the entire frame into `WebSocketMessage` and expose it like so:\r\n```java\r\npublic Object getNativeMessage() { ... }\r\n```\r\n",
                    "Hi @rstoyanchev , First of all thanks for your response.\r\nIt may be good in some cases to pass entire frame but from other perspective it can be, for example, a room to unefficient body consumption, or some other unefficient operations with frame data. Usually I prefer a wat which is used in netty/reactor netty projects, which allow to perform potentially unefficient operations only through their helper methods, and that's why i proposed to bypass relevant metadata only here.\r\nIn this case in seems that frame do have only body and \"metadata\", (rsv and finalFragment properties)\r\nWDYT?\r\nIn any case passing complete frame will solve my case completelly as well.\r\n  ",
                    "Spring's `WebSocketMessage` already exposes the `ByteBuf` content of the Netty `WebSocketFrame`.  So in regards to body consumption, I don't see anything that changes. It's more about providing access to the rest of what's in the `WebSocketFrame` in a way that is simple (without any indirection) and is also future proof in case new fields are exposed.",
                    "Hi @rstoyanchev  \r\nUnfortunately, you've fixed only half of the original issue.\r\nsince the method -  `toFrame` does not get the data from the original message and `rsv` and `isFinalFragment` fragment is still missing when user uses `toFrame` method through  WebSocketClient.\r\nand also in Spring Cloud Gateway  (where I originally discovered this issue), the original problem will be still actual.",
                    "So it should be something like this then?\r\n```java\r\nprotected WebSocketFrame toFrame(WebSocketMessage message) {\r\n\tif (message.getNativeMessage() != null) {\r\n\t\treturn message.getNativeMessage();\r\n\t}\r\n\t// the rest of toFrame...\r\n}\r\n```\r\nAs for Spring Cloud Gateway I think that would have to be changed there in a similar way I think."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a simple `if` statement to prioritize the `message.getNativeMessage()` if it's not null.  This suggests a potential improvement in handling messages by returning the native message directly when available, rather than proceeding to some other logic.  The previous code likely had a fallback mechanism, and this change short-circuits that fallback if a native message is present",
            "avg_logprobs": -0.3625629131610577
        }
    },
    {
        "commit_hash": "a537eb3a6a763eb1812afaa1ccfc56a3dadd6cb0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tfor (Annotation ann : this.getAnnotations()) {\n+\t\tfor (Annotation ann : getAnnotations()) {\n-\t\t\treturn ObjectUtils.nullSafeEquals(this.getElementTypeDescriptor(), other.getElementTypeDescriptor());\n+\t\t\treturn ObjectUtils.nullSafeEquals(getElementTypeDescriptor(), other.getElementTypeDescriptor());\n-\t\t\treturn ObjectUtils.nullSafeEquals(this.getMapKeyTypeDescriptor(), other.getMapKeyTypeDescriptor()) &&\n-\t\t\t\t\tObjectUtils.nullSafeEquals(this.getMapValueTypeDescriptor(), other.getMapValueTypeDescriptor());\n+\t\t\treturn ObjectUtils.nullSafeEquals(getMapKeyTypeDescriptor(), other.getMapKeyTypeDescriptor()) &&\n+\t\t\t\t\tObjectUtils.nullSafeEquals(getMapValueTypeDescriptor(), other.getMapValueTypeDescriptor());",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `TypeDescriptor` removes redundant `this.` prefixes from the `for` loop and the equality checks.  This refactoring improves readability by eliminating unnecessary repetition and making the code more concise.  The change is purely stylistic, not functional, and results in a more idiomatic Java style",
            "avg_logprobs": -0.260872068859282
        }
    },
    {
        "commit_hash": "a57d6ba5f3cf8afd6f333435d47035d5fe61fcf3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/StringUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t// Shortcut if there is no work to do\n+\t\tif (pathToUse.indexOf('.') == -1) {\n+\t\t\treturn pathToUse;\n+\t\t}\n+",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize StringUtils.cleanPath",
        "commit_body": "Add an early exit to `StringUtils.cleanPath` to save array creating and\nstring concatenation. With a typical Spring application, the `cleanPath`\nmethod can be called over 600 times, often with a path constructed by\na `ClassPathResource` that is likely to already be clean.\n\nCloses gh-22568\n",
        "linked_issues": [
            {
                "issue_id": "22568",
                "issue_title": "Optimize StringUtils.cleanPath",
                "issue_body": "The `StringUtils.cleanPath` method is called ~600 times with a typical Spring Boot application and mostly with paths that are already correct. I think we can safely bypass String splitting and re-concatenation if the path does not contain `.`.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a short-circuit check.  If the `pathToUse` string does not contain a '.', it's returned immediately, avoiding further processing.  This optimization likely improves performance for paths that don't have a '.' character",
            "avg_logprobs": -0.15330968856811522
        }
    },
    {
        "commit_hash": "a603779f33d47cd9ac87919ccc26f8c2d279fa40",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/UndertowHeadersAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import java.util.ArrayList;\n+ * @author Sam Brannen\n-\t\t\tthis.headers.remove((String) key);\n+\t\t\tCollection<String> removed = this.headers.remove((String) key);\n+\t\t\tif (removed != null) {\n+\t\t\t\treturn new ArrayList<>(removed);\n+\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Return previous value in UndertowHeadersAdapter's remove() method",
        "commit_body": "Prior to this commit, UndertowHeadersAdapter's remove() method violated\nthe java.util.Map contract by always returning null.\n\nThis commit fixes this by returning the previous list stored under the\nspecified key, and otherwise returning null if no previous value was\npresent.\n\nCloses gh-27592\n",
        "linked_issues": [
            {
                "issue_id": "27592",
                "issue_title": "UndertowHeadersAdapter's remove() method violates Map contract",
                "issue_body": "The `remove(Object key)` method in `UndertowHeadersAdapter` should return any previous value stored under the key; however, the current implementation always returns `null`.\r\n\r\nThis has already been fixed in `main` as part of commit https://github.com/spring-projects/spring-framework/commit/785212d67655119a71d3ad700e90c6e09e7c6361#diff-8be9fc708f521a68eb27761d98ddd6ebc62ec5431095673c7273647a538fae6bR132-R136.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how headers are removed.  Previously, a single header key was removed directly.  Now, a check (`if (removed != null)`) is added to handle cases where multiple values existed for a single header key.  If multiple values were present, they are collected into a new `ArrayList` and returned; otherwise, nothing is returned",
            "avg_logprobs": -0.27919191360473633
        }
    },
    {
        "commit_hash": "a6b0b6e27945dcf3c84f2c8ae49969470a1c8c76",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompHeaderAccessor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "+import org.springframework.util.CollectionUtils;\n- * A {@code MessageHeaderAccessor} to use when creating a {@code Message} from a\n- * decoded STOMP frame, or when encoding a {@code Message} to a STOMP frame.\n+ * A {@code MessageHeaderAccessor} to use when creating a {@code Message} from\n+ * a decoded STOMP frame, or when encoding a {@code Message} to a STOMP frame.\n- * <p>When created from STOMP frame content, the actual STOMP headers are stored\n- * in the native header sub-map managed by the parent class\n+ * <p>When created from STOMP frame content, the actual STOMP headers are\n+ * stored in the native header sub-map managed by the parent class\n- * while the parent class\n- * {@link org.springframework.messaging.simp.SimpMessageHeaderAccessor} manages\n- * common processing headers some of which are based on STOMP headers (e.g.\n- * destination, content-type, etc).\n+ * while the parent class {@link SimpMessageHeaderAccessor} manages common\n+ * processing headers some of which are based on STOMP headers\n+ * (e.g. destination, content-type, etc).\n-\t\tif (nativeHeaders.containsKey(STOMP_CONTENT_LENGTH_HEADER)) {\n-\t\t\tList<String> values = nativeHeaders.get(STOMP_CONTENT_LENGTH_HEADER);\n-\t\t\tString value = (values != null ? values.get(0) : null);\n-\t\t\treturn Integer.valueOf(value);\n-\t\t}\n-\t\treturn null;\n+\t\tList<String> values = nativeHeaders.get(STOMP_CONTENT_LENGTH_HEADER);\n+\t\treturn (!CollectionUtils.isEmpty(values) ? Integer.valueOf(values.get(0)) : null);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Efficient STOMP content-length header check",
        "commit_body": "Issue: SPR-14747\n",
        "linked_issues": [
            {
                "issue_id": "19313",
                "issue_title": "Improve performance of StompEncoder.encode() [SPR-14747]",
                "issue_body": "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** opened **[SPR-14747](https://jira.spring.io/browse/SPR-14747?redirect=false)** and commented\n\nHey,\n\nI just noticed a rather costly assertion in the websocket layer - more explicitly in StompEncoder.encode(). Sorry I didn't notice this earlier in order to bring this to 4.3.3.\n\nIt is very similar to #19191, but has a much bigger impact on websocket applications as its executed on basically every message apart from heartbeats. Apart from the JMH benchmarks below, which show a factor of ~1200, the Assert statement in question produced more than 60GB of heap pressure in just 20 seconds. Mostly coming from the string concatenation of course.\n\n!stomp-encoder.jpg|thumbnail!\n\n|Benchmark|Mode|Cnt|Score|Error|Units|\n|:---|:---|:---|:---|:---|:---|\n|MyBenchmark.testNormal|thrpt|100|1639083,456|\u00b1 68418,140|ops/s|\n|MyBenchmark.testEnhanced|thrpt|100|2087033509,372|\u00b1 21891731,313|ops/s|\n\nMuch like the fix for #19191 I switched from Assert.notNull to a simple null check with an IllegalStateException.\n\nWhile looking into StompEncoder I also moved one variable declaration a bit down, which was not needed in every-case. I hope you don't mind.\n\nBest,\nChristoph\n\n---\n\n**Affects:** 4.2.8, 4.3.3\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/pull/1185\n\n**Attachments:**\n- [stomp-encoder.jpg](https://jira.spring.io/secure/attachment/23574/stomp-encoder.jpg) (_50.38 kB_)\n\n**Issue Links:**\n- #19191 Improve performance of assertion in StompSubProtocolHandler\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/f2e1e1b890a94d1eae4a3a9eae6095b3d49ca411, https://github.com/spring-projects/spring-framework/commit/6c764f6b8a3305ed38d77fa8b1fe920562307815, https://github.com/spring-projects/spring-framework/commit/02d83cedeacd1ea92feb0dab4525874a4734231c, https://github.com/spring-projects/spring-framework/commit/94753b5e87a622751493071ec1957bfdfded199e, https://github.com/spring-projects/spring-framework/commit/a6b0b6e27945dcf3c84f2c8ae49969470a1c8c76, https://github.com/spring-projects/spring-framework/commit/774e4c3dc10035448d12e5f883823c260569f891, https://github.com/spring-projects/spring-framework/commit/6577faa2da8b94997eb3de53d4bc575388b25e00\n\n**Backported to:** [4.2.9](https://github.com/spring-projects/spring-framework/milestone/146?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOnce again, a good catch! Merged now, to be backported to 4.3.4 and 4.2.9 tomorrow.\n",
                    "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** commented\n\nThank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the extraction of the STOMP content length header.  It removes redundant null checks and uses `CollectionUtils.isEmpty` for a more concise and efficient check for empty or null lists.  The original code had an `if` statement checking for the presence of the header and then a separate check for null values within the list.  The revised code combines these checks into a single, more readable expression.  This change improves code readability and potentially reduces execution time",
            "avg_logprobs": -0.2896147265876691
        }
    },
    {
        "commit_hash": "a6ff95a69c765b029ce0dca960345cc4360f5a58",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/FactoryBeanRegistrySupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (attribute == null) {\n+\t\t\treturn ResolvableType.NONE;\n+\t\t}\n-\t\treturn ResolvableType.NONE;\n+\t\tthrow new IllegalArgumentException(\"Invalid value type for attribute '\" +\n+\t\t\t\tFactoryBean.OBJECT_TYPE_ATTRIBUTE + \"': \" + attribute.getClass().getName());",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Restore restrictive getTypeForFactoryBeanFromAttributes check",
        "commit_body": "See gh-29799\nSee gh-30987\n",
        "linked_issues": [
            {
                "issue_id": "29799",
                "issue_title": "Clarify `FactoryBean.OBJECT_TYPE_ATTRIBUTE` supported types",
                "issue_body": "The `FactoryBean.OBJECT_TYPE_ATTRIBUTE` can be used to give type information to a `FactoryBean`. The documentation isn't clear about what types can be used.\r\n\r\nBoth [Spring Boot](https://github.com/spring-projects/spring-boot/issues/33746) and [Feign](https://github.com/spring-cloud/spring-cloud-openfeign/issues/337) have used `String` values. It appears that in reality only `Class` and `ResolvableType` are [supported](https://github.com/spring-projects/spring-framework/blob/8dbdfb0449f5223e102c090591d38ed956722147/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java#L1699).\r\n\r\nShould `AbstractBeanFactory` also accept `String` values containing class names? Or should the types supported be documented in `FactoryBean.OBJECT_TYPE_ATTRIBUTE`? If String types are not supported, the openfeign code should probably change.\r\n\r\n\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": []
            },
            {
                "issue_id": "30987",
                "issue_title": "`DefaultListableBeanFactory#getBeanNamesForType` does not take target type into account for `FactoryBean` resolution",
                "issue_body": "Given a `RootBeanDefinition` for a `FactoryBean` that exposes a generic for the bean that it produces (typically Spring Data repositories infrastructure):\r\n\r\n```java\r\nRootBeanDefinition beanDefinition = new RootBeanDefinition(JpaRepositoryFactoryBean.class);\r\nbeanDefinition.setTargetType(ResolvableType.forClassWithGenerics(JpaRepositoryFactoryBean.class,\r\n\t\tCityRepository.class, Object.class, Object.class));\r\n```\r\n\r\nA call to `getBeanNamesForType` with `CityRepository.class` does not return the bean definition. It looks like the target type is not taken into account to resolve the `FactoryBean`'s generic type, if available.\r\n\r\nFailing test case at: https://github.com/snicoll/spring-framework/commit/edb8a052c3be257f9fb5813aae9b7defbb9d5a35",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for a null `attribute` and throws an `IllegalArgumentException` if it's null.  Previously, it unconditionally returned `ResolvableType.NONE`.  The new code now validates the input, preventing potential issues arising from a null attribute value",
            "avg_logprobs": -0.16591200912207887
        }
    },
    {
        "commit_hash": "a711ed59f614e27471bab1e8b518fe165dbf5a4e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/vendor/SpringHibernateJpaPersistenceProvider.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.hibernate.cfg.Environment;\n+import org.springframework.core.NativeDetector;\n+ * @author Sebastien Deleuze\n+\tstatic {\n+\t\tif (NativeDetector.inNativeImage()) {\n+\t\t\tSystem.setProperty(Environment.BYTECODE_PROVIDER, Environment.BYTECODE_PROVIDER_NAME_NONE);\n+\t\t}\n+\t}\n+",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Set hibernate.bytecode.provider to none on native image",
        "commit_body": "Closes gh-29140\n",
        "linked_issues": [
            {
                "issue_id": "29140",
                "issue_title": "Set `hibernate.bytecode.provider` to `none` on native image",
                "issue_body": "In order to avoid using a GraalVM substitution, and given the fact that on native image it is not possible to generate bytecode at runtime, `hibernate.bytecode.provider` should be set to `none` when running as native image.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "This change adds a static initializer block to `SpringHibernateJpaPersistenceProvider`.  It conditionally sets a system property (`Environment.BYTECODE_PROVIDER`) to `Environment.BYTECODE_PROVIDER_NAME_NONE` if running in a native image environment (detected by `NativeDetector.inNativeImage()`).  This likely prevents Hibernate from using a default bytecode provider in native image scenarios, potentially improving performance or compatibility",
            "avg_logprobs": -0.08866924047470093
        }
    },
    {
        "commit_hash": "a7789db0673f6997233a6af361b23d14bf54eea0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (this.streamDriver instanceof StaxDriver) {\n-\t\t\t\twriter = ((StaxDriver) this.streamDriver).createStaxWriter(streamWriter);\n+\t\t\tif (this.streamDriver instanceof StaxDriver staxDriver) {\n+\t\t\t\twriter = staxDriver.createStaxWriter(streamWriter);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `cast` with a `var` declaration.  Specifically, the code now uses a local variable `staxDriver` of type `StaxDriver` within the `if` statement's conditional.  This improves readability and avoids the potential for a `ClassCastException` if `this.streamDriver` is not actually a `StaxDriver`",
            "avg_logprobs": -0.19362090469954849
        }
    },
    {
        "commit_hash": "a7fe6b8f5c74dd6ea0e531b3ba1e90a455ee15dd",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/ResponseCookie.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (lenient) {\n+\t\t\t\tif (lenient && !StringUtils.isEmpty(domain)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid NPE in ResponseCookie on null domain",
        "commit_body": "See gh-24663\n",
        "linked_issues": [
            {
                "issue_id": "24663",
                "issue_title": "Ignore empty domain string in ResponseCookie",
                "issue_body": "Affects `v5.2.4.RELEASE`, though I think response cookie validation was added in `v5.2.x`.\r\n\r\nWe're calling a 3rd party service that returns a `Set-Cookie` header with a `domain=\"\"` value. This is non-compliant with [rfc6265](https://tools.ietf.org/html/rfc6265) so _is_ technically wrong.\r\n\r\nHowever, Spring's now throwing an exception when encountering this header, so the entire request fails and the application is unable to consume the response.\r\n\r\nIs this intended behaviour? I think in this case Spring should [\"be conservative in what it does, be liberal in what it accepts from others\"](https://en.wikipedia.org/wiki/Robustness_principle).",
                "issue_state": "closed",
                "issue_comment": [
                    "What exactly is it returning? validateDomain starts with this which should ignore `\"\"`:\r\n```java\r\nif (!StringUtils.hasLength(domain)) {\r\n\treturn;\r\n}\r\n```\r\n\r\n> However, Spring's now throwing an exception when encountering this header, so the entire request fails and the application is unable to consume the response.\r\n\r\nTo my knowledge we are not automatically parsing the cookies. It has to be a call from the application to access the cookies, so whether to parse the cookies and how to treat errors should be in the application's control. \r\n",
                    "`Set-Cookie: xxx=xxx; Domain=\"\"; Expires=Wed, 10-Mar-2021 16:08:18 GMT; Path=/`\r\nSo it's parsing `\"\\\"\\\"\"` I think.",
                    "I'll get the full stacktrace but as far as I know we're not explicitly accessing the cookies.",
                    "> So it's parsing `\"\\\"\\\"\"` I think\r\n\r\nThis doesn't look right. What client library is this with Reactor Netty or Jetty?\r\n\r\n> as far as I know we're not explicitly accessing the cookies\r\n\r\nYes please if you could find where it's failing. There might some response copying somewhere (e.g. through a filter) but by default the cookies are only parsed via `ClientResponse#cookies`.\r\n\r\nUltimately if a server is sending invalid cookies, I don't think we can ignore that either. However the `\"\"` looks more like a parsing issue to me. It should result in an empty string probably. \r\n",
                    "Could be opentracing reading the cookies:\r\n\r\n```\r\nERROR 2020-03-10 17:00:24,628 [] [reactor-http-nio-2] r.c.p.Operators: Operator called default onErrorDropped\r\njava.lang.IllegalArgumentException: \"\": invalid cookie domain char '34'\r\n\tat org.springframework.http.ResponseCookie$Rfc6265Utils.validateDomain(ResponseCookie.java:384)\r\n\tat org.springframework.http.ResponseCookie.<init>(ResponseCookie.java:72)\r\n\tat org.springframework.http.ResponseCookie.<init>(ResponseCookie.java:36)\r\n\tat org.springframework.http.ResponseCookie$1.build(ResponseCookie.java:253)\r\n\tat org.springframework.http.client.reactive.ReactorClientHttpResponse.lambda$getCookies$4(ReactorClientHttpResponse.java:110)\r\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)\r\n\tat java.base/java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1600)\r\n\tat java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658)\r\n\tat java.base/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:274)\r\n\tat java.base/java.util.HashMap$ValueSpliterator.forEachRemaining(HashMap.java:1672)\r\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)\r\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)\r\n\tat java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)\r\n\tat java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)\r\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\r\n\tat java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:497)\r\n\tat org.springframework.http.client.reactive.ReactorClientHttpResponse.getCookies(ReactorClientHttpResponse.java:103)\r\n\tat org.springframework.web.reactive.function.client.DefaultClientResponse.cookies(DefaultClientResponse.java:104)\r\n\tat org.springframework.web.reactive.function.client.DefaultClientResponseBuilder.lambda$new$1(DefaultClientResponseBuilder.java:92)\r\n\tat org.springframework.web.reactive.function.client.DefaultClientResponseBuilder.cookies(DefaultClientResponseBuilder.java:138)\r\n\tat org.springframework.web.reactive.function.client.DefaultClientResponseBuilder.<init>(DefaultClientResponseBuilder.java:92)\r\n\tat org.springframework.web.reactive.function.client.ClientResponse.from(ClientResponse.java:227)\r\n\tat io.opentracing.contrib.spring.web.client.TracingClientResponseSubscriber.onNext(TracingClientResponseSubscriber.java:81)\r\n\tat io.opentracing.contrib.spring.web.client.TracingClientResponseSubscriber.onNext(TracingClientResponseSubscriber.java:35)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onNext(FluxPeek.java:192)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onNext(MonoFlatMapMany.java:242)\r\n\tat reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2267)\r\n\tat reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onSubscribeInner(MonoFlatMapMany.java:143)\r\n\tat reactor.core.publisher.MonoFlatMapMany$FlatMapManyInner.onSubscribe(MonoFlatMapMany.java:237)\r\n\tat reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54)\r\n\tat reactor.core.publisher.Flux.subscribe(Flux.java:8186)\r\n\tat reactor.core.publisher.MonoFlatMapMany$FlatMapManyMain.onNext(MonoFlatMapMany.java:188)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.FluxRetryPredicate$RetryPredicateSubscriber.onNext(FluxRetryPredicate.java:82)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.lambda$onNext$2(TracedSubscriber.java:69)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.withActiveSpan(TracedSubscriber.java:95)\r\n\tat io.opentracing.contrib.reactor.TracedSubscriber.onNext(TracedSubscriber.java:69)\r\n\tat reactor.core.publisher.MonoCreate$DefaultMonoSink.success(MonoCreate.java:156)\r\n\tat reactor.netty.http.client.HttpClientConnect$HttpObserver.onStateChange(HttpClientConnect.java:398)\r\n\tat reactor.netty.ReactorNetty$CompositeConnectionObserver.onStateChange(ReactorNetty.java:514)\r\n\tat reactor.netty.resources.PooledConnectionProvider$DisposableAcquire.onStateChange(PooledConnectionProvider.java:501)\r\n\tat reactor.netty.resources.PooledConnectionProvider$PooledConnection.onStateChange(PooledConnectionProvider.java:413)\r\n\tat reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:550)\r\n\tat reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:90)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n\tat io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n\tat io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:321)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:308)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:422)\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\r\n\tat io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\r\n\tat java.base/java.lang.Thread.run(Thread.java:835)\r\n```",
                    "Yes, OpenTracing is causing cookies to be parsed early. The OpenTracing implementation, which came from Sleuth I think, has room for improvement. I will create tickets for that and link here.\r\n\r\nWe can also improve how ClientResponse mutation works. I have created #24680 but because it is a more significant change it's set for 5.3.\r\n\r\nIn the mean time here I think we can check for and ignore `\"\"` to avoid this issue.",
                    "Great, thanks for the quick responses."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for an empty or null `domain` string *only* if the `lenient` flag is true.  Previously, the `if (lenient)` block always executed.  The addition of `&& !StringUtils.isEmpty(domain)` ensures that the `domain` is validated only when `lenient` is true and the `domain` is not empty or null.  This likely prevents potential issues with invalid domain values when lenient mode is enabled",
            "avg_logprobs": -0.21021194847262636
        }
    },
    {
        "commit_hash": "a832c98cedc56690ad606b53f497814370792d12",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/context/request/ServletWebRequest.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (SAFE_METHODS.contains(getRequest().getMethod())) {\n+\t\t\treturn false;\n+\t\t}\n-\t\tif (SAFE_METHODS.contains(getRequest().getMethod()) || !ifMatchHeaders.hasMoreElements()) {\n+\t\tif (!ifMatchHeaders.hasMoreElements()) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": "See gh-29460\n",
        "linked_issues": [
            {
                "issue_id": "29460",
                "issue_title": "Polish ServletWebRequest and DefaultServerWebExchange",
                "issue_body": "1.  Remove unused return value\r\n2. Add Nullable annotaions\r\n3. Simplify if statement ",
                "issue_state": "closed",
                "issue_comment": [
                    "@sbrannen \r\nThank you for your review.\r\nI reflected your review.\r\n",
                    "This has been merged into `main` in c12d93c5d1696fc030b7b2fc0fb999b99795c59c and revised in a832c98cedc56690ad606b53f497814370792d12.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change simplifies the conditional logic.  Previously, if the request method was in the `SAFE_METHODS` list *or* there were no more `if-match` headers, the function returned `false`.  The change removes the redundant check for `SAFE_METHODS` if there are no `if-match` headers.  This means the code now only checks for `SAFE_METHODS` if there are `if-match` headers present",
            "avg_logprobs": -0.24679033279418947
        }
    },
    {
        "commit_hash": "a8b7a5e037e6d2452a81b3050923096e2be51f75",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tClientRequest.Builder requestBuilder = this.inserter != null ?\n-\t\t\t\t\tinitRequestBuilder().body(this.inserter) :\n-\t\t\t\t\tinitRequestBuilder();\n+\t\t\tClientRequest.Builder requestBuilder = initRequestBuilder();\n+\t\t\tif (this.inserter != null) {\n+\t\t\t\tbuilder.body(this.inserter);\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine initRequestBuilder in DefaultWebClient",
        "commit_body": "Closes gh-30254\n",
        "linked_issues": [
            {
                "issue_id": "30254",
                "issue_title": "Refine `initRequestBuilder` in `DefaultWebClient`",
                "issue_body": "Move `inserter` into `DefaultRequestBodyUriSpec.initRequestBuilder()`",
                "issue_state": "closed",
                "issue_comment": [
                    "Not sure that's an optimization, but looks a bit cleaner and more consistent.",
                    "Merged, thanks for your contribution.",
                    "My English is not good enough to describe accurately. Thanks for your reply !"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a conditional creation and assignment of a `ClientRequest.Builder` with a simpler, explicit `if` statement.  The original code used a ternary operator to conditionally add a body to the request builder based on the presence of `this.inserter`. The updated code now initializes the builder unconditionally and then adds the body only if `this.inserter` is not null.  This change improves readability and potentially reduces unnecessary object creation",
            "avg_logprobs": -0.2115606225055197
        }
    },
    {
        "commit_hash": "aa49949d7ad09944db4284b957d754e8189ecc74",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.util.ClassUtils;\n-\t\t\t\t\tif (beanInstance != null && !beanMethod.getReturnType().isInstance(beanInstance)) {\n+\t\t\t\t\tif (beanInstance != null && !ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Bean type mismatch check accepts assignable values according to ClassUtils",
        "commit_body": "Issue: SPR-12905\n",
        "linked_issues": [
            {
                "issue_id": "17504",
                "issue_title": "@Configuration enhancer does not throw proper exception in case of mismatched @Bean method [SPR-12905]",
                "issue_body": "**[Christopher Smith](https://jira.spring.io/secure/ViewProfile.jspa?name=w_c_smith)** opened **[SPR-12905](https://jira.spring.io/browse/SPR-12905?redirect=false)** and commented\n\nGiven two unrelated `@Configuration` classes, one of which (`FooConfiguration`) provides `@Bean Foo fooBean()` and the other which (`BarConfiguration`) provides `@Bean Bar fooBean()` and has another bean method that calls `fooBean()`, the CGLib enhancer will fill in the `Foo fooBean` from the first configuration, causing a `ClassCastException` trying to cast `Foo` to `Bar`. This is something of a bug on the user's side for having a name collision, but if the container can't handle duplicate names, it needs to report that error explicitly.\n\n\n---\n\n**Affects:** 4.1.6\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/e403aefe860d12f7427655f4fd2a59966a5d6442, https://github.com/spring-projects/spring-framework/commit/aa49949d7ad09944db4284b957d754e8189ecc74\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis happens due to the container's override behavior: In such a scenario, `@Bean Bar forBean()` overrides `@Bean Foo fooBean`, with the `Bar` variant being the one registered with the container eventually. However, since you have another method programmatically calling the `Foo` variant on the first configuration class, the enhancer tries to redirect back to the container (as it should for any such `@Bean` method call) where it ends up delegating to the `Bar` variant registered there...\n\nEffectively, such overriding is supported even in such a scenario, but only if the overriding bean is assignable to the original `@Bean` return type. So what we're arguably doing wrong here is that we're not throwing a proper exception; I'll try to address that.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'll turn this into a 4.2-only feature since we've already had a minor regression - easy enough to fix, but any such assertion has a potential of breaking somebody's scenario. Arguably not worth the risk for 4.1.7.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `beanMethod.getReturnType().isInstance(beanInstance)` with `ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)`.  This likely improves type checking for compatibility with more complex generic types and potential null values.  The original `isInstance` method might have been too strict in some cases, while `isAssignableValue` provides a more flexible and robust check",
            "avg_logprobs": -0.24456993551815256
        }
    },
    {
        "commit_hash": "aa4e56b251521610999d72fb8c962575bb8bc27a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\tprivate final SourceClass objectSourceClass = new SourceClass(Object.class);\n+\n-\t\tif (classType == null) {\n-\t\t\treturn new SourceClass(Object.class);\n+\t\tif (classType == null || classType.getName().startsWith(\"java.lang.annotation\")) {\n+\t\t\treturn this.objectSourceClass;\n-\t\tif (className == null) {\n-\t\t\treturn new SourceClass(Object.class);\n+\t\tif (className == null || className.startsWith(\"java.lang.annotation\")) {\n+\t\t\treturn this.objectSourceClass;",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize @Configuration class parsing a little",
        "commit_body": "Update `ConfigurationClassParser` to skip `java.lang.annotation` types\nwhich were often processed but would never provide useful results. Also\nuse a single shared immutable `SourceClass` instance to represent\n`Object.class`.\n\nCloses gh-22563\n",
        "linked_issues": [
            {
                "issue_id": "22563",
                "issue_title": "Use less memory and try to skip more classes when processing @Configuration classes",
                "issue_body": "The `ConfigurationClassParser` often ends up creating a new `SourceClass` instance for `Object.class`. We could use a static to represent this and save ourselves a few object allocations.\r\n\r\nThe `asSourceClass` method is also often called with `java.lang.annotation` instances which can always be skipped.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the `ConfigurationClassParser` to handle `null` or `java.lang.annotation`-prefixed class types more efficiently.  Previously, `null` or `className` values would result in a new `SourceClass` instance for `Object.class`.  Now, a pre-created `SourceClass` instance (`objectSourceClass`) is returned for these cases, avoiding redundant object creation",
            "avg_logprobs": -0.2145519256591797
        }
    },
    {
        "commit_hash": "aa4f09d080049d808abffff007457d83a9a61987",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/DataBinder.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import java.util.Collection;\n-\t\t\t\tif (value == null && !BeanUtils.isSimpleValueType(param.nestedIfOptional().getNestedParameterType())) {\n+\t\t\t\tif (value == null && shouldCreateObject(param)) {\n+\tprivate static boolean shouldCreateObject(MethodParameter param) {\n+\t\tClass<?> type = param.nestedIfOptional().getNestedParameterType();\n+\t\treturn !(BeanUtils.isSimpleValueType(type) ||\n+\t\t\t\tCollection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type) || type.isArray());\n+\t}\n+",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine decision to create object for constructor injection",
        "commit_body": "Closes gh-31488\n",
        "linked_issues": [
            {
                "issue_id": "31488",
                "issue_title": "3.2.0-RC1: No primary or single unique constructor found for interface java.util.Set",
                "issue_body": "After upgrading to **Spring Boot 3.2.0-RC1** from **3.1.5** request params binding is not working.\r\n\r\n```java\r\n@RestController\r\n@RequestMapping\r\nstatic class HelloController {\r\n    enum Tag {RED, GREEN}\r\n\r\n    record HelloArgs(String name, Set<Tag> tags) {\r\n        HelloArgs(@RequestParam String name, @RequestParam Set<Tag> tags) {\r\n            this.name = name;\r\n            this.tags = tags == null ? Set.of() : tags;\r\n        }\r\n    }\r\n\r\n    @GetMapping\r\n    String hello(HelloArgs args) {\r\n        return \"Hello %s %s\".formatted(args.name(), args.tags.stream().map(Tag::name).collect(Collectors.joining()));\r\n    }\r\n}\r\n```\r\nWith request:\r\n`http GET http://localhost:8080\\?name\\=Hulk`\r\n```\r\nERROR 54976 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.lang.IllegalStateException: No primary or single unique constructor found for interface java.util.Set] with root cause\r\n\r\njava.lang.IllegalStateException: No primary or single unique constructor found for interface java.util.Set\r\n\tat org.springframework.beans.BeanUtils.getResolvableConstructor(BeanUtils.java:266) ~[spring-beans-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.validation.DataBinder.createObject(DataBinder.java:923) ~[spring-context-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.validation.DataBinder.createObject(DataBinder.java:952) ~[spring-context-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.validation.DataBinder.construct(DataBinder.java:902) ~[spring-context-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.bind.ServletRequestDataBinder.construct(ServletRequestDataBinder.java:112) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor.constructAttribute(ServletModelAttributeMethodProcessor.java:156) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.method.annotation.ModelAttributeMethodProcessor.resolveArgument(ModelAttributeMethodProcessor.java:148) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:122) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:217) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:170) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:918) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:830) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:564) ~[tomcat-embed-core-10.1.15.jar:6.0]\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) ~[spring-webmvc-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658) ~[tomcat-embed-core-10.1.15.jar:6.0]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) ~[tomcat-embed-websocket-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.1.0-RC1.jar:6.1.0-RC1]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:340) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:896) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1744) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-10.1.15.jar:10.1.15]\r\n\tat java.base/java.lang.Thread.run(Thread.java:1583) ~[na:na]\r\n```\r\n\r\n\r\nWhile with: `http GET http://localhost:8080\\?name\\=Hulk\\&tags\\=RED,GREEN` everything is okay.\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for giving the RC2 a try. \r\n\r\nBoth Spring Framework 6.0.x (Boot 3.1.x) and 6.1 (Boot 3.2) do not support constructor binding to a `Collection`. In the above example, 6.0.x passes `null` for the second parameter. 6.1 supports nested data constructors, and fails because it's trying to do more. We can make 6.1 ignore collection parameters, and pass `null` too, but I just confirm what your expectations are. Even in 6.0.x the `tags` parameter is not supported, it just happens to be more lenient by passing `null`.\r\n\r\nAs an aside, the `@RequestParam` annotations don't play any role at that level, unless you have some custom support for them. They're only checked when declared on controller method parameters.",
                    "Thanks for the tip `@RequestParam`.\nIf 6.1 is more strict, how should tags be declared?",
                    "It's not more strict intentionally. We can adjust the behavior to be equally lenient and pass `null`. I just wasn't sure what role `tags` plays in the first place, it's not very useful if it's always `null`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the `DataBinder` class to improve the handling of null values when binding to parameters.  Previously, a null value was only checked against simple value types.  The new code introduces a `shouldCreateObject` method to determine if a new object should be created for a null parameter.  This method now considers whether the parameter type is a `Collection`, `Map`, or array, in addition to simple value types",
            "avg_logprobs": -0.30500972747802735
        }
    },
    {
        "commit_hash": "ab48b88f919f2c9f8ab4880be5d82b0d55052779",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/beanvalidation/BeanValidationBeanRegistrationAotProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\telse if (ex instanceof TypeNotPresentException) {\n+\t\t\t\t\tlogger.debug(\"Skipping validation constraint hint inference for bean \" +\n+\t\t\t\t\t\t\tregisteredBean.getBeanName() + \" due to a TypeNotPresentException at validator level: \" + ex.getMessage());\n+\t\t\t\t}\n-\t\t\t\t\tlogger.error(\"Skipping validation constraint hint inference for bean \" +\n+\t\t\t\t\tlogger.warn(\"Skipping validation constraint hint inference for bean \" +",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine BeanValidationBeanRegistrationAotProcessor logging",
        "commit_body": "This commit prints a log message at debug level without\na stacktrace for TypeNotPresentException and uses\nwarn level instead of error level for other exceptions\nsince the processing of such bean will just be skipped.\n\nCloses gh-31147\n",
        "linked_issues": [
            {
                "issue_id": "31147",
                "issue_title": "Update logging level in BeanValidationBeanRegistrationAotProcessor for validation exceptions",
                "issue_body": "spring boot 3.1.3\r\ngradle native plugin 0.9.25\r\n\r\nprocessAot gradle task\r\n\r\n```\r\n...anValidationBeanRegistrationAotProcessor : Skipping validation constraint hint inference for bean queryDslQuerydslPredicateOperationCustomizer\r\njava.lang.TypeNotPresentException: Type com.querydsl.core.types.Path not present\r\n\tat java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:117) ~[na:na]\r\n\tat java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125) ~[na:na]\r\n\tat java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49) ~[na:na]\r\n\tat java.base/sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68) ~[na:na]\r\n\tat java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138) ~[na:na]\r\n\tat java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49) ~[na:na]\r\n\tat java.base/sun.reflect.generics.repository.MethodRepository.computeReturnType(MethodRepository.java:75) ~[na:na]\r\n\tat java.base/sun.reflect.generics.repository.MethodRepository.getReturnType(MethodRepository.java:66) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.getGenericReturnType(Method.java:297) ~[na:na]\r\n\tat org.hibernate.validator.internal.properties.javabean.JavaBeanMethod.<init>(JavaBeanMethod.java:20) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.properties.javabean.JavaBeanHelper.executable(JavaBeanHelper.java:133) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.properties.javabean.JavaBeanHelper.executable(JavaBeanHelper.java:121) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.properties.javabean.JavaBeanHelper.executable(JavaBeanHelper.java:113) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.findExecutableMetaData(AnnotationMetaDataProvider.java:307) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getMetaData(AnnotationMetaDataProvider.java:292) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getMethodMetaData(AnnotationMetaDataProvider.java:279) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.retrieveBeanConfiguration(AnnotationMetaDataProvider.java:131) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getBeanConfiguration(AnnotationMetaDataProvider.java:121) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.getBeanConfigurationForHierarchy(BeanMetaDataManagerImpl.java:234) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.createBeanMetaData(BeanMetaDataManagerImpl.java:201) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl.getBeanMetaData(BeanMetaDataManagerImpl.java:165) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.hibernate.validator.internal.engine.ValidatorImpl.getConstraintsForClass(ValidatorImpl.java:316) ~[hibernate-validator-8.0.1.Final.jar:8.0.1.Final]\r\n\tat org.springframework.validation.beanvalidation.BeanValidationBeanRegistrationAotProcessor$BeanValidationDelegate.processAheadOfTime(BeanValidationBeanRegistrationAotProcessor.java:100) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.validation.beanvalidation.BeanValidationBeanRegistrationAotProcessor.processAheadOfTime(BeanValidationBeanRegistrationAotProcessor.java:67) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.beans.factory.aot.BeanDefinitionMethodGeneratorFactory.getAotContributions(BeanDefinitionMethodGeneratorFactory.java:151) ~[spring-beans-6.0.11.jar:6.0.11]\r\n\tat org.springframework.beans.factory.aot.BeanDefinitionMethodGeneratorFactory.getBeanDefinitionMethodGenerator(BeanDefinitionMethodGeneratorFactory.java:99) ~[spring-beans-6.0.11.jar:6.0.11]\r\n\tat org.springframework.beans.factory.aot.BeanDefinitionMethodGeneratorFactory.getBeanDefinitionMethodGenerator(BeanDefinitionMethodGeneratorFactory.java:115) ~[spring-beans-6.0.11.jar:6.0.11]\r\n\tat org.springframework.beans.factory.aot.BeanRegistrationsAotProcessor.processAheadOfTime(BeanRegistrationsAotProcessor.java:49) ~[spring-beans-6.0.11.jar:6.0.11]\r\n\tat org.springframework.beans.factory.aot.BeanRegistrationsAotProcessor.processAheadOfTime(BeanRegistrationsAotProcessor.java:37) ~[spring-beans-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.BeanFactoryInitializationAotContributions.getContributions(BeanFactoryInitializationAotContributions.java:67) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.BeanFactoryInitializationAotContributions.<init>(BeanFactoryInitializationAotContributions.java:49) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.BeanFactoryInitializationAotContributions.<init>(BeanFactoryInitializationAotContributions.java:44) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.ApplicationContextAotGenerator.lambda$processAheadOfTime$0(ApplicationContextAotGenerator.java:58) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.ApplicationContextAotGenerator.withCglibClassHandler(ApplicationContextAotGenerator.java:67) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.ApplicationContextAotGenerator.processAheadOfTime(ApplicationContextAotGenerator.java:53) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.ContextAotProcessor.performAotProcessing(ContextAotProcessor.java:106) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.ContextAotProcessor.doProcess(ContextAotProcessor.java:84) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.ContextAotProcessor.doProcess(ContextAotProcessor.java:49) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.context.aot.AbstractAotProcessor.process(AbstractAotProcessor.java:82) ~[spring-context-6.0.11.jar:6.0.11]\r\n\tat org.springframework.boot.SpringApplicationAotProcessor.main(SpringApplicationAotProcessor.java:80) ~[spring-boot-3.1.2.jar:3.1.2]\r\nCaused by: java.lang.ClassNotFoundException: com.querydsl.core.types.Path\r\n\tat java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) ~[na:na]\r\nCaused by: java.lang.ClassNotFoundException: com.querydsl.core.types.Path\r\n\r\n\tat java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) ~[na:na]\r\n\tat java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ~[na:na]\r\n\tat java.base/java.lang.Class.forName0(Native Method) ~[na:na]\r\n\tat java.base/java.lang.Class.forName(Class.java:496) ~[na:na]\r\n\tat java.base/java.lang.Class.forName(Class.java:475) ~[na:na]\r\n\tat java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114) ~[na:na]\r\n\t... 39 common frames omitted\r\n```\r\n**i don't use query dsl in project,** when gradle native plugin is disabled there is no exception and project runs fine\r\n\r\nwhen i add api 'com.querydsl:querydsl-jpa:5.0.0' as dependency exception is also gone",
                "issue_state": "closed",
                "issue_comment": [
                    "Does the exception cause AOT processing to fail or is it just distracting and rather noisy? Looking at the message, I suspect it's the latter as it's reporting the reason for \"skipping validation constraint hint inference\".",
                    "it is just distracting, but it was not present in earlier versions",
                    "Thanks for the clarification.\r\n\r\nI think this could be improved in Spring Framework as most runtime exceptions thrown from `getConstraintsForClass` will result in an error being logged. In this case, debug logging would be more appropriate as the failure is benign. We'll transfer the issue to the Framework team so that they can consider making such a change.",
                    "@adsafawqew Can you please provide a reproducer? I would like to be able to verify the behavior of the different log levels during AOT processing to refine the logging accordingly.",
                    "If you would like us to look at this issue, please provide the requested information. If the information is not provided within the next 7 days this issue will be closed.\n",
                    "can confirm that this has been fixed with spring boot version 3.1.4",
                    "having similar issue with spring-boot v `3.1.8` and grralvm gradle plugin v `0.9.28`\r\n```\r\n[2/7] Performing analysis...  [*]                                                                        (8.7s @ 1.27GB)\r\n   7,970 (85.10%) of  9,365 classes reachable\r\n   9,846 (63.42%) of 15,524 fields reachable\r\n  26,676 (73.17%) of 36,459 methods reachable\r\n   1,337 classes, 1,524 fields, and 2,538 methods registered for reflection\r\n       1 native library: -framework CoreServices\r\n\r\nFatal error: java.lang.TypeNotPresentException: Type com.querydsl.core.types.Path not present\r\n        at java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:117)\r\n        at java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125)\r\n        at java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)\r\n        at java.base/sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68)\r\n        at java.base/sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138)\r\n        at java.base/sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)\r\n        at java.base/sun.reflect.generics.repository.MethodRepository.computeReturnType(MethodRepository.java:75)\r\n        at java.base/sun.reflect.generics.repository.MethodRepository.getReturnType(MethodRepository.java:66)\r\n        at java.base/java.lang.reflect.Method.getGenericReturnType(Method.java:295)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.reflect.ReflectionDataBuilder.registerTypesForMethod(ReflectionDataBuilder.java:505)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.reflect.ReflectionDataBuilder.processMethodMetadata(ReflectionDataBuilder.java:264)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.reflect.ReflectionDataBuilder.duringAnalysis(ReflectionDataBuilder.java:199)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.reflect.ReflectionFeature.duringAnalysis(ReflectionFeature.java:254)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.lambda$runPointsToAnalysis$10(NativeImageGenerator.java:748)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.FeatureHandler.forEachFeature(FeatureHandler.java:85)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.lambda$runPointsToAnalysis$11(NativeImageGenerator.java:748)\r\n        at org.graalvm.nativeimage.pointsto/com.oracle.graal.pointsto.AbstractAnalysisEngine.runAnalysis(AbstractAnalysisEngine.java:162)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.runPointsToAnalysis(NativeImageGenerator.java:745)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.doRun(NativeImageGenerator.java:578)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.run(NativeImageGenerator.java:535)\r\n------------------------------------------------------------------------------------------------------------------------\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGeneratorRunner.buildImage(NativeImageGeneratorRunner.java:403)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGeneratorRunner.build(NativeImageGeneratorRunner.java:580)\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGeneratorRunner.main(NativeImageGeneratorRunner.java:128)\r\nCaused by: java.lang.ClassNotFoundException: com.querydsl.core.types.Path\r\n        at java.base/java.net.URLClassLoader.findClass(URLClassLoader.java:445)\r\n        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:587)\r\n        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)\r\n        at java.base/java.lang.Class.forName0(Native Method)\r\n        at java.base/java.lang.Class.forName(Class.java:467)\r\n        at java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114)\r\n        ... 22 more\r\n                        3.6s (7.5% of total time) in 27 GCs | Peak RSS: 4.60GB | CPU load: 2.69\r\n```\r\nalso have no `querydsl` usage in my project so wonder if this is something given by Spring's transitive dependencies and/or an issue in gradle plugin itself.",
                    "@ashirmanov Please create a new issue with a reproducer as an attached archive or a link to a repository if you want us to have a look.",
                    "Had the same issue building native image with graalVM @ashirmanov , resolved by adding: `implementation 'com.querydsl:querydsl-core:5.1.0'` to my build.gradle. I honestly don't know what is using it under the hood, but the latest dependency I added was `org.springdoc:springdoc-openapi-starter-webmvc-ui:2.4.0`."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the handling of `TypeNotPresentException` within the `BeanValidationBeanRegistrationAotProcessor`.  Previously, a `logger.error` was used to log the skipping of validation constraint hint inference.  The change now uses `logger.warn` for this specific exception type.  This suggests a change in severity level, potentially indicating that `TypeNotPresentException` is now considered less critical than other exceptions that previously triggered the `error` log",
            "avg_logprobs": -0.2401461060514155
        }
    },
    {
        "commit_hash": "ab5aea5a1346cf489e8c727c3d4ee563352b3787",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t/** Java 8's java.util.Optional.empty() */\n-\tprivate static Object javaUtilOptionalEmpty = null;\n-\n+\n+\t/** Java 8's java.util.Optional.empty() */\n+\tprivate static Object javaUtilOptionalEmpty = null;\n+\n-\t\t} catch (Exception ex) {\n+\t\t}\n+\t\tcatch (Exception ex) {\n-\t\tif (targetType.getObjectType().equals(javaUtilOptionalEmpty.getClass())) {\n+\t\tif (javaUtilOptionalEmpty != null && targetType.getObjectType().equals(javaUtilOptionalEmpty.getClass())) {",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensively check javaUtilOptionalEmpty",
        "commit_body": "Issue: SPR-11888\n",
        "linked_issues": [
            {
                "issue_id": "16507",
                "issue_title": "WebMVC throws nullpointerexception on java 6 in TypeConverterDelegate [SPR-11888]",
                "issue_body": "**[Boris Bera](https://jira.spring.io/secure/ViewProfile.jspa?name=boris-b)** opened **[SPR-11888](https://jira.spring.io/browse/SPR-11888?redirect=false)** and commented\n\nWhen running the latest snapshot (4.1.0.BUILD-20140619.135109-207) of spring-webmvc on java 1.6, requests done with a MockMvc will throw a nullpointerexception in the TypeConverterDelegate class.\n\nStacktrace:\n\n```\norg.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:973)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:852)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:668)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837)\n\tat org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:62)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:770)\n\tat org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:170)\n\tat org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:137)\n\tat org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:141)\n\tat com.vantrix.mp.mpcms.impl.rest.MPRESTServiceImplUT.thatFindConvertsParameters(MPRESTServiceImplUT.java:222)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)\n\tat org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)\n\tat org.junit.runners.Suite.runChild(Suite.java:127)\n\tat org.junit.runners.Suite.runChild(Suite.java:26)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:160)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)\nCaused by: java.lang.NullPointerException\n\tat org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:260)\n\tat org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:106)\n\tat org.springframework.beans.TypeConverterSupport.doConvert(TypeConverterSupport.java:64)\n\tat org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:47)\n\tat org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:582)\n\tat org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:105)\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:79)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:157)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:124)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:938)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:870)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961)\n\t... 46 more\n```\n\nI did some digging and I think the problem comes from this commit: https://github.com/spring-projects/spring-framework/commit/0dc6082b01606c3c996b728541467ba5104b747f\n\nThe problem is on line 260 in spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java\n\nIn java 1.6, javaUtilOptionalEmpty is null and calling .getClass() on it throws the exception.\n\n\n---\n\n**Affects:** 4.1 RC1\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nIndeed, the same applies to a similar check in GenericConversionService.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes a `try-catch` block that was previously handling an `Exception` and checking if the `targetType` was equal to the `javaUtilOptionalEmpty` class.  The `try-catch` block is now entirely removed, and the conditional check is now guarded by a check for `javaUtilOptionalEmpty != null`.  This suggests the original `try-catch` block was likely unnecessary and potentially introduced a bug or performance issue",
            "avg_logprobs": -0.3281711196899414
        }
    },
    {
        "commit_hash": "abb8a93e2fa3e91286d72518dbb5f88c219834ef",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/user/DefaultUserDestinationResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate String subscriptionDestinationPrefix = \"/user/queue/\";\n-\n-\t\tthis.subscriptionDestinationPrefix = this.destinationPrefix + \"queue/\";\n-\t/**\n-\t * Return the prefix used to identify user destinations for (un)subscribe messages.\n-\t * <p>By default \"/user/queue/\".\n-\t */\n-\tpublic String getSubscriptionDestinationPrefix() {\n-\t\treturn this.subscriptionDestinationPrefix;\n-\t}\n-\t\t\tif (!checkDestination(destination, this.subscriptionDestinationPrefix)) {\n+\t\t\tif (!checkDestination(destination, this.destinationPrefix)) {",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Drop separate user dest property for subscriptions",
        "commit_body": "Before this change DefaultUserDestinationResolver provided a separate\ndestination prefix property for identifying \"user\" destinations in\nsubscription requests as opposed to in sent messages. Such a separate\nproperty should not be needed.\n\nIssue: SPR-11263\n",
        "linked_issues": [
            {
                "issue_id": "15888",
                "issue_title": "hardcoded \".../queue/...\"-part in DefaultUserDestinationResolver conflicts with rabbitmq exchange naming [SPR-11263]",
                "issue_body": "**[zyro](https://jira.spring.io/secure/ViewProfile.jspa?name=zyro)** opened **[SPR-11263](https://jira.spring.io/browse/SPR-11263?redirect=false)** and commented\n\nthe hardcoded \"queue\" suffix for the subscription prefix makes it impossible to use a pattern like \"/user/exchange/amq.direct/...\" instead of \"/user/queue/...\".\ne.g. with rabbitmq this means to be restricted to durable, no-auto-delete queues atm?\n\n\n---\n\n**Affects:** 4.0 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/abb8a93e2fa3e91286d72518dbb5f88c219834ef\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nSee commit [abb8a9](https://github.com/spring-projects/spring-framework/commit/abb8a93e2fa3e91286d72518dbb5f88c219834ef)\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how user destinations are resolved for subscription messages in `DefaultUserDestinationResolver`.  Previously, the `subscriptionDestinationPrefix` was hardcoded to \"/user/queue/\".  Now, it dynamically derives the prefix from the `destinationPrefix` member variable, effectively making the prefix configurable.  This change removes the hardcoded \"/user/queue/\" prefix and replaces it with a more flexible approach",
            "avg_logprobs": -0.2579066848754883
        }
    },
    {
        "commit_hash": "abcfffdde9aa833c1ce493525e9d2b9e4f15c46c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/support/AllEncompassingFormHttpMessageConverter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (jaxb2Present && !jackson2Present) {\n+\t\tif (jaxb2Present && !jackson2XmlPresent) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Allow JAXB to be registered next to plain Jackson",
        "commit_body": "Issue: SPR-14336\n",
        "linked_issues": [
            {
                "issue_id": "18908",
                "issue_title": "AllEncompassingFormHttpMessageConverter ignores JAXB XML when Jackson used for JSON [SPR-14336]",
                "issue_body": "**[Jan Zahornadsky](https://jira.spring.io/secure/ViewProfile.jspa?name=yankyo)** opened **[SPR-14336](https://jira.spring.io/browse/SPR-14336?redirect=false)** and commented\n\nAfter changes introduced in #17894, the new conditions are causing that in a project that uses both XML (via JAXB) and JSON (via Jackson) AllEncompassingFormHttpMessageConverter no longer works correctly with XML.\n\nReferring to the code in https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/support/AllEncompassingFormHttpMessageConverter.java, the condition for including Jaxb part converter should read\n\n```java\n// instead of && !jackson2Present\nif (jaxb2Present && !jackson2XmlPresent) {\n\taddPartConverter(new Jaxb2RootElementHttpMessageConverter());\n}\n```\n\n---\n\n**Affects:** 4.2.6\n\n**Issue Links:**\n- #17894 AllEncompassingFormHttpMessageConverter prioritizes Jackson 2 XML over JSON\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/abcfffdde9aa833c1ce493525e9d2b9e4f15c46c, https://github.com/spring-projects/spring-framework/commit/d0b2fe5e8c8e8d1a51f57f15ffbcbb8c2180b835\n\n**Backported to:** [4.2.7](https://github.com/spring-projects/spring-framework/milestone/144?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional check within `AllEncompassingFormHttpMessageConverter`.  Originally, it checked if Jackson 2 was present.  The change now checks if Jackson 2 *XML* support is present instead.  This suggests a shift in the dependency handling or a change in how XML support is determined.  The code now prioritizes Jackson 2 XML over the older Jackson 2 implementation",
            "avg_logprobs": -0.2927038328988211
        }
    },
    {
        "commit_hash": "ac11acb532803ad557c2739549b9ac5e00695f12",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/PostProcessorRegistrationDelegate.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+ * @author Sam Brannen\n+\t\t// Nothing to sort?\n+\t\tif (postProcessors.size() <= 1) {\n+\t\t\treturn;\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize sorting in PostProcessorRegistrationDelegate",
        "commit_body": "Closes gh-24776\n",
        "linked_issues": [
            {
                "issue_id": "24776",
                "issue_title": "Optimize sortPostProcessors() in PostProcessorRegistrationDelegate",
                "issue_body": "Size equal to 0 or 1 can return directly\r\n\r\n```java\r\nprivate static void sortPostProcessors(List<?> postProcessors, ConfigurableListableBeanFactory beanFactory) {\r\n\t\tComparator<Object> comparatorToUse = null;\r\n\t\tif (beanFactory instanceof DefaultListableBeanFactory) {\r\n\t\t\tcomparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator();\r\n\t\t}\r\n\t\tif (comparatorToUse == null) {\r\n\t\t\tcomparatorToUse = OrderComparator.INSTANCE;\r\n\t\t}\r\n\t\tpostProcessors.sort(comparatorToUse);\r\n\t}\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "Good catch. We'll optimize this in `5.2.6`.",
                    "It make code ugly, is it worthy?",
                    "@quaff, We have implemented similar optimizations recently. See #24617 for details."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to prevent unnecessary sorting of post-processors.  If the `postProcessors` list has one or fewer elements, the method now immediately returns, avoiding the sorting operation. This optimization likely improves performance when the list is small",
            "avg_logprobs": -0.18836752573649088
        }
    },
    {
        "commit_hash": "ac4525ddf8b280759c0d3ba63d3569dda64a2e3a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/JdbcUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\telse if (\"MariaDB\".equals(source)) {\n+\t\t\tname = \"MySQL\";\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Detect MariaDB as MySQL (for mariadb-java-client 2.4+ compatibility)",
        "commit_body": "Closes gh-22344\n",
        "linked_issues": [
            {
                "issue_id": "22344",
                "issue_title": "mariadb-java-client 2.4.0 productName changed: breaks Spring Batch",
                "issue_body": "**Affects:** Spring Framework 5.1.4-RELEASE (Spring Batch 4.1.1.RELEASE)\r\n\r\n---\r\n\r\nUp to `mariadb-java-client` 2.3.0, driver product name was \"MySQL\". With version 2.4.0, it's now \"MariaDB\" (due to [this change](https://github.com/MariaDB/mariadb-connector-j/commit/5ec5099441a49c677785848132a6099b2beaee99#diff-a6869b202907d71c3d5aecefe6de0ce1R1133)), so `org/springframework/batch/support/DatabaseType.java:fromMetaData()` cannot recognize it.  \r\n-> Could you detect MariaDB as MySQL database? Thx!  \r\n\r\nSpring Batch loads `JobRepositoryFactoryBean` that calls `DatabaseType.java:fromMetaData()` and throws the following error:\r\n\r\n```\r\n23:08:09 ERROR o.s.boot.SpringApplication:858 [] Application run failed\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'application': Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'batchConfigurer': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Unable to initialize Spring Batch\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:139) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1737) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:576) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:846) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:863) ~[spring-context-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546) ~[spring-context-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:142) ~[spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:775) ~[spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) ~[spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:316) ~[spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1260) ~[spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1248) ~[spring-boot-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat manon.Application.main(Application.java:36) ~[classes/:na]\r\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'batchConfigurer': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Unable to initialize Spring Batch\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:139) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:419) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1737) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:576) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:498) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:320) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:318) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:602) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:590) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1204) ~[spring-context-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration.initialize(SimpleBatchConfiguration.java:114) ~[spring-batch-core-4.1.1.RELEASE.jar:4.1.1.RELEASE]\r\n\tat org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration$ReferenceTargetSource.createObject(SimpleBatchConfiguration.java:142) ~[spring-batch-core-4.1.1.RELEASE.jar:4.1.1.RELEASE]\r\n\tat org.springframework.aop.target.AbstractLazyCreationTargetSource.getTarget(AbstractLazyCreationTargetSource.java:88) ~[spring-aop-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:193) ~[spring-aop-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat com.sun.proxy.$Proxy137.getTransaction(Unknown Source) ~[na:na]\r\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:474) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:289) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat manon.user.service.RegistrationServiceImpl$$EnhancerBySpringCGLIB$$f2c072d8.ensureAdmin(<generated>) ~[classes/:na]\r\n\tat manon.Application.initApp(Application.java:53) ~[classes/:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\t... 18 common frames omitted\r\nCaused by: java.lang.IllegalStateException: Unable to initialize Spring Batch\r\n\tat org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.initialize(BasicBatchConfigurer.java:101) ~[spring-boot-autoconfigure-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:363) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:307) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\tat org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136) ~[spring-beans-5.1.4.RELEASE.jar:5.1.4.RELEASE]\r\n\t... 48 common frames omitted\r\nCaused by: java.lang.IllegalArgumentException: DatabaseType not found for product name: [MariaDB]\r\n\tat org.springframework.batch.support.DatabaseType.fromProductName(DatabaseType.java:82) ~[spring-batch-infrastructure-4.1.1.RELEASE.jar:4.1.1.RELEASE]\r\n\tat org.springframework.batch.support.DatabaseType.fromMetaData(DatabaseType.java:121) ~[spring-batch-infrastructure-4.1.1.RELEASE.jar:4.1.1.RELEASE]\r\n\tat org.springframework.batch.core.repository.support.JobRepositoryFactoryBean.afterPropertiesSet(JobRepositoryFactoryBean.java:183) ~[spring-batch-core-4.1.1.RELEASE.jar:4.1.1.RELEASE]\r\n\tat org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.createJobRepository(BasicBatchConfigurer.java:131) ~[spring-boot-autoconfigure-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\tat org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.initialize(BasicBatchConfigurer.java:96) ~[spring-boot-autoconfigure-2.1.2.RELEASE.jar:2.1.2.RELEASE]\r\n\t... 55 common frames omitted\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "It looks like we can sufficiently address this for Spring Batch's purposes at the core framework level through detecting \"MariaDB\" as \"MySQL\" in `JdbcUtils.commonDatabaseName` (which Spring Batch's `DatabaseType` class is using). Beyond that, we should also detect it as MySQL in our `sql-error-codes` file.",
                    "@jonathanlermitage any opportunity to give this an early try against `5.1.5.BUILD-SNAPSHOT` from https://repo.spring.io/snapshot, ideally before the official 5.1.5 release on Wednesday? It'd be great to know whether this actually works for Spring Batch now...",
                    "@jhoeller I tried on a personal [project](https://github.com/jonathanlermitage/manon/commit/5a40fd335ef24c3396171a0b07215821c3a45b11) and it works fine.  \r\nThx!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a new `else if` condition to the existing conditional logic.  If the `source` string is \"MariaDB\", the `name` variable is set to \"MySQL\".  This suggests a mapping or renaming of database types within the code",
            "avg_logprobs": -0.15223342401010018
        }
    },
    {
        "commit_hash": "ac9ca412c8ea974a83015cc4dff19fe43fa51c58",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/UrlResource.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.util.Base64Utils;\n+ * @author Denis Kostin\n+\n+\t\tif (this.url.getUserInfo() != null) {\n+\t\t\tString basicAuth = \"Basic \" + Base64Utils.encodeToString(url.getUserInfo().getBytes());\n+\t\t\tcon.setRequestProperty(\"Authorization\", basicAuth);\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add Basic Authorization for UrlResource",
        "commit_body": "See gh-1822\n",
        "linked_issues": [
            {
                "issue_id": "1822",
                "issue_title": "Added Basic Authorization for UrlResource",
                "issue_body": "This pull request adds Basic Authorization for UrlResource.\r\nThis is fix for https://github.com/spring-projects/spring-boot/issues/6138",
                "issue_state": "closed",
                "issue_comment": [
                    "@x-x-z Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=1822)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=1822) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@x-x-z Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=1822)!",
                    "\ud83d\udc4d \r\nIt would be nice if this change has been merged.",
                    "@x-x-z can you share how this is a fix for the issue you've linked?",
                    "Sorry for the delay @x-x-z and thanks very much for making your first contribution to Spring Framework."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `url.getUserInfo()` and, if not null, sets the `Authorization` header of the connection (`con`) to a Basic authentication string generated from the user info using Base64 encoding.  This implements basic authentication for URLs with user credentials",
            "avg_logprobs": -0.14229009862531694
        }
    },
    {
        "commit_hash": "ad6d183a0614adaa0bb1493a9500a4a9b412c1e2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/support/ConversionUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\telse if (sourceElementType.getType().isAssignableFrom(targetElementType.getType())) {\n+\t\tif (sourceElementType.getType().isAssignableFrom(targetElementType.getType())) {\n-\t\telse {\n-\t\t\t// no\n-\t\t\treturn false;\n-\t\t}\n+\t\t// no\n+\t\treturn false;",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove unneeded conditional logic",
        "commit_body": "Update `ConversionUtils` to remove conditional logic that isn't\nnecessary.\n\nIssue: SPR-16968\n",
        "linked_issues": [
            {
                "issue_id": "21506",
                "issue_title": "Add checkstyle [SPR-16968]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-16968](https://jira.spring.io/browse/SPR-16968?redirect=false)** and commented\n\nAdding checkstyle to the Spring Framework build would help catch common coding issues and aid contributors.\n\n\n---\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1865\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nI have a PR in progress\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nhttps://github.com/spring-projects/spring-framework/pull/1865\n\nFirst off, a massive apology for the size of the PR. It turned out to be a lot more involved that I first thought. Other than the number of files touched, I don't think there's too many controversial parts to the PR. Perhaps the one that might cause the the biggest concern is the change in imports. I've added rules to enforce the import order based on [the rules in the WIKI](https://github.com/spring-projects/spring-framework/wiki/Code-Style#import-statements) but I've also enforced that `star` static imports shouldn't be allowed. This was mainly so I could use IDE tooling, but I also think it makes sense as it's very easy to mess up if the same method name is declared in more than one `star` import. I've had this happen quite often with Mockito and Hamcrest. I also think it's easier to read the source offline when when exact import statements are declared.\n\nThe other one that might be a bit controversial is single argument lambdas. In Spring Boot we opted to always use the parentheses around the argument so that single argument and multi-argument lambdas look the same.\n\nLet me know if you want me to refine any of the rules or rework the commits in any way.\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nPhil, there is plenty of good polish in that PR but it also adapts a few widespread things that we intentionally did differently: e.g. no copyright headers on package-info, no \"this.\" prefix on logger access, no type+\"this.\" prefix in inner classes for access to outer state... and allowing star imports in test classes.\n\nGenerally speaking, I'm not sure whether enforcing production checkstyle guidelines on test sources is necessary or even desirable. At the very least, we could have more relaxed guidelines for test sources. For a start, enumerating the assertion method imports for every single test class feels odd to me... but I'm also generally much more relaxed about the code style used for test methods or inner classes used by them, with many production rules not needing to apply there.\n\nAs for single-argument lambdas, I visually object to the enforced parentheses there. Frankly, I'd rather wrap the expression itself in additional parentheses than such a plain parameter name part. We knew you chose differently in Boot but I'm afraid I'm not up for changing our style here in this respect.\n\nThe equals/hashCode stuff is unfortunately a common false signal by style-checking tools. All of those classes were valid since the superclass `hashCode()` implementation has a base hash that the subclasses choose to keep in that coarse-grained fashion. Enforcing `hashCode()` in those subclasses seems rather pointless, in particular when the overridden methods literally just call super and are effectively just there to keep checkstyle happy.\n\nWith respect to consistent code blocks and consistent ternary expression style, there were a few glitches... but also a few cases where we intentionally used one-line if variants, e.g. in `AbstractBeanDefinition` for better readability of that long if cascade. I'm also not opposed to shortened blocks in test classes, and I don't see all those inverted ternary expressions as really worthwhile... when local readability doesn't really improve through that measure.\n\nAll in all, from where I stand at the moment, the PR itself is way too much to merge. Let me rather go through the commits individually and hand-pick key changes while ignoring a whole range of others... and see where we end up with. In particular, I'm going to focus on production source fine-tuning, not touching test sources unless there is something totally bogus there. Once I've done an initial pass through this, let's see which checkstyle rules we'll eventually set up.\n\nLast but not least, thanks for your efforts there! This is pointing out a lot of stuff worth reviewing, even in areas where we might not enforce hard rules eventually.\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nThanks for the fast review, I know there's a way too much in one PR so I was expecting to need a few rounds. I might be able to do something with the commits I have locally which are a lot more fine grained.\n\n> Phil, there is plenty of good polish in that PR but it also adapts a few widespread things that we intentionally did differently: e.g. no copyright headers on package-info, no \"this.\" prefix on logger access, no type+\"this.\" prefix in inner classes for access to outer state... and allowing star imports in test classes.\n\nI figured some of those were intentional, but I wasn't 100% sure. For Spring Boot I have a lot of IDE templates and auto-cleanup enabled so I've tended to take a blanket rule over exceptions. For example, if I create a new class file I get the copyright header, but Eclipse doesn't give me a way to skip it only for `package-info.java` files. Likewise, if I save a file in Spring Boot the IDE automatically adds `this.`, but it doesn't offer a way to skip it for `this.logger`. Same with star imports, I either get all or none, so I opted for none.\n\nI intentionally started this PR with the same approach to see what you thought about it. I think with checkstyle we can refine the rules to enforce what we want. I'll have a look to see if we can refine some of those checks to also enforce the exceptions. For me, one of the biggest benefits to checkstyle is helping to know what the rules are. I had no idea that `this.logger` shouldn't be used, so I think it would be really beneficial to enforce that one.\n\n> Generally speaking, I'm not sure whether enforcing production checkstyle guidelines on test sources is necessary or even desirable. At the very least, we could have more relaxed guidelines for test sources. For a start, enumerating the assertion method imports for every single test class feels odd to me... but I'm also generally much more relaxed about the code style used for test methods or inner classes used by them, with many production rules not needing to apply there.\n\nIt's easy to add a blanket exclude for `src/test/*` if that's a better option. I didn't do that for pretty much the same reason as above. Eclipse doesn't offer an easy opt-out of formatting and cleanup for `src/test` so I just treated them in exactly the same way.\n\n> As for single-argument lambdas, I visually object to the enforced parentheses there. Frankly, I'd rather wrap the expression itself in additional parentheses than such a plain parameter name part. We knew you chose differently in Boot but I'm afraid I'm not up for changing our style here in this respect.\n\nNo problem, I wasn't 100% sold on it myself at first in Boot (but I do really like the consistency now). I can refine the checkstyle rule in the other direction and enforce that all single parameter lambdas must _not_ have parentheses.\n\n> The equals/hashCode stuff is unfortunately a common false signal by style-checking tools. All of those classes were valid since the superclass hashCode() implementation has a base hash that the subclasses choose to keep in that coarse-grained fashion. Enforcing hashCode() in those subclasses seems rather pointless, in particular when the overridden methods literally just call super and are effectively just there to keep checkstyle happy.\n\nI agree, It's a little pointless. On the other hand, it found at least one that was genuine I think. Do you think the empty `hashCode` is worth it for those few false-positive cases, since it helps when new code is developed? Or would you rather drop that rule entirely?\n\n> With respect to consistent code blocks and consistent ternary expression style, there were a few glitches... but also a few cases where we intentionally used one-line if variants, e.g. in AbstractBeanDefinition for better readability of that long if cascade.\n\nI could either drop the rule, or add an exception for the few cases where it looks better shortened. I'm personally in favor of hard rules here, just so nothing is open to interpretation. I think I use more brain cycles working out why a bit of code is formatted differently than just dealing with more whitespace.\n\n> I'm also not opposed to shortened blocks in test classes, and I don't see all those inverted ternary expressions as really worthwhile... when local readability doesn't really improve through that measure.\n\nIf we drop test checks then those blocks won't be enforced. On the other hand, if it's test code perhaps if doesn't really matter if they take up a bit more space? The ternary things is a bit strict as well. Stephane pointed out that you polish a lot of them to use `!=` and he finds that it helps when scanning code because his eyes just go `(the test ? the not equals case ? the equals case)`. Individually they don't add much, but collectively they might help. It will be easy to make that an option if you prefer?\n\n> All in all, from where I stand at the moment, the PR itself is way too much to merge. Let me rather go through the commits individually and hand-pick key changes while ignoring a whole range of others... and see where we end up with. In particular, I'm going to focus on production source fine-tuning, not touching test sources unless there is something totally bogus there. Once I've done an initial pass through this, let's see which checkstyle rules we'll eventually set up.\n\nI'm happy to have another pass here as well if it helps. Splitting out the PR into test, production and unwinding a few of the rules discussed above shouldn't take me too long. Probably the most labor intensive part was the javadoc changes so I'd be super happy if those could go in?\n\n> Last but not least, thanks for your efforts there! This is pointing out a lot of stuff worth reviewing, even in areas where we might not enforce hard rules eventually.\n\nSorry it ballooned into such a monster. It really ended up being quite extreme all things considered!\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\n3 things...\n1. Thanks for taking the initiative here.\n2. Yes, that is indeed quite a doozie of a PR. ;)\n3. Regarding the Eclipse formatter settings, I took a look, but TBH it's impossible to make heads or tails of that diff. Would you mind sorting the current settings on `master` alpha-numerically (and pushing to `master`) and then sort your updated settings the same way so that the diff becomes suitable for human consumption? That would make it much easier for me to make sense of the changes. Also, please change \"5.0\" to \"5.1\" for `@since` tags for new types.\n\nCheers!\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nI'm doing another round on this one, I'll take the eclipse settings as different commit.\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\n[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen) The eclipse update is pushed\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) I've forced pushed a second round so the PR should be a bit easier to digest now. I know you wanted the javadoc one as a different PR but I've left it in this one for now (otherwise I can't get checkstyle to pass).\n\nHere are the updates:\n\n- Tests are no longer verified and I've removed the test source from each commit. I've added a couple of commits for test polishing that I still think is worthwhile.\n- The javadoc commits has been squashed into a single commit. The `@param` rule on classes has been changed to match the existing style.\n- The copyright header is no longer applied to `package-info.java` and I've added a rule to enforce that nobody adds one by mistake.\n- I've kept the block style rule but changed {[AbstractBeanDefinition.equals}} in a polish commit to make it more palatable.\n- The `this.` rule is now enforced for most items but relaxed for inner classes. I've added a rule to make sure `this.logger` is never used.\n- I've kept the rule of equals must have hashcode but added exceptions for the override cases. There are still a few legitimate ones I think.\n- The lambda rules are now enforced in the other direction (all single arg lambdas must not use parenthesis)\n- Star imports have still been expanded in the src/main but we can do another round on this if you let me know the exceptions.\n- I've completely dropped the ternary checks for now. I'm not sure what the rules should be regarding parenthesis. I've see `a & b ? \"foo\" : \"bar\"`, `(a & b) ? \"foo\" : \"bar\"` and `(a & b ? \"foo\" : \"bar\")`. If there's a rule that can be applied I can refine the checkstyle code.\n\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\n[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)\n\n> The eclipse update is pushed\n\nWhere? To a different branch?\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nAhhh... you pushed to `master`. Found the commit.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change converts an `else if` statement to an `if` statement, removing the subsequent `else` block.  This effectively short-circuits the conditional logic.  The original `else` block, which contained a comment \"no\", is now replaced with a direct `return false`.  The net effect is that if the condition `sourceElementType.getType().isAssignableFrom(targetElementType",
            "avg_logprobs": -0.20233577728271485
        }
    },
    {
        "commit_hash": "ae43b17fa0f7c6303a53a97803a8a64ce3d42b01",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/JsonViewResponseBodyAdvice.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\n-import org.springframework.util.Assert;\n- * {@code @RequestMapping} or {@code @ExceptionHandler} method. The serialization\n- * view specified in the annotation will be passed in to the\n- * {@code MappingJackson2HttpMessageConverter} which will then use it to\n+ * {@code @RequestMapping} or {@code @ExceptionHandler} method.\n+ *\n+ * <p>The serialization view specified in the annotation will be passed in to\n+ * the {@code MappingJackson2HttpMessageConverter} which will then use it to\n+ * <p>Note that despite {@code @JsonView} allowing for more than one class to\n+ * be specified, the use for a response body advice is only supported with\n+ * exactly one class argument. Consider the use of a composite interface.\n+ *\n-\t\tAssert.isTrue(annotation.value().length != 0, \"No view class in JsonView annotation on \" + returnType);\n-\t\tbodyContainer.setSerializationView(annotation.value()[0]);\n+\t\tClass<?>[] classes = annotation.value();\n+\t\tif (classes.length != 1) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"@JsonView only supported for response body advice with exactly 1 class argument: \" + returnType);\n+\t\t}\n+\t\tbodyContainer.setSerializationView(classes[0]);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "JsonViewResponseBodyAdvice throws IllegalArgumentException in case of >1 view class specified",
        "commit_body": "Issue: SPR-12270\n",
        "linked_issues": [
            {
                "issue_id": "16875",
                "issue_title": "Clarify the single class restriction with @JsonView for a response body advice [SPR-12270]",
                "issue_body": "**[Alexey Krylov](https://jira.spring.io/secure/ViewProfile.jspa?name=lexx)** opened **[SPR-12270](https://jira.spring.io/browse/SPR-12270?redirect=false)** and commented\n\nCurrently only one `@JsonView` class is used:\n\nJsonViewResponseBodyAdvice.java:\n\n```\n\t@Override\n\tprotected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType,\n\t\t\tMethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tJsonView annotation = returnType.getMethodAnnotation(JsonView.class);\n\t\tAssert.isTrue(annotation.value().length != 0, \"No view class in JsonView annotation on \" + returnType);\n\t\tbodyContainer.setSerializationView(annotation.value()[0]);\n\t}\n```\n\nMy code:\n\n```\n@JsonView({Category.Default.class, Product.Default.class})\n   @RequestMapping(\"/catalog.json\")\n   public Collection<Category> getCatalog(@Named(\"deviceId\") @RequestParam(value = \"device_id\", required = false) Integer deviceId) {\n       return retrieveCatalog(deviceId);\n   }\n```\n\nIn this example only Category.Default.class will be used.\nIt will be very nice to have full support for `@JsonView`.\n\n\n\n---\n\n**Affects:** 4.1 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/a3fd00eadbc59698a9c7870fb3539431d4579f00, https://github.com/spring-projects/spring-framework/commit/ae43b17fa0f7c6303a53a97803a8a64ce3d42b01\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze)** commented\n\nHi Alexey,\n\n`@JsonView` was originally created to annotate a field with one or multiple views, but like JAX-RS `@JsonView` support (more details at http://wiki.fasterxml.com/JacksonJsonViews), we are reusing this annotation in Spring MVC for another purpose: enabling a view on a per handler method basis, and in this context Jackson API does not support multiple views.\n\nI am going to add a check in order to actively reject multiple view classes in this context, and update our documentation accordingly.\n\nFor your need, you should use a single view interface that will inherit of multiple other ones. Jackson will use the view specified and all the inherited ones to serialize the output.\n\nPlease also notice that we are going to change the default configuration in the upcoming 4.1.1 release when using `@EnableWebMvc` or `<mvc:annotation-driven />`. By default, `SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION` will be set to false in order to avoid including non annotated fields/properties in the output when `@JsonView` is used on a method handler. See #16793 for more details.\n\nRegards,\nS\u00e9bastien Deleuze\n",
                    "**[Alexey Krylov](https://jira.spring.io/secure/ViewProfile.jspa?name=lexx)** commented\n\nHi Sebastien,\nWill try this approach with one composite interface.\nThanks.\n",
                    "**[Alexey Krylov](https://jira.spring.io/secure/ViewProfile.jspa?name=lexx)** commented\n\nYes, it works!\nThanks!\n\n```\npublic interface NativeClient extends Category.WithProductsCount, Product.WithSections, Product.WithoutDescription {\n}\n...\n\n@JsonView(NativeClient.class)\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[S\u00e9bastien Deleuze](https://jira.spring.io/secure/ViewProfile.jspa?name=sdeleuze), I've revised `JsonViewResponseBodyAdvice`'s assertion to insist on exactly 1 class specified there. Let's mark this issue as resolved once we've also documented that as discussed on the team call today.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change enforces a constraint on the `@JsonView` annotation within the `JsonViewResponseBodyAdvice`.  Previously, it silently accepted multiple view classes.  Now, it throws an `IllegalArgumentException` if the annotation specifies more than one view class.  This change explicitly requires exactly one view class to be used with this advice, promoting better usage and preventing potential ambiguity",
            "avg_logprobs": -0.23794782638549805
        }
    },
    {
        "commit_hash": "aeb77cf4e1506745db53b4514479368387e72786",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\t\t// Another thread is busy in a singleton factory callback, potentially blocked.\n-\t\t\t\t\t\t// Fallback as of 6.2: process given singleton bean outside of singleton lock.\n-\t\t\t\t\t\t// Thread-safe exposure is still guaranteed, there is just a risk of collisions\n-\t\t\t\t\t\t// when triggering creation of other beans as dependencies of the current bean.\n-\t\t\t\t\t\tif (threadWithLock != null && logger.isInfoEnabled()) {\n-\t\t\t\t\t\t\tlogger.info(\"Creating singleton bean '\" + beanName + \"' in thread \\\"\" +\n-\t\t\t\t\t\t\t\t\tThread.currentThread().getName() + \"\\\" while thread \\\"\" + threadWithLock.getName() +\n-\t\t\t\t\t\t\t\t\t\"\\\" holds singleton lock for other beans \" + this.singletonsCurrentlyInCreation);\n+\t\t\t\t\t\tif (threadWithLock != null) {\n+\t\t\t\t\t\t\t// Another thread is busy in a singleton factory callback, potentially blocked.\n+\t\t\t\t\t\t\t// Fallback as of 6.2: process given singleton bean outside of singleton lock.\n+\t\t\t\t\t\t\t// Thread-safe exposure is still guaranteed, there is just a risk of collisions\n+\t\t\t\t\t\t\t// when triggering creation of other beans as dependencies of the current bean.\n+\t\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.info(\"Creating singleton bean '\" + beanName + \"' in thread \\\"\" +\n+\t\t\t\t\t\t\t\t\t\tThread.currentThread().getName() + \"\\\" while thread \\\"\" + threadWithLock.getName() +\n+\t\t\t\t\t\t\t\t\t\t\"\\\" holds singleton lock for other beans \" + this.singletonsCurrentlyInCreation);\n+\t\t\t\t\t\t\t}",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Restore correct threadWithLock check without isInfoEnabled()",
        "commit_body": "See gh-23501\n",
        "linked_issues": [
            {
                "issue_id": "23501",
                "issue_title": "Synchronization during singleton creation may result in deadlock",
                "issue_body": "**Affects:** 5.1.9.RELEASE\r\n\r\nDuring singleton creation, `DefaultSingletonBeanRegistry` synchronises on `this.singletonObjects`:\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/b1171d82967cfd374f0b08f9580fe662fa1a98e8/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L204\r\n\r\nWhile synchronized, it then uses the `singletonFactory` to create the singleton:\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/b1171d82967cfd374f0b08f9580fe662fa1a98e8/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L222\r\n\r\nThis call into user code while holding a lock can result in deadlock. We've seen one example reported in [this Spring Boot issue](https://github.com/spring-projects/spring-boot/issues/17765) where Micrometer is also involved. I've also reproduced a very similar problem without Micrometer and with no synchronization in user code:\r\n\r\n```java\r\npackage example;\r\n\r\nimport javax.annotation.PostConstruct;\r\nimport javax.validation.Validator;\r\nimport javax.validation.constraints.Max;\r\n\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.validation.annotation.Validated;\r\nimport org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;\r\nimport org.springframework.validation.beanvalidation.MethodValidationPostProcessor;\r\n\r\npublic class SingletonCreationDeadlockTests {\r\n\t\r\n\t@Test\r\n\tpublic void create() {\r\n\t\tnew AnnotationConfigApplicationContext(Config.class).close();;\r\n\t}\r\n\t\r\n\tprivate static final class Registry {\r\n\t\t\r\n\t\tprivate final ConfigProperties properties;\r\n\t\t\r\n\t\tRegistry(ConfigProperties properties) {\r\n\t\t\tthis.properties = properties;\r\n\t\t}\r\n\t\t\r\n\t\tvoid register() {\r\n\t\t\tthis.properties.getSetting();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t@Validated\r\n\tstatic class ConfigProperties {\r\n\r\n\t\t@Max(10)\r\n\t\tprivate int setting = 5;\r\n\r\n\t\tpublic int getSetting() {\r\n\t\t\treturn this.setting;\r\n\t\t}\r\n\r\n\t\tpublic void setSetting(int setting) {\r\n\t\t\tthis.setting = setting;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t@Configuration\r\n\tstatic class Config {\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic Registry registry(ConfigProperties properties) {\r\n\t\t\treturn new Registry(properties);\r\n\t\t}\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic ConfigProperties properties() {\r\n\t\t\treturn new ConfigProperties();\r\n\t\t}\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic LocalValidatorFactoryBean localValidatorFactoryBean() {\r\n\t\t\treturn new LocalValidatorFactoryBean();\r\n\t\t}\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic static MethodValidationPostProcessor methodValidationPostProcessor(@Lazy Validator validator) {\r\n\t\t\tMethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor();\r\n\t\t\tpostProcessor.setValidator(validator);\r\n\t\t\treturn postProcessor;\r\n\t\t}\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic Registrar registrar(Registry registry) {\r\n\t\t\treturn new Registrar(registry);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic class Registrar {\r\n\t\t\r\n\t\tprivate final Registry registry;\r\n\t\t\r\n\t\tRegistrar(Registry registry) {\r\n\t\t\tthis.registry = registry;\r\n\t\t}\r\n\t\t\r\n\t\t@PostConstruct\r\n\t\tvoid register() {\r\n\t\t\tThread thread = new Thread(() -> {\r\n\t\t\t\tregistry.register();\r\n\t\t\t});\r\n\t\t\tthread.start();\r\n\t\t\ttry {\r\n\t\t\t\tthread.join();\r\n\t\t\t} catch (InterruptedException ex) {\r\n\t\t\t\tThread.currentThread().interrupt();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n```\r\n\r\nHere's a zip of a complete project containing the above test: [singleton-creation-deadlock.zip](https://github.com/spring-projects/spring-framework/files/3529528/singleton-creation-deadlock.zip)\r\n\r\nThe deadlock occurs because the main thread has locked `singletonObjects` and then waits for the thread created by `Registrar` to complete. The thread created by `Registrar` ends up waiting to lock `singletonObjects` due to `ConfigProperties` being `@Validated` and the resolution of the `@Lazy` `Validator` requiring a call to `DefaultListableBeanFactory.doResolveDependency` which results in a call to `DefaultSingletonBeanRegistry.getSingleton` where the attempt to lock `singletonObjects` is made.",
                "issue_state": "closed",
                "issue_comment": [
                    "I am seeing this exact same deadlock. Why are we `synchronizing` on a `ConcurrentHashMap (singletonObjects)` anyways?",
                    "We've just seen this problem again in https://github.com/spring-projects/spring-boot/issues/33070. Here's a slightly simpler recreation that uses an `ObjectProvider` rather than a `@Lazy` `Validator` to trigger the problem:\r\n\r\n```java\r\npackage com.example.demo;\r\n\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.beans.factory.ObjectProvider;\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\nimport jakarta.annotation.PostConstruct;\r\n\r\npublic class SingletonCreationDeadlockTests {\r\n\t\r\n\t@Test\r\n\tpublic void create() {\r\n\t\tnew AnnotationConfigApplicationContext(Config.class).close();;\r\n\t}\r\n\t\r\n\tprivate static final class Registry {\r\n\t\t\r\n\t\tprivate final ObjectProvider<ConfigProperties> properties;\r\n\t\t\r\n\t\tRegistry(ObjectProvider<ConfigProperties> properties) {\r\n\t\t\tthis.properties = properties;\r\n\t\t}\r\n\t\t\r\n\t\tvoid register() {\r\n\t\t\tthis.properties.getIfAvailable().getSetting();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic class ConfigProperties {\r\n\r\n\t\tprivate int setting = 5;\r\n\r\n\t\tpublic int getSetting() {\r\n\t\t\treturn this.setting;\r\n\t\t}\r\n\r\n\t\tpublic void setSetting(int setting) {\r\n\t\t\tthis.setting = setting;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t@Configuration\r\n\tstatic class Config {\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic Registry registry(ObjectProvider<ConfigProperties> properties) {\r\n\t\t\treturn new Registry(properties);\r\n\t\t}\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic Registrar registrar(Registry registry) {\r\n\t\t\treturn new Registrar(registry);\r\n\t\t}\r\n\t\t\r\n\t\t@Bean\r\n\t\tpublic ConfigProperties properties() {\r\n\t\t\treturn new ConfigProperties();\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tstatic class Registrar {\r\n\t\t\r\n\t\tprivate final Registry registry;\r\n\t\t\r\n\t\tRegistrar(Registry registry) {\r\n\t\t\tthis.registry = registry;\r\n\t\t}\r\n\t\t\r\n\t\t@PostConstruct\r\n\t\tvoid register() {\r\n\t\t\tThread thread = new Thread(() -> {\r\n\t\t\t\tregistry.register();\r\n\t\t\t});\r\n\t\t\tthread.start();\r\n\t\t\ttry {\r\n\t\t\t\tthread.join();\r\n\t\t\t} catch (InterruptedException ex) {\r\n\t\t\t\tThread.currentThread().interrupt();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n```",
                    "The problem here is the starting of a new thread in `@PostConstruct` which is conceptually a variant of `InitializingBean.afterPropertiesSet`, only really meant to validate configuration state before publishing the bean instance to the container (which is why it has happening within the singleton creation lock). It's a bit like the end of a constructor implementation.\r\n\r\nDoing extensive work that might trigger new threads - and even wait for them to return - is rather meant to happen in a `SmartInitializingSingleton.afterSingletonsInstantiated` callback (or in an `ApplicationListener<ContextRefreshedEvent>` or the like). For a simple guideline: Whatever you would not do in a constructor, you should not do in a `@PostConstruct` method either.\r\n\r\nRevisiting the singleton creation lock is a tough challenge due to singleton beans typically being part of a larger bean dependency graph. With a relaxed per-bean lock, circular references might run into a deadlock when triggered from different threads. There is no simple works-for-everything solution here, I'm afraid.",
                    "Thanks, Juergen. The new thread started in `@PostConstruct` was just a synthetic way of recreating the deadlock. In the latest situation where we've seen the problem there's no user code starting or joining a thread.\r\n\r\nThe two threads that are involved are the main thread and the JVM's \"Notification Thread\". Due to Micrometer listening for GC notifications, the notification thread is making a call to a `SingletonSupplier` that's calling `ObjectProvider.getObject()` to supply the singleton. This results in it waiting to take the singleton creation lock. At the same time, the main thread is holding the singleton creation lock and then ends up trying to call the same `SingletonSupplier` which is locked by the notification thread.",
                    "Thanks for the clarification, Andy - that clarifies a lot.\r\n\r\nCould Micrometer possibly only start listening to GC notifications once it is fully initialized, including the beans that it depends on? It seems brittle to let GC notifications trigger any kind of bean initialization to begin with...",
                    "It's tricky and quite complex. In some situations, listening to the GC notification won't cause any bean creation. It will cause bean creation if you're using Prometheus, have Exemplars enabled, and the lazily created `SpanContextSupplier` implementation hasn't already been created. The laziness is necessary as there's a dependency cycle otherwise:\r\n\r\n```\r\n/**\r\n * Since the MeterRegistry can depend on the {@link Tracer} (Exemplars) and the\r\n * {@link Tracer} can depend on the MeterRegistry (recording metrics), this\r\n * {@link SpanContextSupplier} breaks the cycle by lazily loading the {@link Tracer}.\r\n */\r\n```\r\n\r\nI take the general point though that in all likelihood we need to find a way to resolve this in Boot and/or Micrometer.\r\n\r\n/cc @jonatan-ivanov"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change moved the logging statement inside an `if (logger.isInfoEnabled())` block.  Previously, the logging call was unconditionally executed if `threadWithLock` was not null.  The modification now only logs the message if the logger is configured to output info-level messages, improving efficiency and reducing unnecessary logging.  This is a simple refactoring focused on logging optimization",
            "avg_logprobs": -0.2323382655276528
        }
    },
    {
        "commit_hash": "af03fa765785973944bed689250b13c5ea9ff6f7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context-indexer/src/main/java/org/springframework/context/index/processor/StandardStereotypesProvider.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "- * {@code jakarta.*} annotation <i>present</i> on a class or interface.\n+ * {@code jakarta.*} or {@code javax.*} annotation <i>present</i> on a class or\n+ * interface.\n-\t\t\tif (type.startsWith(\"jakarta.\")) {\n+\t\t\tif (type.startsWith(\"jakarta.\") || type.startsWith(\"javax.\")) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reinstate support for javax.* annotations in component indexer",
        "commit_body": "- for consistency with the changes made in e1826d2322\n\nSee gh-31090\n",
        "linked_issues": [
            {
                "issue_id": "31090",
                "issue_title": "Reinstate support for legacy JSR-250 `@javax.annotation.ManagedBean` and JSR-330 `@javax.inject.Named` annotations",
                "issue_body": "With the migration to Jakarta annotations in 6.0, we switched to supporting `@jakarta.annotation.ManagedBean` and `@jakarta.inject.Named` annotations for component scanning and component name lookups.\r\n\r\nTo better assist projects in the migration to Spring 6+, we should reinstate support for the legacy JSR-250 `@javax.annotation.ManagedBean` and JSR-330 `@javax.inject.Named` annotations so that existing compiled code will continue to work as expected.\r\n\r\n## Related Issues\r\n\r\n- #27444\r\n- #30695\r\n\r\n## Deliverables\r\n\r\n- [x] Support `@javax.annotation.ManagedBean` and `@javax.inject.Named` in `ClassPathScanningCandidateComponentProvider#registerDefaultFilters(...)`.\r\n- [x] Support `@javax.annotation.ManagedBean` and `@javax.inject.Named` in `AnnotationBeanNameGenerator#isStereotypeWithNameValue(...)`.\r\n- [x] Update tests.\r\n- [x] Update Javadoc.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Current work on this feature can be viewed in the following feature branch: https://github.com/spring-projects/spring-framework/compare/main...sbrannen:spring-framework:issues/gh-31090-legacy-ManagedBean-and-Named-annotations"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `StandardStereotypesProvider` class to now consider both `jakarta.*` and `javax.*` annotations when determining if a class or interface is annotated.  Previously, only `jakarta.*` annotations were checked.  This is a simple but crucial change to support both Jakarta and legacy javax annotations",
            "avg_logprobs": -0.21701117295485275
        }
    },
    {
        "commit_hash": "af13580fd52be266df4e10b058c134bf05373d9f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/MvcUriComponentsBuilder.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tfor (int i = 0; i < this.argumentValues.length; i++) {\n-\t\t\t\tthis.argumentValues[i] = null;\n-\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Remove unnecessary array initialization",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change sets all elements of the `argumentValues` array to `null`.  This suggests a clearing or resetting of the `argumentValues` array, likely preparing it for reuse or a new set of values",
            "avg_logprobs": -0.11615416208902994
        }
    },
    {
        "commit_hash": "b082f546ecf781af7d572c22dc52f0c49760452b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ReflectionUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tList<Method> defaultMethods = findConcreteMethodsOnInterfaces(clazz);\n+\t\t\t\tList<Method> defaultMethods = findDefaultMethodsOnInterfaces(clazz);\n-\tprivate static List<Method> findConcreteMethodsOnInterfaces(Class<?> clazz) {\n+\tprivate static List<Method> findDefaultMethodsOnInterfaces(Class<?> clazz) {\n-\t\t\tfor (Method ifcMethod : ifc.getMethods()) {\n-\t\t\t\tif (ifcMethod.isDefault()) {\n+\t\t\tfor (Method method : ifc.getMethods()) {\n+\t\t\t\tif (method.isDefault()) {\n-\t\t\t\t\tresult.add(ifcMethod);\n+\t\t\t\t\tresult.add(method);",
        "change_count": 10,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ReflectionUtils` modifies the method `findConcreteMethodsOnInterfaces` to `findDefaultMethodsOnInterfaces`.  The core change is a renaming of the method and a subsequent change within the loop.  Instead of filtering for `ifcMethod.isDefault()`, it now checks `method.isDefault()`.  This suggests a refactoring to more accurately target methods with default implementations on interfaces, likely improving clarity and maintainability",
            "avg_logprobs": -0.32540218353271483
        }
    },
    {
        "commit_hash": "b0d273e047871a50709535a8af8823a2b892a9ad",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/support/BitsCronField.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (value.indexOf('?') != -1) {\n+\t\tif (value.equals(\"?\")) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a check for the presence of a `?` character within the `value` string with a direct equality check for the string `value` being equal to `\"?\")`.  This significantly narrows the condition.  Previously, the code checked if the `?` character existed anywhere within the string; now it only checks if the entire string is `?`",
            "avg_logprobs": -0.1933265108811228
        }
    },
    {
        "commit_hash": "b0e6091cadeaf29a95ab7d85eebd3c46671b6ac6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/messaging/SubProtocolWebSocketHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tlogger.error(\"No session for \" + message);\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t// The broker may not have removed the session yet\n+\t\t\t\tlogger.debug(\"No session for \" + message);\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Lower \"no session\" message log level in SubProtocolWSH",
        "commit_body": "Issue: SPR-12247\n",
        "linked_issues": [
            {
                "issue_id": "16861",
                "issue_title": "Sending message in ApplicationListener<SessionDisconnectEvent> results in ERROR level logging  [SPR-12247]",
                "issue_body": "**[Rob Winch](https://jira.spring.io/secure/ViewProfile.jspa?name=rwinch)** opened **[SPR-12247](https://jira.spring.io/browse/SPR-12247?redirect=false)** and commented\n\nWhen sending a message in an `ApplicationListener<SessionDisconnectEvent>` I get an error similar to the following:\n\n```\nERROR 3993 --- [tboundChannel-3] o.s.w.s.m.SubProtocolWebSocketHandler    : No session for GenericMessage [payload=byte[19], headers={simpMessageType=MESSAGE, simpSubscriptionId=sub-3, contentType=application/json;charset=UTF-8, simpSessionId=1q1pejao, simpDestination=/topic/friends/signout}]\n```\n\nThis should not result in error level logging.\n\nThe reason I want to send a message from an `ApplicationListener<SessionDisconnectEvent>` is that I am writing a chat application that is sending a message to all connected clients to indicate the user has signed out.\n\n\n---\n\n**Affects:** 4.1 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/b0e6091cadeaf29a95ab7d85eebd3c46671b6ac6\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nHow are you sending the message exactly?\n",
                    "**[Rob Winch](https://jira.spring.io/secure/ViewProfile.jspa?name=rwinch)** commented\n\nI'm using the `SimpMessageSendingOperations` as shown below:\n\n```\nmessagingTemplate.convertAndSend(\"/topic/friends/signout\", Arrays.asList(user.getUsername()));\n```\n\nYou can find a complete example in [github](https://github.com/rwinch/spring-security-0-to-4.0/blob/dda960c125c4ef2cfb34f5bb8c9942ffc1b8b46f/src/main/java/sample/config/WebSocketConfig.java#L167)\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOkay most likely the broker hasn't had a chance to remove the subscription yet.\n",
                    "**[Rob Winch](https://jira.spring.io/secure/ViewProfile.jspa?name=rwinch)** commented\n\nThanks for the quick replies. This was my guess as well.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies logging behavior for cases where a session is not found.  Previously, an error log was always emitted.  Now, a debug log is used instead, *only* if the debug level is enabled.  This change likely aims to reduce unnecessary error messages, potentially improving performance and readability of logs in non-debug environments",
            "avg_logprobs": -0.2059625680895819
        }
    },
    {
        "commit_hash": "b121c0e2eac898d9762523af01895ca18219126d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/TomcatHttpHandlerAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import javax.servlet.ServletInputStream;\n+\t\t\tServletInputStream inputStream = ((ServletRequest) getNativeRequest()).getInputStream();\n+\t\t\tif (!(inputStream instanceof CoyoteInputStream)) {\n+\t\t\t\t// It's possible InputStream can be wrapped, preventing use of CoyoteInputStream\n+\t\t\t\treturn super.readFromInputStream();\n+\t\t\t}\n-\t\t\t\tServletRequest request = getNativeRequest();\n-\t\t\t\tint read = ((CoyoteInputStream) request.getInputStream()).read(byteBuffer);\n+\t\t\t\tint read = ((CoyoteInputStream) inputStream).read(byteBuffer);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid ClassCastException in TomcatHttpHandlerAdapter",
        "commit_body": "Closes gh-24707\n",
        "linked_issues": [
            {
                "issue_id": "24707",
                "issue_title": "Avoid ClassCastException for CoyoteInputStream in TomcatHttpHandlerAdapter",
                "issue_body": "Servlet filter added in Spring Boot's `org.springframework.boot.web.embedded.tomcat.TomcatContextCustomizer` may override `HttpServletRequestWrapper.getInputStream()` and return an object derived from `ServletInputStream` that is not assignment compatible with Tomcat's `CoyoteInputStream`.",
                "issue_state": "closed",
                "issue_comment": [
                    "@sada-sigsci, do you have a concrete use case where you encountered a `ClassCastException` in conjunction with the `TomcatHttpHandlerAdapter`?",
                    "Tentatively slated for 5.2.5 since this seems like a potential bug.",
                    "Thank you for reviewing the PR.\r\nYes, web application security servlet filter middleware we work on reads the POST body and inspects for any anomalies before the HTTP servlet can read the POST body. Unbuffered POST body can be read (ServletInputStream.markSupported() may return false) only once in the filter. So the servlet filter has to extend the ServletInputStream class and wrap the body already read in the filter.",
                    "`TomcatHttpHandlerAdapter` is for use in WebFlux where direct use of the Servlet is not supported. It is expected to use `WebFilter` instead. For example Spring Security provides a WebFlux integration based on that.\r\n\r\nAs an aside, when Servlet 3.1 non-blocking I/O is used, as in WebFlux, quite a few other parts of the Servlet API should not be used, or would interfere if used.\r\n\r\n",
                    "Example application is standard Reactive `SpringBootApplication` using embedded Tomcat instead of default Netty and customized using component `WebServerFactoryCustomizer<TomcatReactiveWebServerFactory>`.\r\n\r\nApplication was throwing ClassCastException when `@RestController` method tried to read `@RequestBody`. \r\n\r\n`TomcatHttpHandlerAdapter` wrapped `httpHandlerServlet` and added to `TomcatReactiveWebserver` in spring-boot(`TomcatReactiveWebServerFactory.java`). This fix is required so the servlet `httpHandlerServlet` is able to read the POST body on behalf of application `@RequestBody` \r\n\r\nOur middleware class derived from ServletInputStream overrides non-blocking i/o methods and `ReadListener` of servlets 3.1 ",
                    "So you are wrapping `ServletInputStream` and don't want it (e.g. unwrapped and) read more efficiently via `CoyoteInputStream` writing directly to a `ByteBuffer` (vs via `byte[]` first)? "
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `TomcatHttpHandlerAdapter` improves handling of `ServletInputStream`.  Previously, it directly accessed the `getInputStream()` of the `ServletRequest` and then cast it to `CoyoteInputStream`.  The new code now first checks if the `inputStream` is an instance of `CoyoteInputStream`. If not, it defers to the superclass's `readFromInputStream()` method, likely handling cases where the `InputStream` is wrapped",
            "avg_logprobs": -0.24770063400268555
        }
    },
    {
        "commit_hash": "b1231de062f58571702e77ad9a3896fdbad092ef",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\tprivate static int getPropertyNameKeyEnd(String propertyName, int startIndex) {\n+\tprivate int getPropertyNameKeyEnd(String propertyName, int startIndex) {\n-\t\t\t\t\t// The property name contains opening prefix(es)\n+\t\t\t\t\t// The property name contains opening prefix(es)...\n-\t\t\t\t\t\t// No unclosed prefix(es) in the property name (left), this is the suffix we are looking for\n+\t\t\t\t\t\t// No unclosed prefix(es) in the property name (left) ->\n+\t\t\t\t\t\t// this is the suffix we are looking for.\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\t// This suffix does not close the initial prefix, but one that occurred within the property name\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\t// This suffix does not close the initial prefix but rather\n+\t\t\t\t\t\t// just one that occurred within the property name.\n+",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix formatting",
        "commit_body": "See gh-21855\n",
        "linked_issues": [
            {
                "issue_id": "21855",
                "issue_title": "Correctly parse property name in path \"map[key[foo]]\"",
                "issue_body": "We have a `Bean` that contains a `Map`. In this `Map` we want to save properties with property names which contain an index that is relevant for our application only, like `key5[foo]`. For spring that index doesn't matter, it should just treat `key5[foo]` as property name.\r\nHowever spring-bean is not able to correctly retrieve the property name, it tries to retrieve `key5[foo` (missing square bracket at the end). That's because spring just looks for the first occurrence of `]` and thinks it's the closing square bracket of the property name, however in our case that square bracket is part of the property name, and the relevant square bracket for spring (to actually close the property name) comes afterwards.\r\n\r\n- [x] Added tests\r\n- [x] Signed the CLA.\r\n\r\nWould be nice if this could be backported to `5.1.x`.\r\nThanks!",
                "issue_state": "closed",
                "issue_comment": [
                    "The Codacy check fails because the `switch` statement I added does not have a `default`. However that isn't necessary for the logic I added.\r\nDo I really have to add an empty/no-op `default` to that `switch` statement?",
                    "@jhoeller any chance you will assign this issue to the `5.1.5` milestone? I think the bug here - as well as the fix - is obvious. Thanks!",
                    "On review, I'll rather make this a 5.2 topic since the bean property binding is a high-risk area for regressions. Even if some such paths are not meant to be valid from our side, people may encounter e.g. property paths with incomplete nested brackets which we would possibly parse differently then."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a static helper method `getPropertyNameKeyEnd` within `AbstractNestablePropertyAccessor` to an instance method.  This change removes the static keyword, making the method operate on the instance's data rather than relying on class-level state.  The accompanying comments are also slightly reworded for clarity, particularly in the `else` block, which now more explicitly describes the situation where the suffix doesn't close the initial prefix",
            "avg_logprobs": -0.31774291171822494
        }
    },
    {
        "commit_hash": "b13f86cf461feaa32f5298a0f12f17e79d7a2a32",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/util/RfcUriParser.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "+\t\t\t\t\tcase '.':\n+\t\t\t\t\t\tparser.index(--i);\n+\t\t\t\t\t\tparser.advanceTo(PATH);\n+\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tif (c == '.') {\n-\t\t\t\t\t\t\tparser.index(--i);\n-\t\t\t\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix failing tests in spring-test after recent changes",
        "commit_body": "See gh-33639\n",
        "linked_issues": [
            {
                "issue_id": "33639",
                "issue_title": "Add URL Parser for RFC 3986",
                "issue_body": "Before 6.2, `UriComponentsBuilder` used regex expressions. Generally, they split on the main component delimiters, `\":\"`, `\"/\"`, `\"?\"`, and `\"#\"`, but did not enforce deviations from the allowed character set by component. The resulting `UriComponents` can then encode any non-conforming characters.\r\n\r\nRegular expressions are convenient, but provide limited control and visibility. This is why in #32513 we added an implementation of the URL parsing algorithm from the [WhatWg URL Living Standard](https://url.spec.whatwg.org/) that browsers use to align on how to handle a wide range of cases leniently. While this provides more robust parsing than before, arguably on a server we can expect URLs that don't deviate from the RFC quite as far as what browsers need to be able to handle.\r\n\r\nWe can add a new parser that follows RFC syntax along the lines of the `java.net.URI` or Jetty's `HttpUri` parsers. The new parser should respect the main component delimiters, but otherwise leave some room for leniency within each component to allow some characters like spaces or curly braces (URI variables), similar to what the regex expressions did. `UriComponents` can then encode any non-confirming characters that remain after URI variables are expanded.\r\n\r\nIt should be possible to choose which parser to use, RFC or the WhatWG, when more leniency or alignment with browsers is needed.\r\n\r\nThe topic of RFC vs WhatWG parsing was first brought up by @joakime in #33542. For broader context, and possible future effort to standardize lenient parsing of user provided URLs, see https://lists.w3.org/Archives/Public/ietf-http-wg/2024JulSep/0281.html.\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces an `if` statement checking for a '.' character with a `switch` case.  This results in a more concise and potentially slightly faster handling of the '.' character during URI parsing.  The original `if` statement is now handled directly within the `switch` statement",
            "avg_logprobs": -0.2077396869659424
        }
    },
    {
        "commit_hash": "b158110801db32b50243be538165274551a49512",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (body != null) {\n-\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\n-\t\t\t\t}\n+\t\t\t\tif (body != null) {\n+\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\n+\t\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix debug log for no matching acceptableTypes",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "No change.  The code snippet, which is a simple `if` statement, remains identical.  There are no modifications to conditional logic or iteration constructs",
            "avg_logprobs": -0.1399408398252545
        }
    },
    {
        "commit_hash": "b23cc01cb7981bdaf7274483a69673c519123444",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DisposableBeanAdapter.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t\tMethod[] destroyMethods = new Method[destroyMethodNames.length];\n+\t\t\t\tList<Method> destroyMethods = new ArrayList<>(destroyMethodNames.length);\n+\t\t\t\t\t\tdestroyMethods.add(destroyMethod);\n-\t\t\t\t\tdestroyMethods[i] = destroyMethod;\n-\t\t\t\tthis.destroyMethods = destroyMethods;\n+\t\t\t\tthis.destroyMethods = destroyMethods.toArray(Method[]::new);\n-\t\t\t\tif (destroyMethod != null) {\n-\t\t\t\t\tinvokeCustomDestroyMethod(destroyMethod);\n-\t\t\t\t}\n+\t\t\t\tinvokeCustomDestroyMethod(destroyMethod);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Revise \"Ignore nonexistent default-destroy-method in XML config\"",
        "commit_body": "This commit revises the fix in c811428512ffd04d41e558dbbc672382079ced2c.\n\nCloses gh-30301\n",
        "linked_issues": [
            {
                "issue_id": "30301",
                "issue_title": "NPE thrown for nonexistent `default-destroy-method` in XML config",
                "issue_body": "**Affects:** v6.0.7\r\n\r\n---\r\n\r\nWhen I configure the `default-destroy-method` in XML config and there is a bean that does not have a destroy method, a `NullPointerException` is thrown when closing the `ApplicationContext`.\r\n\r\n\r\n### Example Config and Code\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"\r\n  default-init-method=\"myInit\"\r\n  default-destroy-method=\"myDestroy\">\r\n\r\n  <bean id=\"a\" class=\"com.wpp.core.c1.s1_6._3.AInit\"/>\r\n  <bean id=\"b\" class=\"com.wpp.core.c1.s1_6._3.BDestroy\"/>\r\n\r\n</beans>\r\n```\r\n\r\n```java\r\npackage com.wpp.core.c1.s1_6._3;\r\npublic class AInit {\r\n  public void myInit() {\r\n    System.out.println(\"A myInit\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.wpp.core.c1.s1_6._3;\r\npublic class BDestroy {\r\n  public void myDestroy() {\r\n    System.out.println(\"B myDestroy\");\r\n  }\r\n}\r\n```\r\n\r\n```java\r\npackage com.wpp.core.c1.s1_6._3;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\npublic class DefaultInitAndDestroyDemo {\r\n  public static void main(String[] args) {\r\n    var context = new ClassPathXmlApplicationContext(\"com/wpp/core/c1/s1_6/_3/DefaultInitAndDestroyDemo.xml\");\r\n    context.close();\r\n  }\r\n}\r\n```\r\n\r\n### Exception\r\n\r\n```\r\n09:59:03.853 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext -- Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@880ec60\r\n09:59:04.048 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader -- Loaded 2 bean definitions from class path resource [com/wpp/core/c1/s1_6/_3/DefaultInitAndDestroyDemo.xml]\r\n09:59:04.088 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory -- Creating shared instance of singleton bean 'a'\r\nA myInit\r\n09:59:04.123 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory -- Creating shared instance of singleton bean 'b'\r\n09:59:04.194 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext -- Closing org.springframework.context.support.ClassPathXmlApplicationContext@880ec60, started on Fri Apr 07 09:59:03 CST 2023\r\nB myDestroy\r\n09:59:04.197 [main] WARN org.springframework.beans.factory.support.DefaultListableBeanFactory -- Destruction of bean with name 'a' threw an exception\r\njava.lang.NullPointerException: Cannot invoke \"java.lang.reflect.Method.getParameterCount()\" because \"destroyMethod\" is null\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:278)\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:238)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1189)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1182)\r\n\tat org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1084)\r\n\tat org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1053)\r\n\tat org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:1003)\r\n\tat com.wpp.core.c1.s1_6._3.DefaultInitAndDestroyDemo.main(DefaultInitAndDestroyDemo.java:25)\r\n```\r\n\r\n### Related Issues\r\n\r\n- #10879\r\n- #30295\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Hi @edfeff,\r\n\r\nThanks for raising the issue and providing the sample application.\r\n\r\nIt turns out that we already have a test in our own test suite which demonstrates the `NullPointerException`.\r\n\r\nIf we run `org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests.ignoreDefaultLifecycleMethods()`, we see the following message logged at WARN level.\r\n\r\n```\r\n13:31:19.852 [main] WARN  o.s.b.f.s.DefaultListableBeanFactory - Destruction of bean with name 'foo' threw an exception\r\njava.lang.NullPointerException: Cannot invoke \"java.lang.reflect.Method.getParameterCount()\" because \"destroyMethod\" is null\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:290) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:239) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1189) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1182) ~[main/:?]\r\n\tat org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests.ignoreDefaultLifecycleMethods(DefaultLifecycleMethodsTests.java:70) ~[test/:?]\r\n```",
                    "This appears to have been a regression introduced in 6.0.x and has been fixed for inclusion in 6.0.8.",
                    "Reopening to investigate a potentially more suitable fix for the regression."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces an array `destroyMethods` with a `List<Method>`.  This change improves the flexibility of the `DisposableBeanAdapter` class by allowing for dynamic addition of destroy methods.  The original array was fixed in size, while the `ArrayList` allows for potentially adding more methods in the future.  The code now dynamically adds each `destroyMethod` to the `destroyMethods` list and then converts it back to an array for use",
            "avg_logprobs": -0.3725566864013672
        }
    },
    {
        "commit_hash": "b27735d4a6ab6f0f17174e2cd1ffae1a41dbc219",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/aot/hint/BindingReflectionHintsRegistrar.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\t\t\t\t// For Kotlin reflection\n+\t\t\t\t\ttypeHint.withMembers(MemberCategory.INTROSPECT_DECLARED_METHODS);\n-\t\t\t\t\tif (methodName.startsWith(\"component\") || methodName.equals(\"copy\")) {\n+\t\t\t\t\tif (methodName.startsWith(\"component\") || methodName.equals(\"copy\") || methodName.equals(\"copy$default\")) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine BindingReflectionHintsRegistrar Kotlin support",
        "commit_body": "Closes gh-29593\n",
        "linked_issues": [
            {
                "issue_id": "29593",
                "issue_title": "Refine `BindingReflectionHintsRegistrar` Kotlin support",
                "issue_body": "Originally reported at https://github.com/spring-projects/spring-boot/issues/33351. It looks like Spring Data isn't contributing the necessary reflection hints to allow `BeanWrapper.KotlinCopyUtil.setProperty` to find and invoke the copy method.",
                "issue_state": "closed",
                "issue_comment": [
                    "thanks @wilkinsona - we'll take care of it.",
                    "Looking at `BindingReflectionHintsRegistrar.KotlinDelegate` the `registerComponentHints` method only registers the ones where name equals `copy` which misses those named `copy$default`. \\\\ cc @sdeleuze ",
                    "adding reflection for the `copy$default` methods solves the issue. Think we should fix this in framework.\r\n```kotlin\r\nhints.reflection().registerType(Book::class.java) {\r\n\tit.withMethod(\r\n\t\t\"copy\\$default\",\r\n\t\tlistOf(\r\n\t\t\tTypeReference.of(Book::class.java),\r\n\t\t\tTypeReference.of(java.lang.Long::class.java),\r\n\t\t\tTypeReference.of(java.lang.String::class.java),\r\n\t\t\tTypeReference.of(Int::class.java),\r\n\t\t\tTypeReference.of(java.lang.Object::class.java)),\r\n\t\tExecutableMode.INVOKE\r\n\t)\r\n}\r\nhints.reflection().registerType(Author::class.java) {\r\n\tit.withMethod(\r\n\t\t\"copy\\$default\",\r\n\t\tlistOf(\r\n\t\t\tTypeReference.of(Author::class.java),\r\n\t\t\tTypeReference.of(java.lang.Long::class.java),\r\n\t\t\tTypeReference.of(java.lang.String::class.java),\r\n\t\t\tTypeReference.of(java.util.Set::class.java),\r\n\t\t\tTypeReference.of(Int::class.java),\r\n\t\t\tTypeReference.of(java.lang.Object::class.java)),\r\n\t\tExecutableMode.INVOKE\r\n\t)\r\n}\r\n```",
                    "Thanks, @christophstrobl. I agree that a fix for this belongs in Framework.",
                    "We should also probably configure `queryAllDeclaredMethods` on those types, see [this comment](https://github.com/spring-projects/spring-data-commons/issues/2737?notification_referrer_id=NT_kwDOAAInNbE0OTI1ODExMDAxOjE0MTEwOQ#issuecomment-1328677161)."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new condition `methodName.equals(\"copy$default\")` to the existing `if` statement.  Previously, only methods starting with \"component\" or named \"copy\" were considered.  The addition now includes methods named \"copy$default\" as well, likely for Kotlin-specific reflection handling. This suggests the code is now more robust in handling Kotlin-generated methods",
            "avg_logprobs": -0.19063698803936993
        }
    },
    {
        "commit_hash": "b35d44bd4c4f2f12d6c337bc96f53f246df3c4c0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceHttpRequestHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (bytesRead < buffer.length) {\n+\t\t\tif (bytesRead == -1) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix inputstream reading for HTTP range requests",
        "commit_body": "Prior to this commit, range requests would be served by\nResourceHttpRequestHandler by partially reading the inputstream of\nstatic resources. In case of resources contained in ZIP/JAR containers,\nInputStreams may not fill the entire read buffer when calling\n`inputStream.read(byte[])`. This was the case when using Spring Boot's\nZipInflaterInputStream - this would then not read the entire file\ncontent and would close the response without writing the expected body\nlength indicated in the \"Content-Length\" header.\n\nThis commit makes sure that the whole resource is read.\n\nIssue: SPR-13661\n",
        "linked_issues": [
            {
                "issue_id": "18236",
                "issue_title": "HTTP Range requests hang on large file in nested jar [SPR-13661]",
                "issue_body": "**[Kevin McLaughlin](https://jira.spring.io/secure/ViewProfile.jspa?name=krm1312)** opened **[SPR-13661](https://jira.spring.io/browse/SPR-13661?redirect=false)** and commented\n\nFollowup from #15431.\n\nWe ended up adding a servlet filter that drops attempts to set ACCEPT_RANGE header.\nSample bootapp showing this issue is at https://github.com/krm1312/springrangeissues. Take that project and:\n\n```\nmvn clean package && java -jar bootapp/target/bootapp.jar\n```\n\nand then try a range request with curl:\n\n```\ncurl -vvv -H \"Accept-Encoding: gzip\"  -H 'Range: bytes=4726785-5726784' http://localhost:8080/test/file.bin > /tmp/f\n```\n\nIt effectively hangs.\n\n---\n\n**Affects:** 4.2.2\n\n**Issue Links:**\n- #18235 Allow disabling HTTP range support\n- #15431 Add support for http byte-range requests\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/b35d44bd4c4f2f12d6c337bc96f53f246df3c4c0\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Brian Clozel](https://jira.spring.io/secure/ViewProfile.jspa?name=bclozel)** commented\n\nThis has been fixed and should be available shortly on https://repo.spring.io.\n\nI think this problem can only be seen when running a packaged Spring Boot application, so indeed using Spring Boot's `ZipInflaterInputStream` for reading resources. Serving resources just using Spring Framework does not show the problem.\n\nYou can test this fix in your Boot application by configuring it to use the latest SNAPSHOT version of Framework. Note: obviously, I don't think doing this is supported by the Boot team, but rather a simple way to verify the fix if you want to. You can add the following in your POM to do so (along a repository declaration to `\"repo.spring.io/libs-snapshot\"`):\n\n```xml\n<properties>\n  <spring.version>4.2.4.BUILD-SNAPSHOT</spring.version>\n</properties>\n```\n\nThanks for this report and this very useful repro project!\n",
                    "**[Kevin McLaughlin](https://jira.spring.io/secure/ViewProfile.jspa?name=krm1312)** commented\n\nFinally had a chance to test this with our real application.  Looks good.\n\nAlso, as a side note, serving the entire file seems to take about half the time in my unscientific test (time curl) w/ 4.2.4 from localhost.  Not sure if that was expected with the fix, but, we'll take it.\n\nThanks!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a check for insufficient bytes read (`bytesRead < buffer.length`) with a check for end-of-stream (`bytesRead == -1`).  This suggests a potential modification to how the code handles the end of the input stream.  The original condition likely dealt with partial reads; the new condition directly handles the case where no more data is available",
            "avg_logprobs": -0.19029491826107628
        }
    },
    {
        "commit_hash": "b6144e5682c966759e7fd16dbac4d4948d332161",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/socket/adapter/AbstractListenerWebSocketSession.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.util.StringUtils;\n-\t\tclose(CloseStatus.SERVER_ERROR.withReason(ex.getMessage()));\n+\t\tif(!StringUtils.hasText(ex.getMessage())) {\n+\t\t\tclose(CloseStatus.SERVER_ERROR);\n+\t\t}\n+\t\telse {\n+\t\t\tclose(CloseStatus.SERVER_ERROR.withReason(ex.getMessage()));\n+\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improve setting of WebSocket error status",
        "commit_body": "See gh-28836\n",
        "linked_issues": [
            {
                "issue_id": "28836",
                "issue_title": "Avoid IllegalArgumentException when setting WebSocket error status",
                "issue_body": "Fixing internal error, when the message of an exception doesn't contain any text.\r\n\r\nIn my application, this probably caused a memory leak. (Which I will retest with a fork, but it will take some time because the issue happened very infrequently)\r\n\r\nThis is how it looks in the log:\r\n```\r\njava.lang.IllegalArgumentException: Reason must not be empty\r\n\tat org.springframework.util.Assert.hasText(Assert.java:289) ~[spring-core-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.CloseStatus.withReason(CloseStatus.java:184) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.onError(AbstractListenerWebSocketSession.java:250) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onError(FluxDoFinally.java:119) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onError(MonoIgnoreElements.java:84) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:842) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:608) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:588) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapMain.innerError(FluxFlatMap.java:863) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxFlatMap$FlatMapInner.onError(FluxFlatMap.java:990) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onError(FluxPeekFuseable.java:903) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.onError(MonoSubscribeOn.java:152) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.SinkEmptyMulticast$VoidInner.error(SinkEmptyMulticast.java:247) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.SinkEmptyMulticast.tryEmitError(SinkEmptyMulticast.java:88) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.SinkEmptySerialized.tryEmitError(SinkEmptySerialized.java:65) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.onError(AbstractListenerWebSocketSession.java:245) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat org.springframework.http.server.reactive.WriteResultPublisher$State.publishError(WriteResultPublisher.java:277) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.WriteResultPublisher.publishError(WriteResultPublisher.java:99) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.AbstractListenerWriteProcessor$State.onError(AbstractListenerWriteProcessor.java:479) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.AbstractListenerWriteProcessor.onError(AbstractListenerWriteProcessor.java:132) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19]\r\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher$State.onError(AbstractListenerReadPublisher.java:497) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.onError(AbstractListenerReadPublisher.java:145) ~[spring-web-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.handleError(AbstractListenerWebSocketSession.java:208) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat org.springframework.web.reactive.socket.adapter.StandardWebSocketHandlerAdapter.onError(StandardWebSocketHandlerAdapter.java:120) ~[spring-webflux-5.3.21.jar!/:5.3.21]\r\n\tat org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.onError(WsHttpUpgradeHandler.java:234) ~[tomcat-embed-websocket-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.upgradeDispatch(WsHttpUpgradeHandler.java:161) ~[tomcat-embed-websocket-9.0.64.jar!/:na]\r\n\tat org.apache.coyote.http11.upgrade.UpgradeProcessorInternal.dispatch(UpgradeProcessorInternal.java:60) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:890) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1787) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.64.jar!/:na]\r\n\tat java.base/java.lang.Thread.run(Thread.java:833) ~[na:na]\r\n```",
                "issue_state": "closed",
                "issue_comment": [
                    "I think we could switch to a very generic message instead.",
                    "Any suggestions? Then I will change the PR accordingly.",
                    "I've left it as a status-only response since the status code itself communicates the nature. I've also added logging with the exception message at INFO and the full stacktrace at DEBUG."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of exceptions during WebSocket session closure.  Previously, the exception message was always used to create a `CloseStatus` for a `SERVER_ERROR`.  Now, if the exception message is empty or null, a `SERVER_ERROR` close status without a reason is used; otherwise, the message is included in the `CloseStatus`.  This improves error handling by avoiding potential issues with empty or invalid exception messages",
            "avg_logprobs": -0.16939753426445855
        }
    },
    {
        "commit_hash": "b65984a0782c96e1799475ebaed45b5ed4a908c6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/DefaultResourceLoader.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tfor (ProtocolResolver protocolResolver : this.protocolResolvers) {\n+\t\tfor (ProtocolResolver protocolResolver : getProtocolResolvers()) {",
        "change_count": 2,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Consume getProtocolResolvers() rather than internal list",
        "commit_body": "This commit makes sure that DefaultResourceLoader consistently use\ngetProtocolResolvers() to access additional protocol resolvers. This\nallows subclasses to define how the list is provided.\n\nCloses gh-23564\n",
        "linked_issues": [
            {
                "issue_id": "23564",
                "issue_title": "Custom DefaultResourceLoader subclass should be able to consume context-provided ProtocolResolvers",
                "issue_body": "**Affects:** 4.3+\r\n\r\n`ConfigurableApplicationContext` has a `addProtocolResolver` method that can be used to register additional `ProtocolResolver` implementations. As far as I can see, this is the recommended approach that is followed by a number of implementations out there (example in [Spring Cloud AWS](https://github.com/spring-cloud/spring-cloud-aws/blob/f436ecab53dbdbd549e2e73298975a8c34b15931/spring-cloud-aws-context/src/main/java/org/springframework/cloud/aws/context/support/io/SimpleStorageProtocolResolverConfigurer.java#L55)).\r\n\r\nWhen setting a custom `ResourceLoader` on the context, one could get the already registered  `ProtocolResolver` instances (via `getProtocolResolvers`) if they want to reuse them but there is no way to be notified that additional instances have been configured. Unfortunately, the vast majority of the current implementations will register their protocol resolver later.\r\n\r\nA concrete example is Spring Boot Devtools that has to set a custom `ResourceLoader` but should be improved to honour `ProtocolResolver` as well, see https://github.com/spring-projects/spring-boot/issues/9331\r\n\r\nOne way to workaround this problem is to get the registered list every time a resource has to be resolved. If you just want the default behaviour it's not super obvious to do that. I have some prototype in https://github.com/snicoll/spring-boot/commit/1ceba096825869707f3c048d15c7068e3ef0e4a7, wondering if we could improve the code by a change in framework.\r\n\r\n ",
                "issue_state": "closed",
                "issue_comment": [
                    "As per our discussion today, we should at least make it easier for a custom `DefaultResourceLoader` to consume context-provided ProtocolResolvers. It seems that using the `getProtocolResolvers()` method instead of iterating the internal collection is an easy step to take there, making it convenient enough for Spring Boot and others to arrange for such a scenario. This is also doable for 5.1.10."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `this.protocolResolvers` with `getProtocolResolvers()`.  This suggests a potential refactoring to encapsulate the `protocolResolvers` list within a method, likely for better maintainability, testability, or to allow for future customization of the resolver list.  The original code directly accessed an internal field, while the updated code uses a getter, promoting a more object-oriented approach",
            "avg_logprobs": -0.1850417270216831
        }
    },
    {
        "commit_hash": "b6e252495a70d716179db1e91397190ac2a0aee9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t\tif (!subs.containsKey(sessionId) || !subs.get(sessionId).contains(subsId)) {\n+\t\t\t\t\t\tList<String> subsForSession = subs.get(sessionId);\n+\t\t\t\t\t\tif (subsForSession == null || !subsForSession.contains(subsId)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Protect against NPE in DefaultSubscriptionRegistry",
        "commit_body": "Follow-up fix on the recent commit:\nhttps://github.com/spring-projects/spring-framework/commit/44c31a\n\nIssue: SPR-15543\n",
        "linked_issues": [
            {
                "issue_id": "20102",
                "issue_title": "DefaultSubscriptionRegistry should prevent duplicate subscription id in accessCache [SPR-15543]",
                "issue_body": "**[Bao Tran](https://jira.spring.io/secure/ViewProfile.jspa?name=tran.bao51093)** opened **[SPR-15543](https://jira.spring.io/browse/SPR-15543?redirect=false)** and commented\n\nIn DefaultSubscriptionRegistry, multiple subscriptions on the same session should have unique subscription id's.\nIn DefaultSubscriptionRegistry.addSubscriptionInternal method, there are calls to:\n\n```java\nthis.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);\nthis.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);\n```\n\n* Assume that registerSubscription is called with a message argument.\n* If findSubscriptions method is called with destination argument after addSubscription and before updateAfterNewSubscription, accessCache will contain duplicate subscriptionId for destination - sessionId key.\n* This will lead to a subscriber receives a message twice due to loop in SimpleBrokerMessageHandler.sendMessageToSubscribers\n\n---\n\n**Affects:** 4.3.8\n\n**Issue Links:**\n- #19848 Cannot receive message sometimes with SimpleBrokerMessageHandler\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1427, and commits https://github.com/spring-projects/spring-framework/commit/4fc41eeeb90f9c5cd01f96ec46a1438ce2fbdc0e, https://github.com/spring-projects/spring-framework/commit/b6e252495a70d716179db1e91397190ac2a0aee9, https://github.com/spring-projects/spring-framework/commit/44c31a6aad26ce2a4e7225e93e6fb26612f07b2c, https://github.com/spring-projects/spring-framework/commit/8deec9569c2741c2fc5a78e375765dfb93586f49\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThanks for finding this and identifying the fix!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a direct check for the existence of a `sessionId` key in the `subs` map and a subsequent check for the presence of a specific `subsId` within the associated list with a more explicit approach.  It now first retrieves the list of subscriptions (`subsForSession`) associated with the `sessionId`.  This intermediate variable improves readability and potentially allows for more efficient handling of null values, as the `null` check is performed before the `contains` check",
            "avg_logprobs": -0.2488100242614746
        }
    },
    {
        "commit_hash": "b8e663c531a0e1e628095cba37a74efaa40a1419",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\tprivate final Set<Object> earlyProxyReferences = Collections.newSetFromMap(new ConcurrentHashMap<>(16));\n+\tprivate final Map<Object, Object> earlyProxyReferences = new ConcurrentHashMap<>(16);\n-\t\tif (!this.earlyProxyReferences.contains(cacheKey)) {\n-\t\t\tthis.earlyProxyReferences.add(cacheKey);\n-\t\t}\n+\t\tthis.earlyProxyReferences.put(cacheKey, bean);\n-\t\t\tif (!this.earlyProxyReferences.contains(cacheKey)) {\n+\t\t\tif (this.earlyProxyReferences.remove(cacheKey) != bean) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AbstractAutoProxyCreator ignores unused early proxy references",
        "commit_body": "Closes gh-22370\n",
        "linked_issues": [
            {
                "issue_id": "22370",
                "issue_title": "@Transactional beans not getting proxied when being initialized during failed circular reference attempt",
                "issue_body": "Currently using spring 4.3.22.RELEASE\r\n\r\nWorking in a large project with a bunch of circular preferences.  When creating the bean structure, if bean creation fails initially(seeing a beanCreationException due to a failed ProxyBean creation without a known target class), the entire dependency graph of failed bean creations is rolled back.  In our case, this includes our proxied @ Transactional bean.  When the bean graph creation continues down a different, eventually successful path, the @ Transactional bean is recreated.  However, during the original rollback, InfrastructureAdvisorAutoProxyCreator (extending AbstractAutoProxyCreator) isn't informed, so it's copy of earlyProxyReferences isn't informed that the early bean creation from earlier is gone, so when org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(Object, String) is called, it does not call wrapIfNecessary, as earlyProxyReferences still contains the bean name, from when it fails the first time.\r\n\r\nNote, that if the circular reference causes a failure only once, this doesn't seem to happen, but if there are 2 failures, it seems to start returning unproxied beans. It appears to be the case that we have to be trying to wire the @ transactional bean into a bean in a different context for this to happen.  It should be noted spring ends up initializing, just with missing proxies, which is almost worse than just failing, as the app comes up in an unknown state",
                "issue_state": "closed",
                "issue_comment": [
                    "This is available in `5.1.5.BUILD-SNAPSHOT` from https://repo.spring.io/snapshot now. Feel free to give it an early try before the official 5.1.5 release on Wednesday...\r\n\r\nIt's also available in `4.3.23.BUILD-SNAPSHOT` in case you'd like that branch a try. However, please note that the official 4.3.23 release is only scheduled for late March.",
                    "Thank you for this fixed.  It appears to have fixed the creation of non-proxied beans.  We had some other issues behind it that have kept us from verifying it 100%"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a `Set` with a `Map` to store `earlyProxyReferences`.  Critically, the `add` operation is replaced with a `put` operation, storing the `bean` associated with the `cacheKey`.  The `contains` check is replaced with a `remove` operation that checks if the removed value matches the expected `bean`. This change likely improves efficiency by allowing for a more direct lookup and potentially avoiding unnecessary iterations",
            "avg_logprobs": -0.28793964385986326
        }
    },
    {
        "commit_hash": "b92515bdee5a3f153183e2f86ee5e378c28b0d1e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/ProxyFactoryBean.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (this.targetName == null) {\n+\t\t\tif (this.targetName == null && logger.isInfoEnabled()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add logger.isInfoEnabled check before logger.info",
        "commit_body": "Closes gh-24667",
        "linked_issues": [
            {
                "issue_id": "24667",
                "issue_title": "Add logger.isInfoEnabled check before logger.info",
                "issue_body": "",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for `logger.isInfoEnabled()` before logging an informational message.  Previously, the `if (this.targetName == null)` block would always execute.  Now, it only executes if the logger is configured to output info messages. This improves efficiency by preventing unnecessary logging operations if the logger is not enabled",
            "avg_logprobs": -0.17702277047293527
        }
    },
    {
        "commit_hash": "b95362a3fd170a5ee16b90b74d4939efde06db02",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (StringUtils.startsWithIgnoreCase(request.getContentType(), \"multipart/\")) {\n+\t\t\tString contentType = request.getContentType();\n+\t\t\tif (StringUtils.startsWithIgnoreCase(contentType, \"multipart/\")) {\n-\t\t\t\tparams = (request.getParameterMap().isEmpty() ? \"\" : \"masked\");\n+\t\t\t\t// Avoid request body parsing for form data\n+\t\t\t\tparams = (StringUtils.startsWithIgnoreCase(contentType, \"application/x-www-form-urlencoded\") ||\n+\t\t\t\t\t\t!request.getParameterMap().isEmpty() ? \"masked\" : \"\");",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid request params access for form data in logRequest",
        "commit_body": "Close gh-28587\n",
        "linked_issues": [
            {
                "issue_id": "28587",
                "issue_title": "Avoid parsing request body in DispatcherServlet for \"parameters={masked}\" log message",
                "issue_body": "**Affects:** spring-webmvc-5.3.20 and possibly many more\r\n\r\nWhen having trace logging enabled... e.g.\r\n```\r\nlogging:\r\n  level:\r\n    org.springframework.web: TRACE\r\n```\r\n\r\nand sending a **POST** request with content type **application/x-www-form-urlencoded**, the body of the request may be consumed by trace logging and only an empty stream or reader be available for the application.\r\n\r\nThe reason seems to be this line: https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L988\r\n\r\nEven though it only attempts to check for existence of parameters it also triggers parsing of parameters which seems to consume the request body.",
                "issue_state": "closed",
                "issue_comment": [
                    "Yes, It will cause `request::setCharacterEncoding` not working.",
                    "Potentially related to:\r\n\r\n- #27350",
                    "This happens transparently when request parameters are accessed. It's how the Servlet API works. We can't prevent it from happening entirely but rather accept that it can happen.\r\n\r\nThere are two ways form data can be used. For data binding, which is the most convenient way to handle form data, it makes no difference because we bind from request parameters. For `@RequestBody`, the message converter relies on `ServletServerHttpRequest`, which reconstitutes the body content from request parameters. So, in most cases you shouldn't notice any of this. \r\n\r\nDid you run into a specific issue or just happened to notice? ",
                    "Hi @rstoyanchev,\r\n\r\nThanks for your reply.\r\nI came across this issue when trying to forward the raw body content to another network service.\r\n\r\nI understand this might happen transparently (e.g. the FormContentFilter implementation has a similar effect on PATCH requests).\r\nHowever in my opinion it would be better to avoid this to be triggered solely by the log level if possible.\r\nI just wouldn't expect the application behaviour to change when I switch from WARN to DEBUG or TRACE.\r\nWhat do you think?\r\n",
                    "I think it's important to show \"masked\" for request parameters in order to hint that there is something to see if logging is changed. We could however print the same when the content-type is \"application/x-www-form-urlencoded\" and thus avoid the `getParameters.size()` check for that case."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change in `DispatcherServlet` avoids unnecessary request body parsing for form data.  Previously, if the request content type was \"multipart/\", the parameters were marked as \"masked\" regardless of whether the request contained form data.  The updated code now checks if the content type is also \"application/x-www-form-urlencoded\" *or* if the request parameters are not empty",
            "avg_logprobs": -0.2187609100341797
        }
    },
    {
        "commit_hash": "baa7b1c6c84f64465cecdf6ad2e2bf90371cbd7b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/AntPathMatcher.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t\treturn (pattern.endsWith(this.pathSeparator) ? path.endsWith(this.pathSeparator) :\n-\t\t\t\t\t\t!path.endsWith(this.pathSeparator));\n+\t\t\t\treturn (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator));\n-\t\t\t\t\tif (skipped > 0) {\n-\t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n-\t\t\t\t\treturn (pattDir.length() > 0) && isWildcardChar(pattDir.charAt(0));\n+\t\t\t\t\treturn (skipped > 0 || (pattDir.length() > 0 && isWildcardChar(pattDir.charAt(0))));",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplified match condition checks",
        "commit_body": "Issue: SPR-15477\n",
        "linked_issues": [
            {
                "issue_id": "20037",
                "issue_title": "Optimize AntPathMatcher when checking for potential matches [SPR-15477]",
                "issue_body": "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** opened **[SPR-15477](https://jira.spring.io/browse/SPR-15477?redirect=false)** and commented\n\nHey,\n\njust noticed a possible improvement when checking for potential matches in AntPathMatcher. The problem here is that `toCharArray()` is called in `isPotentialMatch()` and `skipSegment()` which clones the array under the hood and causes allocations that we could avoid.\n\nThe attached patch shows a possible solution with simply using `charAt()` that leads to the following benchmark results. Would be happy if this is accepted.\n\n#### New\n\n```\nBenchmark                                      Mode  Cnt         Score         Error   Units\nBenchmark.testNew                      thrpt   20  43196627,181 \u00b1 1235654,920   ops/s\nBenchmark.testNew:\u00b7gc.alloc.rate       thrpt   20         0,001 \u00b1       0,002  MB/sec\nBenchmark.testNew:\u00b7gc.alloc.rate.norm  thrpt   20        ? 10??                  B/op\nBenchmark.testNew:\u00b7gc.count            thrpt   20           ? 0                counts\n```\n\n#### Old\n\n```\nBenchmark                                                   Mode  Cnt         Score        Error   Units\nBenchmark.testOld                                   thrpt   20  29555122,576 \u00b1 507145,389   ops/s\nBenchmark.testOld:\u00b7gc.alloc.rate                    thrpt   20      1052,083 \u00b1     18,027  MB/sec\nBenchmark.testOld:\u00b7gc.alloc.rate.norm               thrpt   20        56,000 \u00b1      0,001    B/op\nBenchmark.testOld:\u00b7gc.churn.PS_Eden_Space           thrpt   20      1050,787 \u00b1     28,954  MB/sec\nBenchmark.testOld:\u00b7gc.churn.PS_Eden_Space.norm      thrpt   20        55,927 \u00b1      1,048    B/op\nBenchmark.testOld:\u00b7gc.churn.PS_Survivor_Space       thrpt   20         0,190 \u00b1      0,046  MB/sec\nBenchmark.testOld:\u00b7gc.churn.PS_Survivor_Space.norm  thrpt   20         0,010 \u00b1      0,002    B/op\nBenchmark.testOld:\u00b7gc.count                         thrpt   20       354,000               counts\nBenchmark.testOld:\u00b7gc.time                          thrpt   20       182,000                   ms\n```\n\nCheers,\nChristoph\n\n\n---\n\n**Affects:** 4.3.8\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1399, and commits https://github.com/spring-projects/spring-framework/commit/baa7b1c6c84f64465cecdf6ad2e2bf90371cbd7b, https://github.com/spring-projects/spring-framework/commit/13b39521d80ca5b736c36572de2159144b2f7b26, https://github.com/spring-projects/spring-framework/commit/cd95f346662148b6bb9d2c9a2b11eee334b3d441, https://github.com/spring-projects/spring-framework/commit/84d2e5a3c8a2b559c339996cbc191dddea681748\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOptimizing local computations as well, I guess this would be even better:\n\n```\nprivate int skipSegment(String path, int pos, String prefix) {\n     int skipped = 0;\n     for (int i = 0; i < prefix.length(); i++) {\n          char c = prefix.charAt(i);\n          if (isWildcardChar(c)) {\n               return skipped;\n          }\n          int currPos = pos + skipped;\n          if (currPos >= path.length()) {\n               return 0;\n          }\n          if (c == path.charAt(currPos)) {\n               skipped++;\n          }\n     }\n     return skipped;\n}\n```\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nFeel free to update your PR accordingly, we can merge it straight away then. Otherwise I can also proceed with my local changes if you prefer.\n",
                    "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** commented\n\nThanks for looking into this. Jep, you're right - we could save a bit more. For completeness reasons the newest benchmark:\n\n```java\nBenchmark.testNew                      thrpt   20  43428506,223 \u00b1 542779,409   ops/s\nBenchmark.testNew:\u00b7gc.alloc.rate       thrpt   20         0,001 \u00b1      0,002  MB/sec\nBenchmark.testNew:\u00b7gc.alloc.rate.norm  thrpt   20        ? 10??                 B/op\nBenchmark.testNew:\u00b7gc.count            thrpt   20           ? 0               counts\n```\n\nI've updated the PR accordingly.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, here we go then :-) I'll backport it to 4.3.x tomorrow.\n",
                    "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** commented\n\nThank you!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the conditional logic within `AntPathMatcher`.\\n\\n**Original (simplified):**\\n\\nThe original code had a nested conditional statement checking if the `path` and `pattern` ended with the path separator (`pathSeparator`).  It returned `true` if both ended with it or if neither did.\\n\\n**Change:**\\n\\nThe change replaces the nested conditional with a single equality check: `(pattern.endsWith(this.pathSeparator) == path.endsWith(this",
            "avg_logprobs": -0.2276162910461426
        }
    },
    {
        "commit_hash": "bac5cd866e3ad685b84be0bcce2bdef573077242",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t\tsessionAttrHandler = this.sessionAttributesHandlerCache.get(handlerType);\n-\t\t\t\tif (sessionAttrHandler == null) {\n-\t\t\t\t\tsessionAttrHandler = new SessionAttributesHandler(handlerType, this.sessionAttributeStore);\n-\t\t\t\t\tthis.sessionAttributesHandlerCache.put(handlerType, sessionAttrHandler);\n-\t\t\t\t}\n+\t\t\t\tsessionAttrHandler = this.sessionAttributesHandlerCache.computeIfAbsent(handlerType, type -> new SessionAttributesHandler(type, this.sessionAttributeStore));",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify getSessionAttributesHandler() method",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a conditional creation and caching of `SessionAttributesHandler` with a `computeIfAbsent` operation.  The original code checked if the handler existed in the cache and created it if not.  The new `computeIfAbsent` approach is more concise and efficient, creating the handler only if it's missing from the cache.  This avoids redundant checks and object creation",
            "avg_logprobs": -0.17451076266131824
        }
    },
    {
        "commit_hash": "bac68c8d3f9ca4caa70b54c14e0e9805f88f8d34",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/multipart/support/StandardServletMultipartResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "- *\t// ...\n- *\t&#064;Override\n- *\tprotected void customizeRegistration(ServletRegistration.Dynamic registration) {\n- *\n- *\t\t// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n- *\t\tregistration.setMultipartConfig(new MultipartConfigElement(\"/tmp\"));\n- *\t}\n+ *\t // ...\n+ *\t &#064;Override\n+ *\t protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n+ *     // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n+ *     registration.setMultipartConfig(new MultipartConfigElement(\"/tmp\"));\n+ *   }\n-\t\t// Same check as in Commons FileUpload...\n-\t\tif (!\"post\".equalsIgnoreCase(request.getMethod())) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tString contentType = request.getContentType();\n-\t\treturn StringUtils.startsWithIgnoreCase(contentType, \"multipart/\");\n+\t\treturn StringUtils.startsWithIgnoreCase(request.getContentType(), \"multipart/\");",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "StandardServletMultipartResolver accepts any HTTP method for multipart",
        "commit_body": "Issue: SPR-16975\n",
        "linked_issues": [
            {
                "issue_id": "21513",
                "issue_title": "StandardServletMultipartResolver should support also HTTP PUT method [SPR-16975]",
                "issue_body": "**[Michal Aron](https://jira.spring.io/secure/ViewProfile.jspa?name=michalaron)** opened **[SPR-16975](https://jira.spring.io/browse/SPR-16975?redirect=false)** and commented\n\nStandardServletMultipartResolver should support HTTP PUT method as well.\n\nIn the referenced StackOverflow question (in the accepted answer), there is justification that the limitation for POST method is chosen because of W3C RFC and the deduction that \"PUT request represent a single resource.\u00a0But multiparts means multiple resources in a single body.\".\n\nBut I do not think this argument is really convincing, when reading the original W3C RFC - it is rather vague, the term \"entity enclosed with the request\" may have more meanings and does not have to necessarily forbid \"multiple body parts\", therefore I think the derived limitation to POST method only is too strict.\n\nThe other answer to the same question (https://stackoverflow.com/a/20374337/3626641)\u00a0gives pretty good argument that \"custom object that contains multiple fields, including one or more files, should be ok, it could still be considered as being one resource in REST terms\".\n\nThis is exactly the situation I am facing on my project and I believe I am not the only one - there are multiple examples of people having to extend the\u00a0StandardServletMultipartResolver to support POST as as well - e.g. [https://stackoverflow.com/questions/7981640/spring-3-0-fileupload-only-with-post/33658066](https://stackoverflow.com/questions/7981640/spring-3-0-fileupload-only-with-post/33658066#33658066))\n\nOn our project, we have a method for updating complex form in one request (including both JSON part and file part, so we need to use multipart request), but the method should be still PUT in my opinion, as according to RESTful design best practices, an idempotent update (even a complex one), should be handled using PUT method.\n\nBy the way, we are migrating the project from JAX-RS / Apache CXF endpoints to Spring WEB REST controllers and with the previous solution, PUT multipart requests worked fine.\n\n\u00a0\n\n\u00a0\n\n\n---\n\n**Affects:** 4.3.16\n\n**Reference URL:** https://stackoverflow.com/questions/20373912/spring-mvc-framework-multipartresolver-with-put-method?lq=1\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop), what's your take on this? I'm inclined to relax that check to POST and PUT but I'm wondering about the implications, in particular towards potential vulnerabilities.\n\nNotably, Commons FileUpload traditionally restricts its multipart check to POST, so we should leave our `CommonsMultipartResolver` restricted accordingly... but we could relax it for `StandardServletMultipartResolver` at least.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI can't think of any reasons not to do that, and looking at underlying code in Tomcat and Jetty, I don't see any checks for the HTTP method, only\u00a0for the presence of the multipart config element.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'll remove that entire HTTP method check in `StandardServletMultipartResolver` then, generally accepting any HTTP method (potentially even custom HTTP methods) with content type \"multipart/...\" there.\n",
                    "**[Michal Aron](https://jira.spring.io/secure/ViewProfile.jspa?name=michalaron)** commented\n\nThank you very much [Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) for implementing this so quickly!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes a redundant `if` statement that checks if the request method is \"POST\".  Previously, the code checked if the request method was \"POST\" and if the content type started with \"multipart/\".  Now, the check for the content type is the only remaining condition.  This simplifies the method by eliminating unnecessary conditional logic.  The `if` statement and its associated return were removed, resulting in a more concise and efficient method",
            "avg_logprobs": -0.240853654577377
        }
    },
    {
        "commit_hash": "bb45fb4538d723ecdc136ceaaba032bcf8cdb42c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\tif (!this.lastMessageSucceeded) {\n+\t\t\t\t\t// We failed more than once in a row or on startup - sleep before\n+\t\t\t\t\t// first recovery attempt.\n+\t\t\t\t\tsleepBeforeRecoveryAttempt();\n+\t\t\t\t}\n+\t\t/**\n+\t\t * Apply the back off time once. In a regular scenario, the back off is only applied if we\n+\t\t * failed to recover with the broker. This additional sleep period avoids a burst retry\n+\t\t * scenario when the broker is actually up but something else if failing (i.e. listener\n+\t\t * specific).\n+\t\t */\n+\t\tprivate void sleepBeforeRecoveryAttempt() {\n+\t\t\tBackOffExecution execution = DefaultMessageListenerContainer.this.backOff.start();\n+\t\t\tapplyBackOffTime(execution);\n+\t\t}\n+",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Restore sleep interval between recovery attempt",
        "commit_body": "Commit 6a04831 introduced a regression that lead to burst recovery\nattempts when the broker is up but the listener is failing for some\nreason (the most obvious one being that the destination does not\nexist).\n\nSince the sleep period between recovery attempts strategy is more\ncomplex, we can't just sleep for a period of time. But we can create\nan execution and apply it once which should work just fine for most\nuse cases.\n\nIssue: SPR-12183\n",
        "linked_issues": [
            {
                "issue_id": "16797",
                "issue_title": "Message listener container does not apply proper recovery anymore [SPR-12183]",
                "issue_body": "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** opened **[SPR-12183](https://jira.spring.io/browse/SPR-12183?redirect=false)** and commented\n\nThere is [this question](http://stackoverflow.com/questions/25778127/spring-jms-listener-container-listener-setup-timeout) on SO and also some other tests that confirm that 4.1 introduced a regression in the way the message listener container handles recovery.\n\nIt seems that certain exceptions are not being recognized the same way, not leading to an invalidation of the connection and therefore not applying the recovery at all.\n\nIt looks like #16400 may be the reason of the regression even though it's not obviously clear why it would be.\n\n---\n\n**Affects:** 4.1 GA\n\n**Issue Links:**\n- [AMQP-427](https://jira.spring.io/browse/AMQP-427) BackOff support in SimpleMessageListenercontainer (_**\"is depended on by\"**_)\n- #16400 MessageListenerAdapter might throw JMSException on message deserialization\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/bb45fb4538d723ecdc136ceaaba032bcf8cdb42c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nThe regression was introduced by `6a04831`. We have an extra trick to detect that we failed several times in a row that got removed. Actually this trick serves an additional purpose: if the listener fails to initialize, we would go in that removed if since the listener has not been called already and we faulty assume that it's the second time we're failing (while it's the first time, really).\n\nThere are probably a few things we could do here:\n\n1. Track back why we implemented this logic and figure out if that's still valid. If that's not, that whole boolean flag should go away. If that is we have a problem as it does not play nicely with the backoff mechanism anymore. Maybe we need to restore the previous mechanism for that use case only?\n2. Handle the initialization exception in a better way (i.e. if the listener hasn't even been called at all, maybe we should wrap that exception in such a way we can detect it and call a **dedicated** protected class which should give enough flexibility to figure out what to do. Right now we run a recovery (as we should) but that recovery works immediately as the broker is up. We should probably have some ways to manage that.\n\nTo be clear, the previous situation wasn't that better either: the app starts, we fail to connect to a certain queue, we wait X secs (5 by default) and we try again, it fails, etc. The only difference is that we've removed an extra if block that was applying the recovery timeout so now we're trying and failing in burst mode.\n\nUsers seem to rely on the feature if the broker starts at the same time as the app (it might fail one or two times and then the queue would eventually come up). This regression is therefore quite major.\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nAs a safety precaution for 4.1.1, we have restored the sleep period interval that was wrongly removed. We can revisit the hook points in 4.2 if need to be.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a new `sleepBeforeRecoveryAttempt` method and a conditional sleep before the first recovery attempt.  Previously, backoff was only applied if recovery from the broker failed.  This change introduces a separate sleep period *before* the first recovery attempt, regardless of broker status.  This is intended to prevent a burst of retries if the problem is not with the broker itself, but with the listener or another component",
            "avg_logprobs": -0.2599873352050781
        }
    },
    {
        "commit_hash": "bbc85ea466bda4539caf96990df37dfad5958751",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (getTransactionManager() == null && getBeanFactory() == null) {\n+\t\tif (getTransactionManager() == null && this.beanFactory == null) {\n-\t\t\t\t\t\"Setting the property 'transactionManager' or running in a BeanFactory is required\");\n+\t\t\t\t\t\"Set the 'transactionManager' property or make sure to run within a BeanFactory \" +\n+\t\t\t\t\t\"containing a PlatformTransactionManager bean!\");",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refined exception message",
        "commit_body": "Issue: SPR-14609\n(cherry picked from commit ab68673)\n",
        "linked_issues": [
            {
                "issue_id": "19177",
                "issue_title": "Transaction manager cache fails to repopulate when multiple transaction managers defined [SPR-14609]",
                "issue_body": "**[Tim Lenz](https://jira.spring.io/secure/ViewProfile.jspa?name=seabamirum)** opened **[SPR-14609](https://jira.spring.io/browse/SPR-14609?redirect=false)** and commented\n\nWhen `TransactionAspectSupport` is initialized, the transaction manager cache is populated by the `setTransactionManager` method. At this point there can be multiple `TransactionInterceptor` instances defined, each with its own cache, with no conflicts.\n\nHowever, as soon as the transaction cache entry in `TransactionAspectSupport` is cleared by the garbage collector, the transaction manager bean is then looked up by type, which leads to a `NoUniqueBeanDefinitionException` if multiple transaction managers are defined in your application context.\n\nThis is a regression caused by #19080.\n\n---\n\n**Affects:** 4.3.2\n\n**Issue Links:**\n- #19271 one beanfactory can not have more than one TransactionManager  when low memory (_**\"is duplicated by\"**_)\n- #19080 Transaction manager bean in TransactionInterceptor retained after JUnit test class completes\n- [INT-4104](https://jira.spring.io/browse/INT-4104) No qualifying bean of type [org.springframework.transaction.PlatformTransactionManager] is defined\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis is the trigger to undo #19080 for the (still unreleased) 4.2.8, whereas we'll try to fix it retaining #19080 for 4.3.3.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n`TransactionAspectSupport` stores a given `PlatformTransactionManager` instance as a strong reference (again) while retaining the soft cache for retrieved `PlatformTransactionManager` beans.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a null check within a `TransactionAspectSupport` class.  It replaces `getBeanFactory()` with `this.beanFactory`, and updates the error message to be more informative and user-friendly, emphasizing the need for a `PlatformTransactionManager` within a `BeanFactory`.  This suggests a potential improvement in error handling and clarity for users configuring the aspect",
            "avg_logprobs": -0.2670980001750745
        }
    },
    {
        "commit_hash": "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t} catch (Exception ex) {\n+\t\t}\n+\t\tcatch (Exception ex) {\n-\t\t\telse if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n+\t\t\telse {\n+\t\t\t\t// convertedValue == null\n+\t\t\t\tif (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+\t\t\t\t\tconvertedValue = javaUtilOptionalEmpty;\n+\t\t\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensively check javaUtilOptionalEmpty",
        "commit_body": "Issue: SPR-11888\n",
        "linked_issues": [
            {
                "issue_id": "16507",
                "issue_title": "WebMVC throws nullpointerexception on java 6 in TypeConverterDelegate [SPR-11888]",
                "issue_body": "**[Boris Bera](https://jira.spring.io/secure/ViewProfile.jspa?name=boris-b)** opened **[SPR-11888](https://jira.spring.io/browse/SPR-11888?redirect=false)** and commented\n\nWhen running the latest snapshot (4.1.0.BUILD-20140619.135109-207) of spring-webmvc on java 1.6, requests done with a MockMvc will throw a nullpointerexception in the TypeConverterDelegate class.\n\nStacktrace:\n\n```\norg.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:973)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:852)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:668)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837)\n\tat org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:62)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:770)\n\tat org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:170)\n\tat org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:137)\n\tat org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:141)\n\tat com.vantrix.mp.mpcms.impl.rest.MPRESTServiceImplUT.thatFindConvertsParameters(MPRESTServiceImplUT.java:222)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)\n\tat org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)\n\tat org.junit.runners.Suite.runChild(Suite.java:127)\n\tat org.junit.runners.Suite.runChild(Suite.java:26)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:160)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)\n\tat com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)\n\tat com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)\nCaused by: java.lang.NullPointerException\n\tat org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:260)\n\tat org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:106)\n\tat org.springframework.beans.TypeConverterSupport.doConvert(TypeConverterSupport.java:64)\n\tat org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:47)\n\tat org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:582)\n\tat org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:105)\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:79)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:157)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:124)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:781)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:721)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:938)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:870)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961)\n\t... 46 more\n```\n\nI did some digging and I think the problem comes from this commit: https://github.com/spring-projects/spring-framework/commit/0dc6082b01606c3c996b728541467ba5104b747f\n\nThe problem is on line 260 in spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java\n\nIn java 1.6, javaUtilOptionalEmpty is null and calling .getClass() on it throws the exception.\n\n\n---\n\n**Affects:** 4.1 RC1\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nIndeed, the same applies to a similar check in GenericConversionService.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an `else if` block and adds a null check.  The original code checked if the `requiredType` was `java.util.Optional.empty()` and assigned `javaUtilOptionalEmpty` to `convertedValue` if true.  The updated code now only assigns `javaUtilOptionalEmpty` to `convertedValue` *if* `javaUtilOptionalEmpty` is not null *and* the type matches",
            "avg_logprobs": -0.16332147598266603
        }
    },
    {
        "commit_hash": "bc5246938d07820305167e581e7a8ece23ed265e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceHttpRequestHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import org.springframework.util.CollectionUtils;\n-\t\tif (logger.isWarnEnabled()) {\n+\t\tif (logger.isWarnEnabled() && CollectionUtils.isEmpty(this.locations)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix ResourceHttpRequestHandler empty location log",
        "commit_body": "Fix ResourceHttpRequestHandler to only log warning when locations\nis empty.\n\nIssue: SPR-10780\n",
        "linked_issues": [
            {
                "issue_id": "15407",
                "issue_title": "ResourceHttpRequestHandler always logs warning [SPR-10780]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-10780](https://jira.spring.io/browse/SPR-10780?redirect=false)** and commented\n\nResourceHttpRequestHandler always logs a warning about missing resources\n\n\n---\n\n**Affects:** 3.2.3\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/8feeec4a6008f7b4b0202ca8c595ac7aaefee87c, https://github.com/spring-projects/spring-framework/commit/bc5246938d07820305167e581e7a8ece23ed265e\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for empty `locations` before logging a warning.  Previously, a warning was logged unconditionally.  Now, a warning is only logged if the `locations` list is empty *and* the logger is enabled for warnings. This prevents unnecessary warnings when `locations` is not empty",
            "avg_logprobs": -0.11992674782162621
        }
    },
    {
        "commit_hash": "bd8d71be0e6ff0a6cb5cded33b473c6ba8260e9d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageWriterResultHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\tResolvableType actualElementType;\n+\t\t\tactualElementType = elementType;\n-\t\t\telementType = (bodyType.toClass() == Object.class && body != null ?\n-\t\t\t\t\tResolvableType.forInstance(body) : bodyType);\n+\t\t\tactualElementType = body != null ? ResolvableType.forInstance(body) : bodyType;\n+\t\t\telementType = (bodyType.toClass() == Object.class && body != null ? actualElementType : bodyType);\n-\t\t\t\tif (writer.canWrite(elementType, bestMediaType)) {\n+\t\t\t\tif (writer.canWrite(actualElementType, bestMediaType)) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "canWrite uses actual return value type if known",
        "commit_body": "Closes gh-22803\n",
        "linked_issues": [
            {
                "issue_id": "22803",
                "issue_title": "Return value doesn't serialize to JSON when return type is Mono of Interface in WebFlux",
                "issue_body": "In WebMVC type application, Spring's message converter can convert the return value to a proper message(like a JSON) when controller return type declared by interface.\r\n\r\nBut, Webflux's behavior is different.\r\n\r\nFor example, we have Car class that implements Vehicle interface.\r\n```\r\npublic interface Vehicle {\r\n}\r\n\r\npublic class Car implements Vehicle {\r\n    private String gearType;\r\n}\r\n```\r\nAnd then there is a controller method like that.\r\n```\r\n@GetMapping(\"vehicle\")\r\npublic Vehicle getVehicle() {\r\n    return new Car();\r\n}\r\n```\r\nI can get a json response of Car class with `content-type: application/json` header.\r\n\r\nBut, webflux's result is defferent. \r\n```\r\n@GetMapping(\"vehicle\")\r\npublic Mono<Vehicle> getVehicle() {\r\n    return Mono.just(new Car());\r\n}\r\n```\r\nIt only supports a 'content-type: text/event-stream' when return type is a mono of interface.\r\nIs it a bug?",
                "issue_state": "closed",
                "issue_comment": [
                    "This odd. The signature with `Mono<Vehicle>` should work in both Spring MVC and WebFlux as expected. Do you have a sample?",
                    "Here is my simple example.\r\n\r\nWebflux : https://github.com/freddieyyh/demo/tree/webflux\r\nWebMVC : https://github.com/freddieyyh/demo/tree/webmvc\r\n\r\nCommand `curl -X GET -H \"Accept: application/json\" \"localhost:8080/interface-a\"`\r\nworks on WebMVC demo, but doesn't work on  Webflux demo.",
                    "The `Result` interface from the sample has no methods, so Jackson returns false for `getObjectMapper().canSerialize(Result.class)`. Adding at least one accessor makes it work. \r\n\r\nSpring MVC works is because it uses the actual type `ResultA`. We can make an improvement in WebFlux so that a concrete return value works the same, but for `Mono<Result>` it would still rely on the declared type, so it's best to have some sort of accessor on the interface."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the logic for determining the `elementType` used to determine if a message writer can handle a response.  The original code had a conditional assignment of `elementType` based on whether the body was null and the body type was `Object`.  The new code first assigns `actualElementType` to either the body's resolvable type or the original `bodyType`, depending on whether the body is null.  Then, it uses `actualElementType` in the `writer.",
            "avg_logprobs": -0.2887663459777832
        }
    },
    {
        "commit_hash": "bd8e682c51a6a383df559717d5352188032afb1b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tConstructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz);\n-\t\t\tif (kotlinPrimaryConstructor != null) {\n-\t\t\t\treturn kotlinPrimaryConstructor;\n-\t\t\t}\n+\t\t\treturn KotlinDelegate.findPrimaryConstructor(clazz);",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify BeanUtils.findPrimaryConstructor()",
        "commit_body": "Closes gh-26519",
        "linked_issues": [
            {
                "issue_id": "26519",
                "issue_title": "Simplify BeanUtils.findPrimaryConstructor()",
                "issue_body": "Simplified code.",
                "issue_state": "closed",
                "issue_comment": [
                    "@1993heqiang Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26519)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26519) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@1993heqiang Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=26519)!",
                    "This has been merged into `master`.\r\n\r\nThanks",
                    "good"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a conditional check and directly returns the result of `KotlinDelegate.findPrimaryConstructor(clazz)`.  Previously, if the constructor was null, the code would return null; now, it directly returns the result of the function call, effectively eliminating the `if` statement. This simplifies the code and potentially improves performance by avoiding the branch prediction overhead",
            "avg_logprobs": -0.20947797878368482
        }
    },
    {
        "commit_hash": "be853d466b406b7f6a66420158b5eba1de2fe267",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t@Override\n+\t\tpublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {\n+\t\t\tfor (Annotation annotation : getAnnotations()) {\n+\t\t\t\tif (annotation.annotationType() == annotationClass) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+",
        "change_count": 10,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "AnnotatedElementAdapter explicitly declares isAnnotationPresent method",
        "commit_body": "Issue: SPR-14872\n(cherry picked from commit 17863df)\n",
        "linked_issues": [
            {
                "issue_id": "19438",
                "issue_title": "NoSuchMethodError when using AnnotatedElementAdapter with Java 7 [SPR-14872]",
                "issue_body": "**[Andy Wilkinson](https://jira.spring.io/secure/ViewProfile.jspa?name=awilkinson)** opened **[SPR-14872](https://jira.spring.io/browse/SPR-14872?redirect=false)** and commented\n\nThe changes made in [this commit](https://github.com/spring-projects/spring-framework/commit/62918ca7797a9c7822fdf960c63a29b901c2343b#diff-fc2c4d51949d677cc8ad3d926d0186e9) don't appear to work on Java 7. It looks like `AnnotatedElementAdapter` is relying on `isAnnotationPresent(Class<? extends Annotation>)` being provide as a default method. That's not the case when running on Java 7. An example of the failure is:\n\n```\njava.lang.AbstractMethodError: org.springframework.core.convert.TypeDescriptor$AnnotatedElementAdapter.isAnnotationPresent(Ljava/lang/Class;)Z\n\tat org.springframework.core.annotation.AnnotatedElementUtils.isAnnotated(AnnotatedElementUtils.java:272)\n\tat org.springframework.core.convert.TypeDescriptor.hasAnnotation(TypeDescriptor.java:243)\n\tat org.springframework.format.support.FormattingConversionService$AnnotationPrinterConverter.matches(FormattingConversionService.java:246)\n\tat org.springframework.core.convert.support.GenericConversionService$ConvertersForPair.getConverter(GenericConversionService.java:668)\n\tat org.springframework.core.convert.support.GenericConversionService$Converters.getRegisteredConverter(GenericConversionService.java:566)\n\tat org.springframework.core.convert.support.GenericConversionService$Converters.find(GenericConversionService.java:551)\n\tat org.springframework.core.convert.support.GenericConversionService.getConverter(GenericConversionService.java:269)\n\tat org.springframework.core.convert.support.GenericConversionService.canConvert(GenericConversionService.java:159)\n\tat org.springframework.core.convert.support.GenericConversionService.canConvert(GenericConversionService.java:149)\n\tat org.springframework.binding.convert.service.GenericConversionService.getConversionExecutor(GenericConversionService.java:159)\n\tat org.springframework.binding.convert.service.GenericConversionService.executeConversion(GenericConversionService.java:345)\n\tat org.springframework.binding.expression.el.BindingValueExpression.convertValueIfNecessary(BindingValueExpression.java:99)\n\tat org.springframework.binding.expression.el.BindingValueExpression.getValue(BindingValueExpression.java:55)\n\tat org.springframework.binding.expression.el.ELExpression.getValue(ELExpression.java:54)\n\tat org.springframework.binding.expression.el.ELExpressionParserTests.testGetValueWithCoersion(ELExpressionParserTests.java:160)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:252)\n\tat junit.framework.TestSuite.run(TestSuite.java:247)\n\tat org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)\n\tat org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:64)\n\tat org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:50)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n\tat org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n\tat org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)\n\tat org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)\n\tat com.sun.proxy.$Proxy2.processTestClass(Unknown Source)\n\tat org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:106)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:606)\n\tat org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)\n\tat org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)\n\tat org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)\n\tat org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)\n\tat org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n\n---\n\n**Affects:** 4.3.4\n\n**Issue Links:**\n- #19410 AnnotationFormatterFactory should support `@AliasFor`\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/17863dfbda56f1a9d820d5dd550ca9e6d8d7b01a, https://github.com/spring-projects/spring-framework/commit/be853d466b406b7f6a66420158b5eba1de2fe267\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThanks for catching this, Andy! I've added a corresponding implementation of `isAnnotationPresent` to our internal `AnnotatedElementAdapter`.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new `isAnnotationPresent` method to the `TypeDescriptor` class.  This method iterates through the annotations of the `TypeDescriptor` instance and checks if any of them match the provided `annotationClass`.  If a match is found, it immediately returns `true`; otherwise, it returns `false` after iterating through all annotations.  This effectively implements a simple annotation presence check",
            "avg_logprobs": -0.09868823780732996
        }
    },
    {
        "commit_hash": "be85bd8e09293169342668f89540a9b668dc48b8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpPlus.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\n+\n-\t\tif (this.exitTypeDescriptor == \"Ljava/lang/String\") {\n+\t\tif (\"Ljava/lang/String\".equals(this.exitTypeDescriptor)) {\n-\t\t\t\t\tcase 'F': \n+\t\t\t\t\tcase 'F':\n-\t\t\t\t\t\tbreak;\t\t\t\t\n+\t\t\t\t\t\tbreak;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Don't use `==` when comparing strings",
        "commit_body": "Fix a few places where `==` was accidentally used to compare\nstrings.\n\nIssue: SPR-16968\n",
        "linked_issues": [
            {
                "issue_id": "21506",
                "issue_title": "Add checkstyle [SPR-16968]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-16968](https://jira.spring.io/browse/SPR-16968?redirect=false)** and commented\n\nAdding checkstyle to the Spring Framework build would help catch common coding issues and aid contributors.\n\n\n---\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1865\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nI have a PR in progress\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nhttps://github.com/spring-projects/spring-framework/pull/1865\n\nFirst off, a massive apology for the size of the PR. It turned out to be a lot more involved that I first thought. Other than the number of files touched, I don't think there's too many controversial parts to the PR. Perhaps the one that might cause the the biggest concern is the change in imports. I've added rules to enforce the import order based on [the rules in the WIKI](https://github.com/spring-projects/spring-framework/wiki/Code-Style#import-statements) but I've also enforced that `star` static imports shouldn't be allowed. This was mainly so I could use IDE tooling, but I also think it makes sense as it's very easy to mess up if the same method name is declared in more than one `star` import. I've had this happen quite often with Mockito and Hamcrest. I also think it's easier to read the source offline when when exact import statements are declared.\n\nThe other one that might be a bit controversial is single argument lambdas. In Spring Boot we opted to always use the parentheses around the argument so that single argument and multi-argument lambdas look the same.\n\nLet me know if you want me to refine any of the rules or rework the commits in any way.\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nPhil, there is plenty of good polish in that PR but it also adapts a few widespread things that we intentionally did differently: e.g. no copyright headers on package-info, no \"this.\" prefix on logger access, no type+\"this.\" prefix in inner classes for access to outer state... and allowing star imports in test classes.\n\nGenerally speaking, I'm not sure whether enforcing production checkstyle guidelines on test sources is necessary or even desirable. At the very least, we could have more relaxed guidelines for test sources. For a start, enumerating the assertion method imports for every single test class feels odd to me... but I'm also generally much more relaxed about the code style used for test methods or inner classes used by them, with many production rules not needing to apply there.\n\nAs for single-argument lambdas, I visually object to the enforced parentheses there. Frankly, I'd rather wrap the expression itself in additional parentheses than such a plain parameter name part. We knew you chose differently in Boot but I'm afraid I'm not up for changing our style here in this respect.\n\nThe equals/hashCode stuff is unfortunately a common false signal by style-checking tools. All of those classes were valid since the superclass `hashCode()` implementation has a base hash that the subclasses choose to keep in that coarse-grained fashion. Enforcing `hashCode()` in those subclasses seems rather pointless, in particular when the overridden methods literally just call super and are effectively just there to keep checkstyle happy.\n\nWith respect to consistent code blocks and consistent ternary expression style, there were a few glitches... but also a few cases where we intentionally used one-line if variants, e.g. in `AbstractBeanDefinition` for better readability of that long if cascade. I'm also not opposed to shortened blocks in test classes, and I don't see all those inverted ternary expressions as really worthwhile... when local readability doesn't really improve through that measure.\n\nAll in all, from where I stand at the moment, the PR itself is way too much to merge. Let me rather go through the commits individually and hand-pick key changes while ignoring a whole range of others... and see where we end up with. In particular, I'm going to focus on production source fine-tuning, not touching test sources unless there is something totally bogus there. Once I've done an initial pass through this, let's see which checkstyle rules we'll eventually set up.\n\nLast but not least, thanks for your efforts there! This is pointing out a lot of stuff worth reviewing, even in areas where we might not enforce hard rules eventually.\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nThanks for the fast review, I know there's a way too much in one PR so I was expecting to need a few rounds. I might be able to do something with the commits I have locally which are a lot more fine grained.\n\n> Phil, there is plenty of good polish in that PR but it also adapts a few widespread things that we intentionally did differently: e.g. no copyright headers on package-info, no \"this.\" prefix on logger access, no type+\"this.\" prefix in inner classes for access to outer state... and allowing star imports in test classes.\n\nI figured some of those were intentional, but I wasn't 100% sure. For Spring Boot I have a lot of IDE templates and auto-cleanup enabled so I've tended to take a blanket rule over exceptions. For example, if I create a new class file I get the copyright header, but Eclipse doesn't give me a way to skip it only for `package-info.java` files. Likewise, if I save a file in Spring Boot the IDE automatically adds `this.`, but it doesn't offer a way to skip it for `this.logger`. Same with star imports, I either get all or none, so I opted for none.\n\nI intentionally started this PR with the same approach to see what you thought about it. I think with checkstyle we can refine the rules to enforce what we want. I'll have a look to see if we can refine some of those checks to also enforce the exceptions. For me, one of the biggest benefits to checkstyle is helping to know what the rules are. I had no idea that `this.logger` shouldn't be used, so I think it would be really beneficial to enforce that one.\n\n> Generally speaking, I'm not sure whether enforcing production checkstyle guidelines on test sources is necessary or even desirable. At the very least, we could have more relaxed guidelines for test sources. For a start, enumerating the assertion method imports for every single test class feels odd to me... but I'm also generally much more relaxed about the code style used for test methods or inner classes used by them, with many production rules not needing to apply there.\n\nIt's easy to add a blanket exclude for `src/test/*` if that's a better option. I didn't do that for pretty much the same reason as above. Eclipse doesn't offer an easy opt-out of formatting and cleanup for `src/test` so I just treated them in exactly the same way.\n\n> As for single-argument lambdas, I visually object to the enforced parentheses there. Frankly, I'd rather wrap the expression itself in additional parentheses than such a plain parameter name part. We knew you chose differently in Boot but I'm afraid I'm not up for changing our style here in this respect.\n\nNo problem, I wasn't 100% sold on it myself at first in Boot (but I do really like the consistency now). I can refine the checkstyle rule in the other direction and enforce that all single parameter lambdas must _not_ have parentheses.\n\n> The equals/hashCode stuff is unfortunately a common false signal by style-checking tools. All of those classes were valid since the superclass hashCode() implementation has a base hash that the subclasses choose to keep in that coarse-grained fashion. Enforcing hashCode() in those subclasses seems rather pointless, in particular when the overridden methods literally just call super and are effectively just there to keep checkstyle happy.\n\nI agree, It's a little pointless. On the other hand, it found at least one that was genuine I think. Do you think the empty `hashCode` is worth it for those few false-positive cases, since it helps when new code is developed? Or would you rather drop that rule entirely?\n\n> With respect to consistent code blocks and consistent ternary expression style, there were a few glitches... but also a few cases where we intentionally used one-line if variants, e.g. in AbstractBeanDefinition for better readability of that long if cascade.\n\nI could either drop the rule, or add an exception for the few cases where it looks better shortened. I'm personally in favor of hard rules here, just so nothing is open to interpretation. I think I use more brain cycles working out why a bit of code is formatted differently than just dealing with more whitespace.\n\n> I'm also not opposed to shortened blocks in test classes, and I don't see all those inverted ternary expressions as really worthwhile... when local readability doesn't really improve through that measure.\n\nIf we drop test checks then those blocks won't be enforced. On the other hand, if it's test code perhaps if doesn't really matter if they take up a bit more space? The ternary things is a bit strict as well. Stephane pointed out that you polish a lot of them to use `!=` and he finds that it helps when scanning code because his eyes just go `(the test ? the not equals case ? the equals case)`. Individually they don't add much, but collectively they might help. It will be easy to make that an option if you prefer?\n\n> All in all, from where I stand at the moment, the PR itself is way too much to merge. Let me rather go through the commits individually and hand-pick key changes while ignoring a whole range of others... and see where we end up with. In particular, I'm going to focus on production source fine-tuning, not touching test sources unless there is something totally bogus there. Once I've done an initial pass through this, let's see which checkstyle rules we'll eventually set up.\n\nI'm happy to have another pass here as well if it helps. Splitting out the PR into test, production and unwinding a few of the rules discussed above shouldn't take me too long. Probably the most labor intensive part was the javadoc changes so I'd be super happy if those could go in?\n\n> Last but not least, thanks for your efforts there! This is pointing out a lot of stuff worth reviewing, even in areas where we might not enforce hard rules eventually.\n\nSorry it ballooned into such a monster. It really ended up being quite extreme all things considered!\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\n3 things...\n1. Thanks for taking the initiative here.\n2. Yes, that is indeed quite a doozie of a PR. ;)\n3. Regarding the Eclipse formatter settings, I took a look, but TBH it's impossible to make heads or tails of that diff. Would you mind sorting the current settings on `master` alpha-numerically (and pushing to `master`) and then sort your updated settings the same way so that the diff becomes suitable for human consumption? That would make it much easier for me to make sense of the changes. Also, please change \"5.0\" to \"5.1\" for `@since` tags for new types.\n\nCheers!\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nI'm doing another round on this one, I'll take the eclipse settings as different commit.\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\n[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen) The eclipse update is pushed\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) I've forced pushed a second round so the PR should be a bit easier to digest now. I know you wanted the javadoc one as a different PR but I've left it in this one for now (otherwise I can't get checkstyle to pass).\n\nHere are the updates:\n\n- Tests are no longer verified and I've removed the test source from each commit. I've added a couple of commits for test polishing that I still think is worthwhile.\n- The javadoc commits has been squashed into a single commit. The `@param` rule on classes has been changed to match the existing style.\n- The copyright header is no longer applied to `package-info.java` and I've added a rule to enforce that nobody adds one by mistake.\n- I've kept the block style rule but changed {[AbstractBeanDefinition.equals}} in a polish commit to make it more palatable.\n- The `this.` rule is now enforced for most items but relaxed for inner classes. I've added a rule to make sure `this.logger` is never used.\n- I've kept the rule of equals must have hashcode but added exceptions for the override cases. There are still a few legitimate ones I think.\n- The lambda rules are now enforced in the other direction (all single arg lambdas must not use parenthesis)\n- Star imports have still been expanded in the src/main but we can do another round on this if you let me know the exceptions.\n- I've completely dropped the ternary checks for now. I'm not sure what the rules should be regarding parenthesis. I've see `a & b ? \"foo\" : \"bar\"`, `(a & b) ? \"foo\" : \"bar\"` and `(a & b ? \"foo\" : \"bar\")`. If there's a rule that can be applied I can refine the checkstyle code.\n\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\n[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)\n\n> The eclipse update is pushed\n\nWhere? To a different branch?\n",
                    "**[Sam Brannen](https://jira.spring.io/secure/ViewProfile.jspa?name=sbrannen)** commented\n\nAhhh... you pushed to `master`. Found the commit.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `this.exitTypeDescriptor == \"Ljava/lang/String\"` with `\"Ljava/lang/String\".equals(this.exitTypeDescriptor)`.  This is a stylistic change, likely to improve readability and potentially handle `null` values more robustly.  The original `==` comparison could lead to a `NullPointerException` if `this.exitTypeDescriptor` were null. The `.equals()` method avoids this by explicitly checking for null",
            "avg_logprobs": -0.1845932960510254
        }
    },
    {
        "commit_hash": "c052a0259238ee577a00a55abeb771fb967de440",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tif (ex instanceof RuntimeException &&\n-\t\t\t\t\tex.getCause() != null &&\n-\t\t\t\t\tex.getMessage().startsWith(\"Async resource cleanup failed\")) {\n-\t\t\t\treturn ex.getCause();\n+\t\t\tif (ex instanceof RuntimeException && ex.getCause() != null) {\n+\t\t\t\tString msg = ex.getMessage();\n+\t\t\t\tif (msg != null && msg.startsWith(\"Async resource cleanup failed\")) {\n+\t\t\t\t\treturn ex.getCause();\n+\t\t\t\t}",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ignore null message when introspecting resource cleanup failure",
        "commit_body": "Closes gh-30597\n",
        "linked_issues": [
            {
                "issue_id": "30597",
                "issue_title": "NPE in `ReactiveTransactionSupport.unwrapIfResourceCleanupFailure`",
                "issue_body": "**Affects:** spring boot 3.0.7\r\n\r\n---\r\nin method unwrapIfResourceCleanupFailure of org.springframework.transaction.interceptor.TransactionAspectSupport.ReactiveTransactionSupport class\r\nif ex.getMessage() returns null then we get NullPointerException:\r\n\r\n```java\r\n\t\t\tif (ex instanceof RuntimeException &&\r\n\t\t\t\t\tex.getCause() != null &&\r\n\t\t\t\t\tex.getMessage().startsWith(\"Async resource cleanup failed\")) {\r\n\t\t\t\treturn ex.getCause();\r\n\t\t\t}\r\n```\r\nhttps://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L1088",
                "issue_state": "closed",
                "issue_comment": [
                    "This seems to be a regression caused by #27572. To be revised for 6.0.10."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the conditional logic for handling exceptions.  The original code checked for a specific exception message prefix (\"Async resource cleanup failed\") *only* if the exception had a cause and was a `RuntimeException`.  The revised code first checks for a `RuntimeException` and a cause, and then checks if the message starts with the specific string.  This change improves readability and potentially performance by moving the message check *after* the initial cause check",
            "avg_logprobs": -0.3275835418701172
        }
    },
    {
        "commit_hash": "c0f4d78ef9b9e03836baa31ac3ada0b4c48197e7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/AbstractSqlParameterSource.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tInteger sqlType = this.sqlTypes.get(paramName);\n-\t\tif (sqlType != null) {\n-\t\t\treturn sqlType;\n-\t\t}\n-\t\treturn TYPE_UNKNOWN;\n+\t\treturn this.sqlTypes.getOrDefault(paramName, TYPE_UNKNOWN);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use Map.getOrDefault in getSqlType implementation",
        "commit_body": "Issue: SPR-15238\n",
        "linked_issues": [
            {
                "issue_id": "19803",
                "issue_title": "Use Map.getOrDefault in AbstractSqlParameterSource.getSqlType [SPR-15238]",
                "issue_body": "**[Jonathan Borenstein](https://jira.spring.io/secure/ViewProfile.jspa?name=jonborenstein)** opened **[SPR-15238](https://jira.spring.io/browse/SPR-15238?redirect=false)** and commented\n\nThe getOrDefault method for Maps in Java 8 can be used throughout the Spring Framework if applicable.\n\n\n---\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1321, and commits https://github.com/spring-projects/spring-framework/commit/c0f4d78ef9b9e03836baa31ac3ada0b4c48197e7\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI see `getOrDefault` as a convenience method that's only really useful for constant default values. Performing object construction or retrieval for a default value is arguably an expensive operation that should only be triggered when necessary, in particular when we are likely to encounter a cache hit. `getOrDefault` unfortunately suggests a less-than-optimal idiom there.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIn the discussion on the pull request, we ruled out cases with expensive default calculation but identified `AbstractSqlParameterSource.getSqlType` as a remaining worthwhile change.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a simple `if` statement checking for a null value in `sqlTypes` with a `getOrDefault` method call.  This is a more concise and potentially more efficient way to retrieve the `sqlType` from the `sqlTypes` map, returning `TYPE_UNKNOWN` if the key (`paramName`) is not found",
            "avg_logprobs": -0.14719676971435547
        }
    },
    {
        "commit_hash": "c1437f9817d9c4ac2ca16eaa4440fc39acfa18ac",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-import java.time.Duration;\n-\t\t\tlong restartTime = System.nanoTime();\n-\t\t\tlong timeTakenToRestart = Duration.ofNanos(System.nanoTime() - restartTime).toMillis();\n-\t\t\tlong timeTakenToRestoreJvm = CRaCMXBean.getCRaCMXBean().getUptimeSinceRestore();\n-\t\t\tlogger.info(\"Spring-managed lifecycle restart completed in \" + timeTakenToRestart\n-\t\t\t\t\t+ \" ms (restored JVM running for \" + timeTakenToRestoreJvm + \" ms)\");\n+\t\t\tif (!checkpointOnRefresh) {\n+\t\t\t\tlogger.info(\"Spring-managed lifecycle restart completed (restored JVM running for \" +\n+\t\t\t\t\t\tCRaCMXBean.getCRaCMXBean().getUptimeSinceRestore() + \" ms)\");\n+\t\t\t}",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine CRaC restoration logs",
        "commit_body": "Closes gh-31462\n",
        "linked_issues": [
            {
                "issue_id": "31462",
                "issue_title": "Refine CRaC restoration logs",
                "issue_body": "As discussed with @wilkinsona, we should refine CRaC restoration logs in order to ensure consistency with Spring Boot and avoid duplicated and inconsistent logging.\r\n\r\nWith the changes introduced by this issue, the logs for [on demand checkpoint/restore of a running application](https://docs.spring.io/spring-framework/reference/6.1/integration/checkpoint-restore.html#_on_demand_checkpointrestore_of_a_running_application) will be:\r\n```\r\nRestarting Spring-managed lifecycle beans after JVM restore\r\nTomcat started on port 8080 (http) with context path ''\r\nSpring-managed lifecycle restart completed (restored JVM running for 181 ms)\r\n```\r\n\r\nThe logs for [automatic checkpoint/restore at startup](https://docs.spring.io/spring-framework/reference/6.1/integration/checkpoint-restore.html#_automatic_checkpointrestore_at_startup) will be:\r\n```\r\nRestarting Spring-managed lifecycle beans after JVM restore\r\nTomcat started on port 8080 (http) with context path ''\r\nRestored Application in 0.11 seconds (process running for 0.112)\r\n```",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes the calculation and logging of the time taken for the restart of the Spring-managed lifecycle if `checkpointOnRefresh` is false.  Previously, this time was always logged.  The new code conditionally logs only when `checkpointOnRefresh` is true.  This suggests a potential optimization or a way to control logging based on a specific condition",
            "avg_logprobs": -0.2409822646885702
        }
    },
    {
        "commit_hash": "c188f22378ffa060b1be98ffdf6776c3a35513ca",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "- * <li>Collections (list and sets): the n<sup>th</sup> element</li>\n+ * <li>Collections (lists and sets): the n<sup>th</sup> element</li>\n-\t\t\tif (targetDescriptor.getMapKeyTypeDescriptor() != null) {\n-\t\t\t\tkey = state.convertValue(key, targetDescriptor.getMapKeyTypeDescriptor());\n+\t\t\tTypeDescriptor mapKeyTypeDescriptor = targetDescriptor.getMapKeyTypeDescriptor();\n+\t\t\tif (mapKeyTypeDescriptor != null) {\n+\t\t\t\tkey = state.convertValue(key, mapKeyTypeDescriptor);",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the handling of map key type conversion within the `Indexer` class.  Previously, a direct `if` statement checked for a non-null `mapKeyTypeDescriptor`.  Now, a variable `mapKeyTypeDescriptor` is assigned the value from `targetDescriptor.getMapKeyTypeDescriptor()`, and the `if` statement uses this variable.  This improves readability and potentially reduces redundant lookups",
            "avg_logprobs": -0.23348649978637695
        }
    },
    {
        "commit_hash": "c2101cbcf49feeacb8f7796cdb69eaa0f9814fe6",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (StringUtils.hasLength(qualifier)) {\n+\t\tif (StringUtils.hasText(qualifier)) {\n-\t\telse if (this.transactionManagerBeanName != null) {\n+\t\telse if (StringUtils.hasText(this.transactionManagerBeanName)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Require non-empty values for TxMgr qualifiers & bean names",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `StringUtils.hasLength` with `StringUtils.hasText` in the conditionals for checking the `qualifier` and `transactionManagerBeanName` strings.  This likely means the code now correctly handles cases where the strings contain only whitespace, as `hasText` checks for non-empty strings *and* non-whitespace strings, while `hasLength` only checks for non-empty strings",
            "avg_logprobs": -0.24442873001098633
        }
    },
    {
        "commit_hash": "c23fd784a0d91f5de1e6b5cab82e86b1746fc3b4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/scheduling/concurrent/ConcurrentTaskExecutor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t * <p><b>NOTE:</b> Exception handling in {@code TaskDecorator} implementations\n-\t * is limited to plain {@code Runnable} execution via {@code execute} calls.\n-\t * In case of {@code #submit} calls, the exposed {@code Runnable} will be a\n-\t * {@code FutureTask} which does not propagate any exceptions; you might\n-\t * have to cast it and call {@code Future#get} to evaluate exceptions.\n-\tprivate TaskExecutorAdapter getAdaptedExecutor(Executor concurrentExecutor) {\n-\t\tif (managedExecutorServiceClass != null && managedExecutorServiceClass.isInstance(concurrentExecutor)) {\n-\t\t\treturn new ManagedTaskExecutorAdapter(concurrentExecutor);\n-\t\t}\n-\t\tTaskExecutorAdapter adapter = new TaskExecutorAdapter(concurrentExecutor);\n+\tprivate TaskExecutorAdapter getAdaptedExecutor(Executor originalExecutor) {\n+\t\tTaskExecutorAdapter adapter =\n+\t\t\t\t(managedExecutorServiceClass != null && managedExecutorServiceClass.isInstance(originalExecutor) ?\n+\t\t\t\t\t\tnew ManagedTaskExecutorAdapter(originalExecutor) : new TaskExecutorAdapter(originalExecutor));",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Consistently apply TaskDecorator to ManagedExecutorService as well",
        "commit_body": "Closes gh-32455\n",
        "linked_issues": [
            {
                "issue_id": "32455",
                "issue_title": "Consistently apply TaskDecorator to ManagedExecutorService as well",
                "issue_body": "Following up on #30442, there is still one case where a configured `TaskDecorator` is not applied: to a late-initialized JSR-236 `ManagedExecutorService`, as typically encountered by `DefaultManagedTaskExecutor` in an application server environment.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change simplifies the `getAdaptedExecutor` method by removing a conditional `if` statement and replacing it with a ternary operator.  The original code checked if the `concurrentExecutor` was an instance of `managedExecutorServiceClass`, and if so, created a `ManagedTaskExecutorAdapter`.  The new code directly creates a `ManagedTaskExecutorAdapter` if the condition is true, otherwise it creates a `TaskExecutorAdapter`.  This change results in more concise and readable code",
            "avg_logprobs": -0.1991560935974121
        }
    },
    {
        "commit_hash": "c24825ca195a4d4eeb642d603b1db62639cf0024",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\treturn getSingleton(beanName, true);\n+\t\treturn getSingleton(beanName, isSingletonCurrentlyInCreation(beanName));\n-\t\tif (singletonObject == null) {\n+\t\tif (singletonObject == null && allowEarlyReference) {\n-\t\t\t\tif (singletonObject == null && allowEarlyReference) {\n+\t\t\t\tif (singletonObject == null) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DefaultSingletonBeanRegistry avoids singletonObjects lock wherever possible for non-singleton factory performance",
        "commit_body": "Issue: SPR-9819\n",
        "linked_issues": [
            {
                "issue_id": "14452",
                "issue_title": "Non-singleton beans performance issue  [SPR-9819]",
                "issue_body": "**[Andriy Rosa](https://jira.spring.io/secure/ViewProfile.jspa?name=andriyrosa)** opened **[SPR-9819](https://jira.spring.io/browse/SPR-9819?redirect=false)** and commented\n\nFor each method invocation for not-singleton scope bean\nInterceptor got bean from bean-factory by using AbstractBeanFactory.getBean\n\nBut before getting required bean inside method getBean we have cheeking\n\nObject sharedInstance = getSingleton(beanName);\nif (sharedInstance != null && args == null) {\n\nInside getSingleton we have synchronized blocks.\n\nconsidering that in high-load project we can have a lot of scoped-beans methods invocations, getSingleton lock all threads, and performance gone to very poor.\n\nI'm not very good in spring-core architecture, however by my mean the most obvious solution - it push into args argument of getBean method specific arg, which will show, that we request not singleton bean for sure\n\nP.S.: Take my apologies for my bad English.\n\n---\n\n**Affects:** 3.1.1\n\n**Issue Links:**\n- #10033 Threads bottlenecking in DefaultSingletonBeanRegistry when using Wicket's `@SpringBean` annotation for injection (_**\"is duplicated by\"**_)\n- #13117 Performance bottleneck and potential thread deadlock in DefaultSingletonBeanRegistry\n- #14414 AbstractBeanFactory#markBeanAsCreated performance issue due to lock contention\n- #15302 DefaultSingletonBeanRegistry::getSingleton(String beanName) attempts to create bean when it shouldn't\n- #16864 Further locking optimizations for the retrieval of non-singleton beans\n\n0 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe've addressed this for 3.2 now, avoiding that singletonObjects lock wherever possible (i.e. just doing an efficient ConcurrentHashMap check).\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `DefaultSingletonBeanRegistry` class, specifically the retrieval of singleton beans.  The original code unconditionally returned the singleton object.  The updated code now checks if the bean is currently being created as a singleton (`isSingletonCurrentlyInCreation(beanName)`) and uses this information to determine whether to allow an early reference.  This suggests a potential improvement in handling singleton creation scenarios, likely to prevent issues with circular dependencies or other situations where early access to a bean is problematic.",
            "avg_logprobs": -0.2965642738342285
        }
    },
    {
        "commit_hash": "c28a0d562761f7f8f85e7637e40cacdad7fa2390",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/jpa/persistenceunit/PersistenceManagedTypesBeanRegistrationAotProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\n+\t\t\tClass<? extends Annotation> attributeBinderTypeClass = loadClass(\"org.hibernate.annotations.AttributeBinderType\", classLoader);\n+\t\t\tif (attributeBinderTypeClass != null) {\n+\t\t\t\tReflectionUtils.doWithFields(managedClass, field -> registerForReflection(reflection,\n+\t\t\t\t\t\tAnnotationUtils.findAnnotation(field, attributeBinderTypeClass), \"binder\"));\n+\t\t\t\tReflectionUtils.doWithMethods(managedClass, method -> registerForReflection(reflection,\n+\t\t\t\t\t\tAnnotationUtils.findAnnotation(method, attributeBinderTypeClass), \"binder\"));\n+\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add missing hints for Hibernate `@TenantId`",
        "commit_body": "Closes gh-32967\n",
        "linked_issues": [
            {
                "issue_id": "32967",
                "issue_title": "Add missing hints for Hibernate `@TenantId`",
                "issue_body": "Related to #32842 but for `@AttributeBinderType` meta annotation support.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a check and processing for `org.hibernate.annotations.AttributeBinderType` annotations.  It dynamically loads the annotation type and then iterates through the fields and methods of a `managedClass`, registering any found instances of the annotation for reflection using `registerForReflection`.  This suggests an enhancement to support Hibernate's `AttributeBinderType` annotations for better processing of managed classes",
            "avg_logprobs": -0.22482688252518818
        }
    },
    {
        "commit_hash": "c2f6a98c907c01596f3a082dd0bc3dcf65fcb927",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/HttpHeaders.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (filename != null) {\n+\t\tif (StringUtils.hasText(filename)) {\n-\t\tif (contentDisposition != null) {\n+\t\tif (StringUtils.hasText(contentDisposition)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Lenient handling of empty Content-Disposition filename",
        "commit_body": "Closes gh-25769\n",
        "linked_issues": [
            {
                "issue_id": "25769",
                "issue_title": "HttpHeaders.setContentDispositionFormData should ignore empty filename",
                "issue_body": "When a Multipart Form request is used with an empty string as Filename, a \"No Filename\" exception is thrown. Can an empty String check be added to prevent the code from failing in empty string scenarios?\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/3b0f14fd2e1964dfd9a23cbb19d6eb240e7e511e/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L864\r\n```\r\npublic void setContentDispositionFormData(String name, @Nullable String filename) {\r\n\t\tAssert.notNull(name, \"Name must not be null\");\r\n\t\tContentDisposition.Builder disposition = ContentDisposition.builder(\"form-data\").name(name);\r\n\t\t if (filename != null) {  // Add Empty String check here, don't let through if empty String\r\n\t\t\tdisposition.filename(filename);    // calls method below\r\n\t\t}\r\n\t\tsetContentDisposition(disposition.build());\r\n\t}\r\n```\r\n\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/29885e2b9f18646fd8b0971daa51ff7ce2401935/spring-web/src/main/java/org/springframework/http/ContentDisposition.java#L601\r\n```\r\n@Override\r\n\t\tpublic Builder filename(String filename) {\r\n\t\t\tAssert.hasText(filename, \"No filename\");  // Assertion Fails since the the filename does not have text\r\n\t\t\tthis.filename = filename;\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n```",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `filename != null` and `contentDisposition != null` checks with `StringUtils.hasText(filename)` and `StringUtils.hasText(contentDisposition)`, respectively.  This change likely filters out empty strings and whitespace-only strings, improving robustness by preventing potential `NullPointerExceptions` and handling cases where the filename or content disposition might be represented by empty strings or just whitespace",
            "avg_logprobs": -0.1564593717276332
        }
    },
    {
        "commit_hash": "c3dbaed4ced5dafe736dfe391807ac85bfe6858e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\t\t\tresult = synthesizeAnnotation(result, method);\n-\t\treturn synthesizeAnnotation(result, method);\n+\t\treturn result;\n-\t\t\tif (result != null) {\n+\t\t\tif (result != null && synthesize) {\n+\t\t\t\tresult = synthesizeAnnotation(result, clazz);\n-\t\treturn (synthesize ? synthesizeAnnotation(result, clazz) : result);\n+\t\treturn result;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AnnotationUtils caches findAnnotation results in pre-synthesized form",
        "commit_body": "Issue: SPR-13621\n",
        "linked_issues": [
            {
                "issue_id": "18199",
                "issue_title": "Performance regression on startup (in particular in AnnotationUtils) [SPR-13621]",
                "issue_body": "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** opened **[SPR-13621](https://jira.spring.io/browse/SPR-13621?redirect=false)** and commented\n\nThere is a major performance regression on annotations lookup in Spring Framework 4.2. We found out that a basic Spring Boot application was 10% slower between 1.2 and 1.3. We did some investigation and found out that a Spring boot 1.3 app based on 4.2 was also 10% slower  than the same app on 4.1\n\nOne of the major hotspot difference is `AnnotationUtils.findAnnotation`. On 4.1 its own time is 23 ms (232ms in total) while on 4.2 it is 1,936ms (5,340ms in total)\n\n---\n\n**Affects:** 4.2.2\n\n**Issue Links:**\n- #21208 Reduce ClassUtils.forName overhead (in particular for annotation introspection purposes)\n- #21271 Avoid repeated superclass introspection in AnnotationUtils.findAnnotation\n\n1 votes, 10 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nBased on my attempts today, a particularly wasteful part seems to be the synthesize step for annotations on re-retrieval: While we have been caching the original annotation result, we always re-synthesize the entire annotation for every lookup call... I've modified this to cache the synthesized result now which should provide a significant boost for re-retrieval attempts. However, I have no idea how much of a difference this makes in actual Boot startup time, so please re-run the tests there, [St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)...\n\nIf this doesn't provide enough benefit yet, we could also try to skip the synthesize step altogether for lookup attempts where it doesn't make an actual difference, i.e. where the calling code is ok with aliased attributes to be exposed independently (which it may signal through a boolean flag). However, let's see where the change above takes us first.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nA few further steps taken in the meantime:\n\nWe're avoiding our rather expensive annotation retrieval algorithm in common callers of AnnotatedElementUtils when there are no annotations to begin with: e.g. in StandardAnnotationMetadata, AutowiredAnnotationBeanPostProcessor, AnnotationTransactionAttributeSource. StandardAnnotationMetadata also caches the annotation array now, avoiding repeated re-retrieval.\n\nAnnotatedElementUtils consistently operates on the actual annotation type if available, avoiding String name comparisons in favor of annotation type identity checks wherever possible. Also, it avoids double getDeclaredAnnotations/getAnnotations checks on anything other than Classes now - since they'll always deliver the same result for Methods etc anyway, just in a wasteful fresh array.\n\nI've also fixed our new 4.2 order determination check in ConfigurationClassUtils so that it only kicks in for actual configuration candidates; it was running through an unnecessary Order annotation lookup for every single bean in the context before.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs a further step, we're avoiding annotation synthesizing for getAnnotationAttributes retrieval now, in particular affecting ASM-based introspection during component scans.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes a redundant call to `synthesizeAnnotation` and adds a conditional check.  Originally, `synthesizeAnnotation(result, method)` was called unconditionally, and then again conditionally based on a boolean flag (`synthesize`).  The change now only calls `synthesizeAnnotation(result, clazz)` if `result` is not null *and* the `synthesize` flag is true.  This eliminates a redundant call in the common case where `synthesize` is false",
            "avg_logprobs": -0.2005501937866211
        }
    },
    {
        "commit_hash": "c4e8ffece16db679ef4d92d97d7b3e8c748f0b5a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/DefaultParameterNameDiscoverer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t// TODO Remove this conditional inclusion when upgrading to Kotlin 1.5, see https://youtrack.jetbrains.com/issue/KT-44594\n-\t\tif (KotlinDetector.isKotlinReflectPresent() && !NativeDetector.inNativeImage()) {\n+\t\tif (KotlinDetector.isKotlinReflectPresent()) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove outdated NativeDetector check for Kotlin reflection",
        "commit_body": "See gh-25179\n",
        "linked_issues": [
            {
                "issue_id": "25179",
                "issue_title": "Disable and remove unsupported features from native images",
                "issue_body": "The work done on [spring-graalvm-native substitutions](https://github.com/spring-projects-experimental/spring-graalvm-native/tree/master/spring-graalvm-native-substitutions) has allows to identify a first set of classes where we need to add a specific code path for GraalVM native images:\r\n\r\n- Remove load time weaving capabilities from `org.springframework.context.support.AbstractApplicationContext`\r\n- Remove `ConfigurationClassEnhancer` usage from `org.springframework.context.annotation.ConfigurationClassPostProcessor`\r\n- Remove usage of `ObjenesisCglibAopProxy` from   `org.springframework.aop.framework.DefaultAopProxyFactory`\r\n- Remove `CglibSubclassCreator` usage from `org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy`\r\n\r\nThere are likely other ones to be identified.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a conditional check for `NativeDetector.inNativeImage()`.  Previously, the `if` statement included a check for both Kotlin reflection presence and whether the code was running in a native image.  The updated code now only checks for the presence of Kotlin reflection.  This suggests the original conditional was a temporary workaround related to Kotlin 1.5 and native image compatibility, which is now considered resolved",
            "avg_logprobs": -0.18201200352158659
        }
    },
    {
        "commit_hash": "c5590ae9e6a3d75feae96f3015a65462c67dbcf8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/support/JdbcUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tcatch (AbstractMethodError err) {\n-\t\t\t\tlogger.debug(\"JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method\", err);\n-\t\t\t}\n-\t\t\tcatch (SQLFeatureNotSupportedException ex) {\n+\t\t\tcatch (SQLFeatureNotSupportedException | AbstractMethodError ex) {\n-\t\t\t\tlogger.debug(\"JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method\", ex);\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(\"JDBC driver has limited support for 'getObject(int, Class)' with column type: \" +\n+\t\t\t\t\t\t\trequiredType.getName(), ex);\n+\t\t\t\t}",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log column type for limited support message in getResultSetValue",
        "commit_body": "Closes gh-32601\n",
        "linked_issues": [
            {
                "issue_id": "32601",
                "issue_title": "Log column type for limited support message in `JdbcUtils.getResultSetValue`",
                "issue_body": "It would have been great to see which type is not supported in the logs, all the more as a driver provider gives a very terse error message (\"Invalid column type\"):\r\nlogger.debug(\"JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method for class = \" + requiredType, ex);\r\n\r\n_Originally posted by @PhilippeHaution in https://github.com/spring-projects/spring-framework/issues/16223#issuecomment-2035184262_",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change combines the `catch` blocks for `AbstractMethodError` and `SQLFeatureNotSupportedException`.  Instead of separate handling, it now catches both exceptions in a single `catch` block using the `|` (or) operator.  Critically, it adds a conditional check (`if (logger.isDebugEnabled())`) before logging the exception details, which prevents unnecessary logging if debug logging is not enabled",
            "avg_logprobs": -0.2629349708557129
        }
    },
    {
        "commit_hash": "c56c3045364a93d135309536cc905e56a2eae38d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/propertyeditors/PathEditor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (uri.getScheme() != null) {\n-\t\t\t\t\tnioPathCandidate = false;\n+\t\t\t\tString scheme = uri.getScheme();\n+\t\t\t\tif (scheme != null) {\n+\t\t\t\t\t// No NIO candidate except for \"C:\" style drive letters\n+\t\t\t\t\tnioPathCandidate = (scheme.length() == 1);\n-\t\t\t\tthrow new IllegalArgumentException(\"Failed to retrieve file for \" + resource, ex);\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\"Could not retrieve file for \" + resource + \": \" + ex.getMessage());",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "PathEditor considers single-letter URI scheme as NIO path candidate",
        "commit_body": "Closes gh-29881\n",
        "linked_issues": [
            {
                "issue_id": "29881",
                "issue_title": "PathEditor cannot handle absolute Windows paths with forward slashes",
                "issue_body": "Since Java can handle Windows paths expressed with forward slashes, people usually express any filesystem path in a configuration file with forward slashes, no matter the OS.\r\n\r\nHowever, Spring's `PathEditor` doesn't seem to handle what seems to me like a pretty common case:\r\n\r\n```java\r\nPathEditor tested = new PathEditor();\r\ntested.setAsText(\"c:/tmp\");\r\n```\r\n\r\nWhile `FileEditor` handles this case just fine and the rather obvious `Path.of(\"c:/tmp\");` works, the second line will result in:\r\n\r\n```\r\njava.io.FileNotFoundException: class path resource [c:/tmp] cannot be resolved to URL because it does not exist\r\n\tat org.springframework.core.io.ClassPathResource.getURL(ClassPathResource.java:214)\r\n\tat org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:160)\r\n\tat org.springframework.beans.propertyeditors.PathEditor.setAsText(PathEditor.java:109)\r\n\t... 71 more\r\n```\r\n\r\nI should mention that, like for `Path.of(...);`, as a user, I wouldn't expect the resulting Path to necessarily exist on the filesystem. An example use-case would be specifying a path at which something should be created by the application. Such a path wouldn't exist at startup.\r\n\r\nUsing: org.springframework:spring-beans:5.3.25",
                "issue_state": "closed",
                "issue_comment": [
                    "Hi, I would like to contribute to this issue can you assign this issue to me? Can you let me know how I can go about solving this issue?",
                    "Hi @sreenath-tm,\r\n\r\nThanks for making the offer, but please hold off on submitting a PR.\r\n\r\nThis issue is still labeled as `waiting-for-triage`. Consequently, we have not yet investigated the claim. I'll bring this up with the team, and we will come to a decision.",
                    "> However, Spring's PathEditor doesn't seem to handle what seems to me like a pretty common case:\r\n\r\nThe value is not a path but an URL that ultimately delegates to `DefaultResourceLoader#getResource`. As such, it's like any file URL in Java using Windows. You can make it more obvious it's an url and the following should work:\r\n\r\n```java\r\ntested.setAsText(\"file:///c:/tmp\");\r\n```\r\n",
                    "May I kindly ask you to reconsider this?\r\n\r\nI find it very counterintuitive that a class called `PathEditor` doesn't behave like the `Path` class it's supposed to convert to. If I use a `Path` object in a configuration, I would expect to be able to specify an actual path as string - straight forward - and not having to disguise it as file URL (otherwise I would've used `URL`).\r\n\r\nThe reliance on `DefaultResourceLoader` seems like an implementation detail and shouldn't be a justification for a clumsy API.",
                    "Alright. I thought using it as an URI was actually expected to avoid ending in a situation where we'd have too many fallbacks. We've discussed this and @jhoeller thinks we can make the fallback more lenient."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of URIs in `PathEditor`.  Previously, if a URI\\'s scheme was present, `nioPathCandidate` was set to `false` unconditionally.  The updated code now checks the length of the scheme string.  If the scheme\\'s length is 1, `nioPathCandidate` is set to `true`, otherwise it remains `false`.  This change likely addresses a specific case where a single-character scheme (e.g",
            "avg_logprobs": -0.22927743911743165
        }
    },
    {
        "commit_hash": "c6c61d64853cbe908caba07c67e7453b45c01f97",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/DefaultLifecycleProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\telse if (checkpointOnRefresh) {\n+\t\t\tthrow new IllegalStateException(\"Checkpoint on refresh requires a CRaC-enabled JVM and 'org.crac:crac' on the classpath\");\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine \"checkpoint on refresh\" error handling",
        "commit_body": "Closes gh-31096\n",
        "linked_issues": [
            {
                "issue_id": "31096",
                "issue_title": "Refine \"checkpoint on refresh\" error handling ",
                "issue_body": "Using `-Dspring.context.checkpoint=onRefresh` without the CRaC dependency on the classpath  results in a `NoClassDefFoundError` thrown at `DefaultLifecycleProcessor.onRefresh` level.\r\n\r\nWe should refine `DefaultLifecycleProcessor` to log a more approachable message earlier in the lifecycle.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added an `else if` condition to the existing conditional logic.  If `checkpointOnRefresh` is true, it now throws an `IllegalStateException` specifying that a CRaC-enabled JVM and the `org.crac:crac` library are required.  This indicates a dependency check for a specific feature",
            "avg_logprobs": -0.1253192597541256
        }
    },
    {
        "commit_hash": "c811428512ffd04d41e558dbbc672382079ced2c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DisposableBeanAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tinvokeCustomDestroyMethod(destroyMethod);\n+\t\t\t\tif (destroyMethod != null) {\n+\t\t\t\t\tinvokeCustomDestroyMethod(destroyMethod);\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ignore nonexistent default-destroy-method in XML config",
        "commit_body": "Prior to this commit, DisposableBeanAdapter attempted to invoke a\nconfigured default-destroy-method on every bean, including beans that\ndo not declare the named destroy method, resulting in a\nNullPointerException being thrown and logged at WARN level.\n\nThis commit addresses this by effectively ignoring any nonexistent\ndestroy method.\n\nCloses gh-30301\n",
        "linked_issues": [
            {
                "issue_id": "30301",
                "issue_title": "NPE thrown for nonexistent `default-destroy-method` in XML config",
                "issue_body": "**Affects:** v6.0.7\r\n\r\n---\r\n\r\nWhen I configure the `default-destroy-method` in XML config and there is a bean that does not have a destroy method, a `NullPointerException` is thrown when closing the `ApplicationContext`.\r\n\r\n\r\n### Example Config and Code\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\"\r\n  default-init-method=\"myInit\"\r\n  default-destroy-method=\"myDestroy\">\r\n\r\n  <bean id=\"a\" class=\"com.wpp.core.c1.s1_6._3.AInit\"/>\r\n  <bean id=\"b\" class=\"com.wpp.core.c1.s1_6._3.BDestroy\"/>\r\n\r\n</beans>\r\n```\r\n\r\n```java\r\npackage com.wpp.core.c1.s1_6._3;\r\npublic class AInit {\r\n  public void myInit() {\r\n    System.out.println(\"A myInit\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.wpp.core.c1.s1_6._3;\r\npublic class BDestroy {\r\n  public void myDestroy() {\r\n    System.out.println(\"B myDestroy\");\r\n  }\r\n}\r\n```\r\n\r\n```java\r\npackage com.wpp.core.c1.s1_6._3;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\npublic class DefaultInitAndDestroyDemo {\r\n  public static void main(String[] args) {\r\n    var context = new ClassPathXmlApplicationContext(\"com/wpp/core/c1/s1_6/_3/DefaultInitAndDestroyDemo.xml\");\r\n    context.close();\r\n  }\r\n}\r\n```\r\n\r\n### Exception\r\n\r\n```\r\n09:59:03.853 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext -- Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@880ec60\r\n09:59:04.048 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader -- Loaded 2 bean definitions from class path resource [com/wpp/core/c1/s1_6/_3/DefaultInitAndDestroyDemo.xml]\r\n09:59:04.088 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory -- Creating shared instance of singleton bean 'a'\r\nA myInit\r\n09:59:04.123 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory -- Creating shared instance of singleton bean 'b'\r\n09:59:04.194 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext -- Closing org.springframework.context.support.ClassPathXmlApplicationContext@880ec60, started on Fri Apr 07 09:59:03 CST 2023\r\nB myDestroy\r\n09:59:04.197 [main] WARN org.springframework.beans.factory.support.DefaultListableBeanFactory -- Destruction of bean with name 'a' threw an exception\r\njava.lang.NullPointerException: Cannot invoke \"java.lang.reflect.Method.getParameterCount()\" because \"destroyMethod\" is null\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:278)\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:238)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1189)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1182)\r\n\tat org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1084)\r\n\tat org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:1053)\r\n\tat org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:1003)\r\n\tat com.wpp.core.c1.s1_6._3.DefaultInitAndDestroyDemo.main(DefaultInitAndDestroyDemo.java:25)\r\n```\r\n\r\n### Related Issues\r\n\r\n- #10879\r\n- #30295\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "Hi @edfeff,\r\n\r\nThanks for raising the issue and providing the sample application.\r\n\r\nIt turns out that we already have a test in our own test suite which demonstrates the `NullPointerException`.\r\n\r\nIf we run `org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests.ignoreDefaultLifecycleMethods()`, we see the following message logged at WARN level.\r\n\r\n```\r\n13:31:19.852 [main] WARN  o.s.b.f.s.DefaultListableBeanFactory - Destruction of bean with name 'foo' threw an exception\r\njava.lang.NullPointerException: Cannot invoke \"java.lang.reflect.Method.getParameterCount()\" because \"destroyMethod\" is null\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.invokeCustomDestroyMethod(DisposableBeanAdapter.java:290) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:239) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1189) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520) ~[main/:?]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1182) ~[main/:?]\r\n\tat org.springframework.beans.factory.xml.DefaultLifecycleMethodsTests.ignoreDefaultLifecycleMethods(DefaultLifecycleMethodsTests.java:70) ~[test/:?]\r\n```",
                    "This appears to have been a regression introduced in 6.0.x and has been fixed for inclusion in 6.0.8.",
                    "Reopening to investigate a potentially more suitable fix for the regression."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check before invoking `invokeCustomDestroyMethod`.  Previously, `invokeCustomDestroyMethod` was always called.  Now, if `destroyMethod` is null, the method call is skipped.  This prevents a potential `NullPointerException` if `destroyMethod` is unexpectedly null",
            "avg_logprobs": -0.11895896518041217
        }
    },
    {
        "commit_hash": "c8c0737ce712569a7e03a97dfe7ef11cbbc33e39",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\telse {\n-\t\t\tthis.applicationListeners.add(listener);\n-\t\t}\n+\t\tthis.applicationListeners.add(listener);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AbstractApplicationContext.getApplicationListeners() exposes all statically registered listeners",
        "commit_body": "Issue: SPR-17324\n",
        "linked_issues": [
            {
                "issue_id": "21858",
                "issue_title": "ApplicationListener is missing from Collection returned by getApplicationListeners() if it was added after the multicaster was initialised [SPR-17324]",
                "issue_body": "**[Andy Wilkinson](https://jira.spring.io/secure/ViewProfile.jspa?name=awilkinson)** opened **[SPR-17324](https://jira.spring.io/browse/SPR-17324?redirect=false)** and commented\n\nIn Boot, if context refresh fails, we publish an `ApplicationFailedEvent`. We can't rely on the context's multicaster being available at this point so we create our own. It is initialised with the collection of listeners returned by `AbstractApplicationContext.getApplicationListeners()`. Unfortunately, any listeners that were added after the context's multicaster was initialised are missing from this collection so they do not receive the `ApplicationFailedEvent`.\n\nIn `AbstractApplicationContext.addApplicationListener(ApplicationListener<?>)`, would it be possible to always call `this.applicationListeners.add(listener)` rather than only calling it when `this.applicationEventMulticaster` is `null`?\n\n---\n\n**Affects:** 5.0.9\n\n**Reference URL:** https://github.com/spring-projects/spring-boot/issues/14490\n\n**Issue Links:**\n- #21840 Unnecessary sort in AbstractApplicationEventMulticaster\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/c8c0737ce712569a7e03a97dfe7ef11cbbc33e39, https://github.com/spring-projects/spring-framework/commit/d61a7ed1f0e0ae91e8aeb29af0447e1d2f473846\n\n**Backported to:** [5.0.10](https://github.com/spring-projects/spring-framework/milestone/191?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code removed an unnecessary `else` block.  The original code contained an `if` statement followed by an `else` block that simply added the `listener` to a list.  The change simplified the code by directly adding the listener to the list without the conditional check.  This change removes redundant code and improves efficiency",
            "avg_logprobs": -0.19468136394725127
        }
    },
    {
        "commit_hash": "c94b6765766358a5816d0818a97e45feef1c8ea8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/cglib/core/SpringNamingPolicy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\telse if (prefix.startsWith(\"java\")) {\n+\t\telse if (prefix.startsWith(\"java.\") || prefix.startsWith(\"javax.\")) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Specifically handle \"java.\"/\"javax.\" packages in SpringNamingPolicy",
        "commit_body": "Closes gh-27622\n",
        "linked_issues": [
            {
                "issue_id": "27622",
                "issue_title": "CGLIB does not allow packages to start with \"java\"",
                "issue_body": "`net.sf.cglib.core.DefaultNamingPolicy`, which is also used by the `SpringNamingPolicy` of the Spring Framework checks explicitly for a `java` prefix.\r\n\r\nA problem that might occur here is that someone tries to build a `javabeat.net` Spring example. This would cause a crash during any CGLIB define class due to the prepended dollar sign (`$`).\r\n\r\nWouldn't it therefore make sense to check for `java.` as a prefix instead of `java`?",
                "issue_state": "closed",
                "issue_comment": [
                    "> A problem that might occur here is that e.g. someone tries to build a \"javabeat.net\" spring example.\r\n\r\nWouldn't the package name be `net.javabeat`, which starts with `net` instead of `java`?\r\n\r\n> This would cause a crash during any cglib define class due to the prepended dollar sign...\r\n\r\nDo you have a concrete use case that results in such a crash?\r\n\r\nAlso, what version of the JDK/JRE are you using?\r\n\r\n\r\n",
                    "I mean the example was just meant to be demonstrative...\r\nBut I actually ran across the issue while trying to run a spring-boot v2.5.6 (spring framework 5.3.12) sample app under orcale jdk 17.\r\nDue to the fact that the fallback method of using ClassLoader::defineClass not being available without a \"--add-opens java.base/java.lang=ALL-UNNAMED\" it just results in a InaccessibleObjectException.\r\n\r\nFull version info for my java binary: Java HotSpot(TM) 64-Bit Server VM (build 17+35-LTS-2724, mixed mode, sharing)\r\n\r\nIt does work under java 11.. but yea i find it kind of odd that cglib implies these restrictions and doesn't make it clear that it does in fact not support these usecases.\r\nOracles naming convention itself does not impose such restrictions:\r\nhttps://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html\r\n\r\nExample.jar and sources:\r\nhttps://drive.google.com/file/d/1Y9ejDOixpaPPP9yMUsIftg3xA0bkcNJv/view?usp=sharing",
                    "Thanks for the feedback.\r\n\r\nIt sounds like you're saying it's only a result of enforcement of strong encapsulation since JDK 16/17 -- right?\r\n\r\nAnd in that case, there is in fact a workaround as you've mentioned with `--add-opens ...`.\r\n\r\nAs for the reason why CGLIB prepends `$` to any fully qualified class name starting with `java` instead of `java.` or `javax.`, perhaps @vlsi can shed some light on that.",
                    "@MuellerMP ,\r\n1) I guess you are right, and it would be better to use `java.` and `javax.` prefix tests (see https://github.com/cglib/cglib/blame/975e481faf39c91b8ac5b9b3d62822b7c52c5f47/cglib/src/main/java/net/sf/cglib/core/DefaultNamingPolicy.java#L41-L42 )\r\n2) However, I guess, it does not matter much, as `$` should be a valid character in the class name even at the very beginning.\r\n\r\nDo you have a stack trace and/or reproducer at hand?",
                    "@sbrannen i think the fallback method using a reflective call to ClassLoader::defineClass is a separate design issue of the CGLIB...\r\nCurrent state in spring and the problem in my case is the naming issue.\r\nIt could also confuse users to see a InaccessibleObjectException just because they named there package in an apparently wrong way. So atleast a helpful exception would be nice trat this usecase is in fact unsupported.\r\n\r\n@vlsi Hey! Can you access the google drive link I posted? It should contain a jar and sources to the sample that reproduces the exception under java 16+.",
                    "@MuellerMP , I've never worked with maven-based spring boot project, and it would take me ages to start. Could you please share the stack trace related to `$`-based class name?",
                    "this is the complete log of the program runthrough (including exception in the reflectutils).\r\n[example-run.txt](https://github.com/spring-projects/spring-framework/files/7447201/example-run.txt)\r\n\r\nOriginal Exception is caught here:\r\nhttps://github.com/spring-projects/spring-framework/blob/v5.3.12/spring-core/src/main/java/org/springframework/cglib/core/ReflectUtils.java#L566\r\nFallthrough throw here:\r\nhttps://github.com/spring-projects/spring-framework/blob/v5.3.12/spring-core/src/main/java/org/springframework/cglib/core/ReflectUtils.java#L589\r\n\r\nThe exception with the naming issue isnt thrown though and occurs here:\r\nhttps://github.com/spring-projects/spring-framework/blob/v5.3.12/spring-core/src/main/java/org/springframework/cglib/core/ReflectUtils.java#L507\r\n\r\nbecause the package name starts with a $ sign so the ContextClass is not in the same package and it results in a IllegalArgumentException.\r\nFor IllegalArgumentException and LinkageErrors there exists a fallback in the ReflectUtils using the ClassLoader::defineClass via reflection which is no longer allowed due to the strong encapsulation.\r\n\r\nthe package name is determined in this stacktrace:\r\nAbstractClassGenerator::generate(ClassLoaderData data)\r\nhttps://github.com/spring-projects/spring-framework/blob/v5.3.12/spring-core/src/main/java/org/springframework/cglib/core/AbstractClassGenerator.java#L345\r\nAbstractClassGenerator::generateClassName(Predicate nameTestPrediacte)\r\nhttps://github.com/spring-projects/spring-framework/blob/v5.3.12/spring-core/src/main/java/org/springframework/cglib/core/AbstractClassGenerator.java#L177\r\nSpringNamingPolicy via inheritance from DefaultNamingPolicy::getClassName(String prefix, String source, Object key, Predicate names):\r\nhttps://github.com/cglib/cglib/blob/master/cglib/src/main/java/net/sf/cglib/core/DefaultNamingPolicy.java#L42\r\n",
                    "I have to admit debugging this sort of error handling is non-trivial and using a reassignable temporary variable that is thrown somewhere else instead of using the Throwable(Throwable cause) constructor first and throwing after is very evil... =(\r\n1) You dont know where the exception actually occured\r\n2) You dont know if there occured an exception beforehand because it is simply ignored and overriden by the latter occuring one\r\n\r\nIMO calling Throwable::addSurpressed would be a better alternative if you really dont want to throw...\r\n\r\n\r\n",
                    "#### Related Issues\r\n\r\n- #28138"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change expands the `else if` condition to include prefixes starting with \"javax.\" in addition to \"java.\"  This likely broadens the scope of classes that are handled by the `SpringNamingPolicy` in a consistent way.  The original condition only considered classes from the `java` package, while the updated condition now also considers classes from the `javax` package",
            "avg_logprobs": -0.2604242547765955
        }
    },
    {
        "commit_hash": "c95dfca726aa72ef0c7dc64526b5808f28e258f1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/xml/DefaultBeanDefinitionDocumentReader.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\t\tif (logger.isInfoEnabled()) {\n+\t\t\t\t\t\tlogger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n+\t\t\t\t\t\t\t\t\"] not matching: \" + getReaderContext().getResource());\n+\t\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log profile-based exclusion of XML bean definition file",
        "commit_body": "Issue: SPR-10202\n",
        "linked_issues": [
            {
                "issue_id": "14835",
                "issue_title": "Log at info level when skipping an application context due to profile not being active [SPR-10202]",
                "issue_body": "**[Greg Lloyd](https://jira.spring.io/secure/ViewProfile.jspa?name=glloyd)** opened **[SPR-10202](https://jira.spring.io/browse/SPR-10202?redirect=false)** and commented\n\nWhen you are expecting an applicationContext to be processed and it contains a profile attribute which is not active there is no indication of why the context was not processed.\n\nIt would be nice if there were an info level log that explicitly logged that applicationContext Y was being skipped because X profile is not active.\n\nThe NoSuchBeanDefinitionException could be caused by any number of issues so it would be nice if there were a few breadcrumbs concerning a profile to help track down the cause.\n\n\n---\n\n**Affects:** 3.1.1\n\n**Reference URL:** http://blog.springsource.org/2011/02/11/spring-framework-3-1-m1-released/\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/c95dfca726aa72ef0c7dc64526b5808f28e258f1\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're logging an explicit info-level message for a skipped XML bean definition file now, aligned with the info-level logging that `XmlBeanDefinitionReader` generally performs.\n\nJuergen\n",
                    "**[Greg Lloyd](https://jira.spring.io/secure/ViewProfile.jspa?name=glloyd)** commented\n\nAmazing. Thanks.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a logging statement to inform the user if an XML bean definition file is skipped because the specified profiles don't match.  Specifically, if the logger is enabled for INFO level, a message is logged explaining the skipped file and the reason (mismatched profiles)",
            "avg_logprobs": -0.15473674024854386
        }
    },
    {
        "commit_hash": "ca2b3c170c439b775a40fd36bd6b71e2adfe3cf3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/aot/KotlinReflectionBeanRegistrationAotProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tClass<?> enclosingClass = type.getEnclosingClass();\n+\t\t\tif (enclosingClass != null) {\n+\t\t\t\truntimeHints.reflection().registerType(enclosingClass);\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add Kotlin hints for enclosing class",
        "commit_body": "This is needed by Kotlin reflection in order to be able to list\nclass members on native.\n\nCloses gh-32472\n",
        "linked_issues": [
            {
                "issue_id": "32472",
                "issue_title": "Missing bean class in native image with a Kotlin nested class",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://spring.io/security-policy !!!\r\n-->\r\n**Affects:** \\<6.1.2>\r\n**Reproducer:** <https://github.com/juliuskrah/graphql-demo/tree/spf-32472>\r\n\r\n# Missing class in AOT processed Bean\r\nGiven the following bean definition:\r\n---\r\n<!--\r\nThanks for taking the time to create an issue. Please read the following:\r\n\r\n- Questions should be asked on Stack Overflow.\r\n- For bugs, specify affected versions and explain what you are trying to do.\r\n- For enhancements, provide context and describe the problem.\r\n\r\nIssue or Pull Request? Create only one, not both. GitHub treats them as the same.\r\nIf unsure, start with an issue, and if you submit a pull request later, the\r\nissue will be closed as superseded.\r\n-->\r\n\r\n```kotlin\r\nclass MongockBeanDefinitionRegistrar(\r\n    private val environment: Environment\r\n): ImportBeanDefinitionRegistrar {\r\n// ...\r\n\r\n    override fun registerBeanDefinitions(\r\n        metadata: AnnotationMetadata,\r\n        registry: BeanDefinitionRegistry,\r\n        importBeanNameGenerator: BeanNameGenerator,\r\n    ) {\r\n      // ...\r\n       val mongockSupportBeanDefinitionBuilder = BeanDefinitionBuilder\r\n            .rootBeanDefinition(MongockRunnerSupport::class.java)\r\n            .addPropertyValue(\"migrationClasses\", changeUnitSets)\r\n            .addPropertyReference(\"driver\", \"connectionDriver\")\r\n            .addPropertyReference(\"config\", \"mongock-io.mongock.runner.springboot.base.config.MongockSpringConfiguration\")\r\n\r\n        val mongockRunnerBeanDefinitionBuilder = BeanDefinitionBuilder.rootBeanDefinition(MongockRunner::class.java)\r\n            .setFactoryMethodOnBean(\"create\", \"mongockRunnerSupport\")\r\n            .setInitMethodName(\"execute\")\r\n\r\n        registry.registerBeanDefinition(getName(MongockRunner::class.java), mongockRunnerBeanDefinitionBuilder.beanDefinition)\r\n        registry.registerBeanDefinition(\"mongockRunnerSupport\", mongockSupportBeanDefinitionBuilder.beanDefinition)\r\n  }\r\n\r\n  class MongockRunnerSupport: ApplicationContextAware, ApplicationEventPublisherAware {\r\n        var driver: ConnectionDriver? = null\r\n        var config: MongockConfiguration? = null\r\n        var migrationClasses: List<Class<*>>? = emptyList()\r\n        private lateinit var applicationContext: ApplicationContext\r\n        private lateinit var eventPublisher: ApplicationEventPublisher\r\n\r\n        fun create(): MongockRunner {\r\n            val builder: RunnerSpringbootBuilder = MongockSpringboot.builder()\r\n            if (this.driver != null) builder.setDriver(driver)\r\n            if (this.config != null) builder.setConfig(config)\r\n            builder.setSpringContext(applicationContext)\r\n            builder.setEventPublisher(eventPublisher)\r\n            migrationClasses?.forEach(builder::addMigrationClass)\r\n            return builder.buildRunner()\r\n        }\r\n\r\n        override fun setApplicationContext(applicationContext: ApplicationContext) {\r\n            this.applicationContext = applicationContext\r\n        }\r\n\r\n        override fun setApplicationEventPublisher(applicationEventPublisher: ApplicationEventPublisher) {\r\n            this.eventPublisher = applicationEventPublisher\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe aot process generates the following class:\r\n\r\n```java\r\n@Generated\r\npublic class MongockBeanDefinitionRegistrar__BeanDefinitions {\r\n\r\n  @Generated\r\n  public static class MongockRunnerSupport {\r\n\r\n    private static BeanInstanceSupplier<MongockRunner> getMongockRunnerInstanceSupplier() {\r\n      return BeanInstanceSupplier.<MongockRunner>forFactoryMethod(MongockBeanDefinitionRegistrar.MongockRunnerSupport.class, \"create\")\r\n              .withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(MongockBeanDefinitionRegistrar.MongockRunnerSupport.class).create());\r\n    }\r\n\r\n\r\n    public static BeanDefinition getMongockRunnerBeanDefinition() {\r\n      RootBeanDefinition beanDefinition = new RootBeanDefinition(MongockRunner.class);\r\n      beanDefinition.setTargetType(MongockRunner.class);\r\n      beanDefinition.setInitMethodNames(\"execute\");\r\n      beanDefinition.setInstanceSupplier(getMongockRunnerInstanceSupplier());\r\n      return beanDefinition;\r\n    }\r\n\r\n\r\n    public static BeanDefinition getMongockRunnerSupportBeanDefinition() {\r\n      RootBeanDefinition beanDefinition = new RootBeanDefinition(MongockBeanDefinitionRegistrar.MongockRunnerSupport.class);\r\n      beanDefinition.getPropertyValues().addPropertyValue(\"migrationClasses\", List.of(CreateProductCollectionChangeUnit202401151530.class));\r\n      beanDefinition.getPropertyValues().addPropertyValue(\"driver\", new RuntimeBeanReference(\"connectionDriver\"));\r\n      beanDefinition.getPropertyValues().addPropertyValue(\"config\", new RuntimeBeanReference(\"mongock-io.mongock.runner.springboot.base.config.MongockSpringConfiguration\"));\r\n      beanDefinition.setInstanceSupplier(MongockBeanDefinitionRegistrar.MongockRunnerSupport::new);\r\n      return beanDefinition;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nI encounter the following exception when running the native executable:\r\n\r\n```java\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mongockRunnerSupport': Unresolved class: class com.example.graph.spring.MongockBeanDefinitionRegistrar$MongockRunnerSupport (kind = CLASS)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:606) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:521) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:224) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1323) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1284) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:486) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:341) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:334) ~[graphql-demo:6.1.2]\r\n\tat com.example.graph.spring.MongockBeanDefinitionRegistrar__BeanDefinitions$MongockRunnerSupport.lambda$getRunnerSpringbootBuilderInstanceSupplier$0(MongockBeanDefinitionRegistrar__BeanDefinitions.java:28) ~[na:na]\r\n\tat org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.aot.BeanInstanceSupplier.lambda$withGenerator$0(BeanInstanceSupplier.java:171) ~[na:na]\r\n\tat org.springframework.util.function.ThrowingBiFunction.apply(ThrowingBiFunction.java:68) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.util.function.ThrowingBiFunction.apply(ThrowingBiFunction.java:54) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.aot.BeanInstanceSupplier.lambda$get$2(BeanInstanceSupplier.java:206) ~[na:na]\r\n\tat org.springframework.util.function.ThrowingSupplier.get(ThrowingSupplier.java:58) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.util.function.ThrowingSupplier.get(ThrowingSupplier.java:46) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.aot.BeanInstanceSupplier.invokeBeanSupplier(BeanInstanceSupplier.java:218) ~[na:na]\r\n\tat org.springframework.beans.factory.aot.BeanInstanceSupplier.get(BeanInstanceSupplier.java:206) ~[na:na]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.obtainInstanceFromSupplier(DefaultListableBeanFactory.java:949) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1216) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:561) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:521) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:325) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:323) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:960) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[graphql-demo:3.2.1]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:762) ~[graphql-demo:3.2.1]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:464) ~[graphql-demo:3.2.1]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[graphql-demo:3.2.1]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1358) ~[graphql-demo:3.2.1]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1347) ~[graphql-demo:3.2.1]\r\n\tat com.example.graph.ApplicationKt.main(Application.kt:16) ~[graphql-demo:na]\r\n\tat java.base@21/java.lang.invoke.LambdaForm$DMH/sa346b79c.invokeStaticInit(LambdaForm$DMH) ~[na:na]\r\nCaused by: kotlin.reflect.jvm.internal.KotlinReflectionInternalError: Unresolved class: class com.example.graph.spring.MongockBeanDefinitionRegistrar$MongockRunnerSupport (kind = CLASS)\r\n\tat kotlin.reflect.jvm.internal.KClassImpl.createSyntheticClassOrFail(KClassImpl.kt:340) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl.access$createSyntheticClassOrFail(KClassImpl.kt:49) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$descriptor$2.invoke(KClassImpl.kt:67) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$descriptor$2.invoke(KClassImpl.kt:53) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:70) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:32) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data.getDescriptor(KClassImpl.kt:53) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl.getDescriptor(KClassImpl.kt:193) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl.getMemberScope$kotlin_reflection(KClassImpl.kt:202) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$declaredNonStaticMembers$2.invoke(KClassImpl.kt:173) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$declaredNonStaticMembers$2.invoke(KClassImpl.kt:173) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:70) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:32) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data.getDeclaredNonStaticMembers(KClassImpl.kt:173) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$allNonStaticMembers$2.invoke(KClassImpl.kt:182) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$allNonStaticMembers$2.invoke(KClassImpl.kt:182) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:70) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:32) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data.getAllNonStaticMembers(KClassImpl.kt:182) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$allMembers$2.invoke(KClassImpl.kt:188) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data$allMembers$2.invoke(KClassImpl.kt:188) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$LazySoftVal.invoke(ReflectProperties.java:70) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.ReflectProperties$Val.getValue(ReflectProperties.java:32) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl$Data.getAllMembers(KClassImpl.kt:188) ~[graphql-demo:1.9.21-release-633]\r\n\tat kotlin.reflect.jvm.internal.KClassImpl.getMembers(KClassImpl.kt:206) ~[graphql-demo:1.9.21-release-633]\r\n\tat org.springframework.data.util.KotlinBeanInfoFactory.getBeanInfo(KotlinBeanInfoFactory.java:64) ~[graphql-demo:3.2.1]\r\n\tat org.springframework.beans.CachedIntrospectionResults.getBeanInfo(CachedIntrospectionResults.java:222) ~[na:na]\r\n\tat org.springframework.beans.CachedIntrospectionResults.<init>(CachedIntrospectionResults.java:248) ~[na:na]\r\n\tat org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:157) ~[na:na]\r\n\tat org.springframework.beans.BeanWrapperImpl.getCachedIntrospectionResults(BeanWrapperImpl.java:162) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.BeanWrapperImpl.getLocalPropertyHandler(BeanWrapperImpl.java:193) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.BeanWrapperImpl.getLocalPropertyHandler(BeanWrapperImpl.java:58) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.getPropertyHandler(AbstractNestablePropertyAccessor.java:739) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.AbstractNestablePropertyAccessor.isWritableProperty(AbstractNestablePropertyAccessor.java:565) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1686) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1433) ~[graphql-demo:6.1.2]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:598) ~[graphql-demo:6.1.2]\r\n\t... 41 common frames omitted\r\n```\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "When running `docker compose -f src/main/resources/compose.yml -f src/main/resources/compose.dev.yml up`, I get a `permissions on /docker-entrypoint-initdb.d/keyfile are too open` error with Docker 24.0.5, could you please fix it to allow me to run the sample properly?",
                    "> When running `docker compose -f src/main/resources/compose.yml -f src/main/resources/compose.dev.yml up`, I get a `permissions on /docker-entrypoint-initdb.d/keyfile are too open` error with Docker 24.0.5, could you please fix it to allow me to run the sample properly?\r\n\r\nSet the permissions on the file\r\n\r\n```bash\r\nchmod 400 src/main/resources/docker/keyfile\r\n```",
                    "I am able to reproduce, that said, I am not sure something has to be fixed in Spring Framework since `org.springframework.data.util.KotlinBeanInfoFactory` is triggering this error. But we can try to qualify more precisely this issue.\r\n\r\nI am not sure yet why we see this error because `com.example.graph.spring.MongockBeanDefinitionRegistrar$MongockRunnerSupport` seems to have various metadata provided, and even if I add `allDeclaredMethods: true` and `\"allPublicMethods\": true` I still see the same error (see [related `kotlin-reflect` source code](https://github.com/JetBrains/kotlin/blob/29efe8645c9e787aa81438b4729cb3388594329e/core/reflection.jvm/src/kotlin/reflect/jvm/internal/KClassImpl.kt#L340)).",
                    "After more tests, I found that the applications works as expected if you add a reflection hint for the outer class `com.example.graph.spring.MongockBeanDefinitionRegistrar` (currently missing).\r\n\r\n@snicoll The code path involves Spring Data which invokes `kotlinClass.getMembers()` which requires the outer class hint, but maybe we could handle that defensively at Framework level. Any thoughts?\r\n\r\nUnrelated, notice that an additional hint for `io.mongock.runner.core.executor.MongockRunnerImpl` is also needed to be able to detect the `execute` function and can't  be, by design, guessed by the inference mechanism if I am not mistaken.",
                    "After chatting with S\u00e9bastien, we think that we should detect this case whenever we infer a reflection hint on a type. We also wonder if the same issue would happen if a non-static inner class was exposed that way in Java."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to see if a type has an enclosing class.  If it does, the enclosing class is registered with the `runtimeHints` for reflection.  This likely improves AOT (Ahead-of-Time) compilation by ensuring the enclosing class is available at compile time",
            "avg_logprobs": -0.1160293420155843
        }
    },
    {
        "commit_hash": "ca7634dfe8389e2be85874628e12fac6dd781466",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\tann = AnnotationUtils.findAnnotation(abd.getBeanClass(), annotationType);\n+\t\t\t\t\tClass<?> beanClass = abd.getBeanClass();\n+\t\t\t\t\tif (beanClass != beanType) {\n+\t\t\t\t\t\tann = AnnotationUtils.findAnnotation(beanClass, annotationType);\n+\t\t\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid duplicate class introspection during findAnnotationOnBean",
        "commit_body": "Closes gh-22318\n",
        "linked_issues": [
            {
                "issue_id": "22318",
                "issue_title": "Avoid duplicate call to findAnnotations in DefaultListableBeanFactory.findAnnotationOnBean",
                "issue_body": "**Affects:** 5.2.0.BUILD-SNAPSHOT\r\n\r\nhttps://github.com/spring-projects/spring-framework/blob/d3b5ba7a361866ea96fcc64d3f76be9b5be3b8e4/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java#L671-L683\r\n\r\nIf `abd.getBeanClass()` returns a `Class` that is equal to `beanType`, it looks to me like the call to `AnnotationUtils.findAnnotation` on line 680 duplicates the call made on line 673 and can be skipped.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to ensure the correct class is used when searching for an annotation.  Previously, `AnnotationUtils.findAnnotation` was always called on `abd.getBeanClass()`.  Now, if `abd.getBeanClass()` doesn't match the expected `beanType`, it searches for the annotation on the `beanClass` instead.  This likely addresses a potential issue where the wrong class was being used to find the annotation, improving accuracy and potentially fixing a bug",
            "avg_logprobs": -0.18269275665283202
        }
    },
    {
        "commit_hash": "cac76192e28ccf18faa8d19147011cbde040e3b4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "- * <p>As of Spring 4.0, this class supports Bean Validation 1.0 and 1.1, with special support\n- * for Hibernate Validator 4.x and 5.0 (see {@link #setValidationMessageSource}).\n+ * <p><b>As of Spring 4.0, this class supports Bean Validation 1.0 and 1.1, with special support\n+ * for Hibernate Validator 4.x and 5.0</b> (see {@link #setValidationMessageSource}).\n+\t\t// Allow for custom post-processing before we actually build the ValidatorFactory.\n+\t\tpostProcessConfiguration(configuration);\n+\n+\t/**\n+\t * Post-process the given Bean Validation configuration,\n+\t * adding to or overriding any of its settings.\n+\t * <p>Invoked right before building the {@link ValidatorFactory}.\n+\t * @param configuration the Configuration object, pre-populated with\n+\t * settings driven by LocalValidatorFactoryBean's properties\n+\t */\n+\tprotected void postProcessConfiguration(Configuration configuration) {\n+\t}\n+\n-\t\tReflectionUtils.invokeMethod(closeMethod, this.validatorFactory);\n+\t\tif (closeMethod != null) {\n+\t\t\tReflectionUtils.invokeMethod(closeMethod, this.validatorFactory);\n+\t\t}",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Added \"postProcessConfiguration\" template method to LocalValidatorFactoryBean",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a `postProcessConfiguration` method to `LocalValidatorFactoryBean`.  This method allows for custom post-processing of the Bean Validation configuration *before* the `ValidatorFactory` is built.  Critically, it introduces a check (`if (closeMethod != null)`) before invoking the `closeMethod` on the `validatorFactory`, preventing potential `NullPointerExceptions`",
            "avg_logprobs": -0.14644725799560546
        }
    },
    {
        "commit_hash": "cb095132b14eb61e1dfed8079a459633ea18a256",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/asm/ClassReader.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-            if (mw.cw.cr == this && signature == mw.signature) {\n+            if (mw.cw.cr == this &&\n+\t\t\t\t\t(signature != null ? signature.equals(mw.signature) : mw.signature == null)) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensive String equals comparison in ClassReader",
        "commit_body": "Issue: SPR-12382\n",
        "linked_issues": [
            {
                "issue_id": "16990",
                "issue_title": "String comparison using .equals() in ASM ClassReader [SPR-12382]",
                "issue_body": "**[Ahn Jung Su](https://jira.spring.io/secure/ViewProfile.jspa?name=iamjs77)** opened **[SPR-12382](https://jira.spring.io/browse/SPR-12382?redirect=false)** and commented\n\nComparison of String objects using == or != in org.springframework.asm.ClassReader.readMethod(ClassVisitor, Context, int)\n\nif (mw.cw.cr == this && signature==mw.signature) {\n...\n}\n\nActually Type of signature and mw.signature are String.\nIt is better to use .equals()\n\n---\n\n**Affects:** 4.1.1\n\n**Issue Links:**\n- #16970 Inefficient new Byte, Integer, Character constructor calls in ASM ClassReader\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/678, and commits https://github.com/spring-projects/spring-framework/commit/cb095132b14eb61e1dfed8079a459633ea18a256\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Ahn Jung Su](https://jira.spring.io/secure/ViewProfile.jspa?name=iamjs77)** commented\n\nI changed source == operations to equlas() method. and commit\n\npull request  : https://github.com/spring-projects/spring-framework/pull/678\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've applied this to master in a more defensive fashion including a null check.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement within `ClassReader`.  The original `if` statement checked if `signature` was equal to `mw.signature`.  The updated code adds a null check for `signature`.  If `signature` is null, it now checks if `mw.signature` is also null.  This addresses a potential `NullPointerException` that could occur if `signature` was null",
            "avg_logprobs": -0.1914679718017578
        }
    },
    {
        "commit_hash": "ccec75c98daa681727f510fa8e69d9651615d59c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CollectionFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\telse if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {\n+\t\telse if (TreeSet.class == collectionType || SortedSet.class == collectionType || NavigableSet.class == collectionType) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add missing TreeSet to CollectionFactory.createCollection()",
        "commit_body": "See gh-28949\n",
        "linked_issues": [
            {
                "issue_id": "28949",
                "issue_title": "Support TreeSet collection type in CollectionFactory.createCollection() without using reflection",
                "issue_body": "It seems to have been missed in #28718.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds `TreeSet.class` to the `else if` condition.  Previously, the code only checked for `SortedSet` and `NavigableSet` types.  The modification now also checks for `TreeSet`, implying that `TreeSet` instances are now handled in the same way as `SortedSet` and `NavigableSet` instances. This likely affects the creation or handling of collections in the `CollectionFactory` class",
            "avg_logprobs": -0.23313119676378039
        }
    },
    {
        "commit_hash": "cd4ce8727e97366cd50281f9ad2dd22922578ac1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/config/WebSocketNamespaceUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\n-\n-\t\t\tinterceptors.add(new OriginHandshakeInterceptor(allowedOrigins));\n+\t\t\tRootBeanDefinition originHandshakeInterceptor = new RootBeanDefinition(OriginHandshakeInterceptor.class);\n+\t\t\toriginHandshakeInterceptor.getPropertyValues().add(\"allowedOrigins\", allowedOrigins);\n+\t\t\tinterceptors.add(originHandshakeInterceptor);\n-\t\t\tfor (Element beanElement : DomUtils.getChildElementsByTagName(parentElement, new String[] {\"bean\", \"ref\"})) {\n+\t\t\tfor (Element beanElement : DomUtils.getChildElementsByTagName(parentElement, \"bean\", \"ref\")) {",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "WebSocket namespace consistently applies resolvable allowed-origins value",
        "commit_body": "Issue: SPR-13760\n",
        "linked_issues": [
            {
                "issue_id": "18333",
                "issue_title": "allowed-origins are not resolved from properties variables [SPR-13760]",
                "issue_body": "**[Emir Bucalovic](https://jira.spring.io/secure/ViewProfile.jspa?name=emir.bucalovic@gmail.com)** opened **[SPR-13760](https://jira.spring.io/browse/SPR-13760?redirect=false)** and commented\n\nIn the Spring XML configuration for stomp-endpoint property 'allowed-origins' is parsed but if there is a property variable it is not resolved to a value. Here is example configuration:\n\n```xml\n<websocket:message-broker application-destination-prefix=\"/app\">\n  <websocket:stomp-endpoint path=\"/websocketcallback\" allowed-origins=\"${system.secure.url},${system.secure.url.wss}\"*>\n\t<websocket:sockjs/>\n  </websocket:stomp-endpoint>\n  <websocket:simple-broker prefix=\"/topic\" />\n</websocket:message-broker>\n```\n\nThis same configuration is parsed and used by AbstractSockJsService where properties variables are indeed processed and resolved to their correct value. In WebSocketNamespaceUtils however, these values are simple read from XML and added to\nOriginHandshakeInterceptor via constructor as strings. Effect of this is that OriginHandshakeInterceptor tries to compare incoming origin header against literal string: '${system.secure.url.wss}' which fails.\n\n---\n\n**Affects:** 4.1.8, 4.2.3\n\n**Issue Links:**\n- #18334 Inefficient and inconsistent setAllowedOrigins collection types in AbstractSockJsService/OriginHandshakeInterceptor\n\n**Backported to:** [4.1.9](https://github.com/spring-projects/spring-framework/milestone/133?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch: We need to create that `OriginHandshakeInterceptor` as an inner bean definition, then the specified constructor argument value should automatically get resolved just like the bean property value specified above...\n\nThis will be available in the upcoming `4.2.4.BUILD-SNAPSHOT`. Please give it a try!\n\nJuergen\n",
                    "**[Emir Bucalovic](https://jira.spring.io/secure/ViewProfile.jspa?name=emir.bucalovic@gmail.com)** commented\n\nGreat job on resolving this so quickly! I'll certainly test it when it's out.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt would be great if you give it a try against the current 4.2.4 snapshot, ahead of the GA release next week:\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-websocket</artifactId>\n        <version>4.2.4.BUILD-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n<repositories>\n    <repository>\n        <id>spring-snapshots</id>\n        <name>Spring Snapshots</name>\n        <url>http://repo.spring.io/snapshot</url>\n        <snapshots>\n            <enabled>true</enabled>\n        </snapshots>\n    </repository>\n</repositories>\n```\n\n",
                    "**[Emir Bucalovic](https://jira.spring.io/secure/ViewProfile.jspa?name=emir.bucalovic@gmail.com)** commented\n\nI've just run some tests with a 4.2.4.BUILD-SNAPSHOT and both AbstractSockJsService and OriginHandshakeInterceptor get their properties resolved correctly (via setter methods). Great job!\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThanks for the feedback!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `WebSocketNamespaceUtils` replaces a direct instantiation of `OriginHandshakeInterceptor` with the creation of a `RootBeanDefinition` and subsequent population of its properties.  This change likely improves the configuration flexibility and potentially allows for more sophisticated bean initialization and dependency injection.  The most significant change is the removal of the direct `interceptors.add(...)` line and its replacement with a more object-oriented approach using a `RootBeanDefinition`",
            "avg_logprobs": -0.3528798675537109
        }
    },
    {
        "commit_hash": "cdf6eb95ab1ec041b1512185d2e00b09f433e866",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/AbstractApplicationContext.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tlogger.warn(\"Exception encountered during context initialization - cancelling refresh attempt\", ex);\n+\t\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n+\t\t\t\t\t\t\t\"cancelling refresh attempt: \" + ex);\n+\t\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduced warn log entry without stacktrace for startup exceptions",
        "commit_body": "Issue: SPR-13663\n",
        "linked_issues": [
            {
                "issue_id": "18238",
                "issue_title": "Revisit BeansException warn logging after startup failure [SPR-13663]",
                "issue_body": "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** opened **[SPR-13663](https://jira.spring.io/browse/SPR-13663?redirect=false)** and commented\n\n#16626 added warn logging to `AbstractApplicationContext` to ensure that `BeansExceptions` don't get missed.\n\nAlthough the intention is good, it has the unwanted side effect of causing most refresh failures to log stacktraces twice. This is particularly obvious with Spring Boot applications where a simple startup failure results in multiple stack-traces.\n\nWe could provide a feature flag to suppress the message.\n\n---\n\n**Affects:** 3.2.15, 4.1.8, 4.2.2\n\n**Issue Links:**\n- #16626 Exceptions thrown during AbstractApplicationContext.refresh() not being logged right when they are caught\n- #22081 Do not swallow exception cause when context refresh fails\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/03585f2e4e3b9e886c7c0e0a684e083ad8a032c9, https://github.com/spring-projects/spring-framework/commit/5d6aab34cbe3c4db38dd1698e246967716befcfd, https://github.com/spring-projects/spring-framework/commit/cdf6eb95ab1ec041b1512185d2e00b09f433e866\n\n**Backported to:** [4.1.9](https://github.com/spring-projects/spring-framework/milestone/133?closed=1), [3.2.16](https://github.com/spring-projects/spring-framework/milestone/104?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nPull-request https://github.com/spring-projects/spring-framework/pull/917\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nI'm in two minds about the feature flag. We could probably argue that `warn` logging is overkill and simply downgrade it to `debug`. The message was only added because the original reporter of #16626 had a deadlock, for most situations the rethrown exception will be logged eventually.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nNo need to wait until 4.2.4 - can easily deal with this for 4.2.3 still :-)\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nResolved through reducing the warn log entry to a single line with exception type and message but no stacktrace, as discussed on Skype.\n\nJuergen\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nHas this been pushed? I don't see any update to the repo.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging of an exception during context initialization.  Previously, a `warn` log message was always emitted.  Now, a check (`logger.isWarnEnabled()`) is added, ensuring the log message is only emitted if the logger is configured to output warnings.  This improves efficiency by preventing unnecessary logging in environments where warnings are not desired",
            "avg_logprobs": -0.1760326591697899
        }
    },
    {
        "commit_hash": "cdfcc23b6f1424f04e8273b3aa69fe185fb73dde",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ExceptionHandlerExceptionResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (logger.isErrorEnabled()) {\n-\t\t\t\tlogger.error(\"Failed to invoke @ExceptionHandler method: \" + exceptionHandlerMethod, invocationEx);\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Failed to invoke @ExceptionHandler method: \" + exceptionHandlerMethod, invocationEx);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduce log level for @ExceptionHandler failure",
        "commit_body": "Issue: SPR-13932\n",
        "linked_issues": [
            {
                "issue_id": "18504",
                "issue_title": "Exclude an exception from @ExceptionHandler [SPR-13932]",
                "issue_body": "**[Bill Chen](https://jira.spring.io/secure/ViewProfile.jspa?name=billc.cn)** opened **[SPR-13932](https://jira.spring.io/browse/SPR-13932?redirect=false)** and commented\n\nAs seen in the referenced SO question, if one wants a blanket handler for all Exceptions apart from a few, one will have to rethrow the unhandled exception in the `@ExceptionHandler` method, which causes a horrendous `ERROR` to be logged.\n\nCan some facility be provided to statically (via the annotation) or, even better, dynamically skip an exception in a handler?\n\n---\n\n**Affects:** 4.2.4\n\n**Reference URL:** http://stackoverflow.com/q/35267756/499922\n\n**Issue Links:**\n- #19473 ExceptionHandlerExceptionResolver should not log propagated exceptions at warn level\n- #19427 Log exception from `@ExceptionHandler` at higher level than debug\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/cdfcc23b6f1424f04e8273b3aa69fe185fb73dde, https://github.com/spring-projects/spring-framework/commit/6ef2d827c67da49ba7751cae6b9bd9a6ec7f8fbc\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI've reduced the log level in `ExceptionHandlerExceptionResolver` to `DEBUG`. That probably resolves your issue. That said the idea of excluding an exception from `@ExceptionHandler` may be more generally useful since it allows other registered HandlerExceptionResolver's to get involved. Possibly an exclude flag on `@ExceptionHandler` in which case we might consider supporting it on the type level.\n\nFor anyone interested in the features please comment/vote.\n",
                    "**[Martin Macko](https://jira.spring.io/secure/ViewProfile.jspa?name=linkedlist)** commented\n\nHi, I've tried to implement this feature. Could you possibly look at my code and do a review?\n\nhttps://github.com/spring-projects/spring-framework/pull/972\n\nThanks.\n",
                    "**[Bill Chen](https://jira.spring.io/secure/ViewProfile.jspa?name=billc.cn)** commented\n\n`@Rossen` I think changing the log level is okay for my case as it removes any undesired side effects of rethrowing. However, the more generic case you mentioned is more useful I guess.\n",
                    "Rather than an exclusion flag, it seems this could be done with two `@ExceptionHandler` methods, one for the more general exception and another for the more specific. ",
                    "Hi @rstoyanchev, I hope you don't mind If I explain our use case in this closed issue\r\n\r\nWe have a globalErrorHandler with `@ExceptionHandler(value = {Exception.class, Error.class})` that is catching every error in order to track them and check code regressions after each deployment.\r\n\r\nWe also have business exceptions (RedirectExceptions) that we'd like to handle in a custom HandleInterceptor, in its afterCompletion method. As you know this does not work because the exception has already been handled by our globalErrorHandler because we can not make it ignore these kind of business exceptions.\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging level for a failure to invoke an `@ExceptionHandler` method.  Previously, an error log was used (`logger.error`).  Now, a debug log is used (`logger.debug`).  This change reduces the amount of logging output for non-critical failures",
            "avg_logprobs": -0.1537637710571289
        }
    },
    {
        "commit_hash": "ce1954da1edd64f1280ead0435c7b3923e33f6da",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (!this.knownSuperclasses.containsKey(superclass)) {\n+\t\t\tif (!superclass.startsWith(\"java\") && !this.knownSuperclasses.containsKey(superclass)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Configuration class processing explicitly skips java.* classes since we'll never find @Bean annotations there anyway",
        "commit_body": "Issue: SPR-11718\n(cherry picked from commit c8ea80d)\n",
        "linked_issues": [
            {
                "issue_id": "16340",
                "issue_title": "Fix/optimize handling of @Bean method override regression with return type narrowing on JDK 8 [SPR-11718]",
                "issue_body": "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** opened **[SPR-11718](https://jira.spring.io/browse/SPR-11718?redirect=false)** and commented\n\nOverriding an `@Bean` method with a narrowed return type is working fine with Spring 3.2.8 on legacy JDKs (6 and 7). However, it's breaking with Spring 3.2.8 on JDK 8. Spring 4.0 on JDK 8 fixes this already, as part of general `@Bean` overload support. For Spring 3.2.9, we should do a minimal fix for the regression on JDK 8, even if we're not allowing overloaded `@Bean` methods in the same class yet.\n\n---\n\n**Affects:** 3.2.8\n\n**Issue Links:**\n- #15653 ConfigurationClass.validate() should allow for overloading in general or not at all\n- #16341 Metadata reading should never use ASM for java.* and javax.* types (in particular on JDK 8)\n\n**Backported to:** [3.2.9](https://github.com/spring-projects/spring-framework/milestone/97?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIt turns out that it's generally worthwhile to ignore bridge methods in our annotation method detection algorithms. As of JDK 8, bridge methods carry the same annotations as the corresponding original methods. However, we always want to operate on original methods anyway, exposing each annotated method just once that way (even on JDK 8).\n\nIn Spring Framework 4.x, we allow overloaded `@Bean` methods in general, simply picking the closest match at runtime. This works fine with the same method registered multiple times, as in our JDK 8 case here. Nevertheless, we should actively exclude bridge methods there as well since it doesn't serve any purpose to consider them, and may lead to subtle runtime differences between JDKs.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'll apply this bridge method exclusion fix to master and 4.0.x as well since it's a generally worthwhile optimization.\n\nWe're also explicitly skipping introspection on java.* classes since we'll never find `@Bean` annotations there anyway. Previously, we optimized their introspection through always using reflection instead of ASM. However, it's actually pointless to even go that far since we'll never find Spring annotations there in the first place.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to prevent unnecessary lookups in the `knownSuperclasses` map.  Previously, the `if` statement checked if the `superclass` was present in the map.  The updated code now adds a condition that `superclass` does *not* start with \"java\".  This means that if the superclass is a standard Java class (likely a core class like `Object`), it will be skipped, avoiding an unnecessary lookup in the map",
            "avg_logprobs": -0.25145309448242187
        }
    },
    {
        "commit_hash": "ce43d1b1da4361b6dbbbd9153a86602e891f5155",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/ApplicationContextAwareProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (!((bean instanceof Aware) && (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||\n-\t\t\t\tbean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||\n-\t\t\t\tbean instanceof MessageSourceAware || bean instanceof ApplicationStartupAware ||\n-\t\t\t\tbean instanceof ApplicationContextAware))) {\n-\t\t\treturn bean;\n+\t\tif (bean instanceof Aware) {\n+\t\t\tinvokeAwareInterfaces(bean);\n-\n-\t\tinvokeAwareInterfaces(bean);",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify logic in ApplicationContextAwareProcessor.postProcessBeforeInitialization()",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change simplifies the conditional logic for checking if a bean implements Aware interfaces.  The original code used a complex nested `if` statement to check for multiple Aware interfaces.  The revised code uses a single `if` statement to check if the bean is an `Aware` and then unconditionally calls `invokeAwareInterfaces` to handle all the Aware interfaces.  This results in a more concise and potentially slightly more efficient check",
            "avg_logprobs": -0.21975790068160655
        }
    },
    {
        "commit_hash": "ce49354400936778b7a7a1e6ec1a373d2a1fa5cb",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/testFixtures/java/org/springframework/web/testfixture/servlet/MockHttpServletResponse.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import java.nio.charset.StandardCharsets;\n+\tprivate static final MediaType APPLICATION_PLUS_JSON = new MediaType(\"application\", \"*+json\");\n+\n+\t\t\t\telse if (mediaType.isCompatibleWith(MediaType.APPLICATION_JSON) ||\n+\t\t\t\t\t\tmediaType.isCompatibleWith(APPLICATION_PLUS_JSON)) {\n+\t\t\t\t\t\tthis.characterEncoding = StandardCharsets.UTF_8.name();\n+\t\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Sync MockHttpServletResponse implementations",
        "commit_body": "See gh-33019\n",
        "linked_issues": [
            {
                "issue_id": "33019",
                "issue_title": "`MockHttpServletResponse` defaults to ISO-8859-1 for JSON while the rest of the framework defaults to UTF-8",
                "issue_body": "**Affects:** 6.1.8\r\n\r\nWhen Spring MVC serializes JSON and no charater encoding is specified, UTF-8 is used by default (see [this](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/converter/json/AbstractJackson2HttpMessageConverter.java#L436) or [this](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java#L156)). \r\n\r\nMockMvc on the other hand always defaults to ISO-8859-1 which results in inconsistencies reproduced [here](https://github.com/lukas-krecan/JsonUnit/issues/212).\r\n\r\nThis is a follow-up of https://github.com/spring-projects/spring-framework/issues/32997\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a new `MediaType` constant `APPLICATION_PLUS_JSON` and updated the conditional logic within the `MockHttpServletResponse` class.  Previously, the code only checked for compatibility with `MediaType.APPLICATION_JSON`.  Now, it also checks for compatibility with `APPLICATION_PLUS_JSON`, and if either is true, sets the `characterEncoding` to UTF-8.  This change likely handles a broader range of JSON media types",
            "avg_logprobs": -0.14476557995410674
        }
    },
    {
        "commit_hash": "ce4eff321cd976df4ba26fe3971642259af891d2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/StringUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tStringBuilder sb = new StringBuilder(inString.length());\n+\t\tint capacity = inString.length();\n+\t\tif (newPattern.length() > oldPattern.length()) {\n+\t\t\tcapacity += 16;\n+\t\t}\n+\t\tStringBuilder sb = new StringBuilder(capacity);\n+\n+",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize StringUtils.replace for larger replacement pattern",
        "commit_body": "Issue: SPR-15430\n",
        "linked_issues": [
            {
                "issue_id": "19991",
                "issue_title": "Improve performance of StringUtils.replace() if pattern is not found [SPR-15430]",
                "issue_body": "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** opened **[SPR-15430](https://jira.spring.io/browse/SPR-15430?redirect=false)** and commented\n\nHey,\n\njust noticed a small improvement for `StringUtils.replace()` in case the pattern that should be replaced is not found in the given String. I noticed this in our loadtests where lots of messages are send to user destinations, which are sanitized like this: `StringUtils.replace(user, \"/\", \"%2F\")`\n\nMost of the time, users don't contain a slash, so there is no replacement needed. Please find the PR attached, that yields the following microbenchmark results:\n\n```\nMyBenchmark.testNew                                   thrpt   20  56148767,184 \u00b1 571831,993   ops/s\nMyBenchmark.testNew:\u00b7gc.alloc.rate                    thrpt   20         0,002 \u00b1      0,003  MB/sec\nMyBenchmark.testNew:\u00b7gc.alloc.rate.norm               thrpt   20        ? 10??                 B/op\nMyBenchmark.testNew:\u00b7gc.count                         thrpt   20           ? 0               counts\nMyBenchmark.testOld                                   thrpt   20  15643379,634 \u00b1 404629,728   ops/s\nMyBenchmark.testOld:\u00b7gc.alloc.rate                    thrpt   20      3698,512 \u00b1     95,454  MB/sec\nMyBenchmark.testOld:\u00b7gc.alloc.rate.norm               thrpt   20       248,000 \u00b1      0,001    B/op\nMyBenchmark.testOld:\u00b7gc.count                         thrpt   20       312,000               counts\nMyBenchmark.testOld:\u00b7gc.time                          thrpt   20       183,000                   ms\n```\n\n\n\n---\n\n**Affects:** 4.3.7\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/1384\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point! I've addressed this as part of a larger revision, also initializing the `StringBuilder` capacity with the length of the input (in `replace` as well as `deleteAny`). We're enforcing the returning of the original `String` in our unit tests now.\n",
                    "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** commented\n\nThanks for addressing this. I have one remark though. Setting the initial capacity for `StringBuilder` in `replace` might cause more allocations when the replacement is longer than the oldPattern. Which is the case for `StringUtils.replace(user, \"/\", \"%2F\")`\n\n```\nBenchmark                                                   Mode  Cnt         Score        Error   Units\nMyBenchMark.testNew                                   thrpt   20  11015863,506 \u00b1 197360,119   ops/s\nMyBenchMark.testNew:\u00b7gc.alloc.rate                    thrpt   20      4285,222 \u00b1     77,203  MB/sec\nMyBenchMark.testNew:\u00b7gc.alloc.rate.norm               thrpt   20       408,000 \u00b1      0,001    B/op\nMyBenchMark.testNew:\u00b7gc.churn.PS_Eden_Space           thrpt   20      4275,075 \u00b1    148,756  MB/sec\nMyBenchMark.testNew:\u00b7gc.churn.PS_Eden_Space.norm      thrpt   20       406,958 \u00b1      9,871    B/op\nMyBenchMark.testNew:\u00b7gc.churn.PS_Survivor_Space       thrpt   20         0,261 \u00b1      0,057  MB/sec\nMyBenchMark.testNew:\u00b7gc.churn.PS_Survivor_Space.norm  thrpt   20         0,025 \u00b1      0,005    B/op\nMyBenchMark.testNew:\u00b7gc.count                         thrpt   20       357,000               counts\nMyBenchMark.testNew:\u00b7gc.time                          thrpt   20       178,000                   ms\nMyBenchMark.testOld                                   thrpt   20  11519565,769 \u00b1  77319,784   ops/s\nMyBenchMark.testOld:\u00b7gc.alloc.rate                    thrpt   20      3954,225 \u00b1     26,527  MB/sec\nMyBenchMark.testOld:\u00b7gc.alloc.rate.norm               thrpt   20       360,000 \u00b1      0,001    B/op\nMyBenchMark.testOld:\u00b7gc.churn.PS_Eden_Space           thrpt   20      3963,766 \u00b1     86,836  MB/sec\nMyBenchMark.testOld:\u00b7gc.churn.PS_Eden_Space.norm      thrpt   20       360,866 \u00b1      7,397    B/op\nMyBenchMark.testOld:\u00b7gc.churn.PS_Survivor_Space       thrpt   20         0,280 \u00b1      0,059  MB/sec\nMyBenchMark.testOld:\u00b7gc.churn.PS_Survivor_Space.norm  thrpt   20         0,025 \u00b1      0,005    B/op\nMyBenchMark.testOld:\u00b7gc.count                         thrpt   20       348,000               counts\nMyBenchMark.testOld:\u00b7gc.time                          thrpt   20       182,000                   ms\n```\n\nShould be okay for most cases - I wanted to note it for completeness reasons though.\n\nCheers\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nHmm, indeed, if we end up with a capacity less than 16 (the `StringBuilder` default), there could indeed be more allocations than before. This was primarily meant as an optimization for larger Strings where the builder's capacity always has to be grown... so strictly speaking, we could enforce a minimum of 16 to have no regression there. Probably better, for cases with a replacement larger than the original pattern, we could simply use a builder capacity of input size + 16 (analogous to the `StringBuilder(String)` constructor). Any objections?\n",
                    "**[Christoph Dreis](https://jira.spring.io/secure/ViewProfile.jspa?name=christoph.dreis)** commented\n\nActually the example above is a username larger than 16 characters. Here is one with less than 16 characters:\n\n```\nBenchmark                                                   Mode  Cnt         Score        Error   Units\nMyBenchmark.testNew                                   thrpt   20  11689788,924 \u00b1 298611,841   ops/s\nMyBenchmark.testNew:\u00b7gc.alloc.rate                    thrpt   20      2764,230 \u00b1     70,548  MB/sec\nMyBenchmark.testNew:\u00b7gc.alloc.rate.norm               thrpt   20       248,000 \u00b1      0,001    B/op\nMyBenchmark.testNew:\u00b7gc.count                         thrpt   20       368,000               counts\nMyBenchmark.testNew:\u00b7gc.time                          thrpt   20       171,000                   ms\nMyBenchmark.testOld                                   thrpt   20  16474672,626 \u00b1 142928,901   ops/s\nMyBenchmark.testOld:\u00b7gc.alloc.rate                    thrpt   20      3267,337 \u00b1     28,232  MB/sec\nMyBenchmark.testOld:\u00b7gc.alloc.rate.norm               thrpt   20       208,000 \u00b1      0,001    B/op\nMyBenchmark.testOld:\u00b7gc.count                         thrpt   20       368,000               counts\nMyBenchmark.testOld:\u00b7gc.time                          thrpt   20       176,000                   ms\n```\n\nOpting for size + 16 in case the replacement is larger than the original pattern might be the way to go, though for smaller Strings it may create more allocations than before (shown in the results below with something like `new StringBuilder(newPattern.length() > oldPattern.length() ? inString.length() + 16 : inString.length())`.\n\n```\nBenchmark                                                   Mode  Cnt         Score        Error   Units\nMyBenchmark.testNew                                   thrpt   20  14444566,216 \u00b1 111195,218   ops/s\nMyBenchmark.testNew:\u00b7gc.alloc.rate                    thrpt   20      3305,505 \u00b1     25,452  MB/sec\nMyBenchmark.testNew:\u00b7gc.alloc.rate.norm               thrpt   20       240,000 \u00b1      0,001    B/op\nMyBenchmark.testNew:\u00b7gc.count                         thrpt   20       327,000               counts\nMyBenchmark.testNew:\u00b7gc.time                          thrpt   20       163,000                   ms\nMyBenchmark.testOld                                   thrpt   20  16699064,442 \u00b1 469500,527   ops/s\nMyBenchmark.testOld:\u00b7gc.alloc.rate                    thrpt   20      3439,320 \u00b1     96,715  MB/sec\nMyBenchmark.testOld:\u00b7gc.alloc.rate.norm               thrpt   20       216,000 \u00b1      0,001    B/op\nMyBenchmark.testOld:\u00b7gc.count                         thrpt   20       377,000               counts\nMyBenchmark.testOld:\u00b7gc.time                          thrpt   20       179,000                   ms\n```\n\nI intentionally left this out of my initial PR, because it leaves you with the question what the best capacity for the StringBuilder is and what the most common case for users is. ;-) I personally have no strong feelings against size + 16, though.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change optimizes the `StringBuilder` capacity calculation when replacing a string pattern.  Instead of always using the input string length, it now calculates a capacity based on the lengths of the old and new patterns.  If the new pattern is longer than the old, it adds 16 to the capacity to potentially avoid unnecessary reallocations. This aims to improve performance by pre-allocating more space in the `StringBuilder`, reducing the number of internal resizing operations",
            "avg_logprobs": -0.20618387993345869
        }
    },
    {
        "commit_hash": "ceb79c9bee2b734cb6b3eb2e02494e69671cb20e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/broker/AbstractBrokerMessageHandler.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-import org.springframework.messaging.support.AbstractMessageChannel;\n+import org.springframework.messaging.support.InterceptableChannel;\n-\t\t\tif (this.clientInboundChannel instanceof AbstractMessageChannel) {\n-\t\t\t\t((AbstractMessageChannel) this.clientInboundChannel).addInterceptor(0, this.unsentDisconnectInterceptor);\n+\t\t\tif (this.clientInboundChannel instanceof InterceptableChannel) {\n+\t\t\t\t((InterceptableChannel) this.clientInboundChannel).addInterceptor(0, this.unsentDisconnectInterceptor);\n-\t\t\tif (this.clientInboundChannel instanceof AbstractMessageChannel) {\n-\t\t\t\t((AbstractMessageChannel) this.clientInboundChannel).removeInterceptor(this.unsentDisconnectInterceptor);\n+\t\t\tif (this.clientInboundChannel instanceof InterceptableChannel) {\n+\t\t\t\t((InterceptableChannel) this.clientInboundChannel).removeInterceptor(this.unsentDisconnectInterceptor);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use InterceptableChannel in AbstractBrokerMessageHandler",
        "commit_body": "Issue: SPR-12218\n",
        "linked_issues": [
            {
                "issue_id": "16832",
                "issue_title": "Exception in \"inboundClientChannel\" interceptor for DISCONNECT prevents broker from learning about it [SPR-12218]",
                "issue_body": "**[Rob Winch](https://jira.spring.io/secure/ViewProfile.jspa?name=rwinch)** opened **[SPR-12218](https://jira.spring.io/browse/SPR-12218?redirect=false)** and commented\n\nIf an exception is thrown in ChannelInterceptor.preSend on DISCONNECT, then the following error is reported when sending to destinations a user has subscribed:\n\n```\nSubProtocolWebSocketHandler[ERROR] - No session for ...\n```\n\nEven if an Exception is thrown in ChannelInterceptor.preSend on DISCONNECT the user mapping should be cleaned up. One option to clean this up would be to use a `ApplicationListener<SessionDisconnectEvent>`\n\n\n---\n\n**Affects:** 4.1 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/ceb79c9bee2b734cb6b3eb2e02494e69671cb20e, https://github.com/spring-projects/spring-framework/commit/371d93b3463c5157f3c4b2b809084ddb00ae2b9e\n\n1 votes, 3 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThe issue mainly affects the simple broker which does not have a heartbeat and must see the DISCONNECT message. A full features broker supports heartbeats and will notice withing a short period that the client is no longer sending messages and will close the connection.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the conditional logic for handling `clientInboundChannel` interceptors.  It replaces `AbstractMessageChannel` with `InterceptableChannel` in the `if` statements.  This change ensures that the `unsentDisconnectInterceptor` is added and removed only from channels that support the `InterceptableChannel` interface, improving type safety and potentially supporting a wider range of message channels",
            "avg_logprobs": -0.21644716262817382
        }
    },
    {
        "commit_hash": "cefd74555ada1285ecd8dc174f6dfc68115807f8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tboolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n-\t\tif (!mbd.isSynthetic() && hasInstAwareBpps) {\n+\t\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n-\t\tif (hasInstAwareBpps) {\n+\t\tif (hasInstantiationAwareBeanPostProcessors()) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish contribution",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes a redundant check.  Originally, `hasInstAwareBpps` was calculated once and then used in two separate `if` statements.  The updated code calculates `hasInstantiationAwareBeanPostProcessors()` only once, directly within the second `if` statement, eliminating the intermediate variable. This improves efficiency by avoiding unnecessary variable assignments",
            "avg_logprobs": -0.18133988645341662
        }
    },
    {
        "commit_hash": "cfae40afb456c98b2a11be600096da89b8aacafd",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageReaderArgumentResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.http.HttpStatus;\n+import org.springframework.web.server.ResponseStatusException;\n-\t\t\treturn Mono.error(new IllegalStateException(\n-\t\t\t\t\t\"In a WebFlux application, form data is accessed via ServerWebExchange.getFormData().\"));\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Form data is accessed via ServerWebExchange.getFormData() in WebFlux.\");\n+\t\t\t}\n+\t\t\treturn Mono.error(new ResponseStatusException(HttpStatus.UNSUPPORTED_MEDIA_TYPE));",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Return 415 for form data with @RequestBody in WebFlux",
        "commit_body": "Closes gh-26386\n",
        "linked_issues": [
            {
                "issue_id": "26386",
                "issue_title": "Return 415 for form data via @RequestBody in WebFlux",
                "issue_body": "A `@RestController` like\r\n\r\n```\r\n@RestController\r\n public class DemoController {\r\n     @PostMapping\r\n     public Map<String, Object> getAttributes(@RequestBody Body body, ServerWebExchange serverWebExchange) {\r\n         return serverWebExchange.getAttribute(body.getAttribute());\r\n     }\r\n }\r\n```\r\n\r\nis expected to handle requests with content type _application/json_. When the client request has a content type _x-www-form-urlencoded_, I would expect that the server returns _415 Unsupported Media Type_ or another client error.\r\nInstead Spring throws _java.lang.IllegalStateException: In a WebFlux application, form data is accessed via ServerWebExchange.getFormData()._\r\n\r\nA sample application with failing test can be found here: https://github.com/huberchrigu/spring-reactive-wrong-content-type",
                "issue_state": "closed",
                "issue_comment": [
                    "Technically it is possible to read the body via `FormHttpMessageReader` but we decided to prevent it as part of #22486 in order to avoid running into the issue of trying to consume the body twice, once via `ServerWebExchange#getFormData` (e.g. in a filter or other) and a second via `@RequestBody`. You're right though that 415 would be a better way to flag this since this effectively means that method doesn't support it.\r\n\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces an `IllegalStateException` with a `ResponseStatusException` (with `HttpStatus.UNSUPPORTED_MEDIA_TYPE`) when form data is accessed in a WebFlux application.  The original error message was replaced with a debug log message if the logger is enabled.  This change indicates a shift from signaling an illegal state to signaling an unsupported media type, likely to better handle situations where the client sends form data in a context where it's not expected",
            "avg_logprobs": -0.26456595972964636
        }
    },
    {
        "commit_hash": "d1303affc8434537927e5ce0149ba4ae6d21c4f9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/HttpRange.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t * @throws IllegalArgumentException if the sum of all ranges exceeds the\n-\t * resource length.\n+\t * @throws IllegalArgumentException if the sum of all ranges exceeds the resource length\n-\t\t\tlong total = regions.stream().map(ResourceRegion::getCount).reduce(0L, (count, sum) -> sum + count);\n+\t\t\tlong total = 0;\n+\t\t\tfor (ResourceRegion region : regions) {\n+\t\t\t\ttotal += region.getCount();\n+\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Avoid expensive Stream API usage in HttpRange",
        "commit_body": "See gh-22742\n",
        "linked_issues": [
            {
                "issue_id": "22742",
                "issue_title": "Avoid expensive assertions in HttpRange",
                "issue_body": "`HttpRange` is used in hot web request invocation paths and should therefore consistently not have any expensive assertions, neither with argument-capturing `Supplier` callbacks nor with direct String concatenation (as it still does in the 4.3.x line). An `if` check with manual exception throwing is the most efficient way to implement such checks, as used in other parts of `HttpRange` already.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a stream-based calculation of the sum of `ResourceRegion` counts with a traditional `for` loop.  The original code used a `reduce` operation within a stream to calculate the total count.  The updated code iterates through the `regions` list and adds each `region.getCount()` to a running `total`.  This change likely improves performance, especially for large lists, as stream operations can have overhead",
            "avg_logprobs": -0.19473809136284723
        }
    },
    {
        "commit_hash": "d2868f5dd0840c158a5a60fa96c4afd9ce19f777",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/BeanUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import java.util.HashSet;\n-\t\tList<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null);\n+\t\tSet<String> ignoreSet = (ignoreProperties != null ? new HashSet<>(Arrays.asList(ignoreProperties)) : null);\n-\t\t\tif (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {\n+\t\t\tif (writeMethod != null && (ignoreSet == null || !ignoreSet.contains(targetPd.getName()))) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use Set to track ignored properties in BeanUtils.copyProperties()",
        "commit_body": "Closes gh-30088\n",
        "linked_issues": [
            {
                "issue_id": "30088",
                "issue_title": "Use `Set` to track ignored properties in `BeanUtils.copyProperties()`",
                "issue_body": null,
                "issue_state": "closed",
                "issue_comment": [
                    "@liupeng12345 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30088)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30088) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@liupeng12345 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30088)!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a `List` with a `HashSet` for storing `ignoreProperties`.  This change optimizes the `contains()` operation from potentially O(n) time complexity (for a `List`) to O(1) time complexity (for a `HashSet`).  The `if` statement now uses the `ignoreSet` instead of `ignoreList`, reflecting the change in data structure.  This is likely a performance improvement, especially for larger sets of `ignoreProperties`",
            "avg_logprobs": -0.21251996994018554
        }
    },
    {
        "commit_hash": "d2aa6a98f25274b99f48866d83c10cfe3bf00f52",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/CoroutinesUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-import org.springframework.util.ReflectionUtils;\n+import org.springframework.util.ReflectionUtils;\n-\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\telse {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polishing",
        "commit_body": "Closes gh-31846\n",
        "linked_issues": [
            {
                "issue_id": "31846",
                "issue_title": "Convert args to Kotlin value class in CoroutinesUtils",
                "issue_body": "Currently, `IllegalArgumentException` occurs when Kotlin suspend function with value class parameters  in proxied class is called.\r\nThis is because those functions are called by `CoroutinesUtils` (called from `AopUtils`), but it does not convert Java type args to Kotlin value class.\r\n\r\nThis PR aims to avoid the exception.\r\nI referred to https://github.com/spring-projects/spring-framework/issues/31698\r\n\r\nRelated issue:\r\nhttps://github.com/ExpediaGroup/graphql-kotlin/issues/1894\r\n\r\nSample code:\r\nhttps://github.com/T45K/Spring_GraphQL-Kotlin_trial\r\n\r\nStack trace:\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n```\r\njava.lang.IllegalArgumentException: object is not an instance of declaring class\r\n\tat java.base/jdk.internal.reflect.DirectMethodHandleAccessor.checkReceiver(DirectMethodHandleAccessor.java:197) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:99) ~[na:na]\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]\r\n\tat kotlin.reflect.jvm.internal.calls.ValueClassAwareCaller.call(ValueClassAwareCaller.kt:190) ~[kotlin-reflect-1.9.20.jar:1.9.255-SNAPSHOT]\r\n\tat kotlin.reflect.jvm.internal.KCallableImpl.callDefaultMethod$kotlin_reflection(KCallableImpl.kt:207) ~[kotlin-reflect-1.9.20.jar:1.9.255-SNAPSHOT]\r\n\tat kotlin.reflect.full.KCallables.callSuspendBy(KCallables.kt:74) ~[kotlin-reflect-1.9.20.jar:1.9.255-SNAPSHOT]\r\n\tat org.springframework.core.CoroutinesUtils.lambda$invokeSuspendingFunction$2(CoroutinesUtils.java:124) ~[spring-core-6.1.1.jar:6.1.1]\r\n\tat kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineUnintercepted$$inlined$createCoroutineFromSuspendFunction$IntrinsicsKt__IntrinsicsJvmKt$4.invokeSuspend(IntrinsicsJvm.kt:270) ~[kotlin-stdlib-1.9.20.jar:1.9.255-SNAPSHOT]\r\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) ~[kotlin-stdlib-1.9.20.jar:1.9.255-SNAPSHOT]\r\n\tat kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.EventLoop.processUnconfinedEvent(EventLoop.common.kt:68) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.DispatchedTaskKt.resumeUnconfined(DispatchedTask.kt:245) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.DispatchedTaskKt.dispatch(DispatchedTask.kt:163) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.CancellableContinuationImpl.dispatchResume(CancellableContinuationImpl.kt:474) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.CancellableContinuationImpl.resumeImpl(CancellableContinuationImpl.kt:508) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.CancellableContinuationImpl.resumeImpl$default(CancellableContinuationImpl.kt:497) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.CancellableContinuationImpl.resumeWith(CancellableContinuationImpl.kt:368) ~[kotlinx-coroutines-core-jvm-1.7.3.jar:na]\r\n\tat kotlinx.coroutines.reactive.AwaitKt$awaitOne$2$1.onNext(Await.kt:242) ~[kotlinx-coroutines-reactive-1.7.3.jar:na]\r\n\tat reactor.core.publisher.StrictSubscriber.onNext(StrictSubscriber.java:89) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:158) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144) ~[reactor-core-3.6.0.jar:3.6.0]\r\n\tat reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:415) ~[reactor-netty-core-1.1.13.jar:1.1.13]\r\n\tat reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:446) ~[reactor-netty-core-1.1.13.jar:1.1.13]\r\n\tat reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:687) ~[reactor-netty-http-1.1.13.jar:1.1.13]\r\n\tat reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:114) ~[reactor-netty-core-1.1.13.jar:1.1.13]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:284) ~[reactor-netty-http-1.1.13.jar:1.1.13]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346) ~[netty-codec-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318) ~[netty-codec-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562) ~[netty-transport-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) ~[netty-common-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.101.Final.jar:4.1.101.Final]\r\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.101.Final.jar:4.1.101.Final]\r\n\tat java.base/java.lang.Thread.run(Thread.java:1583) ~[na:na]\r\n```\r\n\r\n</p>\r\n</details> ",
                "issue_state": "closed",
                "issue_comment": [
                    "Merged, thanks!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an `else` block.  This suggests the code previously contained a conditional statement (likely an `if-else`) where the `else` block is no longer needed.  The original `else` block's code has been removed.  The logic now only executes the code within the `if` block, or no code at all if the `if` condition is false",
            "avg_logprobs": -0.2511306855736709
        }
    },
    {
        "commit_hash": "d41ca095abee4e8284139f239d4b5bbf09f694a5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/bind/annotation/ControllerMappingReflectiveProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.core.KotlinDetector;\n+import org.springframework.util.ReflectionUtils;\n+\t\tClass<?> declaringClass = method.getDeclaringClass();\n+\t\tif (KotlinDetector.isKotlinType(declaringClass)) {\n+\t\t\tReflectionUtils.doWithMethods(declaringClass, m -> hints.registerMethod(m, ExecutableMode.INVOKE),\n+\t\t\t\t\tm -> m.getName().equals(method.getName() + \"$default\"));\n+\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add native support for Kotlin default values in controllers",
        "commit_body": "Closes gh-33384\n",
        "linked_issues": [
            {
                "issue_id": "33384",
                "issue_title": "spring native not support method handler with kotlin default value",
                "issue_body": "spring version: 6.1.8\r\n\r\nexample:\r\n```kotlin\r\n@RestController\r\nclass DefaultController {\r\n    @GetMapping(\"/defaultValue\")\r\n    fun defaultValue(@RequestParam(required = false) argument: Boolean? = null) = argument\r\n}\r\n```\r\n\r\ntest:\r\n```shell\r\ncurl localhost:8080/defaultValue\r\n{\"timestamp\":\"2024-08-14T03:59:59.186+00:00\",\"status\":500,\"error\":\"Internal Server Error\",\"path\":\"/defaultValue\"}\r\n```\r\n\r\nstack trace:\r\n```\r\nServlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Handler dispatch failed: org.graalvm.nativeimage.MissingReflectionRegistrationError: The program tried to reflectively invoke method public static java.lang.Boolean com.example.DefaultController.defaultValue$default(com.example.DefaultController,java.lang.Boolean,int,java.lang.Object) without it being registered for runtime reflection. Add it to the reflection metadata to solve this problem. See https://www.graalvm.org/latest/reference-manual/native-image/metadata/#reflection for help.] with root cause\r\n\r\norg.graalvm.nativeimage.MissingReflectionRegistrationError: The program tried to reflectively invoke method public static java.lang.Boolean com.example.DefaultController.defaultValue$default(com.example.DefaultController,java.lang.Boolean,int,java.lang.Object) without it being registered for runtime reflection. Add it to the reflection metadata to solve this problem. See https://www.graalvm.org/latest/reference-manual/native-image/metadata/#reflection for help.\r\n        at org.graalvm.nativeimage.builder/com.oracle.svm.core.reflect.MissingReflectionRegistrationUtils.forQueriedOnlyExecutable(MissingReflectionRegistrationUtils.java:97) ~[na:na]\r\n        at java.base@17.0.11/java.lang.reflect.Method.acquireMethodAccessor(Method.java:77) ~[com.example.ApplicationKt:na]\r\n        at java.base@17.0.11/java.lang.reflect.Method.invoke(Method.java:566) ~[com.example.ApplicationKt:na]\r\n        at kotlin.reflect.jvm.internal.calls.CallerImpl$Method.callMethod(CallerImpl.kt:97) ~[com.example.ApplicationKt:1.9.24-release-822]\r\n        at kotlin.reflect.jvm.internal.calls.CallerImpl$Method$Static.call(CallerImpl.kt:106) ~[na:na]\r\n        at kotlin.reflect.jvm.internal.KCallableImpl.callDefaultMethod$kotlin_reflection(KCallableImpl.kt:215) ~[com.example.ApplicationKt:1.9.24-release-822]\r\n        at kotlin.reflect.jvm.internal.KCallableImpl.callBy(KCallableImpl.kt:112) ~[com.example.ApplicationKt:1.9.24-release-822]\r\n        at org.springframework.web.method.support.InvocableHandlerMethod$KotlinDelegate.invokeFunction(InvocableHandlerMethod.java:334) ~[na:na]\r\n        at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:252) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:188) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:926) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:831) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[com.example.ApplicationKt:6.1.11]\r\n        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903) ~[com.example.ApplicationKt:6.1.11]\r\n```\r\n\r\nissue reproduce repository: https://github.com/czp3009/spring-native-not-support-method-handler-with-kotlin-default-value\r\n\r\nPossible causes:\r\ni notice that in [this issue](https://github.com/spring-projects/spring-framework/issues/21139#issuecomment-1602718793) spring finally support kotlin default value in method handler\r\n\r\nbut according to code in [PR](https://github.com/mdeinum/spring-framework/commit/06bc03e7e560ee166e142e070feead3b8c80b8fd), it seems that the native hint for method handlers with method names ending in '$default' is missing",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "This change adds Kotlin support to `ControllerMappingReflectiveProcessor`.  It now checks if the method's declaring class is Kotlin. If it is, it iterates through the methods of the declaring class, specifically looking for methods with names matching `methodName$default`.  These methods are then registered with `ExecutableMode.INVOKE` in the `hints` object",
            "avg_logprobs": -0.2420044708251953
        }
    },
    {
        "commit_hash": "d43dfc7bae5aa5e81bc51dfb26c1ae1ff1ecc52e",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\tint separatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n+\t\t\t\tint separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);\n+\t\t\t\tif (separatorIndex == -1) {\n+\t\t\t\t\tseparatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);\n+\t\t\t\t}\n-\t\t\t\t\trootEntryPath = urlFile.substring(separatorIndex + ResourceUtils.JAR_URL_SEPARATOR.length());\n+\t\t\t\t\trootEntryPath = urlFile.substring(separatorIndex + 2);  // both separators are 2 chars",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Properly extract jar file from Tomcat war URL",
        "commit_body": "Issue: SPR-15485\n",
        "linked_issues": [
            {
                "issue_id": "20045",
                "issue_title": "Last modified check of Resource created from Tomcat war:file: URL fails with FileNotFoundException [SPR-15485]",
                "issue_body": "**[Andy Wilkinson](https://jira.spring.io/secure/ViewProfile.jspa?name=awilkinson)** opened **[SPR-15485](https://jira.spring.io/browse/SPR-15485?redirect=false)** and commented\n\nThis is, I believe, a regression due to the changes made in [this commit](https://github.com/spring-projects/spring-framework/commit/899f2359984c4fbf396bfc74a824541b6332eb2f). A side-effect of those changes is that `AbstractFileResolvingResource` now proceeds with file system resolution where as, previously, it would have use the last modified header on the URL connection.\n\nThe file system resolution fails with an exception like this:\n\n```\njava.io.FileNotFoundException: Jar URL cannot be resolved to absolute file path because it does not reside in the file system: war:file:/home/vbao/service/vbao-web.war*/js/bootstrap.min.js\n\tat org.springframework.util.ResourceUtils.getFile(ResourceUtils.java:215)\n\tat org.springframework.core.io.AbstractFileResolvingResource.getFileForLastModifiedCheck(AbstractFileResolvingResource.java:67)\n\tat org.springframework.core.io.AbstractResource.lastModified(AbstractResource.java:153)\n\tat org.springframework.core.io.AbstractFileResolvingResource.lastModified(AbstractFileResolvingResource.java:169)\n\tat org.springframework.web.servlet.resource.ResourceHttpRequestHandler.handleRequest(ResourceHttpRequestHandler.java:345)\n\t\u2026\n```\n\n---\n\n**Affects:** 4.3.8\n\n**Reference URL:** https://github.com/spring-projects/spring-boot/issues/8986\n\n**Issue Links:**\n- #19895 PathMatchingResourcePatternResolver fails to work under Tomcat 8.0.41 with unpackWARs=false\n- #21853 HTTP 404 for static resources with last modified = 0L (breaks Docker images build with Jib)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/d43dfc7bae5aa5e81bc51dfb26c1ae1ff1ecc52e, https://github.com/spring-projects/spring-framework/commit/d2985613d1a0a59e275ae09ddd9076bd3a46e03b, https://github.com/spring-projects/spring-framework/commit/3daf626842713178f4f396524865da18850467b0\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'm surprised that the `ResourceUtils.extractArchiveURL` doesn't do the job here: It should return `file:/home/vbao/service/vbao-web.war` in such a scenario, which is then what `getFileForLastModifiedCheck` enters `ResourceUtils.getFile` with...\n\nI guess we should make that check more defensiveness, but nevertheless, it'd be great to find out why specifically the archive check doesn't work.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've added a defensive fallback for `FileNotFoundException`, going with the URL connection check instead. Nevertheless, the archive extraction check should work fine as well here...\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAs per https://jira.spring.io/browse/SPR-15332?focusedCommentId=151543&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-151543, we also have a specific check for Tomcat war URLs in our jar file extraction code now (for 5.0 RC1 and 4.3.9, along with the other changes in this ticket).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how the `PathMatchingResourcePatternResolver` handles URL parsing, specifically for JAR and WAR files.  It now prioritizes WAR file URLs over JAR URLs.  If a WAR separator isn't found, it falls back to the JAR separator.  Crucially, the substring extraction logic has been simplified by removing the redundant `ResourceUtils.JAR_URL_SEPARATOR.length()` addition, directly using a constant `2` for the length of both separators",
            "avg_logprobs": -0.2596293449401855
        }
    },
    {
        "commit_hash": "d4495a56542276d6ea9a09d6b61c0e30cb75188c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (targetObject == null && this.nullSafe) {\n+\t\tif (targetObject == null && isNullSafe()) {\n-\t\tif (contextObject.getValue() == null && this.nullSafe) {\n+\t\tif (contextObject.getValue() == null && isNullSafe()) {\n-\t\tif (this.nullSafe) {\n+\t\tif (isNullSafe()) {\n-\t\tif (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {\n+\t\tif (isNullSafe() && CodeFlow.isPrimitive(descriptor)) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Revise PropertyOrFieldReference since isNullSafe() is not final",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code changes in `PropertyOrFieldReference.java` refactor the use of `this.nullSafe` to `isNullSafe()`.  This suggests a move towards a method for checking the `nullSafe` flag, likely for better encapsulation and potential reuse within the class.  The original `this.nullSafe` flag was directly used in multiple `if` statements, and now the `isNullSafe()` method is used instead.  This improves code readability and maintainability",
            "avg_logprobs": -0.2905992391158123
        }
    },
    {
        "commit_hash": "d494621ee3d2e0d6c706f401028b0bbd62491495",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/ApplicationListenerDetector.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n+\t\tif (ApplicationListener.class.isAssignableFrom(beanType)) {\n+\t\t\tthis.singletonNames.put(beanName, beanDefinition.isSingleton());\n+\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "avoid store all bean name",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a conditional check to determine whether to store the singleton status of a bean.  Previously, the singleton status was always stored.  Now, it's only stored if the bean type is assignable from `ApplicationListener`.  This likely improves efficiency by avoiding storing singleton status for beans that aren't listeners",
            "avg_logprobs": -0.12602226661913324
        }
    },
    {
        "commit_hash": "d52f07aa1b83208dd84b65d2a4ba724b3a0227ff",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/simp/stomp/StompBrokerRelayMessageHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\theaderAccessor.setSessionId(this.sessionId);\n+\n+\t\t\telse if (logger.isErrorEnabled() && StompCommand.ERROR == headerAccessor.getCommand()) {\n+\t\t\t\tlogger.error(\"Received STOMP ERROR: \" + message);\n+\t\t\t}\n-\t\t\theaderAccessor.setSessionId(this.sessionId);\n-",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log STOMP ERROR frames at error level",
        "commit_body": "Issue: SPR-11673\n",
        "linked_issues": [
            {
                "issue_id": "16296",
                "issue_title": "no msg when cannot authorize against external queue [SPR-11673]",
                "issue_body": "**[Prashant Deva](https://jira.spring.io/secure/ViewProfile.jspa?name=pdeva)** opened **[SPR-11673](https://jira.spring.io/browse/SPR-11673?redirect=false)** and commented\n\nSo i tried putting in the following lines in my code to pass a fake password:\n\n```\n StompBrokerRelayRegistration registration = config.enableStompBrokerRelay(\"/topic\");\n        registration.setRelayHost(\"xxxx.com\");\n        registration.setSystemPasscode(\"hello\");\n        registration.setClientPasscode(\"hello\");\n\n```\n\nthe funny thing is the logs still just show this:\n\n```\n16:24:47,103  INFO reactor-tcp-io-2 netty.NettyTcpClient:304 - CONNECT: [id: 0x0db8042b, /192.168.1.15:49980 => xxxx.com/162.242.220.165:61613]\n```\n\nof course there is no data transfer cause the msg queue itself wont allow authentication with a non-existent password, but nothing in the logs by spring shows we had a bad authentication\n\n\n---\n\n**Affects:** 4.0.3\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI see this for the \"system\" connection at startup (DEBUG level):\n\n```\n10:21:58 [reactor-tcp-io-1] StompDecoder - Decoded [Payload byte[32]][Headers={stompCommand=ERROR, nativeHeaders={content-type=[text/plain], message=[Bad CONNECT], content-length=[32], version=[1.0,1.1,1.2]}, simpMessageType=OTHER, contentType=text/plain, id=31149240-3fb5-63b8-15fd-11166e51e9f2, timestamp=1398867718551}]\n```\n\nAnd then this for client connections later (TRACE level):\n\n```\n10:22:31 [clientInboundChannel-2] StompBrokerRelayMessageHandler - Message broker is not active. Ignoring message id=7ac7d601-e1a9-587b-5dbc-a78dd0ac73dd\n```\n\nI made changes so that:\n\n(a) any STOMP ERROR frame received from the broker is logged at **error** level\n(b) any client CONNECT frame ignored when the broker is inactive is logged at **error** level\n(c) any other client message ignored when the broker is inactive is logged at **debug** level\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI'm marking this resolved. The messages should now appear as expected.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `headerAccessor.setSessionId(this.sessionId)` line.  The original code had this line both before and after an `else if` block.  The updated code now only sets the session ID *if* the command is not ERROR.  If the command is ERROR, it logs the error message instead.  This is a simplification that avoids unnecessary execution",
            "avg_logprobs": -0.2843902349472046
        }
    },
    {
        "commit_hash": "d554229981381979d63c3228ae0195a376fa3b18",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/TransportHandlingSockJsService.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfinal List<String> removedSessionIds = new ArrayList<String>();\n+\t\t\t\t\tList<String> removedIds = new ArrayList<String>();\n+\t\t\t\t\t\t\t\tremovedIds.add(session.getId());\n-\t\t\t\t\tif (logger.isDebugEnabled() && !removedSessionIds.isEmpty()) {\n-\t\t\t\t\t\tlogger.debug(\"Closed \" + removedSessionIds.size() + \" sessions \" + removedSessionIds);\n-\t\t\t\t\t\tremovedSessionIds.clear();\n+\t\t\t\t\tif (logger.isDebugEnabled() && !removedIds.isEmpty()) {\n+\t\t\t\t\t\tlogger.debug(\"Closed \" + removedIds.size() + \" sessions: \" + removedIds);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix incomplete log message",
        "commit_body": "Commit 48236b from 2014 introduced a logging improvement to avoid\nlogging each removed session per line and instead log one line at\nthe end with all removed sessions ids. However that list of removed\nsession ids wasn't populated. This commit fixes that.\n\nIssue: SPR-14111\n",
        "linked_issues": [
            {
                "issue_id": "18683",
                "issue_title": "TransportHandlingSockJsService.scheduleSessionTask() doesn't log removed sessions [SPR-14111]",
                "issue_body": "**[Andrey Borisov](https://jira.spring.io/secure/ViewProfile.jspa?name=aandreyborisov)** opened **[SPR-14111](https://jira.spring.io/browse/SPR-14111?redirect=false)** and commented\n\n```java\ntry {\n  if (session.getTimeSinceLastActive() > getDisconnectDelay()) {\n  sessions.remove(session.getId());\n  session.close();\n}\n}\n```\n\ncode is not adding expired session to LIST 'removedSessionIds', hence logging is not working as expected\n\n\n---\n\n**Affects:** 4.2.5\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/d554229981381979d63c3228ae0195a376fa3b18, https://github.com/spring-projects/spring-framework/commit/01d50e9bde8a1da5e8e869d1287cef6a97907a38\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should be fixed now thanks.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the handling of closed session IDs.  Instead of using a `removedSessionIds` list, it now uses a `removedIds` list.  This change also updates the logging to reflect the new variable name and adds a more descriptive message.  The original `removedSessionIds.clear()` statement is removed, as the list is now used directly in the logging statement",
            "avg_logprobs": -0.329786376953125
        }
    },
    {
        "commit_hash": "d5ff2322463c021bb252d9b1889f6f67cfed56b5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/support/JmsAccessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\treturn obtainConnectionFactory().createConnection();\n+\t\tConnectionFactory cf = obtainConnectionFactory();\n+\t\tConnection con = cf.createConnection();\n+\t\tif (con == null) {\n+\t\t\tthrow new jakarta.jms.IllegalStateException(\n+\t\t\t\t\t\"ConnectionFactory returned null from createConnection(): \" + cf);\n+\t\t}\n+\t\treturn con;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensive check for null returned from createConnection()",
        "commit_body": "Closes gh-29706\n",
        "linked_issues": [
            {
                "issue_id": "29706",
                "issue_title": "JmsTemplate.convertAndSend throws NullPointerException during shutdown",
                "issue_body": "On a web application using Spring 5.2.x the following is showing up in the log files:\r\n\r\n```\r\n java.lang.NullPointerException\r\n    at org.springframework.jms.support.JmsAccessor.createSession(JmsAccessor.java:208) ~[spring-jms-5.2.20.RELEASE.jar:5.2.20.RELEASE]\r\n    at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:495) ~[spring-jms-5.2.20.RELEASE.jar:5.2.20.RELEASE]\r\n    at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:576) ~[spring-jms-5.2.20.RELEASE.jar:5.2.20.RELEASE]\r\n    at org.springframework.jms.core.JmsTemplate.convertAndSend(JmsTemplate.java:680) ~[spring-jms-5.2.20.RELEASE.jar:5.2.20.RELEASE]\r\n    at org.springframework.jms.core.JmsTemplate.convertAndSend(JmsTemplate.java:668) ~[spring-jms-5.2.20.RELEASE.jar:5.2.20.RELEASE]\r\n```\r\n\r\nThe code that explains what is going on at a high level is [JmsTemplate::execute](https://github.com/spring-projects/spring-framework/blob/e163078a56648991789c264c43dcb89f798f46ba/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java#L495).  That code shows that the connection created by the assigned connection factory returned a null connection instead of throwing JMSException. The API contract for JmsTemplate::execute states \"throws JmsException if there is any problem\" but that is not true if the connection factory returned null instead of throwing `JMSException`.\r\n\r\nWhile the root cause is the broken `ConnectionFactory` implementation, I think this code could be improved a bit by:\r\n\r\n1. Patch [JmsAccessor::createConnection](https://github.com/spring-projects/spring-framework/blob/e163078a56648991789c264c43dcb89f798f46ba/spring-jms/src/main/java/org/springframework/jms/support/JmsAccessor.java#L195) to throw JMSException if a connection factory returns a null connection.  The error message should contain the class name of the factory that is not complying with the API spec.\r\n2. Patch [JmsAccessor::createSession](https://github.com/spring-projects/spring-framework/blob/e163078a56648991789c264c43dcb89f798f46ba/spring-jms/src/main/java/org/springframework/jms/support/JmsAccessor.java#L207) throw JMSException if the connection parameter is null.\r\n3. A more conservative alternative to number 1 would be to patch [JmsTemplate.execute](https://github.com/spring-projects/spring-framework/blob/main/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java#L494) to simply check the `conToClose` prior to creating a session.\r\n\r\nThis issue is a low priority as these errors only occur during a shutdown of the application so impact of this issue is trivial.  It just produces a confusing message in the logs.",
                "issue_state": "closed",
                "issue_comment": [
                    "We have such defensive null-checking code for `DataSource.getConnection` access in `spring-jdbc`, so it should be feasible to do the same in `spring-jms`.",
                    "Coming to 6.0.4 first, to be backported to 5.3.25 in a second step.",
                    "FYI, here is an example offender that is now correctly handled by this patch:\r\n\r\nhttps://github.com/apache/activemq/blob/30114aa86df726a37f9cf972e07646b11732e3c9/activemq-jms-pool/src/main/java/org/apache/activemq/jms/pool/PooledConnectionFactory.java#L217"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a null check after obtaining a connection from the `ConnectionFactory`.  Previously, a connection was directly returned from `obtainConnectionFactory().createConnection()`.  The updated code now explicitly retrieves the `ConnectionFactory`, creates a `Connection`, and validates that the returned `Connection` is not null.  If it is null, an `IllegalStateException` is thrown, providing context with the `ConnectionFactory` that failed",
            "avg_logprobs": -0.16590627670288086
        }
    },
    {
        "commit_hash": "d62522982f39f2610f0d9d26d9908ccb1ea24222",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/ui/ModelMap.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfor (String key : attributes.keySet()) {\n+\t\t\tfor (Map.Entry<String, ?> entry : attributes.entrySet()) {\n+\t\t\t\tString key = entry.getKey();\n-\t\t\t\t\tput(key, attributes.get(key));\n+\t\t\t\t\tput(key, entry.getValue());",
        "change_count": 5,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Performance improvement",
        "commit_body": "Use entrySet instead of keySet followed by a lookup per key as the\nformer is more efficient.\n\nIssue: SPR-12363\n",
        "linked_issues": [
            {
                "issue_id": "16968",
                "issue_title": "org.springframework.ui.ModelMap.mergeAttributes(Map) makes inefficient use of keySet iterator [SPR-12363]",
                "issue_body": "**[Sang Gi Ryu](https://jira.spring.io/secure/ViewProfile.jspa?name=jaydon-ryu)** opened **[SPR-12363](https://jira.spring.io/browse/SPR-12363?redirect=false)** and commented\n\norg.springframework.ui.ModelMap.mergeAttributes(Map) makes inefficient use of keySet iterator instead of entrySet iterator.\n\n---\n\n**Affects:** 4.1.1\n\n**Issue Links:**\n- #16961 BeanFactoryAnnotationUtils,qualifiedBeanOfType, Inefficient use of keySet iterator.\n- #17037 MessageHeaderAccessor copyHeaders... tuning\n\n**Referenced from:** pull request https://github.com/spring-projects/spring-framework/pull/672, and commits https://github.com/spring-projects/spring-framework/commit/d62522982f39f2610f0d9d26d9908ccb1ea24222, https://github.com/spring-projects/spring-framework/commit/73e398a1654f570edc7d5e146d5d9fd4adc1592e\n\n2 votes, 2 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nMerged, thanks.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ModelMap.java` modifies the way it iterates through and copies attributes.  It replaces a simple `for` loop iterating over keys with an enhanced `for` loop using `entrySet()`.  This change now uses `entry.getValue()` to retrieve the attribute value, improving efficiency and readability by avoiding redundant calls to `attributes.get(key)`.  Essentially, it's a more concise and potentially faster way to access and copy attribute values",
            "avg_logprobs": -0.22922922384859334
        }
    },
    {
        "commit_hash": "d6a105c15164083f87cce477379ecd6645a5e7b2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/ParamsRequestCondition.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (isEmpty() && other.isEmpty()) {\n+\t\tif (other.isEmpty()) {\n-\t\telse if (other.isEmpty()) {\n-\t\t\treturn this;\n-\t\t}\n-\t\telse if (isEmpty()) {\n+\t\tif (isEmpty()) {",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish Conditional Statements",
        "commit_body": "See gh-31320\n",
        "linked_issues": [
            {
                "issue_id": "31320",
                "issue_title": "Polish Conditional Statements",
                "issue_body": "I found that redundant validations were affecting readability. \r\nTherefore, I refactored the code by removing the redundant validations and improved readability.",
                "issue_state": "closed",
                "issue_comment": [
                    "@chaewon121 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=31320)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=31320) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@chaewon121 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=31320)!",
                    "Thank you for making your first contribution to Spring Framework. FTR, I've aligned the reactive and mvc versions and added missing tests, see [7a05d23](https://github.com/spring-projects/spring-framework/commit/7a05d23597e765762148aa32ecbec89c7497810e)"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes redundant checks.  The original code had a check for `isEmpty()` on both `this` and `other` objects.  The updated code simplifies this by only checking if `other` is empty.  This is equivalent because if `other` is empty, the first `if` condition will be true, and the original `else if` conditions are no longer needed.  The change removes unnecessary branches and improves efficiency",
            "avg_logprobs": -0.36730100843641494
        }
    },
    {
        "commit_hash": "d6e167d16eb9dd18349922f12b2898b5f920ac13",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\telse if (logger.isInfoEnabled() && beanFactory.containsSingleton(beanName)) {\n-\t\t\t\t\tlogger.info(\"Cannot enhance @Configuration bean definition '\" + beanName +\n+\t\t\t\telse if (logger.isWarnEnabled() && beanFactory.containsSingleton(beanName)) {\n+\t\t\t\t\tlogger.warn(\"Cannot enhance @Configuration bean definition '\" + beanName +\n-\t\t\t\t\t\t\t\"return type: Consider declaring such methods as 'static'.\");\n+\t\t\t\t\t\t\t\"return type: Consider declaring such methods as 'static' and/or mark the \" +\n+\t\t\t\t\t\t\t\"containing configuration class as 'proxyBeanMethods=false'.\");",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Raise log level to warn when enhancement cannot apply",
        "commit_body": "Closes gh-31102\n",
        "linked_issues": [
            {
                "issue_id": "31102",
                "issue_title": "Raise log level to warn when configuration class enhancement cannot apply due to circular reference",
                "issue_body": "Our existing log message for a circular reference to the configuration class is not ideally worded since it suggests that the configuration class cannot be enhanced whereas it actually can be enhanced but effectively won't use the enhanced class. Also, it suggests declaring the affected `@Bean` method as `static` but could also mention that the configuration class should be declared as `proxyBeanMethods=false` if enhancement is not needed anyway.\r\n\r\nMost importantly, that log message can easily be missed at info level, so we should raise it to warn level.\r\n\r\nRelated PRs: #22992, #24356. ",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional log message within `ConfigurationClassPostProcessor`.  Specifically, it changes the log level from INFO to WARN when a singleton bean with a non-static method in a `@Configuration` class is encountered.  The message itself is also updated to include a suggestion to make the methods static and/or disable proxying of bean methods. This indicates a shift in the severity of the warning, potentially to better guide developers towards best practices",
            "avg_logprobs": -0.360711907827726
        }
    },
    {
        "commit_hash": "d781f299c0a38ed9a29001920e811165e2054773",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/event/TransactionalApplicationListenerMethodAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate final TransactionalEventListener annotation;\n-\n+\tprivate final boolean fallbackExecution;\n+\n-\t\tthis.annotation = eventAnn;\n+\t\tthis.fallbackExecution = eventAnn.fallbackExecution();\n-\t\telse if (this.annotation.fallbackExecution()) {\n-\t\t\tif (this.annotation.phase() == TransactionPhase.AFTER_ROLLBACK && logger.isWarnEnabled()) {\n+\t\telse if (this.fallbackExecution) {\n+\t\t\tif (getTransactionPhase() == TransactionPhase.AFTER_ROLLBACK && logger.isWarnEnabled()) {",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use extracted attributes instead of annotation access",
        "commit_body": "See gh-31034\n",
        "linked_issues": [
            {
                "issue_id": "31034",
                "issue_title": "`TransactionalApplicationListenerMethodAdapter` should find `@TransactionalEventListener` on target class method",
                "issue_body": "Assume an arrangement like this:\r\n```java\r\ninterface MyInterface {\r\n  void foo();\r\n}\r\n\r\nclass MyClass implements MyInterface {\r\n  @TransactionalEventListener\r\n  void foo() { \u2026 }\r\n}\r\n```\r\n\r\nIn this case, `TransactionalApplicationListenerMethodAdapter` is invoked with `MyClass` as target class, but `MyInterface.foo()` as method. The annotation lookup then fails, as only the interface method is inspected, not the one on the target class.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change removes the `annotation` field and replaces it with a `fallbackExecution` boolean flag.  The `fallbackExecution` flag is now directly initialized from the `eventAnn.fallbackExecution()` method call.  This change simplifies the logic, removing the need to check the `annotation` object for the `fallbackExecution` property.  Critically, the code now uses `this.fallbackExecution` instead of `this.annotation",
            "avg_logprobs": -0.27646961212158205
        }
    },
    {
        "commit_hash": "d85c1fbdd5edb6b2ba906f8a20009317ff7faa98",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/resource/ResourceUrlProvider.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfor (String pattern : hm.getUrlMap().keySet()) {\n-\t\t\t\tObject handler = hm.getUrlMap().get(pattern);\n+\t\t\tfor (String pattern : hm.getHandlerMap().keySet()) {\n+\t\t\t\tObject handler = hm.getHandlerMap().get(pattern);",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Fix initialization issue in ResourceUrlProvider",
        "commit_body": "Before this change ResourceUrlProvider used getUrlMap to detect\nResourceHttpRequestHandler instances, however the map may contain bean\nnames as is the case when using <mvc:resources>. Instead it now uses\ngetHandlerMap.\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the iteration over the `hm` object.  Instead of iterating over the `getUrlMap`, it now iterates over the `getHandlerMap`.  This suggests a change in the data structure being accessed, likely from a `getUrlMap` to a `getHandlerMap`, and a corresponding change in how handlers are retrieved",
            "avg_logprobs": -0.22941671477423775
        }
    },
    {
        "commit_hash": "d87465f9e9a802b6ad97fcc9a19d6d4e24c58082",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/EvalTag.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+import jakarta.el.ELContext;\n+ * @author Sam Brannen\n-\t\tprivate final jakarta.servlet.jsp.el.VariableResolver variableResolver;\n+\t\tprivate final ELContext elContext;\n+\n-\t\t\tthis.variableResolver = pageContext.getVariableResolver();\n+\t\t\tthis.elContext = pageContext.getELContext();\n-\t\t\tif (this.variableResolver == null) {\n+\t\t\tif (this.elContext == null) {\n-\t\t\t\treturn this.variableResolver.resolveVariable(name);\n+\t\t\t\treturn this.elContext.getELResolver().getValue(this.elContext, name, null);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Use ELContext instead of VariableResolver in JspPropertyAccessor",
        "commit_body": "The JSP VariableResolver API has been deprecated since JSP 2.1 in favor\nof the newer ELContext API.\n\nThis commit therefore refactors JspPropertyAccessor to use the\nELContext API.\n\nCloses gh-32383\n",
        "linked_issues": [
            {
                "issue_id": "32383",
                "issue_title": "Use `ELContext` instead of deprecated `VariableResolver` API in `JspPropertyAccessor`",
                "issue_body": "The JSP `VariableResolver` API has been deprecated since JSP 2.1 in favor of the newer `ELContext` API.\r\n\r\nWe should therefore use `ELContext` instead of the deprecated `VariableResolver` API in `JspPropertyAccessor`.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `EvalTag.java` replaces the use of `jakarta.servlet.jsp.el.VariableResolver` with `jakarta.el.ELContext`.  This change updates the way variable resolution is handled, specifically within the `EvalTag`'s constructor.  The crucial change is the replacement of `variableResolver` with `elContext` and the corresponding update to the `resolveVariable` method call.  The new code now uses `elContext",
            "avg_logprobs": -0.24174842834472657
        }
    },
    {
        "commit_hash": "d8f4d37624fc38a8c28d8e427f205b395e290f15",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/buffer/DataBufferUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif ((read = channel.read(byteBuffer)) > 0) {\n+\t\t\t\tif ((read = channel.read(byteBuffer)) >= 0) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fixed bug in reading Flux from Channel",
        "commit_body": "Fixed bug where the returned Flux from DataBufferUtils.read() would be\ncompleted prematurely if the channel was not ready to read, but did\nnot reach the end of the file either.\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement.  Previously, the code checked if `read` (the result of a channel read operation) was greater than 0.  The change now checks if `read` is greater than or equal to 0.  This likely handles the case where `channel.read()` returns -1, indicating the end of the stream, more gracefully.  The original condition would have skipped processing the end-of-stream case",
            "avg_logprobs": -0.18509606392152847
        }
    },
    {
        "commit_hash": "d91fc8c672614c6394f3ebc2e86c05c5f32607f8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/ProxyFactoryBean.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (this.targetName == null && logger.isInfoEnabled()) {\n+\t\t\tif (this.targetName == null) {\n-\t\t\t\t\t\"; Can only include Advisor or Advice type beans in interceptorNames chain except for last entry, \" +\n-\t\t\t\t\t\"which may also be target or TargetSource\", ex);\n+\t\t\t\t\t\"; can only include Advisor or Advice type beans in interceptorNames chain \" +\n+\t\t\t\t\t\"except for last entry which may also be target instance or TargetSource\", ex);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "No log level check unless String concatenation is following",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a logging statement from a conditional check in `ProxyFactoryBean`.  Previously, if `targetName` was null and logging was enabled, an informational message was logged along with the exception.  Now, the logging statement is removed, and the message is only printed if the exception occurs.  This change likely improves performance by avoiding the overhead of logging in the common case where `targetName` is not null",
            "avg_logprobs": -0.24282579643781796
        }
    },
    {
        "commit_hash": "d97eabba2fcb4c69d25befdcd4869ac87ebf9167",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t// do not cache multipart mime types with random boundaries\n+\t\tif (mimeType.startsWith(\"multipart\")) {\n+\t\t\treturn parseMimeTypeInternal(mimeType);\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Do not cache multipart MIME types in cache",
        "commit_body": "Prior to this commmit, \"mutipart/*\" MIME types would be cached by the\n`MimeTypeUtils` LRU cache. Since those MIME types are likely to have\nrandom boundaries in them, they can waste space in the LRU cache.\nThis is not improving things since we're parsing them anyway.\n\nThis commit skips the caching step for all \"multipart\" MIME types.\n\nFixes gh-24767\n",
        "linked_issues": [
            {
                "issue_id": "24767",
                "issue_title": "Do not cache multipart mime types in MimeTypeUtils LRU cache",
                "issue_body": "I'm sorry, I mentioned it once, but the lasted version still doesn't solve the problem. \r\n\r\nI mentioned a  [Pull-Request](https://github.com/spring-projects/spring-framework/pull/24768), hoping for a little use\r\n\r\nDespite this, it doesn't solve all the problems. In many case, we write code like this: \r\n`request.getHeaders().getContentType()`\r\n\r\nIn project Spring-Cloud-Gateway. People can attack us like this: \r\n `curl -X GET -H \"Content-Type: [random characters]\" \"http://127.0.0.1:8080/get\"`\r\nIn project Spring-MVC. People can attack us like this: \r\n'curl -X GET -H \"Accept: [random characters]\" \"http://127.0.0.1:8080/get\"'\r\n\r\n Also can fill the LRU cache, resulting in degraded performance.    Maybe giving an api to turn off the LRU cache can solve this problem, or some better way \r\n\r\nIn project Spring-Cloud-Gateway, when the cache is full, performance drops to 10% in half an hour\r\n\r\nWhen MidiaType is Multipart-formdata,  mimeType characters has random characters, causing the LRU cache to be full, then over-occupy the cpu\r\n\r\nAt that time the LRU cache like this: \r\n\r\napplication/stream+x-jackson-smile, application/vnd.spring-boot.actuator.v3+json, application/vnd.spring-boot.actuator.v2+json, application/json, multipart/form-data; boundary=----WebKitFormBoundaryVHfecvFDYeDEjhu4, multipart/form-data; boundary=----WebKitFormBoundarymKzwdDkWNDNzQFP0, multipart/form-data; boundary=----WebKitFormBoundaryiWpMXOUbWwBwq2AX, application/x-www-form-urlencoded, text/html;charset=UTF-8, application/octet-stream, application/vnd.ms-excel;charset=utf8, application/msword, multipart/form-data; boundary=----WebKitFormBoundaryGF2AJ2ZdPqbWOyEO, multipart/form-data; boundary=----WebKitFormBoundaryTZLPpyBs2F0ycmkB, multipart/form-data; boundary=----WebKitFormBoundaryBUClXdZPA3oxpUpx, image/jpeg;charset=UTF-8, multipart/form-data; boundary=----WebKitFormBoundarysODcdeMwzfHwEjtw, multipart/form-data; boundary=----WebKitFormBoundary26i2en6YQUSXUBzs, multipart/form-data; boundary=----WebKitFormBoundaryxUUWAyZnZjwlM1oy, multipart/form-data; boundary=----WebKitFormBoundarysVMYk11tVTTsXuEB, multipart/form-data; boundary=----WebKitFormBoundaryXsI4dpNsVTCWWrRo, multipart/form-data; boundary=----WebKitFormBoundaryiV1owCGwTHyQzja0, multipart/form-data; boundary=----WebKitFormBoundarygf1XpLmgasAQU9fi, multipart/form-data; boundary=----WebKitFormBoundaryBNaQtUvpQ2VV7YYA, multipart/form-data; boundary=----WebKitFormBoundaryW1rdrg4AbJ5Jn3Po, multipart/form-data; boundary=----WebKitFormBoundaryoBwFj2ABM5LflDmW, multipart/form-data; boundary=----WebKitFormBoundary40xI2TxryjbkSCtO, multipart/form-data; boundary=----WebKitFormBoundarytaCC9B6g8u4urnLF, multipart/form-data; boundary=----WebKitFormBoundaryOrhplGKYP9ozLkCs, multipart/form-data; boundary=----WebKitFormBoundaryvEUouFAr3R3YJYBh, multipart/form-data; boundary=----WebKitFormBoundaryuQ9tEKtn59w5hPLY, multipart/form-data; boundary=----WebKitFormBoundaryRGvPXUBAuZ6xJ95u, application/vnd.openxmlformats-officedocument.wordprocessingml.document, multipart/form-data; boundary=----WebKitFormBoundary7jpljZi4k61KhCNN, multipart/form-data; boundary=----WebKitFormBoundary7GVKDTHVuBABvjGB, multipart/form-data; boundary=----WebKitFormBoundaryZbNBPl3T4VZ44q6B, audio/mp3, multipart/form-data; boundary=----WebKitFormBoundaryI6rUM76YvxrIEcqv, multipart/form-data; boundary=----WebKitFormBoundaryag4BDWrzifHRdDiR, multipart/form-data; boundary=----WebKitFormBoundary1YRsWAdVqDin8g8p, multipart/form-data; boundary=----WebKitFormBoundaryDaatlrV3KAyZu7wA, multipart/form-data; boundary=----WebKitFormBoundaryyhvikZJdRGH1AjQq, multipart/form-data; boundary=----WebKitFormBoundary2z4SJhqeEx5XtVj4, multipart/form-data; boundary=----WebKitFormBoundaryeDLd1MTvuhmcmzNe, multipart/form-data; boundary=----WebKitFormBoundarybKizrvRESfhxHAMQ, multipart/form-data; boundary=----WebKitFormBoundary24U8tmsOluZqcRXX, multipart/form-data; boundary=----WebKitFormBoundarye4j6KdQyBjY4FqSk, multipart/form-data; boundary=----WebKitFormBoundaryjPmgLdzMcMYYB3yS, multipart/form-data; boundary=----WebKitFormBoundaryxzBZ9w6Je3IJ53NM, multipart/form-data; boundary=----WebKitFormBoundaryScy0j73cvx3iCFyY, multipart/form-data; boundary=----WebKitFormBoundaryTBoS8s4YWwmBGTDA, image/*, multipart/form-data; boundary=----WebKitFormBoundaryRUutFo3RXlNPgoBS, text/html;charset=utf-8, multipart/form-data; boundary=----WebKitFormBoundarykLObBi1tJMf158kt, multipart/form-data; boundary=----WebKitFormBoundary8M8MfCWBEFcsxnBU",
                "issue_state": "closed",
                "issue_comment": [
                    "How do we prevent attacks. When the cache is full, the element is always refreshed and will not be emptied.  Is it possible to give a way to turn off the LRU cache ?",
                    "I don't think we can call those attacks, as they're making the CPU load slightly worse and that the parsing algorithm is taking more CPU time than the cache overhead. With that reasoning, disabling the cache completely would be \"an attack vector\" because we would pay the parsing cost even for types that should be cached.\r\n\r\nI've pushed a change that skips the cache for all \"multipart\" based types, since they can all contain random boundaries.",
                    "OK, I agree. I should focus on how to make the cache more efficient",
                    "This fix should be enough for this particular use case. We'll try to improve even more with #24769 but given the possible implications, I've scheduled that for the 5.3.x release.",
                    "Thanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a conditional check to the `MimeTypeUtils` class.  If the input `mimeType` string starts with \"multipart\", it now directly calls `parseMimeTypeInternal` instead of the potentially more complex/expensive default parsing logic.  This optimization likely targets performance improvements for multipart MIME types",
            "avg_logprobs": -0.2180301947671859
        }
    },
    {
        "commit_hash": "d9cae339d60cc7f21b6f067fa4d66c5104cdc15c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tAdvisor advisor = this.advisors.get(index);\n+\t\tAdvisor advisor = this.advisors.remove(index);\n-\t\t\tfor (int j = 0; j < ia.getInterfaces().length; j++) {\n-\t\t\t\tremoveInterface(ia.getInterfaces()[j]);\n+\t\t\tClass<?>[] interfaces = ia.getInterfaces();\n+\t\t\tfor (Class<?> iface : interfaces) {\n+\t\t\t\tremoveInterface(iface);\n-\t\tthis.advisors.remove(index);",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Simplify AdvisedSupport.removeAdvisor()",
        "commit_body": "Closes gh-24205",
        "linked_issues": [
            {
                "issue_id": "24205",
                "issue_title": "Simplify AdvisedSupport.removeAdvisor()",
                "issue_body": "1) it's not necessary to call `IntroductionAdvisor.getInterfaces()` twice for each iteration\r\n2) instead of calling `ArrayList.get()` and then `ArrayList.remove()` we can once call `ArrayList.remove()` to get and remove item by its index",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how advisors are handled within the `AdvisedSupport` class.  Specifically, it now removes the advisor at the given index (`index`) from the `advisors` list *before* iterating through the advisor's interfaces and removing them.  Previously, the advisor was retrieved but not removed, and the removal of the interfaces was done in a loop",
            "avg_logprobs": -0.3223470306396484
        }
    },
    {
        "commit_hash": "daf9a82e8ce3e6e8e795fcb46309cd8bc4a62e52",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate boolean isVariableName(String name) {\n-\t\tchar[] chars = name.toCharArray();\n-\t\tif (!Character.isJavaIdentifierStart(chars[0])) {\n+\tprivate static boolean isVariableName(String name) {\n+\t\tif (!Character.isJavaIdentifierStart(name.charAt(0))) {\n-\t\tfor (int i = 1; i < chars.length; i++) {\n-\t\t\tif (!Character.isJavaIdentifierPart(chars[i])) {\n+\t\tfor (char ch: name.toCharArray()) {\n+\t\t\tif (!Character.isJavaIdentifierPart(ch)) {",
        "change_count": 9,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Simplify AbstractAspectJAdvice.isVariableName()",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change in `AbstractAspectJAdvice.java` modifies the `isVariableName` method.  The most significant change is the addition of the `static` keyword.  This makes the method a static method, meaning it's associated with the class itself rather than instances of the class.  Concurrently, the code now uses `name.charAt(0)` instead of creating a character array and accessing the first character",
            "avg_logprobs": -0.24885232925415038
        }
    },
    {
        "commit_hash": "db1010f9c9f0ff665c6657e9ae8205421cc6eb71",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/converter/support/AllEncompassingFormHttpMessageConverter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter;\n- * adding support for XML and JSON-based parts.\n+ * adding support for XML, JSON, Smile, CBOR, Protobuf and Yaml based parts when\n+ * related libraries are present in the classpath.\n+\tprivate static final boolean jackson2CborPresent;\n+\n+\t\tjackson2CborPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.cbor.CBORFactory\", classLoader);\n+\t\tif (jackson2CborPresent) {\n+\t\t\taddPartConverter(new MappingJackson2CborHttpMessageConverter());\n+\t\t}\n+",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add CBOR support to AllEncompassingFormHttpMessageConverter",
        "commit_body": "Closes gh-32428\n",
        "linked_issues": [
            {
                "issue_id": "32428",
                "issue_title": "Add CBOR support to `AllEncompassingFormHttpMessageConverter`",
                "issue_body": "It was likely a leftover, `MappingJackson2CborHttpMessageConverter` configuration is present in the classpath and should be likely added for consistency. ",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds support for CBOR (using Jackson 2) to the `AllEncompassingFormHttpMessageConverter`.  Previously, only XML and JSON were supported.  The change now dynamically detects the presence of the necessary Jackson 2 CBOR library on the classpath and adds a CBOR converter if found.  This expands the supported formats to include CBOR, in addition to XML, JSON, Smile, Protobuf, and YAML, if their respective libraries are present",
            "avg_logprobs": -0.17965472474390146
        }
    },
    {
        "commit_hash": "db2601d6e25a427368500ffcb8d274319222ec92",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\tlogger.debug(\"Ignoring bean creation exception on FactoryBean type check: \" + ex);\n+\t\t\tif (logger.isWarnEnabled()) {\n+\t\t\t\tlogger.warn(\"Bean creation exception on FactoryBean type check: \" + ex);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AbstractBeanFactory logs bean creation exception on FactoryBean type check at warn level",
        "commit_body": "Issue: SPR-12397\n",
        "linked_issues": [
            {
                "issue_id": "17005",
                "issue_title": "Mybatis config error leads to endless loop, and no std error output [SPR-12397]",
                "issue_body": "**[veggie](https://jira.spring.io/secure/ViewProfile.jspa?name=veggie)** opened **[SPR-12397](https://jira.spring.io/browse/SPR-12397?redirect=false)** and commented\n\nI have found an issue which kept spring looping during its initialization wihout any error messge printed on console.\n\nThe version of mybatis-spring I used is 1.2.2 along with spring 4.1.0.RELEASE.\n\nI guess all typo errors in mybatis mapper xml files including mybatis-config.xml may cause this problem.\n\nThe error logs can be displayed only by setting log level to debug in AbstractBeanFactory class, but this is really an undesirable action because the log would be deluged with unwanted debuging logs from startup phase or web requests.\n\nI wonder if there is a better way to solve this problem, or it's just designed this way.\n\nIn the attachment, the breakpoint will be repeatedly hitted as long as the loop exists, but all the exceptions were suppressed.\n\nMy team members and me have encountered this issue many times. Considering this is the time consuming mistake that anyone could easily make, I really want to know how to fix it. many thx\n\n---\n\n**Affects:** 4.1 GA\n\n**Attachments:**\n- [AbstraceBeanFactory.png](https://jira.spring.io/secure/attachment/22351/AbstraceBeanFactory.png) (_46.12 kB_)\n\n**Issue Links:**\n- #18406 Lot of undesired WARN logs after migration from Spring 3 to Spring 4\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/db2601d6e25a427368500ffcb8d274319222ec92\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, I'm raising the log level to \"warn\" there.\n\nThat said, please note that this only happens for `FactoryBean` implementations that do not return a non-null type from their `getObjectType()` implementation, which is rare. In the case of the Mybatis `MapperFactoryBean`, the object type is getting determined through a customizable property which simply won't be set for early type checks. If the implementation would fall back to some base type, anything non-null, from `getObjectType()` when called early, you wouldn't run into this situation to begin with.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a logging statement within a conditional block.  The original code logged a debug message if the condition was met.  The change now logs a warning message instead.  This suggests a shift in the desired logging level for this specific exception",
            "avg_logprobs": -0.22701156840604894
        }
    },
    {
        "commit_hash": "db596d23dea7a8f35b52581d92b00a18c3f45335",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/context/request/async/DeferredResult.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (this.resultHandler != null) {\n-\t\t\t\tthis.resultHandler.handleResult(this.result);\n-\t\t\t}\n+\t\t}\n+\t\tif (this.resultHandler != null) {\n+\t\t\tthis.resultHandler.handleResult(this.result);",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix deadlock issue in DeferredResult",
        "commit_body": "Previously DeferredResult locked around the setting of the result\nincluding handling up to the part of submitting a dispatch. This\ncan cause a deadlock if a timeout occurs at the same time since\nthe Tomcat timeout thread has its own locking that permits only\none thread to do timeout or dispatch processing.\n\nThe fix reduces the locking to cover only the attempt to set the\nDeferredResult but not the dispatching.\n\nIssue: SPR-10485\n",
        "linked_issues": [
            {
                "issue_id": "15118",
                "issue_title": "Deadlocks with DeferredResult timeout handling on Tomcat [SPR-10485]",
                "issue_body": "**[Peter De Wachter](https://jira.spring.io/secure/ViewProfile.jspa?name=pdewacht)** opened **[SPR-10485](https://jira.spring.io/browse/SPR-10485?redirect=false)** and commented\n\nI'm experiencing deadlocks and other bugs when calling DeferredResult#setResult while that deferred result's timeout handler is running. This is on Tomcat 7.0.39. I'm using the following code to reproduce this.\n\n```\n@Controller\npublic class TestController {\n    private DeferredResult<String> deferred;\n\n    static class DoSomethingUseful implements Runnable {\n        public void run() {\n            try { Thread.sleep(2000); } catch (InterruptedException e) { }\n        }\n    }\n\n    @RequestMapping(value=\"/test/start\")\n    @ResponseBody\n    public DeferredResult<String> start() {\n        deferred = new DeferredResult<String>(4000L, \"timeout\\n\");\n        deferred.onTimeout(new DoSomethingUseful());\n        return deferred;\n    }\n\n    @RequestMapping(value=\"/test/stop\")\n    @ResponseBody\n    public String stop() {\n        deferred.setResult(\"result\\n\");\n        return \"ok\\n\";\n    }\n}\n```\n\nThe start method creates a DeferredResult with a 4 second timeout. To make the bug easy to reproduce, it has an onTimeout handler which will sleep for 2 seconds. The stop method will set a value for the DeferredResult. The code seems correct to me: the DeferredResult documentaion states that \"the application can produce the result from a thread of its choice\", and also that setResult can be called on an DeferredResult that's already expired.\n\nTo reproduce the bug, try something like this:\n\n```\ncurl http://localhost/test/start & sleep 5; curl http://localhost/test/stop\n```\n\nOn Tomcat using the APR connector, this will deadlock. On Tomcat using the NIO connector, this will sometimes (not consistently) never answer the start request and return the \"timeout\\n\" string as a result of the stop request.\n\n---\n\n**Affects:** 3.2.2\n\n**Reference URL:** https://github.com/SpringSource/spring-framework-issues/pull/48\n\n**Issue Links:**\n- #19544 Concurrency problem in DeferredResult: potential double execution of handleResult\n- #18031 DeferredResult not thread-safe for isSetOrExpired call\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/db596d23dea7a8f35b52581d92b00a18c3f45335, https://github.com/spring-projects/spring-framework/commit/25701ef9843eb44429b740996e80fc3171c7ff7f\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Peter De Wachter](https://jira.spring.io/secure/ViewProfile.jspa?name=pdewacht)** commented\n\nAdded link to spring-framework-issues pull request.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should now be fixed. Thanks for the very helpful repro project!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change moves the `if (this.resultHandler != null)` block to a position *after* a potentially existing block of code (implied by the added `}`).  This means the `resultHandler.handleResult` call will only be executed if the `resultHandler` is not null *and* the previous code block completes successfully.  The original code unconditionally called `handleResult` if the `resultHandler` was not null",
            "avg_logprobs": -0.2834560203552246
        }
    },
    {
        "commit_hash": "dbbdd044cdd5439e4066b71af34324670a274514",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/CollectionUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tfor (Object elem : arr) {\n-\t\t\tcollection.add((E) elem);\n-\t\t}\n+\t\tCollections.addAll(collection, (E[])arr);",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Use Collections.addAll instead of Collection.addAll",
        "commit_body": "See gh-24636\n",
        "linked_issues": [
            {
                "issue_id": "24636",
                "issue_title": "Polish mergeArrayIntoCollection of CollectionUtils",
                "issue_body": "This can simplify the code",
                "issue_state": "closed",
                "issue_comment": [
                    "@NathanQingyangXu Thank you for your pointing.",
                    "@chenqimiao actually, the advice from javadoc is outdated, see https://github.com/openjdk/jdk/pull/1764"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a manual `for` loop iteration to add elements from an array to a collection with the `Collections.addAll` method.  This is a significant performance improvement, as `Collections.addAll` is optimized for bulk additions.  The original loop is replaced with a single, more efficient call",
            "avg_logprobs": -0.20760003347245473
        }
    },
    {
        "commit_hash": "dc59e50561eeaedbc6f7a50d8703d627be2c6847",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/MethodParameter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tparamType = ResolvableType.forMethodParameter(this, null, 1).resolve();\n+\t\tif (getContainingClass() != getDeclaringClass()) {\n+\t\t\tparamType = ResolvableType.forMethodParameter(this, null, 1).resolve();\n+\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid unnecessary use of ResolvableType within MethodParameter",
        "commit_body": "Closes gh-23792\n",
        "linked_issues": [
            {
                "issue_id": "23792",
                "issue_title": "Autowiring performance degradation due to 5.2's MethodParameter.getParameterType() implementation",
                "issue_body": "Our applications makes considerable use of programmatic autowiring of beans via org.springframework.beans.factory.config.AutowireCapableBeanFactory#autowire.\r\n\r\nTherefore we have a couple of performance tests, which directly and indirectly measure the throughput of the underlying Spring implementation.\r\nAll those tests degraded by about 20 to 25 percent, after only updating the Spring dependencies from version 5.1.9 to version 5.2.0.\r\n\r\nWe did a bit of work to pinpoint the changes in Spring, which resulted in this performance drop and thought it would be a good idea to report it here so you can verify, whether you like to accept this or have an idea how to achieve both, improved code robustness while maintaining performance.\r\n\r\nThe root of the actual performance degradation seems to originate from changes to org.springframework.core.MethodParameter#getParameterType to use org.springframework.core.ResolvableType (in our case itself used from org.springframework.beans.factory.support.ConstructorResolver#resolveAutowiredArgument).\r\n\r\nThe relevant issue motivating this change seems to be https://github.com/spring-projects/spring-framework/issues/23385\r\n\r\nI quickly verified that it is enough to use 5.1.9 as base and only change the above mentioned two core classes, to observe the performance drop. I have not yet checked the Spring project for own performance tests.",
                "issue_state": "closed",
                "issue_comment": [
                    "I submit a PR to improve the performance of the method MethodParameter.getParameterType. Hope it could help.",
                    "I have the same issue. my web application built with both struts2 and spring mvc, after upgrade to spring 5.2.0, throughput of struts2 decrease to about 80%, but throughput of spring mvc is increased. struts2 action is autowired by `AutowireCapableBeanFactory::createBean(clazz, AUTOWIRE_BY_NAME, false)` .\r\n\r\nBTW: @lgxbslgx's PR not helps much.",
                    "@e-hubert can you provide a simple project and try the PR https://github.com/spring-projects/spring-framework/pull/23811 ?",
                    "@quaff I was looking at the PR and verified that it improved performace quite considerable for our use, but was still waiting for @jhoeller or one of the Spring core dev team members to likely come up with a different take on this.\r\nI do not have a simple project at hand, but as the issue seems to be so isolated one might be better off with a parameterized microbenchmark (e.g. using JMH).",
                    "According to my local benchmarks, it seems sufficient to restore a `containingClass != null` check as we effectively had it in the 5.1.x code path. Refining it with a check for `containingClass != declaringClass` does not hurt but seems like an optimization beyond 5.1.x already, nevertheless worth it. I'll double-check the effect and will proceed with that change for inclusion in 5.2.1.",
                    "If timing permits, I'm of course also willing to give a snapshot build of spring-core 5.2.1 containing the fix (once available) a try and check out all our performance test suites which showed regressions after our update attempt to 5.2.0, although I'm convinced that J\u00fcrgen's local micro benchmark is absolutely sufficient here. Thanks for addressing this!",
                    "A variant of this is in master now for inclusion in the upcoming 5.2.1 build snapshot. Please do try it tomorrow if you can since it's your scenario that actually matters, not my local little benchmark ;-)",
                    "I confirm commit https://github.com/spring-projects/spring-framework/commit/dc59e50561eeaedbc6f7a50d8703d627be2c6847 works.",
                    "I can confirm the issue to be fixed as well. I tested with spring-core-5.2.1.BUILD-20191030.000554-48.jar containing this change. Thanks again!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how the `paramType` is determined in `MethodParameter`.  Previously, `paramType` was always calculated using `ResolvableType.forMethodParameter`.  The change now introduces a conditional check: if the `getContainingClass()` is different from the `getDeclaringClass()`, the `paramType` is calculated; otherwise, it's not.  This suggests a potential optimization to avoid unnecessary resolution in cases where the containing and declaring classes are the same.",
            "avg_logprobs": -0.11330337524414062
        }
    },
    {
        "commit_hash": "dcc8dcdff81dd76cfcb7df8c6f1d61b4a3d4f207",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/ServletServerHttpResponse.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tlong contentLength = getHeaders().getContentLength();\n+\t\t\tif (contentLength != -1) {\n+\t\t\t\tthis.servletResponse.setContentLengthLong(contentLength);\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Set content length on ServletHttpResponse",
        "commit_body": "Prior to this commit, the `ServletServerHttpResponse` would copy headers\nfrom the `HttpHeaders` map and calls methods related to headers exposed\nas properties (content-type, character encoding).\n\nUnlike its reactive variant, this would not set the content length.\nDepending on the Servlet container implementation, this could cause\nduplicate Content-Length response headers in the actual HTTP response.\n\nThis commit aligns both implementations and ensures that the\n`setContentLengthLong` method is called if necessary so that the Servlet\ncontainer can ensure a single header for that.\n\nFixes gh-26330\n",
        "linked_issues": [
            {
                "issue_id": "26330",
                "issue_title": "The response has a duplicate \"Content-Length\" header when get by range header",
                "issue_body": "When I use Undertow as server , and make a range request, the response will have two \"Content-Length\" header.\r\n\r\n## request\r\n\r\n> GET /inspection/api/v1/binary/1568 HTTP/1.1\r\n> Host: inspection.lubansoft.net:58888\r\n> Connection: keep-alive\r\n> Pragma: no-cache\r\n> Cache-Control: no-cache\r\n> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\r\n> Accept: */*\r\n> Accept-Encoding: identity\r\n> Accept-Language: zh-CN,zh;q=0.9\r\n> Range: bytes=0-65535\r\n\r\n## response\r\n\r\n> HTTP/1.1 206 Partial Content\r\n> Expires: 0\r\n> Cache-Control: no-cache, no-store, max-age=0, must-revalidate\r\n> X-XSS-Protection: 1; mode=block\r\n> Pragma: no-cache\r\n> Content-Disposition: form-data; name=\"attachment\"; filename*=UTF-8''%E8%AF%84%E5%AE%9A%E8%A1%A810.3.2%20%E6%98%8E%E6%B4%9E%E6%B5%87%E7%AD%91%E5%88%86%E9%A1%B9%E5%B7%A5%E7%A8%8B%E8%B4%A8%E9%87%8F%E6%A3%80%E9%AA%8C%E8%AF%84%E5%AE%9A%E8%A1%A8%28SG%29.pdf\r\n> Accept-Ranges: bytes\r\n> Date: Mon, 21 Dec 2020 13:02:45 GMT\r\n> Connection: keep-alive\r\n> Content-Language: zh-CN\r\n> X-Frame-Options: SAMEORIGIN\r\n> ETag: \"10\"\r\n> Vary: Origin\r\n> Vary: Access-Control-Request-Method\r\n> Vary: Access-Control-Request-Headers\r\n> Last-Modified: Mon, 21 Dec 2020 06:02:31 GMT\r\n> Content-Range: bytes 196608-212611/212612\r\n> X-Content-Type-Options: nosniff\r\n> Content-Length: 212612\r\n> Content-Length: 16004\r\n> Content-Type: application/pdf\r\n\r\n\r\nin response header, Content-Length has two values , and chrome will have net::ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH error\r\n\r\n\r\n\r\n`org.springframework.web.servlet.resource.ResourceHttpRequestHandler` actually writes the content-length twice. Once, with the entire content-length and then later on, if a partial-content response, with the range length.\r\n\r\nTomcat handles this just fine accepting the last content-length set as the authoritative content-length and writes it back to the client.\r\n\r\nUndertow seems to assume all headers are multi-value and writes both content-length headers back to the client.\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "https://github.com/paulcwarren/spring-content/issues/449",
                    "The http spec doesn\u2019t specify how to handle multiple content-length headers with different values.  This [SO post](https://stackoverflow.com/questions/37002982/multiple-content-length-headers-and-multiple-transfer-encoding-headers), commented on by spec author Julian Reschke, confirms that.  But perhaps that is because it is obviously an error?  \u2028\r\n\r\nThe only think I can really determine from the spec is that is it meant to be a single-valued header.  So, probably this can be chased down to the stack to undertow using tomcat's behavior as justification.   They could decide to treat the last set header as the authoritative value (as tomcat does) and everything would be fine, but equally they could decide to treat it as an error I guess?  Either way, maybe this is the best first course of action.\r\n\r\nBut I also wonder if `org.springframework.web.servlet.resource.ResourceHttpRequestHandler.setHeaders` has to write a content-length header at all?  Given, content-length is single-valued and the message converter attempts to write the header anyway.  Perhaps it is too assumptive to knowingly write this \u201cprovisionally\u201d instance up-front?  \r\n\r\nWould this be viewed as a backward incompatible change though?  A custom `ResourceHttpMessageConverter` might rely on the original `setHeaders` method.  However, to do so I think it would have to override `getContentLength` to return null which would be weird (why would a resource not want to return a content-length???).  So, perhaps it is ok?\r\n\r\nWhat other considerations would we need to make?",
                    "I think it should be fixed in Undertow not Spring.",
                    "I've reproduced the problem and looked into it.\r\n\r\nHere's what's happening:\r\n\r\n1. the `ResourceHttpRequestHandler` is setting the content length using `ServletHttpResponse.setContentLength` or `ServletHttpResponse.setContentLengthLong`\r\n2. it's then delegating to the message converters. `ResourceHttpMessageConverter` and `ResourceRegionHttpMessageConverter` are setting the content length using `HttpHeaders.setContentLength` (this adds a \"Content-Length\" header to the header map).\r\n3. later, `ServletServerHttpResponse` is writing headers to the Servlet response by calling `ServletResponse.addHeader` for each entry\r\n4. unlike other containers, Undertow doesn't seem to enforce a single Content-Length header if we're using `ServletHttpResponse.addHeader` to add headers, which is the case in `ServletServerHttpResponse`\r\n\r\nBecause the \"Content-Length\" header can be set in multiple ways through the Servlet API, containers behave differently. It seems that Tomcat is enforcing a single response header no matter what, while Undertow is enforcing that only if it's set through the `setContentLength{Long}` methods.\r\n\r\nWe can fix this problem with a couple of changes:\r\n\r\n* first, remove the duplicate code and avoid setting the content length twice\r\n* then, align `org.springframework.http.server.ServletServerHttpResponse` with `org.springframework.http.server.reactive.ServletServerHttpResponse` and call `ServletHttpResponse.setContentLength` after copying the headers from the map.\r\n\r\nNote that those specific Servlet containers behavior are hard to test without complete integration tests or replicating their headers implementation. Our own `org.springframework.mock.web.MockHttpServletResponse` is enforcing a single Content-Length header no matter what."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for the `contentLength` header.  If the `contentLength` is not -1 (meaning it's a valid, non-null length), the `servletResponse`'s `setContentLengthLong` method is called with the `contentLength` value.  This ensures the content length is correctly set in the response if available.  Essentially, it's handling the case where the content length is known",
            "avg_logprobs": -0.17718128536058508
        }
    },
    {
        "commit_hash": "ddb41172331ef015e67826a5a1cece1c44d4153f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-orm/src/main/java/org/springframework/orm/hibernate5/HibernateExceptionTranslator.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import javax.persistence.PersistenceException;\n+\n+import org.springframework.orm.jpa.EntityManagerFactoryUtils;\n- * instances to Spring's {@link DataAccessException} hierarchy.\n+ * instances to Spring's {@link DataAccessException} hierarchy. As of Spring 4.3.2 and\n+ * Hibernate 5.2, it also converts standard JPA {@link PersistenceException} instances.\n+ * @see EntityManagerFactoryUtils#convertJpaAccessExceptionIfPossible(RuntimeException)\n-\t\treturn null;\n+\t\tif (ex instanceof PersistenceException && ex.getCause() instanceof HibernateException) {\n+\t\t\treturn convertHibernateAccessException((HibernateException) ex.getCause());\n+\t\t}\n+\t\treturn EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "HibernateExceptionTranslator converts JPA exceptions as well (for Hibernate 5.2)",
        "commit_body": "Issue: SPR-14455\n",
        "linked_issues": [
            {
                "issue_id": "19024",
                "issue_title": "Hibernate5 LocalSessionFactoryBean does not translate javax.persistence exceptions [SPR-14455]",
                "issue_body": "**[Will Darby](https://jira.spring.io/secure/ViewProfile.jspa?name=wbdarby)** opened **[SPR-14455](https://jira.spring.io/browse/SPR-14455?redirect=false)** and commented\n\nHibernate 5.0 deprecated the Criteria API resulting in a migration to the JPA CriteriaQuery API directly supported by the Hibernate Session. Exceptions thrown using the CriteriaQuery API derive from package javax.persistence rather than org.hibernate.exception. The Hibernate5 LocalSessionFactoryBean.translateExceptionIfPossible does not convert these exceptions automatically, requiring the addition of a new PersistentExceptionTranslator. The HibernateJpaDialect does translate javax.persistence exceptions correctly but is not used when a LocalSessionFactoryBean is used.\n\nI believe Hibernate5 LocalSessionFactoryBean.translateExceptionIfPossible should match the implementation of HibernateJpaDialect for translating exceptions since JPA is natively integrated with Hibernate 5.\n\n---\n\n**Affects:** 4.3 GA, 4.3.1\n\n**Issue Links:**\n- #18899 Support for Hibernate ORM 5.2\n- #19026 Flush exception translation not working anymore with Hibernate 5.2\n- #19245 HibernateExceptionTranslator translating to InvalidDataAccessApiUsageException when using vanilla Hibernate\n- #21540 LocalSessionFactoryBean and HibernateTransactionManager for JPA EntityManagerFactory setup\n- #19613 Remove outdated JpaExceptionTranslatorAspect\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAnalogous to `HibernateJpaDialect`, our Hibernate 5 `HibernateExceptionTranslator` detects a `HibernateException` root cause of a `PersistenceException` now, and delegates to `EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible` for plain `PersistenceException` handling.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `HibernateExceptionTranslator` adds handling for `PersistenceException` instances from JPA.  Previously, only `HibernateException` was handled.  The updated code now checks if the exception is a `PersistenceException` *and* its cause is a `HibernateException`. If both conditions are true, it calls a helper method (`convertHibernateAccessException`) to translate the `HibernateException`.  Otherwise, it delegates to `EntityManagerFactoryUtils",
            "avg_logprobs": -0.16185731887817384
        }
    },
    {
        "commit_hash": "de069d06d852e6fa2e8e4ca9d442168729af6588",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-oxm/src/main/java/org/springframework/oxm/jaxb/Jaxb2Marshaller.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\tprotected JAXBContext getJaxbContext() {\n+\t/**\n+\t * Return the JAXBContext used by this marshaller, lazily building it if necessary.\n+\t */\n+\tpublic JAXBContext getJaxbContext() {\n-\t\tif (this.supportJaxbElementClass && JAXBElement.class.isAssignableFrom(clazz)) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn supportsInternal(clazz, this.checkForXmlRootElement);\n+\t\treturn ((this.supportJaxbElementClass && JAXBElement.class.isAssignableFrom(clazz)) ||\n+\t\t\t\tsupportsInternal(clazz, this.checkForXmlRootElement));",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Made \"getJaxbContext()\" method public",
        "commit_body": "Issue: SPR-10282\n",
        "linked_issues": [
            {
                "issue_id": "14916",
                "issue_title": "OXM Jaxb2Unmarshaller to support non-root elements [SPR-10282]",
                "issue_body": "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** opened **[SPR-10282](https://jira.spring.io/browse/SPR-10282?redirect=false)** and commented\n\nThe JAXB2Unmarshaller should support JaxbElement/partial unmarshalling (e.g. classes not having a `@RootElement`).\n#12586/SPR-9742 are analogue cases but for marshalling.\nMy usecase is using org.springframework.batch.item.xml.StaxEventItemReader in Spring Batch where I want to delegate unmarshalling of each event to the OXM unmarshaller.\nThis will fail if I cannot call the more specific unmarshalling method where the expected JAXB class can be provided.\n\nThis hack would make this possible by setting the expected class to return as a parameter to the Spring unmarshaller class:\n\n```\npublic class ImprovedJaxb2Marshaller\n    extends Jaxb2Marshaller\n{\n    private Class<?> partClass;\n\n    public void setPartClass( Class<?> partClass )\n    {\n        this.partClass = partClass;\n    }\n\n    @Override\n    public Object unmarshal( Source source, MimeContainer mimeContainer )\n        throws XmlMappingException\n    {\n        if ( partClass == null )\n        {\n            return super.unmarshal( source, mimeContainer );\n        }\n        else\n        {\n            try\n            {\n                Unmarshaller jaxbUnmarshaller = createUnmarshaller();\n                return source instanceof StAXSource ?\n                                unmarshalStaxSource( jaxbUnmarshaller, source ) :\n                                    jaxbUnmarshaller.unmarshal( source, partClass );\n            }\n            catch ( JAXBException e )\n            {\n                throw super.convertJaxbException( e );\n            }\n        }\n    }\n\n    private Object unmarshalStaxSource( Unmarshaller jaxbUnmarshaller, Source staxSource )\n        throws JAXBException\n    {\n        XMLStreamReader streamReader = StaxUtils.getXMLStreamReader( staxSource );\n        if ( streamReader != null )\n        {\n            return jaxbUnmarshaller.unmarshal( streamReader, partClass ).getValue();\n        }\n        else\n        {\n            XMLEventReader eventReader = StaxUtils.getXMLEventReader( staxSource );\n            if ( eventReader != null )\n            {\n                return jaxbUnmarshaller.unmarshal( eventReader, partClass ).getValue();\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"StaxSource contains neither XMLStreamReader nor XMLEventReader\" );\n            }\n        }\n    }\n\n```\n\n---\n\n**Affects:** 3.1.4\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/283b3ee44be2fe89e7a944a10a69a72eb28d1662, https://github.com/spring-projects/spring-framework/commit/de069d06d852e6fa2e8e4ca9d442168729af6588, https://github.com/spring-projects/spring-framework/commit/23925edc95655d5d6ff664aa28e2fe9f27cad38c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSince you're calling the above a hack: Would you prefer to have a different signature for passing in the part class? Possibly a JAXB-specific unmarshal operation that accepts the part class as a parameter?\n\nIf we can agree on a good way to handle this API-wise, I'm happy to roll it into the upcoming 3.2.2 release.\n\nJuergen\n",
                    "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** commented\n\nIt's more of a hack because I subclass the class but duplicate code for the one method (due to the method being private and not protected/default scope in the superclass).\n\nSetting an optional partClass as a parameter looks ok to me.\n\nThe return class should either be the jaxbElement wrapped class (which can provide more information than the JaxbElement.getValue() can, e.g. it may support elements being set to xsi:nil=true), or the actual value as I do now.\n\n",
                    "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** commented\n\nCould it also make it's way into the 3.1.x branch as it would be backwards compatible when the parameter is not set?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'm afraid we have no plans for further 3.1.x releases at this point. 3.2.x is really planned as a direct follow-up to 3.1.x, with no change in system requirements and no major changes in bootstrap and configuration, so I'd definitely recommend a straight update to 3.2.2 then.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nHow did you arrive at \"partClass\", actually? The JAXB API calls it \"declaredType\", and in its javadoc the \"appropriate JAXB mapped class\". So should we use \"mappedClass\" maybe?\n\nJuergen\n",
                    "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** commented\n\npartClass is Apache Camel JAXB Dataformat lingo: http://camel.apache.org/jaxb.html which I use quite a lot.\nmappedclass is probaby closed to JAXB lingo.\nelementClass could also be an option to be consistent with: or elementClass http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/oxm/jaxb/Jaxb2Marshaller.html#setSupportJaxbElementClass(boolean)\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI went with \"mappedClass\", also adding a javadoc reference to that JAXB unmarshal variant. Should be available in the next 3.2.2 snapshot.\n\nJuergen\n",
                    "**[Stevo Slavi\u0107](https://jira.spring.io/secure/ViewProfile.jspa?name=sslavic)** commented\n\nWish `getJaxbContext` method of `Jaxb2Marshaller` was made public instead, or as addition.\n\nThat would allow single Spring bean unmarshaller definition/configuration to be used for (constructing JAXB `Unmarshaller` instances and) unmarshalling multiple mapped classes e.g. when two child types of same parent are mapped to same named root XML element (see [this example](http://java.dzone.com/articles/jaxb-and-root-elements))\n\nThis would also allow additional native JAXB features like being able to influence unmarshalling with custom `StreamReaderDelegate` to make unmarshalling case insensitive like in [this example](http://blog.bdoughan.com/2010/12/case-insensitive-unmarshalling.html).\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, made getJaxbContext() public as well.\n\nJuergen\n",
                    "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** commented\n\nYou missed the stax part.\nDefault imp should be:\n\n```\n @Override\n    protected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException\n    {\n        XMLStreamReader streamReader = StaxUtils.getXMLStreamReader( staxSource );\n        if ( streamReader != null )\n        {\n            return jaxbUnmarshaller.unmarshal( streamReader, mappedCalss ).getValue();\n        }\n        else\n        {\n            XMLEventReader eventReader = StaxUtils.getXMLEventReader( staxSource );\n            if ( eventReader != null )\n            {\n                return jaxbUnmarshaller.unmarshal( eventReader, mappedClass ).getValue();\n            }\n            else\n            {\n                throw new IllegalArgumentException( \"StaxSource contains neither XMLStreamReader nor XMLEventReader\" );\n            }\n        }\n    }\n\n\n```\n\nIt would also be good if the mappedClass variable could be exposed in a getter() or made protected so subclasses can utilize it.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood catch, fixed for 3.2.3 now, to be available in the next snapshot. Note that I added explicit checks for mappedClass being set there (just like for the regular unmarshal implementation), calling JAXB's unmarshal variant without the mappedClass argument if not set.\n\nWhat exactly would you use mappedClass for in a subclass? We got quite a few properties without getters, so I'm just wondering what raises it above the others...\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nActually, shouldn't the unmarshal call for the non-Stax case end with a getValue() call as well? Otherwise we'd return the JAXBElement wrapper...\n\ni.e. return unmarshaller.unmarshal(source, this.mappedClass).getValue();\n",
                    "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** commented\n\nYes, they should be consistent. Either return jaxbelement in both cases, or the value.\n\nExposing the property to support extensibility (just like the case for exposing the jaxbContext).\nRight now I still subclass this to implement the fix myself (cannot depend on snapshots in my mainbranch) - and then i need access to the class set in configuration.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIndeed, you'll need it for implementing the fix... I do wonder what it'd be good for after the fix has been properly implemented though.\n\nI guess we should return the value consistently; I consider it an oversight that we didn't do that in 3.2.2. A caller wouldn't expect a JAXBElement returned from Spring's unmarshal method.\n\nJuergen\n",
                    "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=davidkarlsen)** commented\n\nNext time it could be something else - but generally opening it more up would allow for extensibility (in this class or others). But I do not have anything specific in mind for the marshaller class atm.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `getJaxbContext` method in `Jaxb2Marshaller`.  The original method was a simple getter that checked if the class `clazz` was an `JAXBElement`.  The updated method now includes a Javadoc comment explaining its purpose: returning the JAXBContext, lazily building it if needed.  Critically, the conditional logic has been simplified and made more readable",
            "avg_logprobs": -0.27547470092773435
        }
    },
    {
        "commit_hash": "defc1d31574ea6b3faa5ed84c4aa23c808b0c7cf",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\t// Only bother with flushFromCaches if the Introspector actually cached...\n-\t\t\tif (!shouldIntrospectorIgnoreBeaninfoClasses) {\n-\t\t\t\t// Immediately remove class from Introspector cache, to allow for proper\n-\t\t\t\t// garbage collection on class loader shutdown - we cache it here anyway,\n-\t\t\t\t// in a GC-friendly manner. In contrast to CachedIntrospectionResults,\n-\t\t\t\t// Introspector does not use WeakReferences as values of its WeakHashMap!\n-\t\t\t\tClass<?> classToFlush = beanClass;\n-\t\t\t\tdo {\n-\t\t\t\t\tIntrospector.flushFromCaches(classToFlush);\n-\t\t\t\t\tclassToFlush = classToFlush.getSuperclass();\n-\t\t\t\t}\n-\t\t\t\twhile (classToFlush != null);\n-\t\t\t}\n-",
        "change_count": 9,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Drop Introspector.flushFromCaches calls completely",
        "commit_body": "According to the JDK's documentation and changelog, the Introspector itself safely handles weak references as of JDK 6 update 21 (which is what we require for Spring 4.0).\n\nIssue: SPR-11356\n",
        "linked_issues": [
            {
                "issue_id": "15981",
                "issue_title": "Revisit need for Introspector.flushFromCaches call in CachedIntrospectionResults [SPR-11356]",
                "issue_body": "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** opened **[SPR-11356](https://jira.spring.io/browse/SPR-11356?redirect=false)** and commented\n\nAs of JDK 7 and apparently also recent JDK 6 versions, java.beans.Introspector has a proper weak cache for BeanInfo objects. As a consequence, we can probably drop our immediate Introspector.flushFromCaches call in the CachedIntrospectionResults constructor - at least on recent JDKs -, not least of it all to avoid the locking implied by that call.\n\n---\n\n**Affects:** 4.0 GA\n\n**Issue Links:**\n- #13653 Improve the performance of BeanInfo lookups in CachedIntrospectionResults\n- #16438 CachedIntrospectionResults caching jar entries and creating big pressure on GC\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/87179b075be80a454f89d8bb78c962c118efd310, https://github.com/spring-projects/spring-framework/commit/defc1d31574ea6b3faa5ed84c4aa23c808b0c7cf\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThe underlying problem has been addressed in the JDK itself as of JDK 6 update 21, which is right in the ballpark that we require as a minimum for Spring 4.0: As a consequence, we can unconditionally drop the flushFromCaches call there.\n\nHowever, for 3.2.x, the situation is more delicate since the support range goes back to older JDK 6 versions and even JDK 5. For that reason, we can't easily backport this; there is arguably too much risk associated with it at this late stage of the branch.\n\nAn option available in 3.2.7 is to set the \"spring.beaninfo.ignore\" property to \"true\", either as a system property or in a \"spring.properties\" file in the root of the classpath - provided that the application does not rely on separate *BeanInfo classes next to its actual bean classes. This mode bypasses the JDK's Introspector cache in a backwards-compatible manner and therefore also skips the flushFromCaches call. This is also avoiding repeated ClassLoader access for non-existing *BeanInfo classes, so it's a worthwhile optimization in its own right. See #13653 for a discussion.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a conditional check and associated code that flushes the Introspector cache for a given bean class and its superclasses.  Previously, the `flushFromCaches` operation was only performed if `shouldIntrospectorIgnoreBeaninfoClasses` was false.  The revised code unconditionally flushes the cache for the bean class and all its superclasses",
            "avg_logprobs": -0.2563943290710449
        }
    },
    {
        "commit_hash": "df51ff03862c6a299f2ff243828ec23608899311",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ClassUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tprimitiveWrapperTypeMap.forEach((key, value) -> {\n-\t\t\tprimitiveTypeToWrapperMap.put(value, key);\n-\t\t\tregisterCommonClasses(key);\n-\t\t});\n+\t\t// Map entry iteration is less expensive to initialize than forEach with lambdas\n+\t\tfor (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n+\t\t\tprimitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());\n+\t\t\tregisterCommonClasses(entry.getKey());\n+\t\t}",
        "change_count": 8,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Revert to Map entry iteration for less expensive static initialization",
        "commit_body": "Issue: SPR-17169\n",
        "linked_issues": [
            {
                "issue_id": "21705",
                "issue_title": "ClassUtils optimization for less expensive static initialization [SPR-17169]",
                "issue_body": "**[Dave Syer](https://jira.spring.io/secure/ViewProfile.jspa?name=david_syer)** opened **[SPR-17169](https://jira.spring.io/browse/SPR-17169?redirect=false)** and commented\n\nSpring core `ClassUtils` is always an annoying blip on the flame\ngraphs of startup benchmarks. It pops up because it indirectly calls\n`java.lang.invoke.MethodHandleNatives.linkCallSite()` which is\nexpensive it seems, or at least when called in a static\ninitializer. You can avoid the cost completely if you switch from\niterating over a map using a lambda to explicit old-style iteration:\n\n```java\nfor (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {\n     Class<?> key = entry.getKey();\n     Class<?> value = entry.getValue();\n     primitiveTypeToWrapperMap.put(value, key);\n     registerCommonClasses(key);\n}\n```\n\ninstead of\n\n```java\nprimitiveWrapperTypeMap.forEach((key, value) -> {\n     primitiveTypeToWrapperMap.put(value, key);\n     registerCommonClasses(key);\n});\n```\n\nThe improvement in micro apps startup is dramatic: about 3.5%.\n\n\n---\n\n**Affects:** 5.0.8\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/df51ff03862c6a299f2ff243828ec23608899311, https://github.com/spring-projects/spring-framework/commit/1d8e5f4d853a51834710536efec72e6819ca9970\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nIf that makes a significant difference, the JVM has some room to improve...\n\nAnyway, I've adapted the static initializer along those lines, effectively downgrading the code to its 4.3.x version again.\n",
                    "**[Dave Syer](https://jira.spring.io/secure/ViewProfile.jspa?name=david_syer)** commented\n\nAgree the JVM probably has a problem. Unfortunately it doesn\u2019t look like it\u2019s one that we can work around simply. My benchmarks don\u2019t show a commensurate improvement in startup time after this change - there is some improvement but not as dramatic as I had hoped. But, the flame graph no longer highlights `ClassUtils` as a hot spot. So we have achieved something, and this change didn\u2019t cost much, so it\u2019s worth keeping. We probably just pushed the actual issue into another place, so I\u2019ll keep digging.\n",
                    "**[Dave Syer](https://jira.spring.io/secure/ViewProfile.jspa?name=david_syer)** commented\n\nI looked at the flame graphs again, before and after. As feared, this change seems to just shuffle the problem around. The same work ends up being done in the JVM somewhere else - e.g. in one app I saw the same ~3.5% penalty for `MethodHandleNatives.linkCallSite()` but coming from `LoggingSystem.get()` in Spring Boot, whereas before this change that flame wasn't visible.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nNo worries. Since this is just a syntactic change with hardly a drawback, I'll keep it that way in `ClassUtils`, not triggering any particular initialization impact on our end (and preserving the initialization behavior that we had in 4.3.x already).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a stream-based `forEach` loop with a traditional `for` loop iterating over `Map.Entry` objects.  This change likely aims to improve performance by avoiding the overhead of lambda expression creation and execution.  The original `forEach` used a lambda expression to process each entry in the `primitiveWrapperTypeMap`, whereas the revised code directly accesses the `Map.Entry` objects, potentially leading to a more efficient iteration",
            "avg_logprobs": -0.21261171194223258
        }
    },
    {
        "commit_hash": "df8412bded77faadd60d62dc5c78ca8b2b44a481",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/handler/ExceptionWebSocketHandlerDecorator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(\"Closing due to exception for \" + session, exception);\n+\t\tif (logger.isErrorEnabled()) {\n+\t\t\tlogger.error(\"Closing session due to exception for \" + session, exception);",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ExceptoinWebSocketHandlerDecorator uses ERROR level",
        "commit_body": "Issue: SPR-15537\n",
        "linked_issues": [
            {
                "issue_id": "20096",
                "issue_title": "Increase log level in ExceptionWebSocketHandlerDecorator [SPR-15537]",
                "issue_body": "**[Ayushya Devmurari](https://jira.spring.io/secure/ViewProfile.jspa?name=pathfinder2104)** opened **[SPR-15537](https://jira.spring.io/browse/SPR-15537?redirect=false)** and commented\n\nWhile working on an app which includes a module of spring-websocket. I did some changes in the code and I was having some hibernate exception in the back, but the exception is not getting printed/logged. I found out this while debugging the code. In this class \"ExceptionWebSocketHandlerDecorator\" in this public static method \"tryCloseWithError\", exception handling is there but logging is missing.\n\nI have created a PR for this, please do the needful. Below is the link for PR.\nhttps://github.com/spring-projects/spring-framework/pull/1424\n\n\n---\n\n**Affects:** 4.3.3\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/99236759ec0f8863914de596566d27d9f36293af, https://github.com/spring-projects/spring-framework/commit/df8412bded77faadd60d62dc5c78ca8b2b44a481\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThat `catch` block only really suppresses exceptions during the actual `close` attempt. Did you indeed get a Hibernate exception right there? Could you please share the stacktrace for it?\n",
                    "**[Ayushya Devmurari](https://jira.spring.io/secure/ViewProfile.jspa?name=pathfinder2104)** commented\n\nI agree with you, I should have give it a closer look, about catch block.\n\nHowever I found this exception in ExceptionWebSocketHandlerDecorator, Below is the stack trace which was generated but couldn't find it in logs. Logs are set to debug mode.\n\n[org.springframework.orm.hibernate5.SessionFactoryUtils.convertHibernateAccessException(SessionFactoryUtils.java:296), \norg.springframework.orm.hibernate5.HibernateExceptionTranslator.convertHibernateAccessException(HibernateExceptionTranslator.java:68), \norg.springframework.orm.hibernate5.HibernateExceptionTranslator.translateExceptionIfPossible(HibernateExceptionTranslator.java:49), \norg.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:59), \norg.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:213), \norg.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:147), \norg.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179), \norg.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:213), \ncom.sun.proxy.$Proxy57.getCandidateByEmail(Unknown Source), \norg.opensource.myapp.communication.CallHandler.register(CallHandler.java:148), \norg.opensource.myapp.communication.CallHandler.handleTextMessage(CallHandler.java:94), \norg.springframework.web.socket.handler.AbstractWebSocketHandler.handleMessage(AbstractWebSocketHandler.java:43), \norg.springframework.web.socket.handler.WebSocketHandlerDecorator.handleMessage(WebSocketHandlerDecorator.java:75), \norg.springframework.web.socket.handler.LoggingWebSocketHandlerDecorator.handleMessage(LoggingWebSocketHandlerDecorator.java:56), \norg.springframework.web.socket.handler.ExceptionWebSocketHandlerDecorator.handleMessage(ExceptionWebSocketHandlerDecorator.java:58), \norg.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.handleTextMessage(StandardWebSocketHandlerAdapter.java:110), \norg.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.access$000(StandardWebSocketHandlerAdapter.java:42), \norg.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:81), \norg.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:78), \norg.apache.tomcat.websocket.WsFrameBase.sendMessageText(WsFrameBase.java:399), \norg.apache.tomcat.websocket.WsFrameBase.processDataText(WsFrameBase.java:500), \norg.apache.tomcat.websocket.WsFrameBase.processData(WsFrameBase.java:295), \norg.apache.tomcat.websocket.WsFrameBase.processInputBuffer(WsFrameBase.java:131), \norg.apache.tomcat.websocket.server.WsFrameServer.onDataAvailable(WsFrameServer.java:71), \norg.apache.tomcat.websocket.server.WsHttpUpgradeHandler$WsReadListener.onDataAvailable(WsHttpUpgradeHandler.java:185), \norg.apache.coyote.http11.upgrade.AbstractServletInputStream.onDataAvailable(AbstractServletInputStream.java:198), \norg.apache.coyote.http11.upgrade.AbstractProcessor.upgradeDispatch(AbstractProcessor.java:96), \norg.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:661), \norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1519), \norg.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1475), \njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142), \njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617), \norg.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61), \njava.lang.Thread.run(Thread.java:745)]\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\n> in this public static method \"tryCloseWithError\", exception handling is there but logging is missing.\n\nI'm not sure what you mean. The first thing this method does is [log the error](https://github.com/spring-projects/spring-framework/blob/11075f12bc2ac27b47d9362751a2a44f808828b9/spring-websocket/src/main/java/org/springframework/web/socket/handler/ExceptionWebSocketHandlerDecorator.java#L89-L91).\n\n> However I found this exception in ExceptionWebSocketHandlerDecorator\n\nAgain not clear what you mean by \"found\". Did you put a break somewhere, where? Did you step through and how could it not log where the source link above shows clearly it is logging.\n",
                    "**[Ayushya Devmurari](https://jira.spring.io/secure/ViewProfile.jspa?name=pathfinder2104)** commented\n\nThanks,\nI agree with you that the first thing the method does is logging the error but if you see it I have to put my logger mode in debug mode, I think error should be printed irrespective of debug mode on or off.\n\nSecond thing, yes I did put a break point in my class from there I navigated to class \"ExceptionWebSocketHandlerDecorator\" and in this method \"tryCloseWithError\" I found that there is some exception,  I \"watch\" the variable \"exception\" and while doing exception.printStackTrace() I found above stacktrace.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the logging behavior when an exception occurs during WebSocket handling.  It replaces `logger.debug` with `logger.error`, indicating a more serious logging level for exception events.  This likely improves the visibility and prioritization of exception messages in the logs",
            "avg_logprobs": -0.32368538596413354
        }
    },
    {
        "commit_hash": "dfc370c368cd45863c41ab65ca09a87f6b4a1250",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (isJarResource(rootDirResource)) {\n-\t\t\t\tresult.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));\n-\t\t\t}\n-\t\t\telse if (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n+\t\t\tif (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n+\t\t\telse if (isJarResource(rootDirResource)) {\n+\t\t\t\tresult.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));\n+\t\t\t}",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "PathMatchingResourcePatternResolver's findPathMatchingResources needs to check for VFS before checking isJarResource",
        "commit_body": "Issue: SPR-11887\n",
        "linked_issues": [
            {
                "issue_id": "16506",
                "issue_title": "Spring 3.2.9 breaks JBoss EAP 5.1.1 VFS compatibility [SPR-11887]",
                "issue_body": "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** opened **[SPR-11887](https://jira.spring.io/browse/SPR-11887?redirect=false)** and commented\n\nHi,\n\nwe just upgraded from Spring 3.2.8 to 3.2.9, and it breaks all of our webapps with JBoss EAP 5.1.1.\n\nIt seems to be related to treating VFS URLs as JARs.\n\n```\n14:38:14,214 ERROR [[/webapp]] Exception lors de l'envoi de l'\u00e9v\u00e8nement contexte initialis\u00e9 (context initialized) \u00e0 l'instance de classe d'\u00e9coute (listener) org.springframework.web.context.ContextLoaderListener\norg.springframework.beans.factory.BeanDefinitionStoreException: I/O failure during classpath scanning; nested exception is java.util.zip.ZipException: error in opening zip file\n\tat org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:302)\n\tat org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:242)\n\tat org.springframework.context.annotation.ComponentScanBeanDefinitionParser.parse(ComponentScanBeanDefinitionParser.java:84)\n\tat org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73)\n\tat org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1438)\n\tat org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1428)\n\tat org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:195)\n\tat org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:139)\n\tat org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:108)\n\tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493)\n\tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390)\n\tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334)\n\tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302)\n\tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174)\n\tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209)\n\tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180)\n\tat org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:125)\n\tat org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:94)\n\tat org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:130)\n\tat org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:537)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:451)\n\tat org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:410)\n\tat org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306)\n\tat org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:112)\n\tat org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3910)\n\tat org.apache.catalina.core.StandardContext.start(StandardContext.java:4389)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:321)\n\tat org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:145)\n\tat org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461)\n\tat org.jboss.web.deployers.WebModule.startModule(WebModule.java:122)\n\tat org.jboss.web.deployers.WebModule.start(WebModule.java:97)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157)\n\tat org.jboss.mx.server.Invocation.dispatch(Invocation.java:96)\n\tat org.jboss.mx.server.Invocation.invoke(Invocation.java:88)\n\tat org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264)\n\tat org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668)\n\tat org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206)\n\tat com.sun.proxy.$Proxy38.start(Unknown Source)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42)\n\tat org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37)\n\tat org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62)\n\tat org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71)\n\tat org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:297)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1652)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:938)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:988)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:826)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:556)\n\tat org.jboss.system.ServiceController.doChange(ServiceController.java:688)\n\tat org.jboss.system.ServiceController.start(ServiceController.java:460)\n\tat org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99)\n\tat org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62)\n\tat org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:55)\n\tat org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:179)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1454)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1172)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1193)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1113)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1652)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:938)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:988)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:826)\n\tat org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:556)\n\tat org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:789)\n\tat org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:699)\n\tat org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117)\n\tat org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:403)\n\tat org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1652)\n\tat org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:938)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082)\n\tat org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:988)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:778)\n\tat org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:543)\n\tat org.jboss.system.server.profileservice.repository.AbstractProfileService.registerProfile(AbstractProfileService.java:308)\n\tat org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:256)\n\tat org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461)\n\tat org.jboss.Main.boot(Main.java:221)\n\tat org.jboss.Main$1.run(Main.java:556)\n\tat java.lang.Thread.run(Thread.java:662)\nCaused by: java.util.zip.ZipException: error in opening zip file\n\tat java.util.zip.ZipFile.open(Native Method)\n\tat java.util.zip.ZipFile.<init>(ZipFile.java:127)\n\tat java.util.jar.JarFile.<init>(JarFile.java:136)\n\tat java.util.jar.JarFile.<init>(JarFile.java:73)\n\tat org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindPathMatchingJarResources(PathMatchingResourcePatternResolver.java:458)\n\tat org.springframework.core.io.support.PathMatchingResourcePatternResolver.findPathMatchingResources(PathMatchingResourcePatternResolver.java:344)\n\tat org.springframework.core.io.support.PathMatchingResourcePatternResolver.getResources(PathMatchingResourcePatternResolver.java:268)\n\tat org.springframework.context.support.AbstractApplicationContext.getResources(AbstractApplicationContext.java:1269)\n\tat org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:257)\n\t... 92 more\n```\n\nThe culprit seems to be this change:\n\n```\n@@ -255,23 +255,22 @@ public abstract class ResourceUtils {                                                                                                                                                                                                      \n         */\n        public static boolean isFileURL(URL url) {\n                String protocol = url.getProtocol();\n-               return (URL_PROTOCOL_FILE.equals(protocol) || protocol.startsWith(URL_PROTOCOL_VFS));                                                                                                                                                            \n+               return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFS.equals(protocol));                                                                                                                                                                \n        }\n\n        /**\n         * Determine whether the given URL points to a resource in a jar file,\n         * that is, has protocol \"jar\", \"zip\", \"wsjar\" or \"code-source\".\n-        * <p>\"zip\" and \"wsjar\" are used by BEA WebLogic Server and IBM WebSphere, respectively,                                                                                                                                                                 \n-        * but can be treated like jar files. The same applies to \"code-source\" URLs on Oracle                                                                                                                                                                   \n+        * <p>\"zip\" and \"wsjar\" are used by WebLogic Server and WebSphere, respectively,                                                                                                                                                                         \n+        * but can be treated like jar files. The same applies to \"code-source\" URLs on                                                                                                                                                                          \n         * OC4J, provided that the path contains a jar separator.\n         * @param url the URL to check\n         * @return whether the URL has been identified as a JAR URL\n         */\n        public static boolean isJarURL(URL url) {\n                String protocol = url.getProtocol();\n-               return (URL_PROTOCOL_JAR.equals(protocol) ||                                                                                                                                                                                                     \n-                               URL_PROTOCOL_ZIP.equals(protocol) ||                                                                                                                                                                                             \n-                               URL_PROTOCOL_WSJAR.equals(protocol) ||                                                                                                                                                                                           \n+               return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) ||                                                                                                                                                                \n+                               URL_PROTOCOL_WSJAR.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) ||                                                                                                                                                   \n                                (URL_PROTOCOL_CODE_SOURCE.equals(protocol) && url.getPath().contains(JAR_URL_SEPARATOR)));\n        }\n```\n\n---\n\n**Affects:** 3.2.9\n\n**Reference URL:** https://github.com/spring-projects/spring-framework/commit/be6b54fe8ba27b80f8d3b32a4d9957a808279c22\n\n**Issue Links:**\n- #16299 UrlResource.exists() does not properly detect JBoss vfszip resources\n\n**Backported to:** [3.2.10](https://github.com/spring-projects/spring-framework/milestone/98?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\nCaused by #16299.\n",
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\nOn Windows, the error is a bit different:\n\n```\n13:12:37.995 [main] ERROR o.s.web.context.ContextLoader - Context initialization failed\norg.springframework.beans.factory.BeanDefinitionStoreException: I/O failure during classpath scanning; nested exception is java.io.FileNotFoundException: D:\\jtb\\servers\\jboss-eap-5.1\\jboss-as\\ser\nver\\default\\deploy\\front.war\\WEB-INF\\lib\\somepackage-impl-2.2.0-SNAPSHOT.jar\\fr\\somepackage\\impl (Le chemin d'acc\u00e8s sp\u00e9cifi\u00e9 est introuvable)\n            at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:302) ~[spring-context-3.2.9.RELEASE\n.jar!/:3.2.9.RELEASE]\n            at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:242) ~[spring-context-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.context.annotation.ComponentScanBeanDefinitionParser.parse(ComponentScanBeanDefinitionParser.java:84) ~[spring-context-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1438) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1428) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:195) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:139) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELE\nASE]\n            at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:108) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEAS\nE]\n            at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180) ~[spring-beans-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:125) ~[spring-web-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:94) ~[spring-web-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:130) ~[spring-context-3.2.9.RELEASE.jar!/:3.2.9.RELEASE\n]\n            at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:537) ~[spring-context-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:451) ~[spring-context-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:410) ~[spring-web-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) ~[spring-web-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:112) ~[spring-web-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3910) ~[jbossweb.jar!/:na]\n            at org.apache.catalina.core.StandardContext.start(StandardContext.java:4389) ~[jbossweb.jar!/:na]\n            at org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeployInternal(TomcatDeployment.java:321) [jboss-web-service.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.web.tomcat.service.deployers.TomcatDeployment.performDeploy(TomcatDeployment.java:145) [jboss-web-service.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.web.deployers.AbstractWarDeployment.start(AbstractWarDeployment.java:461) [jboss.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.web.deployers.WebModule.startModule(WebModule.java:122) [jboss.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.web.deployers.WebModule.start(WebModule.java:97) [jboss.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.6.0_39]\n            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) ~[na:1.6.0_39]\n            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) ~[na:1.6.0_39]\n            at java.lang.reflect.Method.invoke(Method.java:597) ~[na:1.6.0_39]\n            at org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157) [jboss-mbeans.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.mx.server.Invocation.dispatch(Invocation.java:96) [jboss-mbeans.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.mx.server.Invocation.invoke(Invocation.java:88) [jboss-mbeans.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:264) [jboss-mbeans.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:668) [jboss-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.microcontainer.ServiceProxy.invoke(ServiceProxy.java:206) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at sun.proxy.$Proxy38.start(Unknown Source) [na:na]\n            at org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:42) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.microcontainer.StartStopLifecycleAction.installAction(StartStopLifecycleAction.java:37) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.dependency.plugins.action.SimpleControllerContextAction.simpleInstallAction(SimpleControllerContextAction.java:62) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.action.AccessControllerContextAction.install(AccessControllerContextAction.java:71) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractControllerContextActions.install(AbstractControllerContextActions.java:51) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.system.microcontainer.ServiceControllerContext.install(ServiceControllerContext.java:297) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1652) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:938) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:988) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:826) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:556) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.system.ServiceController.doChange(ServiceController.java:688) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.ServiceController.start(ServiceController.java:460) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.deployers.ServiceDeployer.start(ServiceDeployer.java:163) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:99) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.deployers.ServiceDeployer.deploy(ServiceDeployer.java:46) [jboss-system-jmx.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.deployers.spi.deployer.helpers.AbstractSimpleRealDeployer.internalDeploy(AbstractSimpleRealDeployer.java:62) [jboss-deployers-spi.jar!/:2.0.10.GA]\n            at org.jboss.deployers.spi.deployer.helpers.AbstractRealDeployer.deploy(AbstractRealDeployer.java:55) [jboss-deployers-spi.jar!/:2.0.10.GA]\n            at org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:179) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1454) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1172) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1193) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1113) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1652) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:938) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:988) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:826) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:556) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:789) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:699) [jboss-deployers-impl.jar!/:2.0.10.GA]\n            at org.jboss.system.server.profileservice.repository.MainDeployerAdapter.process(MainDeployerAdapter.java:117) [jboss-system.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.server.profileservice.repository.ProfileDeployAction.install(ProfileDeployAction.java:70) [jboss-system.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.server.profileservice.repository.AbstractProfileAction.install(AbstractProfileAction.java:53) [jboss-system.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.system.server.profileservice.repository.AbstractProfileService.install(AbstractProfileService.java:403) [jboss-system.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:348) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:1652) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:938) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1082) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:988) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:778) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:543) [jboss-dependency.jar:2.0.10.GA]\n            at org.jboss.system.server.profileservice.repository.AbstractProfileService.registerProfile(AbstractProfileService.java:308) [jboss-system.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=2011051716\n07)]\n            at org.jboss.system.server.profileservice.ProfileServiceBootstrap.start(ProfileServiceBootstrap.java:256) [jboss-system.jar!/:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.bootstrap.AbstractServerImpl.start(AbstractServerImpl.java:461) [jboss-bootstrap.jar:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.Main.boot(Main.java:221) [run.jar:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at org.jboss.Main$1.run(Main.java:556) [run.jar:5.1.1 (build: SVNTag=JBPAPP_5_1_1 date=201105171607)]\n            at java.lang.Thread.run(Thread.java:662) [na:1.6.0_39]\nCaused by: java.io.FileNotFoundException: D:\\jtb\\servers\\jboss-eap-5.1\\jboss-as\\server\\default\\deploy\\front.war\\WEB-INF\\lib\\somepackage-2.2.0-SNAPSHOT.jar\\fr\\somepackage\\impl (Le chemin d'acc\u00e8s sp\u00e9cifi\u00e9 est introuvable)\n            at java.util.zip.ZipFile.open(Native Method) ~[na:1.6.0_39]\n            at java.util.zip.ZipFile.<init>(ZipFile.java:127) ~[na:1.6.0_39]\n            at java.util.jar.JarFile.<init>(JarFile.java:136) ~[na:1.6.0_39]\n            at java.util.jar.JarFile.<init>(JarFile.java:73) ~[na:1.6.0_39]\n            at org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindPathMatchingJarResources(PathMatchingResourcePatternResolver.java:458) ~[spring-core-3.2.9.RELEASE.jar!/:3.2.9.RE\nLEASE]\n            at org.springframework.core.io.support.PathMatchingResourcePatternResolver.findPathMatchingResources(PathMatchingResourcePatternResolver.java:344) ~[spring-core-3.2.9.RELEASE.jar!/:3.2.9.RELEASE\n]\n            at org.springframework.core.io.support.PathMatchingResourcePatternResolver.getResources(PathMatchingResourcePatternResolver.java:268) ~[spring-core-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.context.support.AbstractApplicationContext.getResources(AbstractApplicationContext.java:1269) ~[spring-context-3.2.9.RELEASE.jar!/:3.2.9.RELEASE]\n            at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:257) ~[spring-context-3.2.9.RELEASE\n.jar!/:3.2.9.RELEASE]\n            ... 92 common frames omitted\n```\n\n",
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\n1. git clone https://github.com/spring-projects/spring-framework.git\n2. cd spring-framework\n3. git checkout v3.2.9.RELEASE\n4. git revert be6b54fe8ba27b80f8d3b32a4d9957a808279c22\n5. ./gradlew build\n\n=> issue fixed\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nKeeping the fix for #16299 applied, the best possible solution seems to be a simple switch of checks: PathMatchingResourcePatternResolver's findPathMatchingResources needs to check for VFS before checking isJarResource. I've addressed this in master, to be available in the next 4.1 snapshot. I'll also backport it to 4.0.6 and 3.2.9 SR1.\n\nJuergen\n",
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\nThanks, I'll test this tomorrow morning (GMT+2).\nRegards,\nPatrick.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nMight be easiest if you locally patch 3.2.9 based on my commit in our master branch (https://github.com/spring-projects/spring-framework/commit/dfc370c368cd45863c41ab65ca09a87f6b4a1250)... or you'll try the latest 4.1 snapshot.\n\nI'm afraid that 4.0.6 and 3.2.9 SR1 snapshots won't be available before next week since we haven't done any backporting yet.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nNote that this is only an issue on JBoss 5 in the first place. VFS 3, as used in JBoss 6 and 7, seems to work fine in any case. From that perspective, Spring Framework 4.x doesn't seem to be affected but I'll keep the fix there for defensive consistency.\n\nIn the course of a further review of our ResourceUtils code, I've also restored detection of \"vfsfile\" as a file system protocol. This got lost through #16299 as well but didn't make as much of a difference since it just caused less efficient resolution.\n\nJuergen\n",
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\nThank you Juergen, you fixed it.\n\n1. git clone https://github.com/spring-projects/spring-framework.git\n2. cd spring-framework\n3. git checkout v3.2.9.RELEASE\n4. git cherry-pick dfc370c368cd45863c41ab65ca09a87f6b4a1250\n5. ./gradlew build\n\n-Any ETA for Spring 3.2.9.SR1? This is a blocker for us.- ([just seen the 15/Jul/14 Due date](https://jira.spring.io/browse/SPR/fixforversion/14641))\n\nBest regards,\nPatrick.\n",
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\nFix confirmed in 3.2.10.BUILD-SNAPSHOT.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThanks, Patrick, that's good to know.\n\nFYI, 3.2.10 is basically in release candidate mode now, with 18 issues fixed - many of them verified by the original reporters already - and not much more expected. At this stage, it's arguably worth releasing not too long after 4.0.6 which will go out on Monday now. So I can't promise an earlier date for 3.2.10 yet but it might end up being ahead of July 28th.\n\nJuergen\n",
                    "**[Patrick Decat](https://jira.spring.io/secure/ViewProfile.jspa?name=pdecat)** commented\n\nFix confirmed with Spring 3.2.10.RELEASE, thanks Juergen!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change swaps the order of the `if-else if` statements.  Originally, it checked if the resource was a JAR first, then a VFS resource.  Now, it checks for a VFS resource first, then a JAR resource.  This is a simple reordering of the conditional logic, likely driven by a specific need to prioritize VFS resource handling",
            "avg_logprobs": -0.236846067966559
        }
    },
    {
        "commit_hash": "e00a882333ed06c682a59f92aa45657434b03df1",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/adapter/jetty/JettyWebSocketHandlerAdapter.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\telse {\n+\t\t\tcallback.succeed();\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Complete Jetty frame callback when opcode is not PONG",
        "commit_body": "The onWebSocketFrame method should complete callback.\nFor more details, see https://github.com/jetty/jetty.project/issues/11088.\n\nCloses gh-31869\n",
        "linked_issues": [
            {
                "issue_id": "31869",
                "issue_title": "Complete frame callback when opcode is not PONG",
                "issue_body": "onWebSocketFrame method should complete callback. more details see issue [JETTY 11088](https://github.com/jetty/jetty.project/issues/11088)",
                "issue_state": "closed",
                "issue_comment": [
                    "@leonchen83 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=31869)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=31869) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@leonchen83 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=31869)!",
                    "@sbordet From your perspective, should we apply this fix to the Jetty 11 support we have in Spring Framework 6.0.x as well?",
                    "@sdeleuze Jetty 11 does not need this fix because it does not use `Callback`.\r\n\r\nThe corresponding signature in Jetty 11 would be:\r\n\r\n```java\r\n@OnWebSocketFrame\r\npublic void onWebSocketFrame(Frame frame)\r\n```\r\n\r\nso no `Callback`.\r\nIn Jetty 11 there is the requirement that the frame payload must be consumed synchronously in the method invocation, or copied to be consumed asynchronously, because when returning from the `onWebSocketFrame()` method the frame payload buffer is recycled."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a `callback.succeed()` call within an `else` block.  This suggests a modification to a conditional logic flow, likely related to handling a WebSocket connection or message.  The `else` block now explicitly signals success when a previous condition was not met",
            "avg_logprobs": -0.20319828234220805
        }
    },
    {
        "commit_hash": "e0734aede82efc80c5ab334d5559abcc5787957b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/PostProcessorRegistrationDelegate.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * BeanPostProcessor that detects beans which implement the ApplicationListener interface.\n-\t * This catches beans that can't reliably be detected by getBeanNamesForType.\n+\t * {@code BeanPostProcessor} that detects beans which implement the {@code ApplicationListener}\n+\t * interface. This catches beans that can't reliably be detected by {@code getBeanNamesForType}\n+\t * and related operations which only work against top-level beans.\n+\t *\n+\t * <p>With standard Java serialization, this post-processor won't get serialized as part of\n+\t * {@code DisposableBeanAdapter} to begin with. However, with alternative serialization\n+\t * mechanisms, {@code DisposableBeanAdapter.writeReplace} might not get used at all, so we\n+\t * defensively mark this post-processor's field state as {@code transient}.\n-\t\tprivate final AbstractApplicationContext applicationContext;\n+\t\tprivate transient final AbstractApplicationContext applicationContext;\n-\t\tprivate final Map<String, Boolean> singletonNames = new ConcurrentHashMap<String, Boolean>(256);\n+\t\tprivate transient final Map<String, Boolean> singletonNames = new ConcurrentHashMap<String, Boolean>(256);\n-\t\t\tif (beanDefinition.isSingleton()) {\n+\t\t\tif (this.applicationContext != null && beanDefinition.isSingleton()) {\n-\t\t\tif (bean instanceof ApplicationListener) {\n+\t\t\tif (this.applicationContext != null && bean instanceof ApplicationListener) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ApplicationListenerDetector explicitly prevents serialization of its ApplicationContext reference",
        "commit_body": "Issue: SPR-14214\n",
        "linked_issues": [
            {
                "issue_id": "18788",
                "issue_title": "ApplicationListenerDetector should prevent serialization of its ApplicationContext reference [SPR-14214]",
                "issue_body": "**[Ricardo Fanjul Fandi\u00f1o](https://jira.spring.io/secure/ViewProfile.jspa?name=fanjulito)** opened **[SPR-14214](https://jira.spring.io/browse/SPR-14214?redirect=false)** and commented\n\nI'm trying to migrate Spring Web Application from 3.x version to 4.2 version of Spring.\n\nMy application is deployed in a cluster of Tomcat 7 using for serialize the session: memcached-session-manager: https://github.com/magro/memcached-session-manager and serializing the objects with Kryo.\n\nWhen serialize the session I found a mistake that made me suspect that I'm trying to serialize the Spring ApplicationContext.\n\nDebugging my application I found this:\n!imagen1.png|thumbnail!\n\nInside the session exist a key \u201corg.springframework.web.context.request.ServletRequestAttributes.DESTRUCTION_CALLBACK.scopedTarget.restSessionDataHolder\u201d whose value reference the ApplicationContext.\n\nI find that, for each bean declared in Session Scope. For example:\n\n```java\n@Component\n@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS,value=\"session\")\npublic class RestSessionDataHolder implements Serializable{\n...\n```\n\nSpring in the method \u201corg.springframework.web.context.request.ServletRequestAttributes.registerSessionDestructionCallback\n(String name, Runnable callback)\u201d, store in the session a key named \u201corg.springframework.web.context.request.ServletRequestAttributes.DESTRUCTION_CALLBACK.scopedTarget.[BEAN_NAME]\u201d with a value that indirectly reference the ApplicatonContext.\n\n!imagen2.png|thumbnail!\n\n!imagen3.png|thumbnail!\n\nInside this atribute exist two \u201cDestructionAwareBeanPostProcessor\u201d: \u201cCommonAnnotationBeanPostProcessor\u201d and \u201corg.springframework.context.support.PostProcessorRegistrationDelegate$ApplicationListenerDetector\u201d.\n\n\u201cPostProcessorRegistrationDelegate$ApplicationListenerDetector\u201d exist since Spring 4.0 and maybe have a bug:\n\n```java\nprivate static class ApplicationListenerDetector implements MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor {\n...\n\t\tprivate final AbstractApplicationContext applicationContext;\n\n```\n\nI think that attribute \u201cprivate final AbstractApplicationContext applicationContext\u201d should be \u201c**transient**\u201d.\n\nFor example the similar attributes of \u201cCommonAnnotationBeanPostProcessor\u201d are transient:\n\n```java\npublic class CommonAnnotationBeanPostProcessor extends InitDestroyAnnotationBeanPostProcessor\n\t\timplements InstantiationAwareBeanPostProcessor, BeanFactoryAware, Serializable {\n\n...\n\n\tprivate transient BeanFactory jndiFactory = new SimpleJndiBeanFactory();\n\n\tprivate transient BeanFactory resourceFactory;\n\n\tprivate transient BeanFactory beanFactory;\n\n\tprivate transient final Map<String, InjectionMetadata> injectionMetadataCache =\n\t\t\tnew ConcurrentHashMap<String, InjectionMetadata>(256);\n```\n\n---\n\n**Affects:** 4.1.7, 4.1.8, 4.1.9, 4.2 GA, 4.2.1, 4.2.2, 4.2.3, 4.2.4, 4.2.5\n\n**Attachments:**\n- [imagen1.png](https://jira.spring.io/secure/attachment/23382/imagen1.png) (_56.23 kB_)\n- [imagen2.png](https://jira.spring.io/secure/attachment/23381/imagen2.png) (_81.84 kB_)\n- [imagen3.png](https://jira.spring.io/secure/attachment/23380/imagen3.png) (_116.81 kB_)\n\n**Issue Links:**\n- #18317 Avoid scoped destruction callbacks in case of no post-processor actually applying\n- #19349 Inner bean behind BeanFactoryPostProcessor should be able to receive application events\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/75a8f5b3cacdc89d0ac0e60335274988dd36ea0d, https://github.com/spring-projects/spring-framework/commit/e0734aede82efc80c5ab334d5559abcc5787957b\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSpring's `DisposableBeanAdapter` has a `writeReplace` implementation which filters for serializable post-processors... Since `ApplicationListenerDetector` isn't marked as serializable, it won't be included to begin with. However, that's only for standard Java serialization which actually respects `writeReplace`... Could this have to do with your specific arrangement, trying to serialize the original `DisposableBeanAdapter` instance and not its replacement object?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nNote that, as of Spring Framework 4.3, we do not create scoped destruction callbacks at all anymore if none of them has anything to do. So `ApplicationListenerDetector` won't be included for non-listener beans anymore.\n\nThat said, it nevertheless doesn't hurt to mark `ApplicationListenerDetector`'s field state as `transient`, even if this might only really help with alternative serialization mechanisms. We can also easily backport that part to 4.2.6, whereas the above mechanism is 4.3 only.\n",
                    "**[Ricardo Fanjul Fandi\u00f1o](https://jira.spring.io/secure/ViewProfile.jspa?name=fanjulito)** commented\n\nThanks for change, solves my problem.\n\nThen, I tried the \"writeReplace()\" and I found that Kryo don't invoke the method \"writeReplace()\".\n\n\"memcached-session-manager\" have many serialization strategies:\nhttps://github.com/magro/memcached-session-manager/wiki/SerializationStrategies.\n\nI tried (Java serialization):\n\"de.javakaffee.web.msm.JavaSerializationTranscoderFactory\".\n\nAnd \"DisposableBeanAdapter.writeReplace()\" is invoked and \"ApplicationListenerDetector\" not included.\n\nThe problema is with \"Kryo\" serialization:\n\"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory\"\n\n\"DisposableBeanAdapter.writeReplace()\" is not invoked so, the \"ApplicationListenerDetector\" is included.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change adds a `transient` keyword to the `applicationContext` field and `singletonNames` field, and adds a null check for `applicationContext` before checking if a bean is a singleton.  This change is likely to address serialization issues with the `PostProcessorRegistrationDelegate` class.  The original code lacked a check for `applicationContext` being null before using it, which could lead to `NullPointerExceptions`",
            "avg_logprobs": -0.28996503829956055
        }
    },
    {
        "commit_hash": "e21d94f91bfdfe8e3d7df43c2823425d096e0770",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/AbstractServerHttpResponse.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tfor (Supplier<? extends Mono<Void>> actions : this.commitActions) {\n-\t\t\tcommit = commit.concatWith(actions.get());\n+\t\tfor (Supplier<? extends Mono<Void>> action : this.commitActions) {\n+\t\t\tcommit = commit.concatWith(action.get());",
        "change_count": 4,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Polish",
        "commit_body": "Closes gh-22472\n",
        "linked_issues": [
            {
                "issue_id": "22472",
                "issue_title": "Polish",
                "issue_body": "This PR simply changes plural to singular.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a `for` loop iterating over a list of `Supplier` objects (`commitActions`).  The original code used `this.commitActions` (plural), while the updated code uses `action` (singular).  This suggests a potential refactoring or simplification, likely removing a redundant or unnecessary pluralization of the variable.  The core functionality of concatenating `Mono<Void>` objects within the loop remains the same",
            "avg_logprobs": -0.23861728244357638
        }
    },
    {
        "commit_hash": "e2b1dcbaca1cc618281d1308a5c24c28d4a04020",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tTypedValue value = this.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n-\t\t\tif (this.ref.cachedReadAccessor instanceof CompilablePropertyAccessor) {\n-\t\t\t\tCompilablePropertyAccessor accessor = (CompilablePropertyAccessor) this.ref.cachedReadAccessor;\n-\t\t\t\tthis.ref.exitTypeDescriptor = CodeFlow.toDescriptor(accessor.getPropertyType());\n+\t\t\tTypedValue value =\n+\t\t\t\t\tthis.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n+\t\t\tPropertyAccessor accessorToUse = this.ref.cachedReadAccessor;\n+\t\t\tif (accessorToUse instanceof CompilablePropertyAccessor) {\n+\t\t\t\tthis.ref.exitTypeDescriptor =\n+\t\t\t\t\t\tCodeFlow.toDescriptor(((CompilablePropertyAccessor) accessorToUse).getPropertyType());",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "AccessorLValue reliably downcasts to CompilablePropertyAccessor in concurrent scenarios",
        "commit_body": "Issue: SPR-14850\n",
        "linked_issues": [
            {
                "issue_id": "19416",
                "issue_title": "NPE PropertyOrFieldReference$AccessorLValue due to concurrency issue [SPR-14850]",
                "issue_body": "**[Thijs Vonk](https://jira.spring.io/secure/ViewProfile.jspa?name=thyzz)** opened **[SPR-14850](https://jira.spring.io/browse/SPR-14850?redirect=false)** and commented\n\nWe're seeing 'strange' NullpointerExceptions while using ThymeLeaf and having heavy load on the machine.\n\n```\n2016-10-26 15:17:23,200 [trace=7cd2c0bf5bcb66db,span=7cd2c0bf5bcb66db] ERROR       TemplateEngine:1085 - [THYMELEAF][http-nio-8080-exec-12] Exception processing template \"sections/default\": Exception evaluating SpringEL expression: \"article.detailUrl\" (includes/ankeilers/standard:5)\n2016-10-26 15:17:23,229 [trace=,span=] ERROR  [dispatcherServlet]:182  - Servlet.service() for servlet dispatcherServlet threw exception\njava.lang.NullPointerException: null\n\tat org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:377)\n\tat org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:88)\n\tat org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:120)\n\tat org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:267)\n\tat org.thymeleaf.spring4.expression.SpelVariableExpressionEvaluator.evaluate(SpelVariableExpressionEvaluator.java:139)\n\tat org.thymeleaf.standard.expression.VariableExpression.executeVariable(VariableExpression.java:154)\n\tat org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:59)\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:103)\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:133)\n\tat org.thymeleaf.standard.expression.Expression.execute(Expression.java:120)\n\tat org.thymeleaf.standard.processor.attr.AbstractStandardSingleAttributeModifierAttrProcessor.getTargetAttributeValue(AbstractStandardSingleAttributeModifierAttrProcessor.java:67)\n\tat org.thymeleaf.spring4.processor.attr.SpringHrefAttrProcessor.getTargetAttributeValue(SpringHrefAttrProcessor.java:68)\n\tat org.thymeleaf.processor.attr.AbstractSingleAttributeModifierAttrProcessor.getModifiedAttributeValues(AbstractSingleAttributeModifierAttrProcessor.java:59)\n\tat org.thymeleaf.processor.attr.AbstractAttributeModifierAttrProcessor.processAttribute(AbstractAttributeModifierAttrProcessor.java:62)\n\tat org.thymeleaf.processor.attr.AbstractAttrProcessor.doProcess(AbstractAttrProcessor.java:87)\n\tat org.thymeleaf.processor.AbstractProcessor.process(AbstractProcessor.java:212)\n\tat org.thymeleaf.dom.Node.applyNextProcessor(Node.java:1017)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:972)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.NestableNode.computeNextChild(NestableNode.java:695)\n\tat org.thymeleaf.dom.NestableNode.doAdditionalProcess(NestableNode.java:668)\n\tat org.thymeleaf.dom.Node.processNode(Node.java:990)\n\tat org.thymeleaf.dom.Document.process(Document.java:93)\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1155)\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1060)\n\tat org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1011)\n\tat org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:335)\n\tat org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:190)\n\tat org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1246)\n\tat org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1029)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:973)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:895)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:967)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:858)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:622)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:843)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:729)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)\n\tat org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration$ApplicationContextHeaderFilter.doFilterInternal(EndpointWebMvcAutoConfiguration.java:281)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)\n\tat org.springframework.web.filter.ShallowEtagHeaderFilter.doFilterInternal(ShallowEtagHeaderFilter.java:87)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)\n\tat org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:115)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207)\n```\n\nLooking at similar NPE issues #17614 and how this was fixed\nI fixed this locally by doing the following in spring-expression v4.2.7\nreplace\n\n```\nline:372\n@Override\npublic TypedValue getValue() {\n\tTypedValue value = this.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n\tif (this.ref.cachedReadAccessor instanceof CompilablePropertyAccessor) {\n\t\tCompilablePropertyAccessor accessor = (CompilablePropertyAccessor) this.ref.cachedReadAccessor;\n\t\t\t\tthis.ref.exitTypeDescriptor = CodeFlow.toDescriptor(accessor.getPropertyType());\n\t}\n\treturn value;\n}\n```\n\nwith\n\n```\n@Override\npublic TypedValue getValue() {\n\tTypedValue value = this.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n\tPropertyAccessor accessorToUse = this.ref.cachedReadAccessor;\n\tif (accessorToUse instanceof CompilablePropertyAccessor) {\n\t\tCompilablePropertyAccessor accessor = (CompilablePropertyAccessor) accessorToUse;\n\t\t\t\tthis.ref.exitTypeDescriptor = CodeFlow.toDescriptor(accessor.getPropertyType());\n\t}\n\treturn value;\n}\n```\n\n---\n\n**Affects:** 4.2.7, 4.2.8\n\n**Issue Links:**\n- #17614 NPE in PropertyOrFieldReference due to concurrency issue when caching SpelExpression objects\n\n**Backported to:** [4.2.9](https://github.com/spring-projects/spring-framework/milestone/146?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Thijs Vonk](https://jira.spring.io/secure/ViewProfile.jspa?name=thyzz)** commented\n\nLooking at the code for 4.3.x and master I suspect this problem may also still occur there. No hard evidence though\n",
                    "**[Thijs Vonk](https://jira.spring.io/secure/ViewProfile.jspa?name=thyzz)** commented\n\nJuergen, how was this fixed? I'm looking for the commit's but can't find any.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Thijs Vonk](https://jira.spring.io/secure/ViewProfile.jspa?name=thyzz) sorry, not pushed/backported yet... coming later tonight or tomorrow, along with a bunch of other commits.\n\nThe fix itself looks just like in your patch, analogous to the older fixes in other locations.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refactors the code to use a more general `PropertyAccessor` instead of directly casting to `CompilablePropertyAccessor` within the conditional.  The original code had a direct cast within the `if` statement.  The revised code stores the `cachedReadAccessor` in a variable `accessorToUse` before the conditional check, improving readability and potentially reducing unnecessary casting",
            "avg_logprobs": -0.2998222541809082
        }
    },
    {
        "commit_hash": "e2ccd55d146c245ee3e6d46783e3c288999894ff",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tMethod[] methods = this.sortedMethodsCache.get(clazz);\n-\t\tif (methods == null) {\n-\t\t\tmethods = clazz.getMethods();\n+\t\treturn this.sortedMethodsCache.computeIfAbsent(clazz, key -> {\n+\t\t\tMethod[] methods = key.getMethods();\n-\t\t\tthis.sortedMethodsCache.put(clazz, methods);\n-\t\t}\n-\t\treturn methods;\n+\t\t\treturn methods;\n+\t\t});",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "ReflectivePropertyAccessor uses computeIfAbsent for cache computation",
        "commit_body": "Issue: SPR-16882\n",
        "linked_issues": [
            {
                "issue_id": "21421",
                "issue_title": "ReflectivePropertyAccessor should cache sorted methods [SPR-16882]",
                "issue_body": "**[Pavel Khokhlov](https://jira.spring.io/secure/ViewProfile.jspa?name=pavel_hp)** opened **[SPR-16882](https://jira.spring.io/browse/SPR-16882?redirect=false)** and commented\n\nAfter migration from SPEL\u00a04.3.9.RELEASE ->\u00a04.3.10.RELEASE we noticed performance degradation with SPEL Expression (at least 2.5x times).\n\nIn attachment you can find [^benchmark.zip]\n\nYou can see JMH report (I used\u00a0jdk1.8.0_151)\n\nThis is\u00a04.3.10.RELEASE\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin/java -Dfile.encoding=UTF-8 -classpath /Users/pkhokhlov/JProjects/benchmark/target/test-classes:/Users/pkhokhlov/.m2/repository/org/openjdk/jmh/jmh-core/1.21/jmh-core-1.21.jar:/Users/pkhokhlov/.m2/repository/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar:/Users/pkhokhlov/.m2/repository/org/apache/commons/commons-math3/3.2/commons-math3-3.2.jar:/Users/pkhokhlov/.m2/repository/org/openjdk/jmh/jmh-generator-annprocess/1.21/jmh-generator-annprocess-1.21.jar:/Users/pkhokhlov/.m2/repository/org/springframework/spring-expression/4.3.10.RELEASE/spring-expression-4.3.10.RELEASE.jar:/Users/pkhokhlov/.m2/repository/org/springframework/spring-core/4.3.10.RELEASE/spring-core-4.3.10.RELEASE.jar:/Users/pkhokhlov/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar org.openjdk.jmh.Main org.spel.bug.SpelBenchmark.*\n1. JMH version: 1.21\n1. VM version: JDK 1.8.0_151, Java HotSpot(TM) 64-Bit Server VM, 25.151-b12\n1. VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin/java\n1. VM options: -Dfile.encoding=UTF-8\n1. Warmup: 2 iterations, 10 s each\n1. Measurement: 2 iterations, 10 s each\n1. Timeout: 10 min per iteration\n1. Threads: 1 thread, will synchronize iterations\n1. Benchmark mode: Throughput, ops/time\n1. Benchmark: org.spel.bug.SpelBenchmark.spel# Run progress: 0.00% complete, ETA 00:00:40\n1. Fork: 1 of 1\n1. Warmup Iteration   1: 197599.695 ops/s\n1. Warmup Iteration   2: 225828.094 ops/s\nIteration   1: 225044.963 ops/s\nIteration   2: 228451.901 ops/s\nResult \"org.spel.bug.SpelBenchmark.spel\":\n  226748.432 ops/s\n1. Run complete. Total time: 00:00:40REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.Benchmark            Mode  Cnt       Score   Error  Units\nSpelBenchmark.spel  thrpt    2  226748.432          ops/s\n```\n\nThis is\u00a04.3.9.RELEASE\n\n```\n/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin/java -Dfile.encoding=UTF-8 -classpath /Users/pkhokhlov/JProjects/benchmark/target/test-classes:/Users/pkhokhlov/.m2/repository/org/openjdk/jmh/jmh-core/1.21/jmh-core-1.21.jar:/Users/pkhokhlov/.m2/repository/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar:/Users/pkhokhlov/.m2/repository/org/apache/commons/commons-math3/3.2/commons-math3-3.2.jar:/Users/pkhokhlov/.m2/repository/org/openjdk/jmh/jmh-generator-annprocess/1.21/jmh-generator-annprocess-1.21.jar:/Users/pkhokhlov/.m2/repository/org/springframework/spring-expression/4.3.9.RELEASE/spring-expression-4.3.9.RELEASE.jar:/Users/pkhokhlov/.m2/repository/org/springframework/spring-core/4.3.9.RELEASE/spring-core-4.3.9.RELEASE.jar:/Users/pkhokhlov/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar org.openjdk.jmh.Main org.spel.bug.SpelBenchmark.*\n1. JMH version: 1.21\n1. VM version: JDK 1.8.0_151, Java HotSpot(TM) 64-Bit Server VM, 25.151-b12\n1. VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/bin/java\n1. VM options: -Dfile.encoding=UTF-8\n1. Warmup: 2 iterations, 10 s each\n1. Measurement: 2 iterations, 10 s each\n1. Timeout: 10 min per iteration\n1. Threads: 1 thread, will synchronize iterations\n1. Benchmark mode: Throughput, ops/time\n1. Benchmark: org.spel.bug.SpelBenchmark.spel# Run progress: 0.00% complete, ETA 00:00:40\n1. Fork: 1 of 1\n1. Warmup Iteration   1: 511243.723 ops/s\n1. Warmup Iteration   2: 564409.791 ops/s\nIteration   1: 579457.251 ops/s\nIteration   2: 582177.903 ops/s\nResult \"org.spel.bug.SpelBenchmark.spel\":\n  580817.577 ops/s\n1. Run complete. Total time: 00:00:40REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.Benchmark            Mode  Cnt       Score   Error  Units\nSpelBenchmark.spel  thrpt    2  580817.577          ops/s\n```\n\n\u00a0\n\n---\n\n**Affects:** 4.3.10\n\n**Attachments:**\n- [benchmark.zip](https://jira.spring.io/secure/attachment/25738/benchmark.zip) (_2.76 kB_)\n\n**Issue Links:**\n- #20324 PropertyOrFieldReference invalidly reuses cached PropertyAccessor\n- #21481 Performance degradation in SPEL expression evaluation\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/4a6e9a55572ae57c0f7eea40ef530855b9ab339d, https://github.com/spring-projects/spring-framework/commit/bfcc1a1f6ae58d3a62765ddd21f6bd5b5182463d, https://github.com/spring-projects/spring-framework/commit/da049f480b2c6543dd8e77821c60197e86d4fcdb, https://github.com/spring-projects/spring-framework/commit/e2ccd55d146c245ee3e6d46783e3c288999894ff\n\n**Backported to:** [4.3.18](https://github.com/spring-projects/spring-framework/milestone/167?closed=1)\n\n0 votes, 5 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Pavel Khokhlov](https://jira.spring.io/secure/ViewProfile.jspa?name=pavel_hp)** commented\n\nProbably problem in method\u00a0getSortedClassMethods\n\nhttps://github.com/spring-projects/spring-framework/blob/c44de3c5df5fb57630727d9491dd6ea5ab47563f/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java#L433\n\nit calls too often and should be cached.\n",
                    "**[Pavel Khokhlov](https://jira.spring.io/secure/ViewProfile.jspa?name=pavel_hp)** commented\n\n`@Juergen` Hoeller\u00a0\n\nI have a question. I've checked release version\u00a0[4.3.18](https://jira.spring.io/issues/?jql=project+%3D+SPR+AND+fixVersion+%3D+4.3.18)\u00a0and I didn't find significant difference, look:\n\n**4.3.18.RELEASE**\n\n```\n1. JMH version: 1.21\n1. VM version: JDK 1.8.0_172, Java HotSpot(TM) 64-Bit Server VM, 25.172-b11\n1. VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home/jre/bin/java\n1. VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=61697:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8\n1. Warmup: 2 iterations, 10 s each\n1. Measurement: 2 iterations, 10 s each\n1. Timeout: 10 min per iteration\n1. Threads: 1 thread, will synchronize iterations\n1. Benchmark mode: Throughput, ops/time\n1. Benchmark: org.benchmark.dbg.spel.SpelBenchmark.spel# Run progress: 0.00% complete, ETA 00:00:40\n1. Fork: 1 of 1\n1. Warmup Iteration   1: 227388.780 ops/s\n1. Warmup Iteration   2: 256747.696 ops/s\nIteration   1: 257249.790 ops/s\nIteration   2: 256228.128 ops/s\nResult \"org.benchmark.dbg.spel.SpelBenchmark.spel\":\n  256738.959 ops/s\n```\n\n256738.959 ops/s\n\n\u00a0\n\n4.3.9.RELEASE\n\n```\n1. JMH version: 1.21\n1. VM version: JDK 1.8.0_172, Java HotSpot(TM) 64-Bit Server VM, 25.172-b11\n1. VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home/jre/bin/java\n1. VM options: -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=61682:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8\n1. Warmup: 2 iterations, 10 s each\n1. Measurement: 2 iterations, 10 s each\n1. Timeout: 10 min per iteration\n1. Threads: 1 thread, will synchronize iterations\n1. Benchmark mode: Throughput, ops/time\n1. Benchmark: org.benchmark.dbg.spel.SpelBenchmark.spel# Run progress: 0.00% complete, ETA 00:00:40\n1. Fork: 1 of 1\n1. Warmup Iteration   1: 533753.413 ops/s\n1. Warmup Iteration   2: 589956.066 ops/s\nIteration   1: 585124.048 ops/s\nIteration   2: 583993.328 ops/s\nResult \"org.benchmark.dbg.spel.SpelBenchmark.spel\":\n  584558.688 ops/s\n```\n\n584558.688 ops/s\n\nSo what was fixed? Could you explain it please?\n\n\u00a0\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThe change was in the sorted method handling that you pointed out above... we're caching the sorted method array now.\n\nI suppose there is some other hotspot involved too then?\n",
                    "**[Kanthi Vaidya](https://jira.spring.io/secure/ViewProfile.jspa?name=kvaidya)** commented\n\nHi Juergen, I saw your code changes for caching the SortedMethods. We don't benefit much if you don't make your ConcurrentHashMap of sorted methods\u00a0 a static variable.\n\nEven after making the ConcurrentHashMap a static variable, we still don't get back the original performance of the prior spring versions. It definitely helps of course.\n\nThis is just one hotspot. More benchmarking and profiling is needed to identify other hot spots. And it probably makes sense to add a test case to the CI infrastructure to catch any such degradations.\n\nThis performance degradation, is preventing us from migration to Spring 5.\n",
                    "**[Kanthi Vaidya](https://jira.spring.io/secure/ViewProfile.jspa?name=kvaidya)** commented\n\n`@juergen`.hoeller can you please reopen this issue?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nPlease create a new issue as a follow-up to this one. I'll schedule that new issue for 5.1 RC1 then.\n\nBeing at it, I'll rename this issue here to specifically cover the sorted methods cache that has been introduced in 4.3.18.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a potentially inefficient method of retrieving and caching methods with a more efficient `computeIfAbsent` operation.  The original code retrieved the methods, checked if they were cached, and if not, cached them.  The new code uses `computeIfAbsent` to directly cache the methods if they aren't already present, avoiding the redundant `if` check and the separate `put` operation.  This change improves performance by reducing unnecessary checks and operations",
            "avg_logprobs": -0.28742041336862667
        }
    },
    {
        "commit_hash": "e38c020535dc5d6b326d5e22f8a59dc35ba7361a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (anns[i] != otherAnns[i]) {\n+\t\t\t\tif (!annotationEquals(anns[i], otherAnns[i])) {\n+\tprivate boolean annotationEquals(Annotation ann, Annotation otherAnn) {\n+\t\t// Annotation.equals is reflective and pretty slow, so let's check identity and proxy type first.\n+\t\treturn (ann == otherAnn || (ann.getClass() == otherAnn.getClass() && ann.equals(otherAnn)));\n+\t}\n+",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "TypeDescriptor efficiently matches equal annotations as well",
        "commit_body": "Issue: SPR-15060\n",
        "linked_issues": [
            {
                "issue_id": "19626",
                "issue_title": "Annotated method argument matching performance issue [SPR-15060]",
                "issue_body": "**[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell)** opened **[SPR-15060](https://jira.spring.io/browse/SPR-15060?redirect=false)** and commented\n\nPossibly related to #19496\n\n```\n@SpringBootApplication\npublic class So41346616Application {\n\n\tpublic static void main(String[] args) {\n\t\tConfigurableApplicationContext context = SpringApplication.run(So41346616Application.class, args);\n\t\tMessageChannel annotated = context.getBean(\"annotated\", MessageChannel.class);\n\t\tMessageChannel notAnnotated = context.getBean(\"notAnnotated\", MessageChannel.class);\n\t\tMessage<?> foo = new GenericMessage<>(\"foo\");\n\t\tStopWatch watch = new StopWatch();\n\t\twatch.start();\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tannotated.send(foo);\n\t\t}\n\t\twatch.stop();\n\t\twatch.start();\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tnotAnnotated.send(foo);\n\t\t}\n\t\twatch.stop();\n\t\twatch.start();\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tannotated.send(foo);\n\t\t}\n\t\twatch.stop();\n\t\tSystem.out.println(\"Annotated: \" + watch.getTaskInfo()[0].getTimeMillis() +\n\t\t\t\t\" not: \" + watch.getTaskInfo()[1].getTimeMillis() +\n\t\t\t\t\" second annotated: \" + watch.getTaskInfo()[2].getTimeMillis());\n\t\tcontext.close();\n\t}\n\n\t@ServiceActivator(inputChannel = \"annotated\")\n\tpublic void with(@Payload String payload) {\n\t}\n\n\t@ServiceActivator(inputChannel = \"notAnnotated\")\n\tpublic void without(String payload) {\n\t}\n\n}\n```\n\n`Annotated: 3521 not: 36 second annotated: 11202`\n\nYourkit pointed me to `ConcurrentReferenceHashMap` and we're getting cache misses and adding new entries for each invocation.\n\n---\n\n**Affects:** 4.3.5\n\n**Reference URL:** http://stackoverflow.com/questions/41346616/spring-boot-starter-integration-1-4-3-performance-degradation\n\n**Attachments:**\n- [Screen Shot 2016-12-27 at 10.36.03 AM.png](https://jira.spring.io/secure/attachment/23669/Screen+Shot+2016-12-27+at+10.36.03+AM.png) (_247.62 kB_)\n- [Screen Shot 2016-12-27 at 12.13.01 PM.png](https://jira.spring.io/secure/attachment/23670/Screen+Shot+2016-12-27+at+12.13.01+PM.png) (_187.09 kB_)\n\n**Issue Links:**\n- #19762 Performance Issue with `@ModelAttribute` (_**\"is duplicated by\"**_)\n- #19496 ConversionService performance regression\n- #19410 AnnotationFormatterFactory should support `@AliasFor`\n- #19493 Improve performance for conversions using a method parameter based type descriptor with annotations\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/e38c020535dc5d6b326d5e22f8a59dc35ba7361a, https://github.com/spring-projects/spring-framework/commit/794580ffcdcce68bba114bd639cba60658a9da63\n\n3 votes, 9 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell)** commented\n\nAfter further debugging, the issue is we never get a hit on the cache because `TypeDescriptor.annotationsMatch()` returns false, even though both descriptors have the \"same\" annotation (but different instances).\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell), could it be that you're not caching the `MethodParameter` instances that you're repeatedly building a `TypeDescriptor` for there? We currently assume cached `MethodParameter` instances for repeated invocations there, since we're actively caching them in all affected places in the core framework.\n\nOf course, we shouldn't have such a regression just because of new `MethodParameter` instances, and I'm going to look at what we can do there. Apparently `Method.getParameterAnnotations()` returns fresh annotation instances every time (not caching them like other annotation lookups in the core reflection APIs), failing our identity check.\n\nThat said, I nevertheless highly recommend `MethodParameter` caching in Spring Integration, in particular if `Method.getParameterAnnotations()` indeed creates fresh annotation instances every time! The annotation creation overhead is worth avoiding there in its own right.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAdding a full `Annotation.equals` check after the identity check in `TypeDescriptor.annotationsMatch` solves the problem. However, this comes at the price of reflective attribute comparisons even in unique cases if there are several methods with the same number of annotations, so I'm still trying to optimize this.\n\nAs per my comment above, all those problems disappear - even cutting down the invocation overhead by a factor of six - when cached `MethodParameter` objects are passed in.\n",
                    "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** commented\n\nJuergen,\n\nThank you for digging this and for the update.\nGary is on PTO this week, although he is on-line from time to time. So, he may provide some feedback eventually.\n\nBut let me share my current concerns if that helps.\n\nWe don't create `MethodParameter` instances all the time. We do that only once during initialization to build a SpEL expression based on the method signature. Everything rest is done via SpEL engine at runtime: https://github.com/spring-projects/spring-integration/blob/master/spring-integration-core/src/main/java/org/springframework/integration/util/MessagingMethodInvokerHelper.java#L692\n\nSo, I'm not sure that our problem is around `MethodParameter`...\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI'm pretty sure that the problem is different `Annotation` instances for the same method parameters, and that can only really come from repeated `Method.getParameterAnnotations()` calls, e.g. through repeated `MethodParameter` creation. In other words, if a shared `MethodParameter` instance came in for each unique declared parameter, you wouldn't see the cache misses in `TypeDescriptor` indicated by Gary above.\n\nIt's worth debugging this in Spring Integration, finding out about potential repeated `MethodParameter` instantiation and repeated `Method.getParameterAnnotations()` calls for repeated invocations of the same handler method. If nothing turns up there, we might indeed have a different problem.\n",
                    "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** commented\n\nJuergen,\n\ndoes it say anything to you?\n\n```\nstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,\n\t\t\tInteger varargsPosition) throws EvaluationException {\n\n\tboolean conversionOccurred = false;\n\tif (varargsPosition == null) {\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i));\n\t\t\tObject argument = arguments[i];\n\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t}\n      }\n...\n```\n\nThat is where I see `new MethodParameter` in my call stack on each `expression.getValue()`.\n",
                    "**[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) thanks for looking at this. FYI We have a planned activity to move from SpEL to `InvocableHandlerMethod` s for this functionality (at least as an - preferred - option), but that is currently planned for 5.0 only because it's a pretty big change.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nOk, that clarifies it indeed: You're going through SpEL's generic resolution algorithm there which indeed recreates `MethodParameter` instances every time... I'll sort this out through an `Annotation.equals` fallback in `TypeDescriptor`. So your present approach will work properly again as of Spring Framework 4.3.6.\n\nAs a side note, I have no idea why `Method.getParameterAnnotations()` creates fresh `Annotation` instances on every call. Annotations on a `Method` and `Constructor` itself and also on a `Field` are cached by the JVM and therefore prepared for identity comparisons. Just parameter-level annotations aren't :-(\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe check for annotation identity, then same annotation proxy class, then reflective `Annotation.equals` now. This is efficient enough for shared annotations and covers non-identical but equal parameter annotations as well.\n",
                    "**[Gary Russell](https://jira.spring.io/secure/ViewProfile.jspa?name=grussell)** commented\n\nThanks [Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) I have confirmed that we are back to 4.3.3 level performance.\n",
                    "**[Mike Noordermeer](https://jira.spring.io/secure/ViewProfile.jspa?name=miken)** commented\n\nIt seems that this bug causes a massive memory leak for us, with 4.3.5. The convertercache contains millions of elements, taking up 500+MB heap space. Not 100% sure it is this bug, but I will try with 4.3.6 to see if that fixes the issue.\n",
                    "**[Mike Noordermeer](https://jira.spring.io/secure/ViewProfile.jspa?name=miken)** commented\n\nI can confirm upgrading to Spring 4.3.6 fixes the problem. For us the problem was not in Spring Integration, but in a `@ModelAttribute` method using `@RequestParam` parameters, like this:\n\n```\n    @ModelAttribute\n    private void populateModel(@RequestParam(required = false) boolean note1Enabled,\n                               @RequestParam(required = false) boolean note2Enabled,\n                               @RequestParam(required = false) boolean note3Enabled,\n...\n```\n\nThis causes a new cache entry for each method execution / parameter. Maybe this is something that needs to be looked into, if the parameter annotations are expected to be cached.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces a direct comparison of annotations (`anns[i] != otherAnns[i]`) with a call to a new `annotationEquals` method.  This new method first checks for reference equality (`ann == otherAnn`) and then, if they are not the same object, checks if they are of the same class and if their `equals` method returns `true`",
            "avg_logprobs": -0.13801210403442382
        }
    },
    {
        "commit_hash": "e3bb06c8783ca45633ee361bb637cc3236471479",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/event/ApplicationListenerMethodAdapter.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (this.method.getParameters().length == 0) {\n+\t\tif (this.method.getParameterTypes().length == 0) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid Java8 API",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces `this.method.getParameters().length` with `this.method.getParameterTypes().length` in the `if` condition.  This likely corrects a potential bug where the method was checking the *parameter names* instead of the *parameter types*.  The `getParameterTypes()` method returns an array of the parameter types, which is the correct way to determine if a method has no parameters",
            "avg_logprobs": -0.13547472726731075
        }
    },
    {
        "commit_hash": "e4539d9f4003bee0f3cd31dd70b87a32ffb95884",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessor.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (methodParam.getParameterAnnotation(RequestBody.class).required()) {\n+\t\t\tif (checkRequired(methodParam)) {\n+\tprotected boolean checkRequired(MethodParameter methodParam) {\n+\t\treturn methodParam.getParameterAnnotation(RequestBody.class).required();\n+\t}\n+",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Add protected method for required RequestBody",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code refactored the `RequestResponseBodyMethodProcessor` to extract the check for the `@RequestBody` annotation's `required` flag into a separate method called `checkRequired`.  This improves code organization and potentially allows for future reuse of the `required` check logic.  The original inline check is now encapsulated",
            "avg_logprobs": -0.17518627109812268
        }
    },
    {
        "commit_hash": "e45d33f9de595d7348f3b4695960cb26bd9255c0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\tif (!isRunning() || this.stopCallback != null) {\n+\t\t\t\t// Not started, already stopped, or previous stop attempt in progress\n+\t\t\t\t// -> return immediately, no stop process to control anymore.\n+\t\t\t\tcallback.run();\n+\t\t\t\treturn;\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DefaultMessageListenerContainer immediately invokes stop callback when not running",
        "commit_body": "Issue: SPR-14233\n",
        "linked_issues": [
            {
                "issue_id": "18807",
                "issue_title": "DefaultLifecycleProcessor hangs on shutdown when stopping with internalJmsListenerEndpointRegistry [SPR-14233]",
                "issue_body": "**[Dirk](https://jira.spring.io/secure/ViewProfile.jspa?name=h3rmanns)** opened **[SPR-14233](https://jira.spring.io/browse/SPR-14233?redirect=false)** and commented\n\nWe are having the following configuration:\n\n- 2 JMSListener\n- XA Transactions with Atomikos or Bitronix\n- Spring Boot 1.3.3\n\nThe application runs fine but after shutdown, the DefaultLifecycleProcessor is waiting 30 seconds and then prints:\n\n```java\n43621 [Thread-7] WARN  org.springframework.context.support.DefaultLifecycleProcessor  - Failed to shut down 1 bean with phase value 2147483647 within timeout of 30000: [org.springframework.jms.config.internalJmsListenerEndpointRegistry]\n```\n\nThis happens only, if one of the JMSListener gets stopped before by doing:\n\n```java\nJmsListenerEndpointRegistry registry = context.getBean(JmsListenerEndpointRegistry.class);\nregistry.getListenerContainer(\"MyListener1\").stop();\n```\n\nIf I comment one listener out, or keep both JMSListener running - the timeout does not happen and the application shuts down immediately.\n\nThe app hangs even if no work has been processed. I reduced the JMSListener\nto contain no own business logic at all:\n\n```java\npublic class MyListener {\n\n\t// Die ID wird benoetigt, damit der Listener programmatisch gestoppt werden kann\n\tprotected static final String ID = \"MyListener1\";\n\n\t@JmsListener(id = ID, destination=\"MYQUEUE\")\n\tpublic void receiveMessage(Message msg) {\n\t\tSystem.out.println(\"Hello!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n\t}\n}\n```\n\nThe problem arises both with Atomikos and Bitronix.\n\nSo to me, it looks like you need to have 2 JMSListeners and need to stop one of them to reproduce this problem.\n\nAny help would be appreciated.\n\n\n---\n\n**Affects:** 4.2.5\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/85675fbe2e8c3418d3f8eb6124a13fbdfb9553a2, https://github.com/spring-projects/spring-framework/commit/85faeef8168baa62beb471be8add5ec539de22f5, https://github.com/spring-projects/spring-framework/commit/09b45d2c0feee9ebdc7c03e3768cf834bf81a195, https://github.com/spring-projects/spring-framework/commit/e45d33f9de595d7348f3b4695960cb26bd9255c0, https://github.com/spring-projects/spring-framework/commit/f83cbff543b3519c9288c1eee0ed3ae7e4c749d2\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nThanks for the report, I was able to reproduce the issue. Investigating...\n",
                    "**[Dirk](https://jira.spring.io/secure/ViewProfile.jspa?name=h3rmanns)** commented\n\nGreat - first step to find a solution ;-)\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nAlright, the issue is fixed on master. [Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller) can you please backport that to `4.2.x`?\n\nIt turns out that `DefaultMessageListenerContainer` was not honouring the stop callback in a particular scenario that was revealed by your use case. Could you please try again in a couple of hours once `4.3.0.BUILD-SNAPSHOT` is available? Or you could wait for the backport and test with `4.2.6.BUILD-SNAPSHOT`. We're releasing these this week so a confirmation would be much appreciated.\n",
                    "**[Dirk](https://jira.spring.io/secure/ViewProfile.jspa?name=h3rmanns)** commented\n\nWow - that was really fast! Thanks! I will test it on 4.2.6.BUILD-SNAPSHOT. I will let you know if that's working now for us!\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nA `4.2.6.BUILD-SNAPSHOT` including this fix will be available in about half an hour.... Indeed, please give it a try once available!\n",
                    "**[Dirk](https://jira.spring.io/secure/ViewProfile.jspa?name=h3rmanns)** commented\n\nI would expect that this not completely fixes my issues, since the hang-up happens even if I restart the MessageListenerContainer again. But I will give it a try ;-) .\n",
                    "**[Dirk](https://jira.spring.io/secure/ViewProfile.jspa?name=h3rmanns)** commented\n\nAm I looking in the wrong place, or is the build still from yesterday 13:20 o'clock?\n\nhttp://repo.spring.io/snapshot/org/springframework/spring-core/4.3.0.BUILD-SNAPSHOT/spring-core-4.3.0.BUILD-20160502.132016-367.jar\nand\nhttp://repo.spring.io/snapshot/org/springframework/spring-core/4.2.6.BUILD-SNAPSHOT/spring-core-4.2.6.BUILD-20160502.132143-47.jar\n\nBut comparing the time,  that could nevertheless contain your changes, does it?\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nBoth builds have completed successfully within 24h so they will contain the fix. Have you tried and it didn't work so you're asking if the fix is in? That's quite confusing...\n",
                    "**[Dirk](https://jira.spring.io/secure/ViewProfile.jspa?name=h3rmanns)** commented\n\nSorry for the confusion and yes, I tried this version already yesterday and still had problems.\nBut it must have been my fault - today the error messages are completely vanished. I can stop/start MessageListenerContainer like a charme and stopping\nthe Spring-Boot Application does not lead to hangs anymore.\n\nThanks for this quick fix and your great work! I know why we are planning to switch from JEE/Appservers to Spring/Spring-Boot wherever possible ;-)\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nAlright, that's great to hear. Thanks for testing!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check to `DefaultMessageListenerContainer` to immediately return and execute a callback (`callback.run()`) if the container isn't running or a stop operation is already in progress.  This prevents further processing and ensures that a stop operation isn't unnecessarily attempted or interfered with",
            "avg_logprobs": -0.2692884322135679
        }
    },
    {
        "commit_hash": "e48ec4fcd333a3f2149f8966b367e51322d9ff90",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\tif (checkGetParameterType) {\n+\t\t\t\t\tif (checkGetParameterType &&\n+\t\t\t\t\t\t\t!(jdbcDriverName.startsWith(\"Oracle\") && dbmd.getDriverMajorVersion() >= 12)) {\n+\t\t\t\t\t\t// Register JDBC driver with no support for getParameterType, except for the\n+\t\t\t\t\t\t// Oracle 12c driver where getParameterType fails for specific statements only\n+\t\t\t\t\t\t// (so an exception thrown above does not indicate general lack of support).",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "StatementCreatorUtils always tries getParameterType on Oracle 12c driver",
        "commit_body": "Issue: SPR-13825\n",
        "linked_issues": [
            {
                "issue_id": "18398",
                "issue_title": "Oracle 12c JDBC driver throws inconsistent exception from getParameterType (affecting setNull calls) [SPR-13825]",
                "issue_body": "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tom.jahncke@gfs.com)** opened **[SPR-13825](https://jira.spring.io/browse/SPR-13825?redirect=false)** and commented\n\nThis relates to: #15726\n\nUsing the oracle driver (ojdbc7 version 12.1.0.2.0) I ran across the following issue (I opened a support case with Oracle on the root cause of the issue.  SR 3-11927085951)\n\nNormally the Oracle driver works fine with following code:\n\n```\nsqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex); (from setNull in StatementCreatorUtils line 262)  \n```\n\nHowever, it is possible for a statement to cause Oracle to throw an exception than then all statements going forward no longer use the JDBC 3.0 features to resolve the sql data type for null values.\n\nI understand why driversWithNoSupportForGetParameterType exists and how it helps performance.  However, since it is black or white once an exception is thrown the setNull never tries to use the JDBC 3.0 features again (until the app is restarted).\n\nI can think of a few hackish ways to address this, but I am hoping you can come with a solid solution that is solid  (My hackish ideas are along the lines or allowing a driver name to be injected that doesn't get added to the global set of drivers not supported.)\n\nFYI, just by having an insert statement with a qualified table name causes the following exception with the oracle JDBC driver.  (Without qualification no exception.):\n\n```\njava.sql.SQLFeatureNotSupportedException: Unsupported feature\n\tat oracle.jdbc.driver.OracleParameterMetaData.checkValidIndex(OracleParameterMetaData.java:176)\n\tat oracle.jdbc.driver.OracleParameterMetaData.getParameterType(OracleParameterMetaData.java:327)\n\tat org.springframework.jdbc.core.StatementCreatorUtils.setNull(StatementCreatorUtils.java:262)\n```\n\n---\n\n**Affects:** 4.2.4\n\n**Attachments:**\n- [Oralce-JDBC-Bug 22983939.pdf](https://jira.spring.io/secure/attachment/23517/Oralce-JDBC-Bug+22983939.pdf) (_186.38 kB_)\n\n**Issue Links:**\n- #16013 PreparedStatement#getParameterMetaData() calls may trigger unwanted side effects\n- #17488 Regression in handling of String passed as Types.OTHER to JdbcTemplate\n- #15726 performancedrop due to repeated JDBC 3.0 getParameterType calls in setNull in StatementCreatorUtils\n- #16854 INSERT SELECT of large CLOB causes ORA-01461 on setString\n- #18688 Java boolean is not handled correctly when used with Oracle JDBC driver\n- #18764 Regression: Insert statement fails with inconsistent datatypes on Oracle 12c driver\n- #19143 Avoid repeated getParameterType calls for setNull with Oracle 12c driver\n- #19196 Protect against getParameterType cursor leak with Oracle 12c JDBC driver\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/e48ec4fcd333a3f2149f8966b367e51322d9ff90, https://github.com/spring-projects/spring-framework/commit/e1bdf5577e94616786e07d6bcf7d424399dd2704\n\n0 votes, 6 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI suppose we will go with explicit detection of compliant Oracle JDBC driver versions where we can reliably assume that they do support `getParameterType`, so a `SQLFeatureNotSupportedException` can be considered as a temporary exception that does not indicate general lack of support.\n\nThat said, the Oracle driver's choice of exception is really misleading there. It means to say \"not supported for this particular statement\" but chooses to throw an exception that indicates general lack of a particular JDBC feature... Anyway, even if that exception remains, we can certainly work around it.\n\nJuergen\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tom.jahncke@gfs.com)** commented\n\nI agree that Oracle choice is very misleading and that getParameterType should work even when the table name is qualified.  Thank you for looking into this so quickly!\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAddressed through a `getDriverMajorVersion` check for 12 and above on the Oracle JDBC driver. I'll backport this to 4.2.x right away; please give the upcoming `4.2.5.BUILD-SNAPSHOT` a try and let me know whether it works for you in your actual Oracle scenario!\n\nJuergen\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tom.jahncke@gfs.com)** commented\n\nI tested the fix with 4.2.5.BUILD-SNAPSHOT and it worked well.  Thank you again for the quick turn around on this fix!!\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, thanks for the immediate feedback!\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWhile this has been backported to 4.2.x, we won't backport it to the 3.2.x line since many other recent JDBC refinements haven't been backported there either. Generally, please upgrade to 4.2+ for proper Oracle 12 support.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Tom.Jahncke@gfs.com](https://jira.spring.io/secure/ViewProfile.jspa?name=Tom.Jahncke@gfs.com), since we have a side effect of this reported in #18764, could you please clarify whether you are using the Oracle 12 JDBC driver against an actual Oracle 12 database there?\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke)** commented\n\nThis was against a 11.2.0.4 Oralce database with the Oracle 12 JDBC driver.  FYI, Oracle did eventually acknowledge this bug and created a patch for the underlying bug, however, that won't be part of their standard JDBC driver until the next official release of their driver.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAlright, thanks for the clarification... It looks like the Oracle 12 driver not only sometimes throws exceptions against the Oracle 11 database but even sometimes returns invalid values (according to #18764). We'll see what we can do to workaround that part.\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke)** commented\n\nOracle JDBC has yet another bug :(  This results in a cursor leak when the getParameterMetaData method throws an exception.  The cursor leak in my situation was noticed when the program was getting java.sql.SQLException: ORA-01000: maximum open cursors exceeded.\n\nOracle does have a patch for this as for April 2016.  You can look up oracle doc: \"Cursor Leak / ORA-1000 From PreparedStatement.getMetaData() Method On Malformed Statements (Doc ID 2124104.1)\" at support.oracle.com for more information.\n\nI am commenting here for visibility sake, as the Oracle docs don't show up in a Google search and I spend an entire day dealing with this.  Hopefully, this saves someone else time.\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke)** commented\n\n`@Juergen` Hoeller, based on what I found and represented in the previous comment I am wondering if this feature needs to rolled back (or replace with a property that can be turned on to always attempt to use the meta data from the prepared statement.)  I am concerned when users of Spring upgrade to 4.2.5+ they will have the potential for a cursor leak which could be a ticking time bomb for the database session.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe have \"spring.jdbc.getParameterType.ignore\" already... Do you see a need for something beyond that?\n\nThe behavior was a bit weird before when we would only stop trying `getParameterType` once one of Oracle 12c's exceptions gets thrown from it... so we might use it for hours and then suddenly stop using it. The revised behavior that we currently have is more predictable from that perspective.\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke)** commented\n\nI agree with what you stated.  The risk / challenge is that every time getParameterMetaData throws an exception Oracle is leaving an open cursor behind, shame Oracle. Oracle has been aware of this bug since 2014 and they have a one off patch you can apply, but you have to seek this out.  This will not be transparent to users and may not even be noticed until application gets to production.  What makes this even worse is Oracle seems to have lots of situations where the SQL runs fine, but the getParameterMetaData throws an exception :(\n\nI am aware of spring.jdbc.getParameterType.ignore, what i was suggesting was a parameter like spring.jdbc.getParameterType.always (default to false) and then remove the Oracle driver / version check in StatementCreatorUtils and instead check to see if this variable is set.\n\nBy the way, I am content leaving the code the way it is as it is working for me because I have applied the patch from Oracle.  I am just attempting to consider the larger community.  I leave the decision in your very capable hands.\n\n",
                    "**[Felix Barnsteiner](https://jira.spring.io/secure/ViewProfile.jspa?name=axe-felix)** commented\n\nAfter upgrading to the latest spring version I also ran into the ticking time bomb of `java.sql.SQLException: ORA-01000` where after a while my application would not be able to respond to requests anymore. Setting `spring.jdbc.getParameterType.ignore` helped, but it took me a while to figure out what was going on. I'd suggest to revert or rethink this change. Just for the record, I'm using oracle driver 12.1.0.2 with Oracle 11.2.0.4.0.\n",
                    "**[Gopi Popuri](https://jira.spring.io/secure/ViewProfile.jspa?name=gpopuri81@gmail.com)** commented\n\nWe are also facing java.sql.SQLException: ORA-01000  after upgrading the latest version.. Our configuration also same as Felix..\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've created #19196 as a follow-up to this issue, considering more defensive - but still consistent - default behavior when running against Oracle 12c. It seems the only way out is to deactivate all `getParameterType` access by default against that driver version, opting in through explicitly setting `spring.jdbc.getParameterType.ignore` to `false` instead (which would then consistently use `getParameterType` even if sometimes an exception gets thrown, as per the intent of the original issue here).\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nFrom all reports above and in #18764, it seems that this only occurs with the Oracle 12.x JDBC driver against an Oracle 11.x database system. Has anybody got insight into whether this happens against an Oracle 12.x database as well? [Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke), does the Oracle support ticket for the patch mention affected database versions?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nA similar kind of leak for `getTables` seems to happen against both database versions: https://community.oracle.com/thread/3774048\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tom.jahncke@gfs.com)** commented\n\nThe Oracle docs on the bug are related to the JDBC driver affects RDMBS version 12.1.0.2 (in addition to the issues we are seeing with 11.2.0.4 RDMBS versions.)\n\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tom.jahncke@gfs.com)** commented\n\nHere is the Oracle write up on the bug.  They do have a patch for this, but you have to contact Oracle directly :(  They only make new version of the JDBC driver in conjunction with a new version of the database.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nSo they're only going to ship that fix once an Oracle 13 JDBC driver gets released? Which might take a further year or two? **sigh**\n\nWith the recent reports here and considering that #18764 is still open, it looks like we have no other choice than to ignore `getParameterType` on Oracle 12c by default. I intend to do that consistently though, not even trying `getParameterType` unless we get an explicit opt-in.\n\nIt's a shame that such an old JDBC feature - dating back to JDBC 3.0 in JDK 1.4, making it 14 years old (!) - still does not work properly today :-(\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tom.jahncke@gfs.com)** commented\n\nI think they would release the patch when the release 12.2 (which was suppose to be this summer, but I believe is delayed.)\n\nI fully agree it is such a shame and makes me even more disappointed in Oracle.\n\nI agree with your proposed approach.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nRevised for 4.3.3 and 4.2.8 now: `StatementCreatorUtils` does not use `getParameterType` on any Oracle driver by default now. If you're on 12c (possibly 12.2 or a custom patch) and would like it to be used, specify `spring.jdbc.getParameterType.ignore=false`. Since those calls seem to be expensive as well, it is arguably better to only use them when actually needed anyway.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke), all, this is available in the latest `4.3.3.BUILD-SNAPSHOT` and `4.2.8.BUILD-SNAPSHOT` now. Please give it a try, both with no custom setting at all (which should restore pre-4.2.5 behavior in a more consistent form through never attempting a getParameterType call on Oracle by default) and with a `spring.jdbc.getParameterType.ignore=false` override (which should reveal the leak again - or work fine if you got a patched driver).\n",
                    "**[Kuassi Mensah](https://jira.spring.io/secure/ViewProfile.jspa?name=kmensah)** commented\n\nFull disclosure: I work for Oracle.\n\nRegarding the following comment\nThey only make new version of the JDBC driver in conjunction with a new version of the database.`@Mention` someone by typing their name...\nI'd like to say that this is untrue, we furnish patches for bugs all the time for customers with a support contract however, if the expectation is to make these patches available on OTN, that's not the purpose of OTN (iow, it is not the place to get bug fixes).\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke)** commented\n\n`@Kuassi` Mensah, what I was trying to indicate that when a bug is fixed the standard oracle JDBC driver jar does get the patch until the next major release (such as 12.2).  So, customers of Oracle have to encounter the bug first hand and they look for a patch if one exists for their issue.\n",
                    "**[Kuassi Mensah](https://jira.spring.io/secure/ViewProfile.jspa?name=kmensah)** commented\n\nBug fixes are also picked up by intermediate patchsets (4th digit) e.g., 12.1.0.2.\n",
                    "**[Tom Jahncke](https://jira.spring.io/secure/ViewProfile.jspa?name=tjahncke)** commented\n\n`@Kuassi`, are bugs release for the JDBC Oracle driver independently of the patchset for the Oracle database?  My disappointment with Oracle is that I encounter this issue which they had a patch for that was was released months before I encounter the issue.  So, I had to encounter the pain just to find out there was a patch I could request and apply.  This took several hours (probably days worth of wasted time.)  There are obviously others encountering the same Oracle JDBC driver bug and wasting time when there is a known fix.\n\n`@Jurergen`, if this is way off topic feel free to tell us to take up this discussion off line.\n",
                    "**[Kuassi Mensah](https://jira.spring.io/secure/ViewProfile.jspa?name=kmensah)** commented\n\nYes, bug fixes are posted indepedently of patch sets and available in a repository for supported customers.\n\nI understand your frustration; your experience is not the way things work. When you submit a technical assistance request (a.k.a. TAR), the support engineer should, after investigation, tell you whether this is a bug or not; if so, whether ther already is a fix or not; if so, point you to the fix. THis should only take the time o investigate the TAR and the time to pull the  fix and apply.\n\nBest, Kuassi\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `if` statement.  Previously, the code checked only if `checkGetParameterType` was true.  Now, it also checks if the JDBC driver is Oracle 12c or higher.  If both conditions are true, the code block is skipped",
            "avg_logprobs": -0.2080703544616699
        }
    },
    {
        "commit_hash": "e53c2c6331be891b19bf90fc8cc0d2c194d88615",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ClassUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (lastDotIndex != -1) {\n+\t\t\tint previousDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR, lastDotIndex -1);\n+\t\t\tif (lastDotIndex != -1 && previousDotIndex != 1 && Character.isUpperCase(name.charAt(previousDotIndex + 1))) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduce nested class lookups in ClassUtils",
        "commit_body": "Prior to this commit, `ClassUtils#forName` would always attempt to\nresolve the given class name as a nested type. For example, searching\nfor `org.example.Spring` would try to resolve:\n\n* `org.example.Spring`\n* if not available, try `org.example$Spring` as well\n\nJava classes usually start with uppercase letters, so this additional\nlookup can be costly and not very useful.\n\nThis commit only attempts nested class lookups when the previous segment\nstarts with an uppercase. So `org.example.Spring.Issue` will look for\n`org.example.Spring$Issue`, but `org.example.Spring` will not.\n\nCloses gh-31258\n",
        "linked_issues": [
            {
                "issue_id": "31258",
                "issue_title": "Reduce nested class lookups in ClassUtils",
                "issue_body": "While working on #31213, I have noticed that Framework performs more class lookups than we thought.\r\n\r\nFor example, we need to register reflection on `jakarta.inject.Inject` types; even if the type is not present on the classpath at build time, the application might try to load it at runtime anyway. If the class is not present at runtime, `ClassUtils#forName` will try to load both `jakarta.inject.Inject` and `jakarta.inject$Inject`.\r\n\r\nWhile I understand the rationale for nested classes, I think we need to consider the following proposals:\r\n\r\n1. This is the expected behavior, so we'll need to amend our reflection hints engine to automatically register nested class variants no matter what. This could be the best solution for our 6.0.x branch.\r\n2. As part of 6.1, we could consider toning things down and only attempting to resolve nested classes if the previous segment starts with a capital letter (which is more typical for a class name), like `org.example.Spring.Issue` -> `org.example.Spring$Issue`. This could also benefit most JVM applications by reducing the amount of unnecessary lookups.\r\n3. Eliminate nested classes entirely; I'm not sure this is the right approach as we're likely to break existing apps for no added benefit.\r\n\r\nAny opinion @jhoeller @snicoll ?",
                "issue_state": "closed",
                "issue_comment": [
                    "Only trying the nested class syntax in case of an upper-case segment before looks like a good way out, covering the common cases that we are trying to optimize for.",
                    "Thanks Juergen, I'll use this issue to apply that change in 6.1."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the conditional logic for determining if a class name represents a package.  It now checks if the character immediately following the *second-to-last* dot in the class name is an uppercase letter.  This suggests a more refined approach to identifying package names, potentially addressing edge cases or improving accuracy compared to the previous `if (lastDotIndex != -1)` condition.  The addition of `previousDotIndex` and the `Character",
            "avg_logprobs": -0.27562143325805666
        }
    },
    {
        "commit_hash": "e5475d698a8a861a03a18c24de16e3e4f0d22f72",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/PropertyEditorRegistrySupport.java",
        "change_type": [
            "Add_Condition",
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tfor (Iterator<Class<?>> it = this.customEditors.keySet().iterator(); it.hasNext() && editor == null;) {\n-\t\t\t\t\tClass<?> key = it.next();\n+\t\t\t\tfor (Map.Entry<Class<?>, PropertyEditor> entry : this.customEditors.entrySet()) {\n+\t\t\t\t\tif (editor != null) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tClass<?> key = entry.getKey();\n-\t\t\t\t\t\teditor = this.customEditors.get(key);\n+\t\t\t\t\t\teditor = entry.getValue();",
        "change_count": 9,
        "condition_type": [
            "condition",
            "iteration"
        ],
        "commit_subject": "Iterate over Map's entrySet() instead of keySet() in PropertyEditorRegistrySupport",
        "commit_body": "Closes gh-27591\n",
        "linked_issues": [
            {
                "issue_id": "27591",
                "issue_title": "Iterate over Map.entrySet() instead of Map.keySet() in PropertyEditorRegistrySupport",
                "issue_body": "Tiny optimization is possible using `Map.entrySet()` instead of `Map.keySet()`",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `5.3.x` and `main`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces an iterator-based `for` loop with an enhanced `for` loop (using `Map.Entry`) to iterate through the `customEditors` map.  This change removes the need for a separate `editor` variable to track the null state, improving readability and potentially performance by avoiding the extra `get()` call in the original loop.  The original loop also had a redundant check (`it",
            "avg_logprobs": -0.3245669174194336
        }
    },
    {
        "commit_hash": "e565d2cabb01539933195b0d1bc3b55992fb9c84",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/support/PropertySourcesPlaceholderConfigurer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (this.ignoreUnresolvablePlaceholders && (this.environment instanceof ConfigurableEnvironment)) {\n-\t\t\t\t\tConfigurableEnvironment configurableEnvironment = (ConfigurableEnvironment) this.environment;\n+\t\t\t\tif (this.ignoreUnresolvablePlaceholders &&\n+\t\t\t\t\t\t(this.environment instanceof ConfigurableEnvironment configurableEnvironment)) {",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply \"instanceof pattern matching\" in PropertySourcesPlaceholderConfigurer",
        "commit_body": "See gh-27947\n",
        "linked_issues": [
            {
                "issue_id": "27947",
                "issue_title": "PropertySourcesPlaceholderConfigurer ignores ignoreUnresolvablePlaceholders flag",
                "issue_body": "## Overview\r\n\r\nIf a `PropertySourcesPlaceholderConfigurer` bean has its `ignoreUnresolvablePlaceholders` flag set to `true`, that flag is not always honored when asking the `Environment` to resolve a property containing placeholders.\r\n\r\nAs a consequence, given a property declared as `my.app.var = ${var}` _without_ a corresponding `var` property declared, an attempt to resolve `@Value(\"${my.app.var}\")` will result in the following exception.\r\n\r\n```\r\njava.lang.IllegalArgumentException: Could not resolve placeholder 'var' in value \"${var}\"\r\n```\r\n\r\n## Related Issues\r\n\r\n- #9628\r\n\r\n## Deliverables\r\n\r\n- [x] Ensure that unresolvable placeholders are always ignored if the `ignoreUnresolvablePlaceholders` flag in `PropertySourcesPlaceholderConfigurer` is set to `true`.\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an unnecessary cast.  The original code cast `this.environment` to `ConfigurableEnvironment` twice within the `if` block.  The updated code uses a more concise conditional expression, casting `this.environment` only once and assigning the result to the variable `configurableEnvironment` directly within the `if` condition. This improves readability and avoids redundant casting",
            "avg_logprobs": -0.22834971043970678
        }
    },
    {
        "commit_hash": "e7f89f87c14bb65a83518508a791dc68e681ddd4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/StringUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (parts.length >= 2) {\n+\t\tif (parts.length > 2) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Fix off-by-one error in parseLocaleString",
        "commit_body": "Fix off-by-one error in StringUtils.parseLocaleString()\n\nIssue: SPR-10364\n",
        "linked_issues": [
            {
                "issue_id": "14996",
                "issue_title": "Off by one error in StringUtils.parseLocaleString [SPR-10364]",
                "issue_body": "**[Zhihong Zhang](https://jira.spring.io/secure/ViewProfile.jspa?name=zhihong)** opened **[SPR-10364](https://jira.spring.io/browse/SPR-10364?redirect=false)** and commented\n\nIf you have locale \"`fr_fr`\", Spring will change it into \"`fr_fr_fr`\". The bug is in this method in `StringUtils.java`,\n\n```java\npublic static Locale parseLocaleString(String localeString) {\n        String[] parts = tokenizeToStringArray(localeString, \"_ \", false, false);\n        String language = (parts.length > 0 ? parts[0] : \"\");\n        String country = (parts.length > 1 ? parts[1] : \"\");\n        validateLocalePart(language);\n        validateLocalePart(country);\n        String variant = \"\";\n        if (parts.length >= 2) {\n                // There is definitely a variant, and it is everything after the country\n                // code sans the separator between the country code and the variant.\n                int endIndexOfCountryCode = localeString.indexOf(country) + country.length();\n                // Strip off any leading '_' and whitespace, what's left is the variant.\n                variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));\n                if (variant.startsWith(\"_\")) {\n                        variant = trimLeadingCharacter(variant, '_');\n                }\n        }\n        return (language.length() > 0 ? new Locale(language, country, variant) : null);\n}\n```\n\nIt assumes that language and country are never the same but in case of \"fr_fr\", they are the same.\n\n\n---\n\n**Affects:** 3.1 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/e7f89f87c14bb65a83518508a791dc68e681ddd4\n\n1 votes, 3 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\nHave you tried the latest Spring 3.2 release? It looks like this bug might be a duplicate of #14056.\n",
                    "**[Zhihong Zhang](https://jira.spring.io/secure/ViewProfile.jspa?name=zhihong)** commented\n\nJust checked lastest release v3.2.1.RELEASE and the bug is fixed.\n\nHowever, the code still has a logic bug. This condition is wrong,\n\n    if (parts.length >= 2) {\n\nIt should be\n\n    if (parts.length > 2) {\n\nWhen there are only 2 parts, there is no variant. You can mark it as fixed.\n",
                    "**[Stevo Slavi\u0107](https://jira.spring.io/secure/ViewProfile.jspa?name=sslavic)** commented\n\nBetter change issue type from bug to improvement.\nI've created [a pull request](https://github.com/SpringSource/spring-framework/pull/255) which optimizes parsing locale string, to skip variant processing when it's clear that locale string doesn't contain variant part.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement.  The original code checked if `parts.length` was *greater than or equal to 2*.  The change now checks if `parts.length` is *greater than 2*.  This means the code will now execute the block of code within the `if` statement only when there are *three or more* elements in the `parts` array, rather than two or more.  This likely affects the logic that operates on the array elements.",
            "avg_logprobs": -0.16253177642822267
        }
    },
    {
        "commit_hash": "e83d495cbba0796b1f2269b9ad7a02ffac1ca5a8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/SimpleAliasRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (resolvedAlias.equals(resolvedName)) {\n+\t\t\t\tif (resolvedAlias == null || resolvedName == null || resolvedAlias.equals(resolvedName)) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "SimpleAliasRegistry prevents NPE for alias resolved to null",
        "commit_body": "Issue: SPR-13016\n",
        "linked_issues": [
            {
                "issue_id": "17607",
                "issue_title": "NPE for alias resolved to null in SimpleAliasRegistry [SPR-13016]",
                "issue_body": "**[David J. M. Karlsen](https://jira.spring.io/secure/ViewProfile.jspa?name=david@davidkarlsen.com)** opened **[SPR-13016](https://jira.spring.io/browse/SPR-13016?redirect=false)** and commented\n\nUseCase:\nI have to override a property (during integration-testing) to be null instead of another value defined in a propertyfile for use with the propertyplaceholderconfigurer.\nWhen doing so this will result in a NPE at SimpleAliasRegistry in line 125 here:\n\n```\nif (resolvedAlias.equals(resolvedName)) {\n\t\t\t\t\tthis.aliasMap.remove(alias);\n\t\t\t\t}\n```\n\nbecause resolvedAlias is null\n\n\n---\n\n**Affects:** 3.2.13, 4.1.6\n\n**Backported to:** [3.2.14](https://github.com/spring-projects/spring-framework/milestone/102?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for `resolvedAlias` and `resolvedName` before the equality check.  Previously, if either `resolvedAlias` or `resolvedName` was null, a `NullPointerException` could have been thrown.  The addition of the null checks prevents this exception",
            "avg_logprobs": -0.08477635383605957
        }
    },
    {
        "commit_hash": "e8486e2afe6e49f5597313da8a4e4f37e2029bc2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/asm/TypePath.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+                if (i < n && typePath.charAt(i) == ';') {\n+                    i += 1;\n+                }\n-     * argument index in decimal form.\n+     * argument index in decimal form followed by ';'.\n-                result.append(getStepArgument(i));\n+                result.append(getStepArgument(i)).append(';');",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Tracking ASM 5.0.4 development: Fix for ASM issue 317539",
        "commit_body": "Issue: SPR-12255\n",
        "linked_issues": [
            {
                "issue_id": "16869",
                "issue_title": "Tracking ASM 5.0.4 development [SPR-12255]",
                "issue_body": "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** opened **[SPR-12255](https://jira.spring.io/browse/SPR-12255?redirect=false)** and commented\n\n* Fix for ASM issue 317539 (http://forge.ow2.org/tracker/?func=detail&aid=317539&group_id=23&atid=100023)\n\n---\n\n**Issue Links:**\n- #17076 Tracking ASM 5.0.4 development (continued)\n\n**Backported to:** [4.0.8](https://github.com/spring-projects/spring-framework/milestone/120?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how argument indices are handled in `TypePath`.  Previously, the argument index was extracted without considering a trailing semicolon.  The change now explicitly checks for and consumes a trailing semicolon (';') after the argument index, indicating a change in the expected input format.  The argument index extraction function (`getStepArgument`) is now used, followed by appending the semicolon to the result",
            "avg_logprobs": -0.23822559356689454
        }
    },
    {
        "commit_hash": "e870c9a39251898f0747f9a591595134bbd16278",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerExecutionChain.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.web.context.request.async.AbstractDelegatingCallable;\n-\t\t\t\t\tchain.addDelegatingCallable(asyncInterceptor.getAsyncCallable(request, response, this.handler));\n+\t\t\t\t\tAbstractDelegatingCallable callable = asyncInterceptor.getAsyncCallable(request, response, this.handler);\n+\t\t\t\t\tif (callable != null) {\n+\t\t\t\t\t\tchain.addDelegatingCallable(callable);\n+\t\t\t\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Reduce logging in HandlerExecutionChain",
        "commit_body": "Before this change the HandlerExecitionChain logged errors each time a\nan AsyncHandlerInterceptor returned a null async Callable, a condition\nwhich is acceptable.\n\nSPR-9524\n",
        "linked_issues": [
            {
                "issue_id": "14158",
                "issue_title": "Excessive logging if AsyncHandlerInterceptor#getAsyncCallable returns null [SPR-9524]",
                "issue_body": "**[Peter De Wachter](https://jira.spring.io/secure/ViewProfile.jspa?name=pdewacht)** opened **[SPR-9524](https://jira.spring.io/browse/SPR-9524?redirect=false)** and commented\n\nI'm experimenting with the new async servlet support and created an AsyncHandlerInterceptor with a getAsyncCallable method that always returns null. Returning null is allowed according to the JavaDoc.\n\nNow with every request Spring logs the following exception with severity error. The interceptor and the website seem to function normally, but the logging is quite annoying.\n\n2012-06-20 17:52:15,154 ERROR [http-bio-443-exec-22] o.s.w.s.HandlerExecutionChain [HandlerExecutionChain.java:176] HandlerInterceptor.addAsyncCallables threw exception\njava.lang.IllegalArgumentException: Callable required\nat org.springframework.util.Assert.notNull(Assert.java:112) ~[spring-core-3.2.0.M1.jar:3.2.0.M1]\nat org.springframework.web.context.request.async.AsyncExecutionChain.addDelegatingCallable(AsyncExecutionChain.java:130) ~[spring-web-3.2.0.M1.jar:3.2.0.M1]\nat org.springframework.web.servlet.HandlerExecutionChain.addDelegatingCallables(HandlerExecutionChain.java:173) ~[spring-webmvc-3.2.0.M1.jar:3.2.0.M1]\nat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:944) [spring-webmvc-3.2.0.M1.jar:3.2.0.M1]\nat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:859) [spring-webmvc-3.2.0.M1.jar:3.2.0.M1]\nat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:883) [spring-webmvc-3.2.0.M1.jar:3.2.0.M1]\nat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:792) [spring-webmvc-3.2.0.M1.jar:3.2.0.M1]\n[...]\n\n\n---\n\n**Affects:** 3.2 M1\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/e870c9a39251898f0747f9a591595134bbd16278\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a null check before adding an `AbstractDelegatingCallable` to the `HandlerExecutionChain`.  Previously, the `asyncInterceptor.getAsyncCallable()` result was directly added to the chain.  Now, a check ensures that the returned callable is not null before adding it. This prevents potential `NullPointerExceptions`",
            "avg_logprobs": -0.16377904835869284
        }
    },
    {
        "commit_hash": "e87e03c539b13a709a4019369a396949db3ac4e8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (configBeanDefs.isEmpty()) {\n+\t\tif (configBeanDefs.isEmpty() || IN_NATIVE_IMAGE) {\n-\t\tif (IN_NATIVE_IMAGE) {\n-\t\t\tthrow new BeanDefinitionStoreException(\"@Configuration classes need to be marked as \" +\n-\t\t\t\t\t\"proxyBeanMethods=false. Found: \" + configBeanDefs.keySet());\n-\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Refine ConfigurationClassPostProcessor behavior in native images",
        "commit_body": "This commit refines ConfigurationClassPostProcessor behavior in\nnative images by skipping configuration classes enhancement\ninstead of raising an error.\n\nSee spring-projects-experimental/spring-graalvm-native#248 for\nmore details.\n\nCloses gh-26236\n",
        "linked_issues": [
            {
                "issue_id": "26236",
                "issue_title": "Refine ConfigurationClassPostProcessor behavior in native images",
                "issue_body": "This issue intends to refine `ConfigurationClassPostProcessor` behavior in native images by skipping configuration classes enhancement instead of raising an error. See spring-projects-experimental/spring-graalvm-native#248 for more details.",
                "issue_state": "closed",
                "issue_comment": [
                    "I've resolved this in a slightly different way. Thanks for the fix!\n"
                ]
            },
            {
                "issue_id": "248",
                "issue_title": "Fix scope of model attributes when including JSP",
                "issue_body": "Prior to this commit, setting model attribute in controller of\nincluded JSP would result in overwriting the value in parent model if\nthe set value was null.\n\nThis is because the method\nDispatcherServlet.restoreAttributesAfterInclude restores after include\nonly those attributes that are currently present in request, but\nsetting the value to null in child controller leads to removing of the\nattribute from request.\n\nNow the removed attributes are added back after include.\n\nIssue: SPR-10360\n\nI have signed and agree to the terms of the SpringSource Individual\nContributor License Agreement.\n",
                "issue_state": "closed",
                "issue_comment": [
                    "I've resolved this in a slightly different way. Thanks for the fix!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a condition to the `ConfigurationClassPostProcessor` class.  Previously, if the `configBeanDefs` were empty *and* the `IN_NATIVE_IMAGE` flag was true, a `BeanDefinitionStoreException` was thrown.  Now, the exception is only thrown if `configBeanDefs` is empty *and* `IN_NATIVE_IMAGE` is true",
            "avg_logprobs": -0.1633737564086914
        }
    },
    {
        "commit_hash": "e9413b93c6d24a250cc3d67c94f9cd87aef2836a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/BeanFactoryAdvisorRetrievalHelper.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException) {\n-\t\t\t\t\t\t\tBeanCreationException bce = (BeanCreationException) rootCause;\n+\t\t\t\t\t\tif (rootCause instanceof BeanCurrentlyInCreationException bce) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Apply \"instanceof pattern matching\" in BeanFactoryAdvisorRetrievalHelper",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces\\n\\n```java\\nif (rootCause instanceof BeanCurrentlyInCreationException) {\\n    BeanCreationException bce = (BeanCreationException) rootCause;\\n    // ... rest of the code\\n}\\n```\\n\\nwith\\n\\n```java\\nif (rootCause instanceof BeanCurrentlyInCreationException bce) {\\n    // ..",
            "avg_logprobs": -0.05590424537658691
        }
    },
    {
        "commit_hash": "e9819b7535841a27586edfcbe83c5ab1adf47339",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageReaderArgumentResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tif (mediaType.isCompatibleWith(MediaType.APPLICATION_FORM_URLENCODED)) {\n+\t\t\treturn Mono.error(new IllegalStateException(\n+\t\t\t\t\t\"In a WebFlux application, form data is accessed via ServerWebExchange.getFormData().\"));\n+\t\t}\n+",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Raise ISE if @RequestBody is used for form data",
        "commit_body": "Closes gh-22486\n",
        "linked_issues": [
            {
                "issue_id": "22486",
                "issue_title": "@RequestBody raises IllegalStateException for form data",
                "issue_body": "**Affects:** Spring Boot 2.1.3.RELEASE\r\n\r\n---\r\nHello!\r\n\r\nI noticed something interesting. When you make a mistake in WebFlux application, you don't see real exception, instead you see the same exception every-time:\r\n\r\n```\r\n2019-02-27 16:41:41.686 ERROR 28059 --- [or-http-epoll-1] a.w.r.e.AbstractErrorWebExceptionHandler : [2af64f7c] 500 Server Error for HTTP POST \"/hello\"\r\n\r\njava.lang.IllegalStateException: Only one connection receive subscriber allowed.\r\n        at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:271) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:121) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:294) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.core.publisher.FluxPeek.subscribe(FluxPeek.java:83) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:294) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoCollectList.subscribe(MonoCollectList.java:59) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFilterFuseable.subscribe(MonoFilterFuseable.java:44) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n...\r\n```\r\n\r\n\r\nExample controller:\r\n\r\n```java\r\npackage app.controllers;\r\n\r\nimport org.springframework.web.bind.annotation.PostMapping;\r\nimport org.springframework.web.bind.annotation.RequestBody;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HelloWorld {\r\n\r\n    @PostMapping(\"/hello\")\r\n    public String handle(@RequestBody String body)  {\r\n        System.out.printf(\"\\n\\n\\nbody: %s\\n\\n\\n\\n\", body);\r\n        return \"Hello WebFlux\";\r\n    }\r\n}\r\n```\r\n\r\nIf you make correct request you will see correct response:\r\n\r\n```\r\n$ curl -i -w \"\\n\\n\" -XPOST -d \"asd\" -H \"Content-Type: application/json\" http://localhost:8080/hello\r\nHTTP/1.1 200 OK\r\nContent-Type: text/plain;charset=UTF-8\r\nContent-Length: 13\r\n\r\nHello WebFlux\r\n```\r\n\r\nIf you make a mistake you will receive 500 and lot's of logs that don't tell you what has happened:\r\n\r\n```\r\ncurl -i -w \"\\n\\n\" -XPOST -d \"asd\" http://localhost:8080/hello\r\nHTTP/1.1 500 Internal Server Error\r\nContent-Type: application/json;charset=UTF-8\r\nContent-Length: 16111\r\n\r\n{\"timestamp\":\"2019-02-27T16:12:13.095+0000\",\"path\":\"/hello\",\"status\":500,\"error\":\"Internal Server Error\",\"message\":\"Only one connection receive subscriber allowed.\",\"trace\":\"java.lang.IllegalStateException: Only one connection receive subscriber allowed.\\n\\tat reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:271)\\n\\tat reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:121)\\n\\tat reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62)\\n\\tat reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132)\\n\\tat reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:294)\\n\\tat \r\n\r\n...\r\n```\r\n\r\nYou can see the same exception in application logs:\r\n\r\n<details>\r\n\r\n```\r\n2019-02-27 17:12:13.109 ERROR 32312 --- [or-http-epoll-3] a.w.r.e.AbstractErrorWebExceptionHandler : [8aba656e] 500 Server Error for HTTP POST \"/hello\"\r\n\r\njava.lang.IllegalStateException: Only one connection receive subscriber allowed.\r\n        at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:271) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:121) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:294) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.core.publisher.FluxPeek.subscribe(FluxPeek.java:83) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:294) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.core.publisher.FluxMap.subscribe(FluxMap.java:62) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoCollectList.subscribe(MonoCollectList.java:59) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFilterFuseable.subscribe(MonoFilterFuseable.java:44) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoSubscriberContext.subscribe(MonoSubscriberContext.java:47) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoMapFuseable.subscribe(MonoMapFuseable.java:59) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoDefaultIfEmpty.subscribe(MonoDefaultIfEmpty.java:37) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Mono.subscribe(Mono.java:3694) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoZip.subscribe(MonoZip.java:128) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.drain(MonoIgnoreThen.java:153) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:56) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoPeekFuseable.subscribe(MonoPeekFuseable.java:74) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnErrorResume.subscribe(MonoOnErrorResume.java:44) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoNext$NextSubscriber.onNext(MonoNext.java:76) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.innerNext(FluxConcatMap.java:275) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxConcatMap$ConcatMapInner.onNext(FluxConcatMap.java:849) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:114) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Operators$ScalarSubscription.request(Operators.java:2070) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:438) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.request(FluxMap.java:155) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.request(FluxOnAssembly.java:438) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.set(Operators.java:1878) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onSubscribe(Operators.java:1752) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:422) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.onSubscribe(FluxMap.java:86) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:422) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoJust.subscribe(MonoJust.java:54) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoCallableOnAssembly.subscribe(MonoCallableOnAssembly.java:82) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoMap.subscribe(MonoMap.java:55) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Mono.subscribe(Mono.java:3694) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.drain(FluxConcatMap.java:442) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxConcatMap$ConcatMapImmediate.onSubscribe(FluxConcatMap.java:212) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onSubscribe(FluxOnAssembly.java:422) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:139) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:63) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxConcatMap.subscribe(FluxConcatMap.java:121) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly.subscribe(FluxOnAssembly.java:132) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoNext.subscribe(MonoNext.java:40) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoSwitchIfEmpty.subscribe(MonoSwitchIfEmpty.java:44) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:60) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoOnAssembly.subscribe(MonoOnAssembly.java:61) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:150) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoProcessor.onNext(MonoProcessor.java:389) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onNext(FluxSwitchIfEmpty.java:67) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxContextStart$ContextStartSubscriber.onNext(FluxContextStart.java:103) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:287) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:331) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:353) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1505) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.MonoCollectList$MonoBufferAllSubscriber.onComplete(MonoCollectList.java:118) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:363) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:363) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:252) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:363) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:136) ~[reactor-core-3.2.6.RELEASE.jar:3.2.6.RELEASE]\r\n        at reactor.netty.channel.FluxReceive.terminateReceiver(FluxReceive.java:372) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:196) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:337) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:334) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.http.server.HttpServerOperations.onInboundNext(HttpServerOperations.java:453) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:141) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at reactor.netty.http.server.HttpTrafficHandler.channelRead(HttpTrafficHandler.java:191) ~[reactor-netty-0.8.5.RELEASE.jar:0.8.5.RELEASE]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:438) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:323) ~[netty-codec-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:297) ~[netty-codec-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:253) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1408) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:930) ~[netty-transport-4.1.33.Final.jar:4.1.33.Final]\r\n        at io.netty.channel.epoll.AbstractEpollStreamChannel$EpollStreamUnsafe.epollInReady(AbstractEpollStreamChannel.java:799) ~[netty-transport-native-epoll-4.1.33.Final-linux-x86_64.jar:4.1.33.Final]\r\n        at io.netty.channel.epoll.EpollEventLoop.processReady(EpollEventLoop.java:427) ~[netty-transport-native-epoll-4.1.33.Final-linux-x86_64.jar:4.1.33.Final]\r\n        at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:328) ~[netty-transport-native-epoll-4.1.33.Final-linux-x86_64.jar:4.1.33.Final]\r\n        at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905) ~[netty-common-4.1.33.Final.jar:4.1.33.Final]\r\n        at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_201]\r\n        Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: \r\nAssembly trace from producer [reactor.core.publisher.FluxMap] :\r\n        reactor.core.publisher.Flux.map(Flux.java:5689)\r\n        reactor.netty.ByteBufFlux.fromInbound(ByteBufFlux.java:70)\r\nError has been observed by the following operator(s):\r\n        |_      Flux.map \u21e2 reactor.netty.ByteBufFlux.fromInbound(ByteBufFlux.java:70)\r\n        |_      Flux.doOnNext \u21e2 reactor.netty.ByteBufFlux.retain(ByteBufFlux.java:282)\r\n        |_      Flux.map \u21e2 org.springframework.http.server.reactive.ReactorServerHttpRequest.getBody(ReactorServerHttpRequest.java:166)\r\n        |_      Flux.collectList \u21e2 org.springframework.core.io.buffer.DataBufferUtils.join(DataBufferUtils.java:438)\r\n        |_      Mono.filter \u21e2 org.springframework.core.io.buffer.DataBufferUtils.join(DataBufferUtils.java:439)\r\n        |_      Mono.map \u21e2 org.springframework.core.io.buffer.DataBufferUtils.join(DataBufferUtils.java:440)\r\n        |_      Mono.map \u21e2 org.springframework.core.codec.AbstractDataBufferDecoder.decodeToMono(AbstractDataBufferDecoder.java:68)\r\n        |_      Mono.error \u21e2 org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver.lambda$readBody$4(AbstractMessageReaderArgumentResolver.java:186)\r\n        |_      Mono.onErrorResume \u21e2 org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver.readBody(AbstractMessageReaderArgumentResolver.java:186)\r\n        |_      Mono.switchIfEmpty \u21e2 org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver.readBody(AbstractMessageReaderArgumentResolver.java:188)\r\n        |_      Mono.defaultIfEmpty \u21e2 org.springframework.web.reactive.result.method.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:192)\r\n        |_      Mono.doOnError \u21e2 org.springframework.web.reactive.result.method.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:193)\r\n        |_      Mono.zip \u21e2 org.springframework.web.reactive.result.method.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:200)\r\n        |_      Mono.flatMap \u21e2 org.springframework.web.reactive.result.method.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:135)\r\n        |_      Mono.defer \u21e2 org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.handle(RequestMappingHandlerAdapter.java:199)\r\n        |_      Mono.then \u21e2 org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.handle(RequestMappingHandlerAdapter.java:199)\r\n        |_      Mono.doOnNext \u21e2 org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.handle(RequestMappingHandlerAdapter.java:200)\r\n        |_      Mono.doOnNext \u21e2 org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.handle(RequestMappingHandlerAdapter.java:201)\r\n        |_      Mono.error \u21e2 org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.handleException(RequestMappingHandlerAdapter.java:234)\r\n        |_      Mono.onErrorResume \u21e2 org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter.handle(RequestMappingHandlerAdapter.java:202)\r\n        |_      Mono.flatMap \u21e2 org.springframework.web.reactive.DispatcherHandler.handle(DispatcherHandler.java:151)\r\n        |_      Mono.flatMap \u21e2 org.springframework.web.reactive.DispatcherHandler.handle(DispatcherHandler.java:152)\r\n        |_      Mono.defer \u21e2 org.springframework.web.server.handler.DefaultWebFilterChain.filter(DefaultWebFilterChain.java:119)\r\n        |_      Mono.flatMap \u21e2 org.springframework.web.filter.reactive.HiddenHttpMethodFilter.filter(HiddenHttpMethodFilter.java:90)\r\n        |_      Mono.defer \u21e2 org.springframework.web.server.handler.DefaultWebFilterChain.filter(DefaultWebFilterChain.java:119)\r\n\r\n```\r\n\r\n</details>\r\n\r\n---\r\n\r\nThis exception is masking real problem and causing a lot of confusion. I noticed that there is a lot issues that mention this exception, so this seems like a widespread problem: https://github.com/spring-projects/spring-framework/issues?q=is%3Aissue+Only+one+connection+receive\r\n\r\nWould it be possible to present real exception in logs to make debugging easier?\r\n\r\nThanks!",
                "issue_state": "closed",
                "issue_comment": [
                    "This exception happens when your application is trying to read twice the request body, and this is forbidden as this would work against backpressure support. Many things can lead to this particular symptom, so this is why you're seeing this error multiple times in our tracker. This doesn't mean the same problem is widespread.\r\n\r\nIn your case, your `curl` request is sending the request body with `Content-Type: application/x-www-form-urlencoded`; Spring Boot has an auto-configured `WebFilter` that parses the form request and makes it available for binding. Then the request is mapped to a controller handler that asks for the full request body with `@RequestBody`. This is where the problem comes from.\r\n\r\nI'll leave this issue opened for now, in case we can get a clearer message for this particular case.\r\n\r\n",
                    "I think we could get a better message. \r\n\r\nThis is happening in `AbstractMessageReaderArgumentResolver`, so one option would be to anticipate the issue for `@RequestBody` arguments , in `handleReadError` we could check if the content-type is `application/x-www-form-urlencoded` and if the error message contains \"only one connection\", and if so extend the error message to also say \"This could be because ...\".\r\n\r\nAlternatively, we could make the same check from `HiddenHttpMethodFilter` itself on the way out and enhance the error message.\r\n\r\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check for `MediaType.APPLICATION_FORM_URLENCODED`.  If the media type is compatible, it now throws an `IllegalStateException` explaining that form data should be accessed using `ServerWebExchange.getFormData()`.  This change likely aims to improve clarity and consistency in how form data is handled in a Spring WebFlux application",
            "avg_logprobs": -0.11210025323403848
        }
    },
    {
        "commit_hash": "ec4e6e0b0e84d11f9e5abaf092d5bcb7410d8a52",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\telse if (sqlType == Types.VARCHAR || sqlType == Types.LONGVARCHAR ||\n-\t\t\t\t(sqlType == Types.CLOB && isStringValue(inValue.getClass()))) {\n+\t\telse if (sqlType == Types.VARCHAR || sqlType == Types.NVARCHAR ||\n+\t\t\t\tsqlType == Types.LONGVARCHAR || sqlType == Types.LONGNVARCHAR ||\n+\t\t\t\t((sqlType == Types.CLOB || sqlType == Types.NCLOB) && isStringValue(inValue.getClass()))) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "StatementCreatorUtils populates NVARCHAR, LONGNVARCHAR, NCLOB via setString as well",
        "commit_body": "Issue: SPR-11938\n",
        "linked_issues": [
            {
                "issue_id": "16555",
                "issue_title": "Support for Types.NCLOB in SqlLobValue to simplify use with NamedParameterJdbcTemplate. [SPR-11938]",
                "issue_body": "**[Oleksandr Gavenko](https://jira.spring.io/secure/ViewProfile.jspa?name=gavenkoa)** opened **[SPR-11938](https://jira.spring.io/browse/SPR-11938?redirect=false)** and commented\n\nThe only way to avoid LobHandler in DAO code for insert/update:\n\n```java\nMapSqlParameterSource paramSource = new MapSqlParameterSource();\nparamSource.addValue(\"clob\", \"a long long text\", Types.CLOB);\nnamedTemplate.update(INSERT_STMT, paramSource);\n```\n\nSee:\n\n* http://stackoverflow.com/questions/5791662/inserting-clob-with-namedparameterjdbctemplate\n* http://codeblow.com/questions/placing-clob-with-namedparameterjdbctemplate/\n\nanother way (only for JdbcTemplate, not for NamedParameterJdbcTemplate):\n\n* http://docs.spring.io/spring/docs/3.0.x/reference/jdbc.html#jdbc-lob\n* http://www.java2s.com/Code/Java/Spring/InsertClobData.htm\n\njava.sql.Types has NCLOB constans for Java 6/7/8:\n\n* http://docs.oracle.com/javase/6/docs/api/java/sql/Types.html#NCLOB\n* http://docs.oracle.com/javase/7/docs/api/java/sql/Types.html#NCLOB\n\nIf I do:\n\n`paramSource.addValue(\"clob\", \"a long long text\", Types.CLOB);`\n\nall work fine, but with:\n\n`paramSource.addValue(\"clob\", \"a long long text\", Types.NCLOB);`\n\nI get:\n\n```java\n=> Fail to add incidentjava.lang.ClassCastException: java.lang.String cannot be cast to oracle.sql.CLOB\n   at oracle.jdbc.driver.OraclePreparedStatement.setObjectCritical(OraclePreparedStatement.java:8762) ~[ojdbc6.jar:11.2.0.3.0]\n   at oracle.jdbc.driver.OraclePreparedStatement.setObjectInternal(OraclePreparedStatement.java:8286) ~[ojdbc6.jar:11.2.0.3.0]\n   at oracle.jdbc.driver.OraclePreparedStatement.setObject(OraclePreparedStatement.java:8868) ~[ojdbc6.jar:11.2.0.3.0]\n   at oracle.jdbc.driver.OraclePreparedStatementWrapper.setObject(OraclePreparedStatementWrapper.java:240) ~[ojdbc6.jar:11.2.0.3.0]\n   at org.springframework.jdbc.core.StatementCreatorUtils.setValue(StatementCreatorUtils.java:406) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.StatementCreatorUtils.setParameterValueInternal(StatementCreatorUtils.java:234) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.StatementCreatorUtils.setParameterValue(StatementCreatorUtils.java:149) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.PreparedStatementCreatorFactory$PreparedStatementCreatorImpl.setValues(PreparedStatementCreatorFactory.java:298) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.PreparedStatementCreatorFactory$PreparedStatementCreatorImpl.createPreparedStatement(PreparedStatementCreatorFactory.java:251) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:583) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:818) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:840) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n   at org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.update(NamedParameterJdbcTemplate.java:281) ~[spring-jdbc-3.2.8.RELEASE.jar:3.2.8.RELEASE]\n```\n\nActual type of table column is NCLOB, and with Type.CLOB code work fine.\n\nMy suggestion just add NCLOB to `src/main/java/org/springframework/jdbc/core/StatementCreatorUtils.java` with same role as CLOB!\n\n---\n\n**Affects:** 3.2.9, 4.0.5\n\n**Issue Links:**\n- #20702 When using NamedParameterJdbcTemplate, NVARCHAR or NCLOB(4000 characters or less) columns are not properly populated since StatementCreatorUtils does setString for these types instead of setNString.\n- #13215 Can't insert into nvarchar2 using SimpleJdbcInsert whereas it works with SimpleJdbcTemplate\n- #16854 INSERT SELECT of large CLOB causes ORA-01461 on setString\n\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point! StatementCreatorUtils populates NVARCHAR, LONGNVARCHAR, NCLOB via setString as well now.\n\nJuergen\n",
                    "**[Oleksandr Gavenko](https://jira.spring.io/secure/ViewProfile.jspa?name=gavenkoa)** commented\n\nHi! I apply your changes on top of 3.x series:\n\n```\ngit diff  ec4e6e0^! >.diff\ngit reset --hard origin/3.2.x \npatch -p1 <.diff\ngradle\n```\n\nand test my application with Type.NCLOB. All fine, thanks!\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds support for `Types.NVARCHAR`, `Types.LONGNVARCHAR`, and `Types.NCLOB` to the `StatementCreatorUtils` class's conditional logic for determining the SQL type of a value.  Previously, only `VARCHAR`, `LONGVARCHAR`, and `CLOB` were considered string types.  The updated `else if` block now correctly handles a wider range of string-based SQL types",
            "avg_logprobs": -0.15313300132751465
        }
    },
    {
        "commit_hash": "eca87b87de8445feab00dd4e98a634ece6c80e20",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/BridgeMethodResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tif (!candidateParameter.equals(genericParameter.toClass())) {\n+\t\t\tif (!ClassUtils.resolvePrimitiveIfNecessary(candidateParameter).equals(ClassUtils.resolvePrimitiveIfNecessary(genericParameter.toClass()))) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Improve Kotlin support in BridgeMethodResolver#findBridgedMethod",
        "commit_body": "This commit adds support for Kotlin non-nullable type which resolves\nto primitive Java types in BridgeMethodResolver#findBridgedMethod.\n\nCloses gh-26585\n",
        "linked_issues": [
            {
                "issue_id": "26585",
                "issue_title": "BridgeMethodResolver#isBridgeMethodFor return incorrect result for kotlin code in certain circumstance",
                "issue_body": "<!--\r\n!!! For Security Vulnerabilities, please go to https://spring.io/security-policy !!!\r\n-->\r\n**Affects:** v5.3.4\r\n---\r\n<!--\r\nThanks for taking the time to create an issue. Please read the following:\r\n\r\n- Questions should be asked on Stack Overflow.\r\n- For bugs, specify affected versions and explain what you are trying to do.\r\n- For enhancements, provide context and describe the problem.\r\n\r\nIssue or Pull Request? Create only one, not both. GitHub treats them as the same.\r\nIf unsure, start with an issue, and if you submit a pull request later, the\r\nissue will be closed as superseded.\r\n-->\r\n\r\nIn kotlin, non-nullable Int is compiled to java primitive type int, this cause the condition `candidateParameter.equals(genericParameter.toClass()` always evaluates to `false`. so `org.springframework.core.BridgeMethodResolver#findBridgedMethod` fails to find the correct bridge method.\r\n\r\n![screenshot1](https://user-images.githubusercontent.com/16322831/108648713-e2c0e000-74f6-11eb-9e64-7aba5467c832.png)\r\n\r\n```kotlin\r\nimport org.springframework.stereotype.Repository\r\nimport org.springframework.transaction.annotation.Transactional\r\n\r\ninterface GenericInterface<ID> {\r\n    fun delete(id: ID)\r\n}\r\n\r\nabstract class AbstractGenericClass<ID> : GenericInterface<ID> {\r\n    override fun delete(id: ID) {\r\n    }\r\n}\r\n\r\n@Repository\r\nclass GenericRepository : AbstractGenericClass<Int>() {\r\n    @Transactional\r\n    override fun delete(\r\n            id: Int\r\n    ) {\r\n        error(\"gotcha\")\r\n    }\r\n}\r\n```\r\n\r\nthe above \"GenericRepository\" is compiled to \r\n```java\r\n@Repository\r\n@Metadata(\r\n   mv = {1, 4, 0},\r\n   bv = {1, 0, 3},\r\n   k = 1,\r\n   d1 = {\"\\u0000\\u0018\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0018\\u0002\\n\\u0002\\u0010\\b\\n\\u0002\\b\\u0002\\n\\u0002\\u0010\\u0002\\n\\u0002\\b\\u0002\\b\\u0017\\u0018\\u00002\\b\\u0012\\u0004\\u0012\\u00020\\u00020\\u0001B\\u0005\u00a2\\u0006\\u0002\\u0010\\u0003J\\u0010\\u0010\\u0004\\u001a\\u00020\\u00052\\u0006\\u0010\\u0006\\u001a\\u00020\\u0002H\\u0017\u00a8\\u0006\\u0007\"},\r\n   d2 = {\"Lcom/cpvsn/crud/demo/feat/generic/GenericRepository;\", \"Lcom/cpvsn/crud/demo/feat/generic/AbstractGenericClass;\", \"\", \"()V\", \"delete\", \"\", \"id\", \"crud-kit.crud-kit-demo.main\"}\r\n)\r\npublic class GenericRepository extends AbstractGenericClass {\r\n   @Transactional\r\n   public void delete(int id) {\r\n      String var2 = \"gotcha\";\r\n      boolean var3 = false;\r\n      throw (Throwable)(new IllegalStateException(var2.toString()));\r\n   }\r\n\r\n   // $FF: synthetic method\r\n   // $FF: bridge method\r\n   public void delete(Object var1) {\r\n      this.delete(((Number)var1).intValue());\r\n   }\r\n}\r\n\r\n```\r\n\r\nDue to this issue, the `@Transactional` on `delete(id: Int)` method have no effects at all.\r\nI'm not sure if this project is expected to be compatible with Kotlin code. If it is, then this is a bug, I think I can try to submit a PR to fix it.",
                "issue_state": "closed",
                "issue_comment": [
                    "@jhoeller I have little experience with bridge methods, but based on my initial findings with [this test](https://github.com/sdeleuze/spring-framework/commit/kotlin-bridge-method-fix), my current thinking is that we could add Kotlin specific code path in `BridgeMethodResolver#isResolvedTypeMatch`.\r\n\r\nInstead of just doing `Type[] genericParameters = genericMethod.getGenericParameterTypes()`, we should maybe use `KClass<T>.javaObjectType` in order to get a type that will be compatible with the rest f the logic. In the use case we have here, `java.lang.Integer` would be returned for both Kotlin `Int` and `Int?` types. But I am not sure `KClass<T>.javaObjectType` is exposed in Java, to be checked with Kotlin team.\r\n\r\nI think you mentioned another potential way to fix that, but I can't remember the details. Any thoughts?\r\n\r\n@noob9527 Since you mentioned a PR, any thoughts on what could look like the fix?",
                    "@sdeleuze \r\nI think `ResolvableType.forMethodParameter(genericMethod, i, declaringClass);` will always return a wrapper type.\r\nso we can just wrap `candidateParameter` to its wrapper type before comparing."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a direct comparison of `candidateParameter` and `genericParameter.toClass()` with a comparison after resolving primitive types using `ClassUtils.resolvePrimitiveIfNecessary`.  This suggests a potential improvement in handling primitive types, ensuring that `int` and `Integer`, for example, are considered equivalent.  The original comparison might have led to incorrect results in cases where the types were different wrapper classes for the same primitive",
            "avg_logprobs": -0.1982039971785112
        }
    },
    {
        "commit_hash": "ecce7520fb2cb56494d78dcc6adadb446d51ace7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/config/AnnotationDrivenBeanDefinitionParser.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tfor (Element converter : DomUtils.getChildElementsByTagName(convertersElement, \"bean\")) {\n-\t\t\t\tBeanDefinitionHolder beanDef = parserContext.getDelegate().parseBeanDefinitionElement(converter);\n-\t\t\t\tbeanDef = parserContext.getDelegate().decorateBeanDefinitionIfRequired(converter, beanDef);\n-\t\t\t\tmessageConverters.add(beanDef);\n+\t\t\tfor (Element beanElement : DomUtils.getChildElementsByTagName(convertersElement, new String[] { \"bean\", \"ref\" })) {\n+\t\t\t\tObject object = parserContext.getDelegate().parsePropertySubElement(beanElement, null);\n+\t\t\t\tmessageConverters.add(object);",
        "change_count": 7,
        "condition_type": [
            "iteration"
        ],
        "commit_subject": "Support HttpMessageConverter refs in mvc namespace",
        "commit_body": "Issue: SPR-9469\n",
        "linked_issues": [
            {
                "issue_id": "14104",
                "issue_title": "Add support for <ref> in addition to <bean> for <mvc:message-converters>  [SPR-9469]",
                "issue_body": "**[Jon Kranes](https://jira.spring.io/secure/ViewProfile.jspa?name=jkranes)** opened **[SPR-9469](https://jira.spring.io/browse/SPR-9469?redirect=false)** and commented\n\nAllow <ref==> as well as \\<bean/> for <mvc:message-converters>, in order to allow configuration using existing beans.  This capability already exists for <mvc:interceptors>.\n\n\n---\n\n**Affects:** 3.1 GA\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies how message converters are parsed from XML configuration.  The original code iterated over `<bean>` elements, parsing and adding them to the `messageConverters` list.  The updated code iterates over both `<bean>` and `<ref>` elements, using `parsePropertySubElement` to handle both cases.  This suggests a broader support for referencing beans (via `<ref>`) in addition to defining them directly within the configuration",
            "avg_logprobs": -0.19084386825561522
        }
    },
    {
        "commit_hash": "ececf32c052082724ab86b5d2b567ffc7c137b67",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t}\n-\t\tif (result != null) {\n-\t\t\tfindAnnotationCache.put(cacheKey, result);\n+\t\t\tif (result != null) {\n+\t\t\t\tfindAnnotationCache.put(cacheKey, result);\n+\t\t\t}\n+",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Revert unintentional change in AnnotationUtils",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `}` and restructures the conditional logic.  The original code had an `if` statement followed by a block containing a single line. The change now uses a single-line `if` statement, making the code more concise.  This modification does not change the functionality, only the formatting",
            "avg_logprobs": -0.4428727121064157
        }
    },
    {
        "commit_hash": "edbc1e92129f659b9c59722611065befa705e2fe",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/listener/AbstractPollingMessageListenerContainer.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\tprivate volatile Boolean commitAfterNoMessageReceived;\n-\n-\t\t\t\t// However, don't do this on Tibco since this may lead to a deadlock there.\n-\t * This is a good idea on any JMS provider other than Tibco, which is what\n-\t * this default implementation checks for.\n+\t * This is a good idea on any modern-day JMS provider.\n-\t\tif (this.commitAfterNoMessageReceived == null) {\n-\t\t\tSession target = ConnectionFactoryUtils.getTargetSession(session);\n-\t\t\tthis.commitAfterNoMessageReceived = !target.getClass().getName().startsWith(\"com.tibco.tibjms.\");\n-\t\t}\n-\t\treturn this.commitAfterNoMessageReceived;\n+\t\treturn true;",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid outdated Tibco workaround in shouldCommitAfterNoMessageReceived",
        "commit_body": "Issue: SPR-14697\n",
        "linked_issues": [
            {
                "issue_id": "19261",
                "issue_title": "AbstractPollingMessageListenerContainer's workaround for Tibco causes performance delays during ems failover [SPR-14697]",
                "issue_body": "**[Aihua Zhou](https://jira.spring.io/secure/ViewProfile.jspa?name=aihuazhou)** opened **[SPR-14697](https://jira.spring.io/browse/SPR-14697?redirect=false)** and commented\n\nWe're using DefaultMessageListenerContainer with tibco EMS and transaction enabled,\n\nwhen ems fails over, and there is no messages on ems, then we observer the following behavior:\n\n1. If there are no messages on EMS during failover, and we publish a message well after all clients have reconnected, then the client will still throws TransactionRolledbackException, due to the fact that the polling container does not commit the transaction if it receives no message if it's using Tibco EMS.\n\n2. This is a problem for high concurrency systesm, where we're running over 100 clients.  In this case each client is holding on to a transaction which will be rolled back.  With queue redelivery set to mas of 255 and delivery delay set to 15, it takes over 1 hour for the messages to get reprocessed.\n\nThe issue is caused by the work around that was put in place for a tibco deadlock issue See spring jira below.\n\n#12215\n\nTibco has confirmed that the deadlock issue was fixed in ems 4.4.2, and is no longer present in any supported versions of ems.  Please roll back the special check that was added.\n\n---\n\n**Affects:** 4.1.9, 4.2.4, 4.3.2\n\n**Issue Links:**\n- #12215 JMS integration with Tibco causes deadlock due to commitIfNecessary in AbstractPollingMessageListenerContainer\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/edbc1e92129f659b9c59722611065befa705e2fe, https://github.com/spring-projects/spring-framework/commit/4396b211ce06237a7408a2f5be0177e3e81258c0, https://github.com/spring-projects/spring-framework/commit/53fc1e96c68a7b2469f19f187afe617803218c6e\n\n**Backported to:** [4.2.8](https://github.com/spring-projects/spring-framework/milestone/145?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nFixed in master, and to be backported to our 4.3.3 and 4.2.8 releases next week.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes the conditional logic that previously checked if the JMS provider was Tibco and dynamically determined whether to commit after no message was received.  The code now unconditionally returns `true`, effectively enabling the commit behavior for all JMS providers.  This change eliminates the need for the `commitAfterNoMessageReceived` flag and the associated `if` statement",
            "avg_logprobs": -0.2250564628177219
        }
    },
    {
        "commit_hash": "eef9bc899f859445bbcf93980c7df2df02ed97b3",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webflux/src/main/java/org/springframework/web/reactive/result/view/freemarker/FreeMarkerView.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprotected Mono<Map<String, Object>> getModelAttributes(Map<String, ?> model,\n-\t\t\tServerWebExchange exchange) {\n+\tprotected Mono<Map<String, Object>> getModelAttributes(\n+\t\t\t@Nullable Map<String, ?> model, ServerWebExchange exchange) {\n-\t\t\tif (model.containsKey(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE)) {\n+\t\t\tif (model != null && model.containsKey(SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE)) {\n-\t\t\tMap<String, Object> attributes = new HashMap<>(model);\n+\t\t\tMap<String, Object> attributes = (model != null ? new HashMap<>(model) : new HashMap<>());",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid NPE in FreeMarkerView.getModelAttributes() in spring-webflux",
        "commit_body": "This commit declares the model method parameter as @Nullable and adds\ndefensive guards against a null model argument.\n\nCloses gh-23105\n",
        "linked_issues": [
            {
                "issue_id": "23105",
                "issue_title": "Improve FreeMarker macro support in spring-webflux",
                "issue_body": "## Overview\r\n\r\nThis issue is a followup to gh-23002.\r\n\r\nThe documentation for `spring.ftl` in `spring-webflux` states the following.\r\n\r\n> To take advantage of these macros, the \"requestContextAttribute\" property of the FreeMarkerView class must be set to \"springMacroRequestContext\". This will expose a RequestContext under the name \"springMacroRequestContext\", as needed by the macros in this library.\r\n\r\nAlthough this technically works, it is not as user-friendly as the analogous support in `spring-webmvc`. Specifically, `AbstractTemplateView` (in `spring-webmvc`) provides a dedicated `exposeSpringMacroHelpers` flag for automatically exposing the `RequestContext` as a model attribute for consumption in FreeMarker templates. Since this boolean flag defaults to `true`, users do not have to configure anything special in `FreeMarkerView` to use all supported macros.\r\n\r\nIn contrast, users of `FreeMarkerView` in `spring-webflux` cannot use all supported macros unless they explicitly set the `requestContextAttribute` property of the `FreeMarkerView` to `\"springMacroRequestContext\"`.\r\n\r\nI think this is cumbersome and should be improved.\r\n\r\n## Deliverables\r\n\r\n- [ ] Consider introducing a dedicated `exposeSpringMacroHelpers` flag in template-based views in `spring-webflux` analogous to the support in `spring-webmvc`.\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "@rstoyanchev, I would appreciate your input on this issue before I begin working on it.",
                    "Sounds reasonable.",
                    "Unfortunately this has broken a test in Spring Boot:\r\n\r\n```\r\njava.lang.NullPointerException\r\n\tat org.springframework.web.reactive.result.view.freemarker.FreeMarkerView.getModelAttributes(FreeMarkerView.java:226)\r\n\tat org.springframework.web.reactive.result.view.AbstractView.render(AbstractView.java:203)\r\n\tat org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfigurationReactiveIntegrationTests.lambda$7(FreeMarkerAutoConfigurationReactiveIntegrationTests.java:120)\r\n\tat reactor.core.publisher.FluxFlatMap.trySubscribeScalarMap(FluxFlatMap.java:141)\r\n\tat reactor.core.publisher.MonoFlatMap.subscribe(MonoFlatMap.java:53)\r\n\tat reactor.core.publisher.Mono.block(Mono.java:1519)\r\n\tat org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfigurationReactiveIntegrationTests.render(FreeMarkerAutoConfigurationReactiveIntegrationTests.java:120)\r\n\tat org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfigurationReactiveIntegrationTests.lambda$1(FreeMarkerAutoConfigurationReactiveIntegrationTests.java:62)\r\n\tat org.springframework.boot.test.context.runner.AbstractApplicationContextRunner.accept(AbstractApplicationContextRunner.java:424)\r\n\tat org.springframework.boot.test.context.runner.AbstractApplicationContextRunner.lambda$1(AbstractApplicationContextRunner.java:359)\r\n\tat org.springframework.boot.test.util.TestPropertyValues.applyToSystemProperties(TestPropertyValues.java:129)\r\n\tat org.springframework.boot.test.context.runner.AbstractApplicationContextRunner.lambda$0(AbstractApplicationContextRunner.java:357)\r\n\tat org.springframework.boot.test.context.runner.AbstractApplicationContextRunner.withContextClassLoader(AbstractApplicationContextRunner.java:369)\r\n\tat org.springframework.boot.test.context.runner.AbstractApplicationContextRunner.run(AbstractApplicationContextRunner.java:356)\r\n\tat org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfigurationReactiveIntegrationTests.defaultViewResolution(FreeMarkerAutoConfigurationReactiveIntegrationTests.java:61)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:498)\r\n\tat org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:628)\r\n\tat org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:117)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:184)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:180)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:127)\r\n\tat org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:68)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1249)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\r\n\tat java.util.ArrayList.forEach(ArrayList.java:1249)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)\r\n\tat org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)\r\n\tat org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)\r\n\tat org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)\r\n\tat org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)\r\n\tat org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:229)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:197)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:211)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:191)\r\n\tat org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:137)\r\n\tat org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:89)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:541)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:763)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:463)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:209)\r\n\tSuppressed: java.lang.Exception: #block terminated with an error\r\n\t\tat reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:133)\r\n\t\tat reactor.core.publisher.Mono.block(Mono.java:1520)\r\n\t\t... 62 more\r\n```\r\n\r\nI think the `model` attribute should be `@Nullable` and an additional guard is needed.",
                    "Thanks for bringing this to our attention, @philwebb!\r\n\r\nPlease let me know if the fix in eef9bc899f859445bbcf93980c7df2df02ed97b3 solves the problem.",
                    "Looks good from a glance, I'm just trying to rerun the tests. I'll report back if there's still any problems."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `getModelAttributes` method to handle potential `null` values for the input `model` map.  Previously, the method directly used `model.containsKey()` without checking for `null`, which could have resulted in a `NullPointerException`.  The updated code now first checks if `model` is `null`. If it is, an empty `HashMap` is created; otherwise, a copy of the input `model` is created using `new HashMap<>(model)`.",
            "avg_logprobs": -0.18250591278076173
        }
    },
    {
        "commit_hash": "ef6aef91077901a5ed532ec3e7a55f5e0e554080",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/tags/form/SelectedValueComparator.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\telse if (editor != null && candidate instanceof String) {\n+\n+\t\tif (editor != null && candidate instanceof String) {",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Allow PropertyEditor conversion as fallback for enums",
        "commit_body": "Issue: SPR-16082\n",
        "linked_issues": [
            {
                "issue_id": "20631",
                "issue_title": "Checkbox/RadioButton incorrectly converts collections of enums with a custom converter [SPR-16082]",
                "issue_body": "**[Seth A Wilcox](https://jira.spring.io/secure/ViewProfile.jspa?name=laoseth)** opened **[SPR-16082](https://jira.spring.io/browse/SPR-16082?redirect=false)** and commented\n\nIf you have an a collection of enums, for which you have implemented a custom org.springframework.core.convert.converter.Converter, the values are mapped from the form differently then they are mapped back to it.  When spring reads the values from a submitted form, it runs the value supplied to the tag through the conversionService, so it expects the values to be in the checkbox/radiobox value field that the converter recognizes.  However, when checking if the checkbox/radio button should be checked, it requires the value of the box to match the name() method of the enum, and does not run through the converter when checking for \"equality' to mark the correct boxes checked.  The issue seems to lie in org.springframework.web.servlet.tags.form.SelectedValueComparator.exhaustiveCompare(Object, Object, PropertyEditor, Map<PropertyEditor, Object>)\n\nThe logic first checks if the class we are binding to is an enum, and if it does, it checks against the toString of the enum.  If that doesn't match, it then returns, skipping the PE compare later on, which would use the conversion service to properly convert the string to the appropriate type.\n\nBasically, the else before the PE-Based comparison should be removed, to the conversion service always gets a chance to convert before the comparison\n\n\n---\n\n**Affects:** 4.3.11\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/97c63857c4562e252943c55dbc9a1cb652f98381, https://github.com/spring-projects/spring-framework/commit/ef6aef91077901a5ed532ec3e7a55f5e0e554080\n\n**Backported to:** [4.3.13](https://github.com/spring-projects/spring-framework/milestone/162?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've revised that algorithm accordingly. Could you please give it a try against this afternoon's  `4.3.13.BUILD-SNAPSHOT`?\n",
                    "**[Seth A Wilcox](https://jira.spring.io/secure/ViewProfile.jspa?name=laoseth)** commented\n\nI was able to double check today, and the change in the nightly build fixes the issue.  Thank you\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes an `else if` statement and replaces it with an `if` statement.  This means the code block previously executed only if the `editor` was not null *and* the `candidate` was a String is now executed unconditionally if both conditions are true.  The original `else if` implied a different condition was already met in a previous `if` or `else if` block.  The change eliminates this implicit assumption, potentially altering the flow of execution",
            "avg_logprobs": -0.307669475825146
        }
    },
    {
        "commit_hash": "f07fc76cf30cbfb6ae71134b653f26af9649ea1b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\tif (StringUtils.hasLength(scheme) && !StringUtils.hasLength(host)) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"[\" + uri + \"] is not a valid URI\");\n+\t\t\t\tif (StringUtils.hasLength(scheme) && scheme.startsWith(\"http\") && !StringUtils.hasLength(host)) {\n+\t\t\t\t\tthrow new IllegalArgumentException(\"[\" + uri + \"] is not a valid HTTP URL\");",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Limit scheme/host check in fromUriString to HTTP URLs",
        "commit_body": "Closes gh-26258\n",
        "linked_issues": [
            {
                "issue_id": "26258",
                "issue_title": "UriComponentsBuilder fromUriString cannot parse File URI",
                "issue_body": "Hi!\r\n\r\nI thinl I found a exception after update to spring-boot 2.4.0, 2.4.1.\r\n\r\nA cannot parse a file uri using UriTemplateHandler. Before, in 2.3.x, I could do it.\r\n\r\nA test example is:\r\n\r\n```\r\n @Test\r\n    public void verify() throws MalformedURLException {\r\n        final UriTemplateHandler uriTemplateHandler;\r\n\r\n        DefaultUriBuilderFactory uriFactory = new DefaultUriBuilderFactory();\r\n        uriFactory.setEncodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT);  // for backwards compatibility..\r\n        uriTemplateHandler = uriFactory;\r\n\r\n        URL url = uriTemplateHandler.expand(file.toURI().toString(), Collections.emptyMap()).toURL();\r\n\r\n        assertThat(url.toString()).isEqualTo(file.toURI().toString());\r\n    }\r\n```\r\n\r\nfile  is a File object with value (toString()): /tmp/junit5116856254058695014/arquivo.txt\r\nSorry If I made some mistake.\r\n\r\nThanks",
                "issue_state": "closed",
                "issue_comment": [
                    "Hi,\r\ncaused by a new validation intended for ipv6, I've raised the PR fixing that",
                    "Yes it looks like this dates back to a change for 5.3 under #25334 that adds a similar check to `fromUriString` as in `fromHttpUrl`. However according to RFC 8320, section 2.2, the semantics of URI authority is defined by the scheme. So while for \"http/https\" a host is expected, for other schemes it might not be."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change refines the validation of URIs.  The original `if` statement checked for a scheme and a missing host, throwing a generic `IllegalArgumentException`.  The updated code adds a more specific check: it now only throws the `IllegalArgumentException` if the scheme is \"http\" *and* the host is missing.  This change provides a more targeted error message for HTTP URLs, improving the clarity and usability of the validation",
            "avg_logprobs": -0.2299325942993164
        }
    },
    {
        "commit_hash": "f1345aadf5879659c186a1dac7915f47d6c1cd14",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\tBeanDefinition beanDefinition = this.beanDefinitionMap.get(beanName);\n-\t\t\tif (!beanDefinition.isAbstract() && findAnnotationOnBean(beanName, annotationType) != null) {\n+\t\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n+\t\t\tif (bd != null && !bd.isAbstract() && findAnnotationOnBean(beanName, annotationType) != null) {\n-\t\t\t\t// Ensure bd is non-null due to potential concurrent modification\n-\t\t\t\t// of the beanDefinitionMap.\n+\t\t\t\t// Ensure bd is non-null due to potential concurrent modification of beanDefinitionMap.",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Defensively access existing beanDefinitionMap entries",
        "commit_body": "See gh-22263\n",
        "linked_issues": [
            {
                "issue_id": "22263",
                "issue_title": "DefaultListableBeanFactory.getBean(Class) may throw NoSuchBeanDefinitionException when removeBeanDefinition is being called simultaneously to remove an unrelated bean",
                "issue_body": "We're seeing sporadic NoSuchBeanDefinitionException exceptions out of ApplicationContext's getBean(Class<T>) when in another thread DefaultListableBeanFactory.removeBeanDefinition(String) is being called, for unrelated/different beans. It appears to be a synchronization issue in DefaultListableBeanFactory's implementation (across use of fields beanDefinitionMap and beanDefinitionNames.) I have included a Spring Boot application that reproduces the issue. Having more beans seems to exacerbate the issue, I presume because it increases time to copy beanDefinitionNames in removeBeanDefinition. \r\n\r\nWe're seeing this with spring-beans-5.1.4 and 5.1.3, unknown about older versions than that.\r\n\r\nHere's an unrealistic application that reproduces the condition, which we ran with spring-boot-starter-parent 2.1.2.RELEASE (spring-beans-5.1.4):\r\n\r\n```\r\npackage com.example.demo;\r\n\r\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\r\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\r\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.ApplicationContextAware;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.scheduling.annotation.EnableScheduling;\r\nimport org.springframework.scheduling.annotation.Scheduled;\r\nimport org.springframework.scheduling.annotation.SchedulingConfigurer;\r\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;\r\nimport org.springframework.scheduling.config.ScheduledTaskRegistrar;\r\n\r\n@Configuration\r\n@EnableScheduling\r\n@SpringBootApplication\r\npublic class DemoApplication implements ApplicationContextAware, SchedulingConfigurer {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(DemoApplication.class, args);\r\n    }\r\n\r\n    private ApplicationContext context;\r\n\r\n    public static class Volatile { }\r\n\r\n    @Scheduled(fixedRate = 400)\r\n    public void addAndRemove() {\r\n\r\n        BeanDefinitionRegistry factory = (BeanDefinitionRegistry)context.getAutowireCapableBeanFactory();\r\n\r\n        // Simulate add/remove of some beans in one background thread.\r\n        // Using larger numbers here makes the exception increasingly easier to hit in get().\r\n        for (int i = 0; i < 1000; i++) {\r\n            String beanName = \"volatile\" + i;\r\n            if (factory.containsBeanDefinition(beanName)) {\r\n                factory.removeBeanDefinition(beanName);\r\n            }\r\n            factory.registerBeanDefinition(beanName, BeanDefinitionBuilder.genericBeanDefinition(Volatile.class).getBeanDefinition());\r\n        }\r\n    }\r\n\r\n    public static class Stable { }\r\n\r\n    @Bean\r\n    public Stable stable()\r\n    {\r\n        return new Stable();\r\n    }\r\n\r\n    @Scheduled(fixedRate = 1)\r\n    public void get() {\r\n        try {\r\n            // Here get a bean that is not the one(s) being added/removed. Expect to be able to get\r\n            // it every time.\r\n            context.getBean(Stable.class);\r\n\r\n        } catch (NoSuchBeanDefinitionException e) {\r\n\r\n            // Eventually NoSuchBeanDefinitionException occurs (the missing bean being one of the Volatile ones!)\r\n            // In DefaultListableBeanFactory.removeBeanDefinition the map is modified, then it starts replacing\r\n            // the list w/ new copy. Meanwhile in getBean it iterates across that list in doGetBeanNamesForType,\r\n            // but then gets from the map. They're not in the map anymore.\r\n\r\n            throw new RuntimeException(\"This is the problem\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void setApplicationContext(ApplicationContext applicationContext) {\r\n        context = applicationContext;\r\n    }\r\n\r\n    @Override\r\n    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {\r\n        ThreadPoolTaskScheduler threadPoolTaskScheduler = new ThreadPoolTaskScheduler();\r\n\r\n        // It's necessary to have get() and addAndRemove running on separate threads\r\n        threadPoolTaskScheduler.setPoolSize(2);\r\n        threadPoolTaskScheduler.initialize();\r\n        scheduledTaskRegistrar.setTaskScheduler(threadPoolTaskScheduler);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": [
                    "For real-world context, in our actual application (not the sample I provided here) the number of beans being added/removed is rather small compared to the total number in the application. They are being added/removed in a task scheduler thread, as here. The other threads in the actual application are HTTP request-handling threads that are using ApplicationContext.getBean for service location. There, we are seeing the NoSuchBeanDefinitionException exception occur sporadically when the HTTP request occurs during remove in the background. As in the sample, the bean(s) being located are not those that are being added/removed.",
                    "Is there anything new about this one?\r\nWe are facing the same issue.\r\nIt looks like the doGetBeanNamesForType which loops on the beanDefinitionNames and the removeBeanDefinition are not sychronized well, so removing the definition from one thread may cause another to fail on get."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `DefaultListableBeanFactory` adds a null check for `bd` (the BeanDefinition).  Previously, a `beanDefinition` was retrieved from the `beanDefinitionMap`, and the code proceeded to check for `abstract` status and annotation presence *without* ensuring the `beanDefinition` was not null.  The addition of `if (bd != null)` prevents a potential `NullPointerException` if the `beanDefinitionMap` is modified concurrently",
            "avg_logprobs": -0.213770751953125
        }
    },
    {
        "commit_hash": "f1cbbd2aa80476dc570d3bdf23d589a9a2544a37",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/annotation/TransactionBeanRegistrationAotProcessor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tif (proxyInterfaces.length == 0) {\n-\t\t\t\treturn;\n-\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Remove redundant array length check",
        "commit_body": "Closes gh-33655\n",
        "linked_issues": [
            {
                "issue_id": "33655",
                "issue_title": "Remove unnecessary array length check",
                "issue_body": "This is why I opened PR.\r\n\r\n1. ClassUtils.getAllInterfacesForClass does not return null.\r\n2. Even if the length of proxyInterfaces is 0, no error occurs in the loop.\r\nSo I think that conditional statement is unnecessary.",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a check for empty `proxyInterfaces` array.  Previously, if the array was empty, the method would return immediately.  Now, it proceeds without that check.  This suggests the code was likely refactored to handle the empty case implicitly or the empty case is no longer possible",
            "avg_logprobs": -0.2629049089219835
        }
    },
    {
        "commit_hash": "f27304d785b47f5390230e7ccde028a37989d5ee",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/GenericTypeAwareAutowireCandidateResolver.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tif (targetType == null) {\n+\t\tif (targetType == null || (descriptor.fallbackMatchAllowed() && targetType.hasUnresolvableGenerics())) {\n-\t\tif (descriptor.fallbackMatchAllowed() && targetType.hasUnresolvableGenerics()) {\n-\t\t\treturn descriptor.getDependencyType().isAssignableFrom(targetType.getRawClass());\n-\t\t}\n+\t\t// Full check for complex generic type match...",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid repeated assignability check for raw class on fallback match, since AutowireCandidateResolver is only being called for basic type matches to begin with",
        "commit_body": "Issue: SPR-9965\n",
        "linked_issues": [
            {
                "issue_id": "14599",
                "issue_title": "Autowiring of generic types [SPR-9965]",
                "issue_body": "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** opened **[SPR-9965](https://jira.spring.io/browse/SPR-9965?redirect=false)** and commented\n\nCurrently the container considers `List` and `Map` types being injected as special injection points and uses generics inspection to inject the appropriate Spring beans. However, there's no general support for injecting generic types in a type safe way.\n\nAssuming we have a generic interface:\n\n```\ninterface MyGenericType<T> { ... }\n```\n\nand two Spring beans:\n\n```\nclass IntegerType extends MyGenericType<Integer> { ... }\n\nclass StringType extends MyGenericType<String> { ... }\n```\n\nA client trying to get a special instance of the generic type looking like this:\n\n```\nclass MyClient {\n\n  @Autowired\n  private List<MyGenericType<Integer>> dependencies;\n}\n```\n\ncurrently not only gets injected the `IntegerType` bean but the `StringType` as well which will cause exceptions at runtime. The core reason this is the case is that the `BeanFactory` currently uses `Class<?>` based type information that does not carry the generics information on injection time and selectvely inspects the generics for injection of special types like `List` and `Map`.\n\nThe Spring Data Commons project has a `TypeInformation` abstraction that allows to lazily resolve generics information as it keeps the generics information around when traversing types, property, method parameter and method return types. It could serve as foundation for an improvement of the `BeanFactory`.\n\n---\n\n**Issue Links:**\n- #15601 Introduce ResolvableType Class (_**\"depends on\"**_)\n- #15621 Generic autowiring should support wiring of components with unresolved type variables\n- #10217 autowiring doesn't match generics\n- #16761 Add generics / parameterized type support to ListableBeanFactory getBeanNamesForType/getBeansOfType methods\n\n5 votes, 13 watchers\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Eugene Petrenko](https://jira.spring.io/secure/ViewProfile.jspa?name=jonnyzzz)** commented\n\nI have a similar issue in my project.\nWe used to use EventDispatcher\\<ListenerClass> for type-autowiring.\nUnfortunately it's not possible to have more than one bean of that time at once.\n\nOnce you declare a non-generic class (i.e. ListenerDispatcher implements EventDispatcher\\<ListenerClass>) all generic\ntype information gets available via Java 1.5+ reflections API.\nThis could be used to make Spring to filter out extra beans.\n\nI implemented this logic via SimpleAutowireCandidateResolver. So I replaced autowire candidates resolver of my BeanFactory with a custom resolver that implemented in the following way:\n\nIt returns null for `getSuggestedValue`, still for `isAutowireCandidate` it checks for generic dependency type and decide which if available candidates is suitable.\n",
                    "**[Oliver Drotbohm](https://jira.spring.io/secure/ViewProfile.jspa?name=olivergierke)** commented\n\nSubmitted pull request at https://github.com/SpringSource/spring-framework/pull/186. Have a look at `GenericTypeWiringTests` for a sample of what the newly introduced functionality allows to do.\n",
                    "**[Piotr Findeisen](https://jira.spring.io/secure/ViewProfile.jspa?name=pofin)** commented\n\nLooks quite similar to #10217\n",
                    "**[Didier Villevalois](https://jira.spring.io/secure/ViewProfile.jspa?name=ptitjes)** commented\n\nFantastic! Could we have Olivier's commit soon in a release ?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis has been rolled into a master now, in a fresh implementation with minimal impact onto the framework's SPIs. To be released in 4.0 RC1 soon!\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nQuick note:\n\nIt's not actually pushed yet since I had a last-minute test failure in a different corner of the framework that I'm still researching. To be pushed as soon as this is sorted out.\n",
                    "**[Richard Kawala](https://jira.spring.io/secure/ViewProfile.jspa?name=rkawala)** commented\n\nWe'd also love a method with a signature like getBean(TypeInformation typeInformation) on ApplicationContext so that I can ask for an object of type Provider\\<SomeClass>.\n",
                    "**[Phil Webb](https://jira.spring.io/secure/ViewProfile.jspa?name=pwebb)** commented\n\n[Richard Kawala](https://jira.spring.io/secure/ViewProfile.jspa?name=rkawala) This particular issue has been closed, if you're still interested in `getBean(TypeInformation ...)` support could you please raise a new issue.\n",
                    "**[Vladislav Rassokhin](https://jira.spring.io/secure/ViewProfile.jspa?name=vladislav.rassokhin)** commented\n\nLooks like this feature works only for `@annotation-based` configurations.\nCan it be somehow enabled for xml-based configurations?\n",
                    "**[Lari Hotari](https://jira.spring.io/secure/ViewProfile.jspa?name=lhotari)** commented\n\nI created a feature request for adding methods to ListableBeanFactory interface that support generics / parameterized types: #16761\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the conditional logic for determining if a dependency type matches a target type.  Previously, a match was only considered if `fallbackMatchAllowed` was true *and* `targetType` had unresolvable generics.  The change introduces an additional condition: if `targetType` is null, the check also passes.  This suggests a potential improvement in handling cases where the target type is not yet known or is explicitly set to null",
            "avg_logprobs": -0.30369319915771487
        }
    },
    {
        "commit_hash": "f29ffb37f71e09bc1ec98633a87b49875b611f8b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletRequestMethodArgumentResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate static final Method getPushBuilderMethod =\n-\t\t\tClassUtils.getMethodIfAvailable(HttpServletRequest.class, \"getPushBuilder\");\n+\tprivate static final Method newPushBuilderMethod =\n+\t\t\tClassUtils.getMethodIfAvailable(HttpServletRequest.class, \"newPushBuilder\");\n-\t\t\t\t(getPushBuilderMethod != null && getPushBuilderMethod.getReturnType().isAssignableFrom(paramType)) ||\n+\t\t\t\t(newPushBuilderMethod != null && newPushBuilderMethod.getReturnType().isAssignableFrom(paramType)) ||\n-\t\telse if (getPushBuilderMethod != null && getPushBuilderMethod.getReturnType().isAssignableFrom(paramType)) {\n-\t\t\tObject pushBuilder = ReflectionUtils.invokeMethod(getPushBuilderMethod, request);\n+\t\telse if (newPushBuilderMethod != null && newPushBuilderMethod.getReturnType().isAssignableFrom(paramType)) {\n+\t\t\tObject pushBuilder = ReflectionUtils.invokeMethod(newPushBuilderMethod, request);",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Compatibility with Servlet 4.0 b05",
        "commit_body": "Issue: SPR-15379\n",
        "linked_issues": [
            {
                "issue_id": "19942",
                "issue_title": "Compatibility with Servlet 4.0 final draft [SPR-15379]",
                "issue_body": "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** opened **[SPR-15379](https://jira.spring.io/browse/SPR-15379?redirect=false)** and commented\n\nFollowing up on #17273, aside from a few new `MockServletContext` accessors which we're supporting already, there's also a planned renaming from `HttpServletRequest.getPushBuilder` to `newPushBuilder`. For our 5.0 RC1, we need to make sure to comply with the latest API draft there, hopefully the final draft by then.\n\n---\n\n**Affects:** 5.0 M5\n\n**Issue Links:**\n- #17273 Support for Servlet 4.0 API\n- #19883 Make use of Servlet 4.0 mapping introspection when available\n- #20434 Upgrade to Servlet API 4.0 for MVC (PushBuilder and Servlet mocks)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/f29ffb37f71e09bc1ec98633a87b49875b611f8b\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe're up to date with Servlet 4.0 b05 in the meantime, including the `newPushBuilder` renaming.\n\nThere are no further changes planned which would affect us, so we're probably good for our 5.0 RC1 now.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change modifies the method for obtaining a `PushBuilder` from an `HttpServletRequest`.  It replaces the `getPushBuilder()` method lookup with a `newPushBuilder()` method lookup.  This change affects the conditional logic used to determine if the `PushBuilder` can be obtained and how it's invoked.  The `getPushBuilderMethod` variable is now `newPushBuilderMethod`",
            "avg_logprobs": -0.2607650947570801
        }
    },
    {
        "commit_hash": "f2e898d35de7d6bd8c24100d631dad9148edb2e8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ObjectUtils.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t * exception types, as declared in a throws clause.\n+\t * exception types, as declared in a {@code throws} clause.\n-\t\t\treturn !optional.isPresent();\n+\t\t\treturn optional.isEmpty();\n-\t\t\tif (!optional.isPresent()) {\n+\t\t\tif (optional.isEmpty()) {\n-\t * <li>{@code\"Optional.empty\"} if {@code obj} is an empty {@link Optional}</li>\n-\t * <li>{@code\"Optional[<concise-string>]\"} if {@code obj} is a non-empty {@code Optional},\n-\t * where {@code <concise-string>} is the result of invoking {@link #nullSafeConciseToString}\n-\t * on the object contained in the {@code Optional}</li>\n+\t * <li>{@code \"Optional.empty\"} if {@code obj} is an empty {@link Optional}</li>\n+\t * <li>{@code \"Optional[<concise-string>]\"} if {@code obj} is a non-empty {@code Optional},\n+\t * where {@code <concise-string>} is the result of invoking this method on the object\n+\t * contained in the {@code Optional}</li>",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change in `ObjectUtils.java` replaces the `optional.isPresent()` check and its negation with `optional.isEmpty()`.  This change improves clarity and consistency by using the more idiomatic and concise `isEmpty()` method for checking if an `Optional` is empty.  The accompanying text updates also reflect this change, replacing `\"Optional.empty\"` with `\"Optional[<concise-string>]\"` in the documentation.  The overall effect is a cleaner, more readable implementation.",
            "avg_logprobs": -0.321201171875
        }
    },
    {
        "commit_hash": "f31eb2dcf9f03148907ea49c209144753c96573a",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\n+\t\t// Skip scanning the module path when running in a native image.\n+\t\tif (NativeDetector.inNativeImage()) {\n+\t\t\treturn result;\n+\t\t}\n+",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Skip scanning the module path when running in a native image",
        "commit_body": "Prior to this commit, the following exception was thrown when using the\nPathMatchingResourcePatternResolver to scan for class path resources\nusing the `classpath*:` prefix within a native image.\n\ncom.oracle.svm.core.jdk.UnsupportedFeatureError: JRT file system is disabled\ncom.oracle.svm.core.util.VMError.unsupportedFeature(VMError.java:89)\njdk.internal.module.SystemModuleFinders$SystemImage.reader(SystemModuleFinders.java:139)\njdk.internal.module.SystemModuleFinders$ModuleContentSpliterator.<init>(SystemModuleFinders.java:527)\njdk.internal.module.SystemModuleFinders$SystemModuleReader.list(SystemModuleFinders.java:502)\norg.springframework.core.io.support.PathMatchingResourcePatternResolver.lambda$findAllModulePathResources$6(PathMatchingResourcePatternResolver.java:819)\n\nThis commit addresses this by not attempting to scan the module path\nwhen running in a GraalVM native image.\n\nCloses gh-29183\n",
        "linked_issues": [
            {
                "issue_id": "29183",
                "issue_title": "Optimize native footprint by avoiding using `ModuleFinder.ofSystem()` at runtime",
                "issue_body": "#28506 introduced JPMS support in `PathMatchingResourcePatternResolver` by using `ModuleFinder.ofSystem()`, but it has introduced a significant footprint increase on native (close to 2M RSS) due to the transitive usage of `JarVerifier` and related crypto classes.\r\n\r\nThis commit skip `ModuleFinder.ofSystem()` usage on native since JPMS usage is pretty niche, so it is probably ok to skip it on native. We may be able to re-introduce JPMS on native support there if we achieve to support this use case via #29081.",
                "issue_state": "closed",
                "issue_comment": [
                    "While working on #29163, I have encountered the following error.\r\n\r\n```\r\n    => com.oracle.svm.core.jdk.UnsupportedFeatureError: JRT file system is disabled\r\n       com.oracle.svm.core.util.VMError.unsupportedFeature(VMError.java:89)\r\n       jdk.internal.module.SystemModuleFinders$SystemImage.reader(SystemModuleFinders.java:139)\r\n       jdk.internal.module.SystemModuleFinders$ModuleContentSpliterator.<init>(SystemModuleFinders.java:527)\r\n       jdk.internal.module.SystemModuleFinders$SystemModuleReader.list(SystemModuleFinders.java:502)\r\n       org.springframework.core.io.support.PathMatchingResourcePatternResolver.lambda$findAllModulePathResources$6(PathMatchingResourcePatternResolver.java:819)\r\n```\r\n\r\nIn light of that, I am reopening this issue and co-assigning it to me since I'll work on a fix."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code added a check for running in a native image.  If `NativeDetector.inNativeImage()` returns `true`, the method immediately returns the existing `result` variable, effectively skipping the subsequent resource scanning logic.  This optimization avoids unnecessary scanning when the application is running in a native image environment",
            "avg_logprobs": -0.1282367857675704
        }
    },
    {
        "commit_hash": "f3884084f27d9058d6a56cf27d695b373e203e7c",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/io/DefaultResourceLoader.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\tif (location.startsWith(CLASSPATH_URL_PREFIX)) {\n+\t\tif (location.startsWith(\"/\")) {\n+\t\t\treturn getResourceByPath(location);\n+\t\t}\n+\t\telse if (location.startsWith(CLASSPATH_URL_PREFIX)) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimized DefaultResourceLoader's getResource implementation for \"/...\" paths, not relying on URL parsing exceptions for such a common case anymore",
        "commit_body": "Issue: SPR-8283\n",
        "linked_issues": [
            {
                "issue_id": "12931",
                "issue_title": "ServletContextResourceLoader performance problem: creates a lot of MalformedURLExceptions (\"no protocol\") in normal operation [SPR-8283]",
                "issue_body": "**[Lari Hotari](https://jira.spring.io/secure/ViewProfile.jspa?name=lhotari)** opened **[SPR-8283](https://jira.spring.io/browse/SPR-8283?redirect=false)** and commented\n\nThe performance of ServletContextResourceLoader.getResource is very bad because it creates a MalformedURLException in normal operation.\nI've noticed this problem in Grails webapplications.\n\nCreating exceptions are costly because filling the stack trace of the exception takes relatively a lot of cpu.\n\nThere should be a better way to check url validity (without exceptions). In commons-validator there is org.apache.commons.validator.routines.UrlValidator , but I guess a simple check in ServletContextResourceLoader.getResource should be ok. (if path starts with '/' , prefer getResourceByPath)\n\n\n---\n\n**Affects:** 3.0.5\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/f3884084f27d9058d6a56cf27d695b373e203e7c\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Lari Hotari](https://jira.spring.io/secure/ViewProfile.jspa?name=lhotari)** commented\n\npinging this issue. It's still a minor performance problem. http://shipilev.net/blog/2014/exceptional-performance/ tells why.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nGood point. I've added a\n\n    if (location.startsWith(\"/\")) {\n        return getResourceByPath(location);\n    }\n\nblock to the very beginning of DefaultResourceLoader's getResource implementation, optimizing for such non-URL paths. We still fall back to getResourceByPath after a URL parsing failure as well, but that's an exceptional case then and not used for regular \"/...\" paths anymore.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies how `DefaultResourceLoader` handles resource locations starting with `/`.  Previously, it only checked for `CLASSPATH_URL_PREFIX`.  Now, if the location starts with \"/\", it delegates to `getResourceByPath()`, otherwise it checks for `CLASSPATH_URL_PREFIX`.  This suggests a change in the expected format of resource locations, potentially allowing for resources located in the file system (those starting with \"/\") in addition to classpath resources",
            "avg_logprobs": -0.2555912733078003
        }
    },
    {
        "commit_hash": "f3cb331e4efde2a36f0dfe4be94105f55db2c29b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\tMethod method = findGetterForProperty(propertyName, clazz, target instanceof Class);\n-\t\tif (method == null && target instanceof Class) {\n-\t\t\tmethod = findGetterForProperty(propertyName, target.getClass(), false);\n+\t\tboolean targetIsaClass = (target instanceof Class);\n+\t\tMethod method = findGetterForProperty(propertyName, clazz, targetIsaClass);\n+\t\tif (method == null && targetIsaClass) {\n+\t\t\t// Fallback for getter instance methods in java.lang.Class.\n+\t\t\tmethod = findGetterForProperty(propertyName, Class.class, false);\n-\t\tif (method == null && target instanceof Class) {\n-\t\t\tmethod = findSetterForProperty(propertyName, target.getClass(), false);\n-\t\t}\n+\t\t// In contrast to findGetterForProperty(), we do not look for setters in\n+\t\t// java.lang.Class as a fallback, since Class doesn't have any public setters.",
        "change_count": 10,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize find[Getter|Setter]ForProperty() in ReflectivePropertyAccessor",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change refactors the logic for finding getter and setter methods for a given property name.  The original code had redundant checks for `target instanceof Class`.  The change introduces a boolean flag `targetIsaClass` for clarity and efficiency.  Critically, the revised code now avoids attempting to find a setter for a `Class` object, as `Class` objects don't have public setters",
            "avg_logprobs": -0.28275064468383787
        }
    },
    {
        "commit_hash": "f3dce4bb9ab84beaad5345a3690dbdaffc8009f9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t\t\tif (!method.getDeclaringClass().isRecord() && method.getParameterCount() == 0) {\n+\t\t\t\t\tif (method.getParameterCount() == 0) {\n+\t\t\t\t\t\tif (method.getDeclaringClass().isRecord()) {\n+\t\t\t\t\t\t\t// Annotations on the compact constructor arguments made available on accessors, ignoring.\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish \"Ignore @Value on record property\"",
        "commit_body": "See gh-31433\n",
        "linked_issues": [
            {
                "issue_id": "31433",
                "issue_title": "Use of @Value in compact constructor of a record should not register method injection",
                "issue_body": "When I try to use `@Value` annotation a record property, I get a warning in the logs that autowiring should only be used on methods with parameters. What that seems to imply is that attaching `@Value` on the property is actually attaching it on the generated method `property()`, which has no parameters.\r\n\r\nExample:\r\n```java\r\n@Component\r\npublic record MyRecord(@Value(\"${myProp}\") String prop) {}\r\n```\r\n\r\nOutput:\r\n```\r\n02:21:15.043 [main] INFO  o.s.b.f.a.AutowiredAnnotationBeanPostProcessor - Autowired annotation should only be used on methods with parameters: public java.lang.String com.example.MyRecord.prop()\r\n```\r\n\r\nMy fix is to just check first, if the bean is a record or not.",
                "issue_state": "closed",
                "issue_comment": [
                    "Thanks for the PR but are you sure that the code you've shared above currently triggers the warning? Does it work at all? \r\n\r\nIt fails for me as follows:\r\n\r\n```\r\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'myComponent': Injection of autowired dependencies failed; nested exception is java.lang.IllegalAccessException: Can not set final java.lang.String field com.example.demo.MyComponent.prop to java.lang.String\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:405) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1431) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:955) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:921) ~[spring-context-5.3.29.jar:5.3.29]\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) ~[spring-context-5.3.29.jar:5.3.29]\r\n\tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:731) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:408) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:307) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1303) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1292) ~[spring-boot-2.7.14.jar:2.7.14]\r\n\tat com.example.demo.DemoApplication.main(DemoApplication.java:12) ~[classes/:na]\r\nCaused by: java.lang.IllegalAccessException: Can not set final java.lang.String field com.example.demo.MyComponent.prop to java.lang.String\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:76) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:80) ~[na:na]\r\n\tat java.base/jdk.internal.reflect.UnsafeQualifiedObjectFieldAccessorImpl.set(UnsafeQualifiedObjectFieldAccessorImpl.java:79) ~[na:na]\r\n\tat java.base/java.lang.reflect.Field.set(Field.java:799) ~[na:na]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:646) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.29.jar:5.3.29]\r\n\t... 17 common frames omitted\r\n```\r\n\r\nTurning a `record` into a bean is a bit odd. In any case, please clarify your assumptions as we can't really process this until we understand it.",
                    "@snicoll I confirm that log is triggered.\r\n```\r\n o.s.b.f.a.AutowiredAnnotationBeanPostProcessor INFO Autowired annotation should only be used on methods with parameters: public java.lang.String io.example.showcase.MyRecord.prop()\r\n\r\n```",
                    "Thanks. \"logging a warning\" broke my brain, I was looking for a warning, not an info message. The bits on testing and use of record remains though.",
                    "@snicoll Sorry for the misunderstanding, it is an INFO log, but communicating a sort of warning, didn't know how to call it. \r\n\r\nIt works well for me with the code I provided (+ basic Spring Boot project, latest, JDK 21 or 17).\r\n\r\nAs for `record` being odd when used as a bean. I was just experimenting with records + Spring. Using records as a bean seems mostly equivalent to e.g.:\r\n```java\r\n@Component\r\npublic class MyClass {\r\n  private String prop;\r\n  public MyClass(@Value(\"${myProp}\") String prop) {\r\n    this.prop = prop;\r\n  }\r\n  // getter\r\n}\r\n```\r\n\r\nBut you're kinda right. Now that I think about the use cases, it might not be that needed. If I have some service that needs a property value, and I use a record for it, I'd get an unwanted property accessor automatically, which is not great. I was thinking more like loading properties into a \"configuration\" carrying bean, but that's also possible with e.g.:\r\n```java\r\n@ConfigurationProperties(prefix = \"config\")\r\npublic record Config(String first, String second) {}\r\n```\r\nwhich works well.",
                    ">  I was thinking more like loading properties into a \"configuration\" carrying bean,\r\n\r\nYeah, sorry. You're totally right. The `@Value` with a record makes sense indeed.",
                    "@martin-lukas thanks very much for making your first contribution to Spring Framework."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional check within `AutowiredAnnotationBeanPostProcessor`.  Originally, it skipped processing methods with zero parameters *unless* the declaring class was not a record.  The change now first checks if the method has zero parameters.  If so, it *then* checks if the declaring class is a record.  If the class *is* a record, the processing is skipped.  This effectively adds a new, prioritized check for record classes",
            "avg_logprobs": -0.23712215423583985
        }
    },
    {
        "commit_hash": "f425a993e7be82ffdbdda24370925a34c42925f2",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-websocket/src/main/java/org/springframework/web/socket/messaging/StompSubProtocolHandler.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\tif (!session.isOpen()) {\n+\t\t\t\t\tlogger.trace(\"Dropped inbound WebSocket message due to closed session\");\n+\t\t\t\t\treturn;\n+\t\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Ignore missing STOMP decoder if session closed",
        "commit_body": "Closes gh-24842\n",
        "linked_issues": [
            {
                "issue_id": "24842",
                "issue_title": "Avoid \u201cNo decoder for session id\u201d Exception if session is closed",
                "issue_body": "Hello, We using spring websocket in stomp for chatting in service. ( android, ios app connect to server with stomp, and then send/receive stomp messages. ) when we deploy stomp web server, throws exception when server reloading. ( intermittently occurs after server reloading. )\r\n\r\n```\r\n\"java.lang.IllegalStateException: No decoder for session id 'e3d585e7-f176-362b-2b7a-9dbf8630cc82'\r\n at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageFromClient(StompSubProtocolHandler.java:231)\r\n at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:312)\r\n at org.springframework.web.socket.handler.WebSocketHandlerDecorator.handleMessage(WebSocketHandlerDecorator.java:75)\r\n```\r\n\r\nI heard that this exception occurs the connection is closed by the server and spring drops the session and everything(decoder) associated with it. This exception occurs in spring library. so we can't anything to prevent this exception occurs.\r\n\r\nI want know about how can we prevent to occur this exception when server deployed.\r\n\r\nI thought some cases about send to \"DISCONNET\" message client.\r\n\r\n1. server send \"DISCONNECT\" message to client with regiseterd session id when server drops.\r\nBut in now, we don't know how can get connected session id in server. If we can get session id for all client connected in server, then we can do it. or if we can extend StompSubProtocolHandler and register custom StompSubProtocolHandler, then it can be done.\r\n\r\n2. catch IllegalStateException and send to \"DISCONNET\" message client.\r\nThis error occurs in library. If we register exception handler, then we seems to control it, but we can't know about session id in clent. ",
                "issue_state": "closed",
                "issue_comment": [
                    "This is most likely a race condition where the `WebSocketSession` has closed at the same time. We can check and if that's the case, only log a warning about the dropped incoming message."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a check for the `session.isOpen()` state before processing inbound WebSocket messages.  If the session is closed, a trace log message is logged, and the message processing is skipped. This prevents potential exceptions or unexpected behavior when trying to process messages on a closed session",
            "avg_logprobs": -0.1607050895690918
        }
    },
    {
        "commit_hash": "f4a73b79b844486da5d39f4c0b7b997c72eb56ca",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\t\t\telse {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid CacheAspectSupport#findInCaches fall through to reactive handler",
        "commit_body": "Prior to this commit if the return type is a CompletableFuture but a\ncache get returns null, the execution falls through to the\nreactiveCachingHandler.\n\nThis commit ensures that evaluation instead continues onto the next\ncache (if any).\n\nCloses gh-33371\n",
        "linked_issues": [
            {
                "issue_id": "33371",
                "issue_title": "Avoid CacheAspectSupport#findInCaches falling through to the reactiveCachingHandler",
                "issue_body": "In `findInCaches`, if the return type is a `CompletableFuture` but a cache get returns `null`, the execution falls through to the `reactiveCachingHandler`.\r\n\r\nIt should instead `continue` onto the next cache in the context (if any).",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a `continue` statement within an `else` block.  This suggests the code was previously performing some action within the `if` block, and now, if the `if` condition is false, the code skips to the next iteration of the enclosing loop.  The `continue` statement is used to skip the remaining code in the current iteration and proceed to the next",
            "avg_logprobs": -0.21697909832000734
        }
    },
    {
        "commit_hash": "f4e23fe204588a744b111b8c7f6bbd1dbeda97b0",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/core/DefaultParameterNameDiscoverer.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import org.springframework.aot.AotDetector;\n+\n- * to the ASM-based {@link LocalVariableTableParameterNameDiscoverer} for checking\n- * debug information in the class file.\n+ * to the ASM-based {@link LocalVariableTableParameterNameDiscoverer} (when not using\n+ * AOT-processed optimizations) for checking debug information in the class file.\n-\t\taddDiscoverer(new LocalVariableTableParameterNameDiscoverer());\n+\t\tif (!AotDetector.useGeneratedArtifacts()) {\n+\t\t\taddDiscoverer(new LocalVariableTableParameterNameDiscoverer());\n+\t\t}",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Do not use LocalVariableTableParameterNameDiscoverer in AOT mode",
        "commit_body": "Closes gh-29531\n",
        "linked_issues": [
            {
                "issue_id": "29531",
                "issue_title": "Deprecate `LocalVariableTableParameterNameDiscoverer` completely (avoiding its exposure in native images)",
                "issue_body": "`DefaultParameterNameDiscoverer` should be updated to not use `LocalVariableTableParameterNameDiscoverer` when running as a native image.",
                "issue_state": "closed",
                "issue_comment": [
                    "I think this should behave the same way on the JVM. the check should be on AOT not native. ",
                    "Could be great for consistency indeed even if technically on JVM + AOT we have to the capability to use it. Let's validate the choice in today's Framework meeting.",
                    "I updated the PR accordingly.",
                    "An interesting case in terms of automatic exclusion indeed.\r\n\r\nWe certainly don't want to support that parameter name discovery strategy in a native image (where the underlying class files are generally not available), and it's not recommended in any other scenario either... since you can always compile with `-parameters` instead, with no need to parse class files then. In such a recommended setup, `StandardReflectionParameterNameDiscoverer` will always be able to resolve the parameter names first, so `LocalVariableTableParameterNameDiscoverer` will never actually be reached.\r\n\r\nFrom that perspective, for a setup following Java 8+ recommendations, `LocalVariableTableParameterNameDiscoverer` could even be removed completely. It's only really there for backwards compatibility with older setups that got migrated without `-parameters`. Baking that assumption into our AOT arrangement - namely that you need to compile with `-parameters` when you are optimizing for AOT, completely avoiding unnecessary class file parsing - seems sensible.",
                    "I'm afraid we'll have to return to a `NativeDetector` check here since `AotDetector` is in the higher-level `aot` package whereas `DefaultParameterNameDiscoverer` is a very low-level `core` component. Since there is no significant difference to be expected in practice, I don't think the cycle-free narrower check matters. After all, `LocalVariableTableParameterNameDiscoverer` is effectively not applicable in a native image due to its class file parsing approach, so it arguably does make sense to exclude it on that basis and rely on `-parameters` usage by convention.",
                    "Reopening this one after a team discussion: It is ultimately preferable to deprecate `LocalVariableTableParameterNameDiscoverer` completely, not using it by default in any setup anymore, since that class file parsing strategy has been long superseded by the Java 8 `-parameters` flag on `javac` already.\r\n\r\nWe have considered doing this before and meant to address the native image impact of it in 6.0 but somehow missed this last week. So let's fix this glitch now, in time for the Boot 3.0 GA release, with a note in the upgrade wiki page.",
                    "As a lenient measure for the transition period, we'll keep `LocalVariableTableParameterNameDiscoverer` active on the JVM but log a warning for each successful parameter name resolution. This will only be logged when parameter names actually need to be inspected, and only when `StandardReflectionParameterNameDiscoverer` did not return anything, suggesting that compilation with `-parameters` has been missed somewhere."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change introduces a conditional check based on `AotDetector.useGeneratedArtifacts()` before adding a `LocalVariableTableParameterNameDiscoverer`.  Previously, this discoverer was always added.  Now, it's only added if AOT-processed optimizations are *not* in use",
            "avg_logprobs": -0.16276098251342774
        }
    },
    {
        "commit_hash": "f781c459b43eeac60188cf6a71508ff0cc8c9229",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tPropertyEditorRegistrySupport registrySupport =\n-\t\t\t\t(registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);\n-\t\tif (registrySupport != null) {\n-\t\t\tregistrySupport.useConfigValueEditors();\n+\t\tif (registry instanceof PropertyEditorRegistrySupport) {\n+\t\t\t((PropertyEditorRegistrySupport) registry).useConfigValueEditors();",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify AbstractBeanFactory.registerCustomEditors()",
        "commit_body": "This commit avoids an unnecessary non-null check in\nregisterCustomEditors().\n\nCloses gh-26022\n",
        "linked_issues": [
            {
                "issue_id": "26022",
                "issue_title": "Simplify AbstractBeanFactory.registerCustomEditors()",
                "issue_body": "Remove unnecessary non-null check",
                "issue_state": "closed",
                "issue_comment": [
                    "This has been merged into `master`.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a potentially null-dereferencing check with a direct cast and method call.  The original code first cast `registry` to `PropertyEditorRegistrySupport`, storing the result in `registrySupport`, and then checked for null before calling `useConfigValueEditors()`.  The updated code directly casts `registry` within the `if` condition, avoiding the intermediate variable and the null check. This improves efficiency and readability by eliminating unnecessary object creation and a potential `NullPointerException`",
            "avg_logprobs": -0.17797468185424806
        }
    },
    {
        "commit_hash": "f8b611444072bea0a2755ba73b4dd15fe33098e5",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+ * @author Juergen Hoeller\n+\t\telse if (bf.containsBean(qualifier)) {\n+\t\t\t// Fallback: target bean at least found by bean name.\n+\t\t\treturn bf.getBean(qualifier, beanType);\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "BeanFactoryAnnotationUtils consistently applies bean name fallback when no BeanDefinition present",
        "commit_body": "Issue: SPR-11915\n",
        "linked_issues": [
            {
                "issue_id": "16534",
                "issue_title": "Manually registered transaction manager are not recognized by qualifiedBeanOfType [SPR-11915]",
                "issue_body": "**[Michael McCarthy](https://jira.spring.io/secure/ViewProfile.jspa?name=mikeycmccarthy)** opened **[SPR-11915](https://jira.spring.io/browse/SPR-11915?redirect=false)** and commented\n\nAs per the StackOverflow question above, I've been trying to use an `@Transactional` annotation with a qualifier, and was hoping that my manually registered singleton bean would get picked up but sadly it doesn't.\n\nIf I debug the method public static \\<T> T qualifiedBeanOfType(BeanFactory beanFactory, Class\\<T> beanType, String qualifier) and evaluate beanFactory.containsBean(qualifier) in my IDE before the method executes, the result of that evaluation is 'true'.\n\nUnfortunately, qualifiedBeanOfType throws a NoSuchBeanDefinitionException before that fallback method gets a chance to run.\n\nIs it just me or will the fallback never get invoked?\n\n\n---\n\n**Affects:** 3.2.9, 4.0.5\n\n**Reference URL:** http://stackoverflow.com/questions/24385151/can-i-programatically-add-a-qualifier-to-a-bean?noredirect=1#comment37747172_24385151\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/67ebef6b3241723a9a1a653d23811838cafd1afa, https://github.com/spring-projects/spring-framework/commit/b9935e9fe31888cecc06ec04174e87edee3da7f0, https://github.com/spring-projects/spring-framework/commit/5ed20d21b1e301280b525cdc0c602f09e4ccff83, https://github.com/spring-projects/spring-framework/commit/f8b611444072bea0a2755ba73b4dd15fe33098e5\n\n**Backported to:** [3.2.10](https://github.com/spring-projects/spring-framework/milestone/98?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nIt looks like that particular use case relies on bean definitions and that's not strictly necessary on a first look because it's not invoked as part of the application context initialization.\n\nSome proxy setup routine actually can't look at anything else than the bean definition as some of the beans are not fully initialized yet.\n\nCould you please setup a small example that demonstrates this issue (check the [spring-framework-issues repo](https://github.com/spring-projects/spring-framework-issues#readme)).\n\nThanks!\n",
                    "**[Michael McCarthy](https://jira.spring.io/secure/ViewProfile.jspa?name=mikeycmccarthy)** commented\n\nThanks for looking! I'll see if I can knock up a test this weekend and put it on GitHub.\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nno worries. The reason I am asking is that I would see when/how those beans are registered. Besides, having a simple test would really speed the resolution of this one if necessary (4.1 RC1 is around the corner).\n\nYou can look [at this project](https://github.com/spring-projects/spring-framework-issues/tree/master/SPR-11107) that already uses transaction-related stuff if you want to get started more easily. I don't need anything fancy for the test, if it just blows up because it can't find the transaction manager, that's enough.\n",
                    "**[Michael McCarthy](https://jira.spring.io/secure/ViewProfile.jspa?name=mikeycmccarthy)** commented\n\nDone, have a look at https://github.com/spring-projects/spring-framework-issues/pull/81. It is probably looks a bit contrived but hopefully shows what is happening here. Thanks\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nrepro project available here: https://github.com/spring-projects/spring-framework-issues/tree/master/SPR-11915\n\nThanks.\n",
                    "**[Michael McCarthy](https://jira.spring.io/secure/ViewProfile.jspa?name=mikeycmccarthy)** commented\n\nIf you need any background on why someone might be registering Spring beans in this way, check out https://github.com/nhuray/dropwizard-spring, and in particular https://github.com/nhuray/dropwizard-spring/blob/master/src/main/java/com/github/nhuray/dropwizard/spring/SpringBundle.java.\n\nNot my project BTW but we're using it.\n\nThanks\nMichael\n",
                    "**[St\u00e9phane Nicoll](https://jira.spring.io/secure/ViewProfile.jspa?name=snicoll)** commented\n\nThis is now fixed in master and will be soon backported to 3.2.x and 4.0.x\n\nYou have a very good point: that fallback method should run no matter what. That's what we've done and your test project runs fine now against a local build of `4.1.0.BUILD-SNAPSHOT`.\n\nThanks for the report!\n",
                    "**[Michael McCarthy](https://jira.spring.io/secure/ViewProfile.jspa?name=mikeycmccarthy)** commented\n\nThat's brilliant, thanks for the quick turnaround! I'll take a look at fisheye to see the change just out of curiosity.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds an `else if` block to the existing conditional logic.  This new block checks if the bean factory (`bf`) contains a bean with the given `qualifier`. If it does, it retrieves the bean using `bf.getBean(qualifier, beanType)` and returns it.  This acts as a fallback mechanism, prioritizing a bean found by qualifier over other potential lookup methods",
            "avg_logprobs": -0.17266987591255
        }
    },
    {
        "commit_hash": "f9aae8dd5a9a325fa9cb3f1a3b5e9081bbe91e65",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\n-\n+\n-\t\t\tif (index > minNrOfArgs) {\n+\t\t\tif (index + 1 > minNrOfArgs) {",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Consistently determine minimum number of arguments from specified index",
        "commit_body": "Closes gh-25130\n",
        "linked_issues": [
            {
                "issue_id": "25130",
                "issue_title": " ConstructorResolver.resolveConstructorArguments() return value issue",
                "issue_body": "In `ConstructorResolver`:\r\n\r\n```java\r\nprivate int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,\r\n\t\t\tConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {\r\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\r\n\t\t// ...\r\n\r\n\t\tfor (Map.Entry<Integer, ConstructorArgumentValues.ValueHolder> entry : cargs.getIndexedArgumentValues().entrySet()) {\r\n\t\t\tint index = entry.getKey();\r\n\t\t\tif (index < 0) {\r\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\r\n\t\t\t\t\t\t\"Invalid constructor argument index: \" + index);\r\n\t\t\t}\r\n\t\t\tif (index > minNrOfArgs) {\r\n\t\t\t\tminNrOfArgs = index + 1;\r\n\t\t\t}\r\n\t\t\t// ....\r\n\t\t}\r\n// ....\r\n    return minNrOfArgs;\r\n}\r\n```\r\n\r\nI assume that method  `resolveConstructorArguments` is to resolve contructor arguments in the XML file and return the minimum number of parameters required by contructor \u3002but if the first parameter is autowired , the second parameter  is config by XML file\uff0cthe method will not work well\u3002\r\n\r\n**example**:\r\n\r\n```java\r\npublic class FactoryObject {\r\n\t\r\n    public DmzService getDmz(String name, int age, Date birthDay, OrderService orderService) {\r\n\r\n\tpublic DmzService getDmz(OrderService orderService,String name) {\r\n\t\t\r\n\t\treturn new DmzService(orderService,name);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n\t   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t   xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\r\n\t   default-autowire=\"constructor\">\r\n\t<bean id=\"factoryObject\" class=\"com.dmz.spring.first.instantiation.service.FactoryObject\"/>\r\n\r\n\t<bean class=\"com.dmz.spring.first.instantiation.service.OrderService\" id=\"orderService\"/>\r\n\r\n\t<bean id=\"dmzService\" factory-bean=\"factoryObject\" factory-method=\"getDmz\">\r\n\t\t<constructor-arg index=\"1\"  value=\"dmz\"/>\r\n\t</bean>\r\n\r\n</beans>\r\n```\r\n\r\nthe `resolveConstructorArguments` method will return 1,but correct answer is 2\u3002\r\n\r\nI think the problem arises because of this judgment:\r\n\r\n```java\r\nif (index > minNrOfArgs) {\r\n    minNrOfArgs = index + 1;\r\n}\r\n```\r\n\r\nIt might be better to change it to look like this\r\n\r\n```\r\nif (index + 1 > minNrOfArgs) {\r\n    minNrOfArgs = index + 1;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a conditional statement within the `ConstructorResolver` class.  It alters the comparison used to determine if the current argument index (`index`) exceeds the minimum number of required arguments (`minNrOfArgs`).  The original `index > minNrOfArgs` is now `index + 1 > minNrOfArgs`",
            "avg_logprobs": -0.24961614608764648
        }
    },
    {
        "commit_hash": "f9b319d3ba9d3141fd5edc4fde558daebd2c596f",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/core/GenericMessagingTemplate.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (replyMessage != null && (originalReplyChannelHeader!= null || originalErrorChannelHeader != null)) {\n+\t\tif (replyMessage != null) {",
        "change_count": 2,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Revert Incorrect MessagingTemplate Change",
        "commit_body": "The change to \"optimize\" the template by not rebuilding the reply\nmessage when the original header channels was null was incorrect.\n\nWe need to null out those headers if they were originally null.\n\nIssue: SPR-15991\n",
        "linked_issues": [
            {
                "issue_id": "20541",
                "issue_title": "DispatcherHandler no longer orders HandlerMapping beans [SPR-15991]",
                "issue_body": "**[Andy Wilkinson](https://jira.spring.io/secure/ViewProfile.jspa?name=awilkinson)** opened **[SPR-15991](https://jira.spring.io/browse/SPR-15991?redirect=false)** and commented\n\n[This change](https://github.com/spring-projects/spring-framework/commit/819ca0dbd40cccd4eae0353ff0b9aeaf248d3ab6) has introduced a regression which means that `HandlerMapping` beans are no longer ordered. Currently, `this.handlerMappings` is being sorted:\n\n```java\nArrayList<HandlerMapping> mappings = new ArrayList<>(mappingBeans.values());\nAnnotationAwareOrderComparator.sort(this.handlerMappings);\nthis.handlerMappings = Collections.unmodifiableList(mappings);\n```\n\nI believe it should be `mappings` that is sorted:\n\n```java\nArrayList<HandlerMapping> mappings = new ArrayList<>(mappingBeans.values());\nAnnotationAwareOrderComparator.sort(mappings);\nthis.handlerMappings = Collections.unmodifiableList(mappings);\n```\n\n---\n\n**Affects:** 5.0 GA\n\n**Issue Links:**\n- #20488 Provide an API for introspection of handler mappings\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/816a58fcf91b7cdb27b430ae6b96c9143a67d124, https://github.com/spring-projects/spring-framework/commit/31619b3ffbf4e36bf9c3974d07115a8e3417ba03, https://github.com/spring-projects/spring-framework/commit/f9b319d3ba9d3141fd5edc4fde558daebd2c596f\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nShould be fixed now, I've also added a test ;).\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes the redundant check for `originalReplyChannelHeader` and `originalErrorChannelHeader`.  The original code checked if either header was present *and* if a reply message existed.  The updated code simplifies this to only check if a reply message exists.  This implies that if `replyMessage` is null, the header checks are no longer relevant and will not be performed.  This change likely improves performance by avoiding unnecessary comparisons",
            "avg_logprobs": -0.22525020222087483
        }
    },
    {
        "commit_hash": "f9cffcce0544b648e002251518e319dbdcfaec41",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\tint batchSize = pss.getBatchSize();\n+\t\tif (batchSize == 0) {\n+\t\t\treturn new int[0];\n+\t\t}\n-\t\t\t\tint batchSize = pss.getBatchSize();\n-\t\t\t\t\treturn batchSize > 0 ? ps.executeBatch() : new int[] {};\n+\t\t\t\t\treturn ps.executeBatch();",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Polish \"Avoid calling executeBatch() with an empty batch\"",
        "commit_body": "See gh-27154\n",
        "linked_issues": [
            {
                "issue_id": "27154",
                "issue_title": "Avoid calling executeBatch() with 0 batch size",
                "issue_body": "Now usign  `org.springframework.jdbc.core.JdbcTemplate#batchUpdate(java.lang.String, org.springframework.jdbc.core.BatchPreparedStatementSetter)` with empty data array may produce exception with some DBs. E. g. with HSQLDB it produce `java.sql.SQLException: statement is not in batch mode`. Suggest avoid it by batchSize checking.",
                "issue_state": "closed",
                "issue_comment": [
                    "@Li0n13 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=27154)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=27154) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@Li0n13 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=27154)!"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change simplifies the batch execution logic in `JdbcTemplate`.  Previously, if the batch size was zero, it returned an empty array (`new int[] {}`).  Now, it directly returns the result of `ps.executeBatch()`, which implicitly handles the zero-size case by returning an empty array.  This removes an unnecessary conditional check (`batchSize > 0 ? ... : ...`). The code is now more concise and efficient",
            "avg_logprobs": -0.17887679206000434
        }
    },
    {
        "commit_hash": "f9d2641fd59a39b149277c707dd277922c3aa5d7",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\tprivate static Class<?> javaxInjectProviderClass;\n+\tprivate static Class<?> jakartaInjectProviderClass;\n-\t\t\tjavaxInjectProviderClass =\n+\t\t\tjakartaInjectProviderClass =\n-\t\t\tjavaxInjectProviderClass = null;\n+\t\t\tjakartaInjectProviderClass = null;\n-\t\telse if (javaxInjectProviderClass == descriptor.getDependencyType()) {\n+\t\telse if (jakartaInjectProviderClass == descriptor.getDependencyType()) {",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Update field name to reflect switch to Jakarta",
        "commit_body": NaN,
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code change replaces `javaxInjectProviderClass` with `jakartaInjectProviderClass` in the `DefaultListableBeanFactory` class.  This suggests a migration from the `javax.inject` dependency to the `jakarta.inject` dependency.  The change affects a conditional check, specifically replacing all instances of `javaxInjectProviderClass` with `jakartaInjectProviderClass` within the `if/else if` block",
            "avg_logprobs": -0.19233794545018396
        }
    },
    {
        "commit_hash": "f9df8c738a4eb9fff292f58a82be7ba09e1c3097",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-web/src/main/java/org/springframework/http/server/reactive/AbstractListenerReadPublisher.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\tcheckOnDataAvailable();\n+\t\t\t// Protect from infinite recursion in Undertow, where we can't check if data\n+\t\t\t// is available, so all we can do is to try to read.\n+\t\t\t// Generally, no need to check if we just came out of readAndPublish()...\n+\t\t\tif (!oldState.equals(State.READING)) {\n+\t\t\t\tcheckOnDataAvailable();\n+\t\t\t}",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Avoid inifinite recursion in UndertowServerHttpRequest",
        "commit_body": "Undertow does not provide a way to check if data is available to read\nbut instead we have to try to read and see if any data is returned.\nThis makes it impossible to implement checkOnDataAvailable without\ntrying to read and that can lead to infinite recursion like this:\n\n...\nUndertowServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(UndertowServerHttpRequest.java:156)\nAbstractListenerReadPublisher.changeToDemandState(AbstractListenerReadPublisher.java:177)\nAbstractListenerReadPublisher.access$900(AbstractListenerReadPublisher.java:47)\nAbstractListenerReadPublisher$State$4.onDataAvailable(AbstractListenerReadPublisher.java:319)\nAbstractListenerReadPublisher.onDataAvailable(AbstractListenerReadPublisher.java:85)\nUndertowServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(UndertowServerHttpRequest.java:156)\n\nThis commit prevent the call to checkOnDataAvailable() when switching\nstates from READING->DEMAND which implies we exited the readAndPublish\nloop because there was no more data to read.\n\nIssue: SPR-16545\n",
        "linked_issues": [
            {
                "issue_id": "21088",
                "issue_title": "StackOverflowError when using WebFlux multipart file data handler with Undertow [SPR-16545]",
                "issue_body": "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** opened **[SPR-16545](https://jira.spring.io/browse/SPR-16545?redirect=false)** and commented\n\nI am using Spring Boot 2 RC2 - Spring 5.0.3 with WebFlux and the Router abstraction. The server is Undertow.\n\nI have created the handler according to: https://github.com/sdeleuze/webflux-multipart/blob/master/src/main/java/com/example/MultipartRoute.java\n\nI have a router handler like this:\n\n```kotlin\n@Component\nclass MultimediaHandler {\n    fun upload(request: ServerRequest): Mono<ServerResponse> {\n        return request.body(BodyExtractors.toMultipartData()).flatMap{ parts ->\n            val map = parts.toSingleValueMap()\n            ServerResponse.ok().build()\n        }\n    }\n}\n```\n\nI am getting a StackOverflowError:\n\n```\njava.lang.StackOverflowError: null\n\tat io.undertow.conduits.FixedLengthStreamSourceConduit.read(FixedLengthStreamSourceConduit.java:249) ~[undertow-core-1.4.22.Final.jar:1.4.22.Final]\n\tat org.xnio.conduits.ConduitStreamSourceChannel.read(ConduitStreamSourceChannel.java:127) ~[xnio-api-3.3.8.Final.jar:3.3.8.Final]\n\tat io.undertow.channels.DetachableStreamSourceChannel.read(DetachableStreamSourceChannel.java:209) ~[undertow-core-1.4.22.Final.jar:1.4.22.Final]\n\tat io.undertow.server.HttpServerExchange$ReadDispatchChannel.read(HttpServerExchange.java:2332) ~[undertow-core-1.4.22.Final.jar:1.4.22.Final]\n\tat org.springframework.http.server.reactive.UndertowServerHttpRequest$RequestBodyPublisher.read(UndertowServerHttpRequest.java:171) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.UndertowServerHttpRequest$RequestBodyPublisher.read(UndertowServerHttpRequest.java:127) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.readAndPublish(AbstractListenerReadPublisher.java:145) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.access$1000(AbstractListenerReadPublisher.java:47) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher$State$4.onDataAvailable(AbstractListenerReadPublisher.java:317) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.onDataAvailable(AbstractListenerReadPublisher.java:85) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.UndertowServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(UndertowServerHttpRequest.java:155) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.changeToDemandState(AbstractListenerReadPublisher.java:177) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\tat org.springframework.http.server.reactive.AbstractListenerReadPublisher.access$900(AbstractListenerReadPublisher.java:47) ~[spring-web-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n\t...\n```\n\n---\n\n**Affects:** 5.0.3\n\n**Attachments:**\n- [foo-small.txt](https://jira.spring.io/secure/attachment/25415/foo-small.txt) (_2.44 kB_)\n- [upload-error-sample.zip](https://jira.spring.io/secure/attachment/25416/upload-error-sample.zip) (_182.67 kB_)\n- [upload-error-sample-wo-kafka.zip](https://jira.spring.io/secure/attachment/25417/upload-error-sample-wo-kafka.zip) (_181.18 kB_)\n\n**Issue Links:**\n- #21173 Spring WebFlux + Undertow + HTTP/2 is not working with a POST request (_**\"is duplicated by\"**_)\n- #21121 spring webflux ServerRequest.bodyToMono().block will freeze for HTTP post request whose header size + body size > 1024\n- #21089 FilePart transferTo fails with java.nio.file.NoSuchFileException\n- #21243 StackOverFlowError and memory leaking when sending large files slowly with Webflux + Undertow\n- #21090 [docs] Restructure chapter Functional Endpoints chpater\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/f9df8c738a4eb9fff292f58a82be7ba09e1c3097\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** commented\n\nWith Netty as server it seems to be working.\n",
                    "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** commented\n\nAdditionally it seems that the example: https://github.com/sdeleuze/webflux-multipart/ Does not compile anymore. Errors in: https://github.com/sdeleuze/webflux-multipart/blob/master/src/main/java/com/example/MultipartController.java\n\nIt would be good to have this documented as well. The official docs only mention the Controller based approach and not the Router-Handler approach: https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart-forms\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI've [created a PR](https://github.com/sdeleuze/webflux-multipart/pull/1) to update the sample.\n\nIn the process of upgrading the sample, I did find and address one other issue, see #21089. After that, with the latest (Boot 2.0 GA, Spring Framework 5.0.5 snapshot) I am unable to reproduce the Undertow issue. Note that in the sample I removed the explicit (outdated 1.0.2) version of `nio-multipart-parser` and relied to the Boot auto configured version (1.1.0).\n\nWould you mind retrying with the updates to confirm?\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nAlso for the documentation updates I've created a separate ticket #21090 since it requires some restructuring.\n",
                    "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** commented\n\nI have used the updated sample. With Undertow I get the same StackOverflow. With Netty it works.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nHm, it works fine for me:\n\n```\n2018-03-02 11:53:44.137  INFO 21105 --- [           main] com.example.WebfluxMultipartApplication  : Starting WebfluxMultipartApplication on rossen-X1 with PID 21105 (/home/rossen/dev/github/sdeleuze/webflux-multipart/target/classes started by rossen in /home/rossen/dev/github/sdeleuze/webflux-multipart)\n2018-03-02 11:53:44.141 DEBUG 21105 --- [           main] com.example.WebfluxMultipartApplication  : Running with Spring Boot v2.0.0.RELEASE, Spring v5.0.5.BUILD-SNAPSHOT\n2018-03-02 11:53:44.143  INFO 21105 --- [           main] com.example.WebfluxMultipartApplication  : No active profile set, falling back to default profiles: default\n2018-03-02 11:53:44.283  INFO 21105 --- [           main] onfigReactiveWebServerApplicationContext : Refreshing org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@4c1d9d4b: startup date [Fri Mar 02 11:53:44 EST 2018]; root of context hierarchy\n2018-03-02 11:53:45.838 DEBUG 21105 --- [           main] s.w.r.r.m.a.RequestMappingHandlerMapping : Looking for request mappings in application context: org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@4c1d9d4b: startup date [Fri Mar 02 11:53:44 EST 2018]; root of context hierarchy\n2018-03-02 11:53:45.925 DEBUG 21105 --- [           main] o.s.w.r.f.s.s.RouterFunctionMapping      : Looking for router functions in application context: org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@4c1d9d4b: startup date [Fri Mar 02 11:53:44 EST 2018]; root of context hierarchy\n2018-03-02 11:53:46.029  INFO 21105 --- [           main] o.s.w.r.f.s.s.RouterFunctionMapping      : Mapped (POST && /upload) -> com.example.MultipartRoute$$Lambda$242/1624817884@464649c\n/** -> class path resource [static/]\n2018-03-02 11:53:46.052  INFO 21105 --- [           main] o.s.w.r.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.reactive.resource.ResourceWebHandler]\n2018-03-02 11:53:46.053  INFO 21105 --- [           main] o.s.w.r.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.reactive.resource.ResourceWebHandler]\n2018-03-02 11:53:46.172  INFO 21105 --- [           main] o.s.w.r.r.m.a.ControllerMethodResolver   : Looking for @ControllerAdvice: org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext@4c1d9d4b: startup date [Fri Mar 02 11:53:44 EST 2018]; root of context hierarchy\n2018-03-02 11:53:46.549  INFO 21105 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2018-03-02 11:53:46.577  INFO 21105 --- [           main] org.xnio                                 : XNIO version 3.3.8.Final\n2018-03-02 11:53:46.592  INFO 21105 --- [           main] org.xnio.nio                             : XNIO NIO Implementation Version 3.3.8.Final\n2018-03-02 11:53:46.683  INFO 21105 --- [           main] o.s.b.w.e.u.UndertowServletWebServer     : Undertow started on port(s) 8080 (http)\n2018-03-02 11:53:46.686  INFO 21105 --- [           main] com.example.WebfluxMultipartApplication  : Started WebfluxMultipartApplication in 3.544 seconds (JVM running for 4.211)\n2018-03-02 11:53:59.000 DEBUG 21105 --- [   XNIO-1 I/O-1] o.s.web.reactive.DispatcherHandler       : Processing GET request for [http://localhost:8080/index.html]\n2018-03-02 11:54:29.455 DEBUG 21105 --- [   XNIO-1 I/O-1] o.s.web.reactive.DispatcherHandler       : Processing POST request for [http://localhost:8080/upload]\n2018-03-02 11:54:29.456 DEBUG 21105 --- [   XNIO-1 I/O-1] o.s.w.r.function.server.RouterFunctions  : Predicate \"(POST && /upload)\" matches against \"POST /upload\"\n2018-03-02 11:54:29.464 DEBUG 21105 --- [   XNIO-1 I/O-1] o.s.w.c.reactive.DefaultCorsProcessor    : Skip CORS: request is from same origin\n```\n\n",
                    "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** commented\n\nI am sorry for the late reply, was on holiday.\n\nI have prepared a sample project. (zip, and input files attached)\n\nSteps to reproduce:\n* unpack the zip file\n* start kafka with: docker-compose up\n* compile the spring project: `./gradlew build`\n* start the app: `java -jar ./build/libs/upload-error-sample-0.0.1-SNAPSHOT.jar`\n* upload the files: `curl -v -F import=\\@/tmp/dc/foo-small.txt  http://localhost:8090/api/imports # Note: change actual path`\n\nTo switch to netty uncomment the netty line in build.gradle and comment out undertow.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nI spend some time trying to get the docker-compose command to run but but failed (and I'm not familiar enough). Is it possible to provide something that doesn't require Docker and Kafka to demonstrate the issue? For example can you make it fail in the webflux-multipart sample?\n\nLooking at your MultimediaHandler, this code looks problematic:\n\n```java\nval filePart = parts.getFirst(\"import\") as FilePart\nfilePart.transferTo(tmpFile.toFile())\n        .then(Mono.just(Files.newBufferedReader(tmpFile).lines().use { it.forEach { importProcessor.importLine().send(GenericMessage<String>(it)) } }))\n        .then(ServerResponse.ok().body(BodyInserters.fromObject(importId.toString())))\n```\n\nYou want `Files.newBufferedReader(tmpFile)` to be deferred so it's executed **after** transferTo completes. Something like:\n\n```java\nval filePart = parts.getFirst(\"import\") as FilePart\nfilePart.transferTo(tmpFile.toFile())\n        .then(Mono.defer(() -> {\n            // read file .. \n            return ServerResponse.ok().body(BodyInserters.fromObject(importId.toString()));\n        });\n```\n\nEven then the file reading and calls to importLine are synchronously executed and potentially blocking but they shouldn't block the event loop thread? I'm not sure if the send is blocking or not given it's Kafka. I presume it might in which case you might have to use publishOn.\n\nAll of those things aren't the original issue, but again I need a sample I can execute to be more specific or a full stack trace at least.\n",
                    "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** commented\n\nI have uploaded one without kafka/docker. Thanks for the suggestions.\n\nMy original intention was to send each line on the file as it arrives, but then I realized I would need to parse the characters for new line (because a line can be in more parts) so I just do with the tempfile approach.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOkay I'll take a look at this sample.\n\nAs for your intent, it sounds like you might want to feed the raw `part.content()` into `StringDecoder` which can split the incoming stream along newline delimiters. You shouldn't need to write to a file.\n",
                    "**[Tamas Eppel](https://jira.spring.io/secure/ViewProfile.jspa?name=teppel)** commented\n\nThanks for the suggestion I have rewritten it like this:\n\n```java\npackage de.techmatrix.dc.matcher.handler\n\nimport de.techmatrix.dc.matcher.component.UploadService\nimport org.springframework.core.ResolvableType\nimport org.springframework.core.codec.StringDecoder\nimport org.springframework.core.io.buffer.DataBuffer\nimport org.springframework.stereotype.Component\nimport org.springframework.util.MimeTypeUtils\nimport org.springframework.web.reactive.function.BodyExtractors\nimport org.springframework.web.reactive.function.BodyInserters\nimport org.springframework.web.reactive.function.server.ServerRequest\nimport org.springframework.web.reactive.function.server.ServerResponse\nimport reactor.core.publisher.Flux\nimport reactor.core.publisher.Mono\nimport reactor.core.publisher.toFlux\nimport reactor.core.scheduler.Schedulers\nimport java.util.*\n\nfun dataBuffers(request: ServerRequest): Flux<DataBuffer> =\n        request.body(BodyExtractors.toMultipartData())\n                .toFlux()\n                .publishOn(Schedulers.parallel())\n                .flatMap { parts -> parts.flatMap { it.value }.toFlux() }.flatMap { it.content() }\n\n@Component\nclass MultimediaHandler(val uploadService: UploadService) {\n    \n    fun upload(request: ServerRequest): Mono<ServerResponse> {\n        val importId = UUID.randomUUID()\n\n        return StringDecoder.allMimeTypes().decode(\n                dataBuffers(request), ResolvableType.forClass(String::class.java), MimeTypeUtils.TEXT_PLAIN, emptyMap())\n                .index()\n                .publishOn(Schedulers.parallel())\n                .doOnNext { uploadService.importLine(importId, it.t2, it.t1.toInt()) }\n                .map { 1 }\n                .reduce { a, b -> a + b }\n                .doOnSuccess { uploadService.importFinished(importId, it) }\n                .then(ServerResponse.ok().body(BodyInserters.fromObject(importId.toString())))\n    }\n}\n```\n\nIt would be quite good to describe this, I did not find anything in the WebFlux documentation, or by searching.\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nOkay, thanks for that. I've been able to confirm the recursion issue:\n\n```\n...\nat org.springframework.http.server.reactive.UndertowServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(UndertowServerHttpRequest.java:156) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher.changeToDemandState(AbstractListenerReadPublisher.java:177) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher.access$900(AbstractListenerReadPublisher.java:47) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher$State$4.onDataAvailable(AbstractListenerReadPublisher.java:319) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher.onDataAvailable(AbstractListenerReadPublisher.java:85) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.UndertowServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(UndertowServerHttpRequest.java:156) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher.changeToDemandState(AbstractListenerReadPublisher.java:177) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher.access$900(AbstractListenerReadPublisher.java:47) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher$State$4.onDataAvailable(AbstractListenerReadPublisher.java:319) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.AbstractListenerReadPublisher.onDataAvailable(AbstractListenerReadPublisher.java:85) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\nat org.springframework.http.server.reactive.UndertowServerHttpRequest$RequestBodyPublisher.checkOnDataAvailable(UndertowServerHttpRequest.java:156) ~[spring-web-5.0.4.RELEASE.jar:5.0.4.RELEASE]\n...\n```\n\nThis is triggered by the `Expect: 100-continue` header that curl sends in this case. However it would happen any time there is back pressure on the input side (i.e. demand present but waiting for data). It works with the \"Expect\" header forced to be empty:\n\n```\n$ curl -v -F --header \"Expect:\" import=@/home/rossen/Downloads/foo-small.txt  http://localhost:8090/api/imports\n```\n\n> I did not find anything in the WebFlux documentation, or by searching.\n\nThe codecs are [documented here](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-codecs). We have planned #21081. Any clues what you searched on, or what you expected to find?\n",
                    "**[Rossen Stoyanchev](https://jira.spring.io/secure/ViewProfile.jspa?name=rstoya05-aop)** commented\n\nThis should be fixed now with [f9df8c](https://github.com/spring-projects/spring-framework/commit/f9df8c738a4eb9fff292f58a82be7ba09e1c3097).\n\n[Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg) if you could, please take a look to see if this fix raises any concerns.\n",
                    "**[Violeta Georgieva](https://jira.spring.io/secure/ViewProfile.jspa?name=violetagg)** commented\n\nLGTM\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the `AbstractListenerReadPublisher` class to prevent potential infinite recursion.  Previously, `checkOnDataAvailable()` was unconditionally called.  The updated code now checks if the previous state was `READING`.  If not, it calls `checkOnDataAvailable()`.  This avoids unnecessary checks and potential infinite loops, particularly in the Undertow environment where direct availability checks are problematic. The change prioritizes attempting a read operation over checking availability in certain scenarios",
            "avg_logprobs": -0.2710467179616292
        }
    },
    {
        "commit_hash": "fb4ad2f3ba0bf0d968a49a05efd8fd41f3e2509d",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "+\t\tif (alreadySeen == null) {\n+\t\t\talreadySeen = new HashSet<>();\n+\t\t}\n+\t\talreadySeen.add(beanName);\n-\t\t\tif (alreadySeen == null) {\n-\t\t\t\talreadySeen = new HashSet<>();\n-\t\t\t}\n-\t\t\talreadySeen.add(beanName);",
        "change_count": 8,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify DefaultSingletonBeanRegistry.isDependent()",
        "commit_body": "Move `alreadySeen` handling out of for-loop.\n\nCloses gh-30839\n",
        "linked_issues": [
            {
                "issue_id": "30839",
                "issue_title": "Simplify `DefaultSingletonBeanRegistry.isDependent()`",
                "issue_body": "Move `alreadySeen` out of for-loop.",
                "issue_state": "closed",
                "issue_comment": [
                    "@bnbakp0582 Please sign the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30839)!\n\n[Click here](https://cla.pivotal.io/sync/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30839) to manually synchronize the status of this Pull Request.\n\nSee the [FAQ](https://cla.pivotal.io/about) for frequently asked questions.",
                    "@bnbakp0582 Thank you for signing the [Contributor License Agreement](https://cla.pivotal.io/sign/spring?repositoryId=spring-projects/spring-framework&pullRequestId=30839)!",
                    "Hi @bnbakp0582,\r\n\r\nThis has been merged into `6.0.x` and `main` in fb4ad2f3ba0bf0d968a49a05efd8fd41f3e2509d and revised in 502997d8e986dcfde1f49b2b2f443a32b5488b13.\r\n\r\nThanks"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change removes a redundant `if` block.  The original code had a duplicate `if (alreadySeen == null)` block, which was unnecessary because the `alreadySeen` variable is initialized in the same scope.  The revised code directly adds the `beanName` to the `HashSet` after ensuring it's initialized. This results in more concise and efficient code",
            "avg_logprobs": -0.32903582089907163
        }
    },
    {
        "commit_hash": "fc8bd64f34d7e34d25144051b1161363a2d31477",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-core/src/main/java/org/springframework/util/ObjectUtils.java",
        "change_type": [
            "Remove_Condition"
        ],
        "diff": "-\t\t\tif (optional.isEmpty()) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tObject result = optional.get();\n+\t\t\tObject result = optional.orElse(null);",
        "change_count": 5,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Simplify ObjectUtils#unwrapOptional",
        "commit_body": "This commit replaces optional.isEmpty() and optional.get() with\noptional.orElse(null) for better efficiency and readability.\n\nCloses gh-33612\n",
        "linked_issues": [
            {
                "issue_id": "33612",
                "issue_title": "Refactor unwrapOptional method to improve readability and performance",
                "issue_body": "### Summary:\r\nThis PR refactors the `unwrapOptional()` method in `ObjectUtils` to enhance code readability and slightly improve performance. The changes focus on simplifying the Optional handling logic.\r\n\r\n### Changes:\r\n- Replaced the combination of `Optional.isEmpty()` and `Optional.get()` with a single call to `Optional.orElse(null)`, improving both readability and code clarity.\r\n- Removed unnecessary conditional checks and made the method more concise.\r\n- Maintained the existing functionality, ensuring that multi-level Optional usage is still not supported.\r\n\r\n### Impact:\r\nThis change will not affect the existing functionality of the system, but it simplifies the code and reduces the potential for errors when working with Optional objects. The performance improvement is marginal but contributes to better maintainability.\r\n\r\nPlease review and provide feedback!",
                "issue_state": "closed",
                "issue_comment": [
                    "@sdeleuze \r\nCould it be that my PR was reflected? Am I a contributor?",
                    "Not sure what you mean by \"reflected\", but yes your PR has been merged, thanks for your contribution.",
                    "@sdeleuze Thank you for doing the PR merge. I will try to contribute more. If I'm a little disappointed in this PR, it's that I wasn't able to add my name to the class comment @author! Thanks again!",
                    "@SungbinYang Your name can be added to a class if you add significant changes to it. I can see you've commented on the other PR asking if it was merged or not. It was. Please refrain from posting further comments like this as each triggers a notification to the thousands watching this repository."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change replaces a null check and explicit `get()` with a single `orElse(null)` call.  This simplifies the code by removing the `if` statement and directly returning the value from the `Optional` if present, or `null` otherwise.  The revised code is more concise and potentially slightly more efficient",
            "avg_logprobs": -0.13379877263849432
        }
    },
    {
        "commit_hash": "fcbe5fa73fd473827f73e516f9819510260d1116",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\t\t\t\t\tif (logger.isInfoEnabled() && implementsInterface(method, ifcs)) {\n-\t\t\t\t\t\t\tlogger.info(\"Unable to proxy interface-implementing method [\" + method + \"] because \" +\n+\t\t\t\t\t\tif (logger.isWarnEnabled() && implementsInterface(method, ifcs)) {\n+\t\t\t\t\t\t\tlogger.warn(\"Unable to proxy interface-implementing method [\" + method + \"] because \" +",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Log attempt at proxying final methods to WARN instead of INFO",
        "commit_body": "See gh-29773\n",
        "linked_issues": [
            {
                "issue_id": "29773",
                "issue_title": "Log `CglibAopProxy` errors as `WARN` instead of `INFO`",
                "issue_body": "Closes gh-29453",
                "issue_state": "closed",
                "issue_comment": [
                    "@qpakzk thank you for making your first contribution to Spring Framework."
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies a logging statement within a conditional check.  The original code logged an informational message when an interface-implementing method couldn't be proxied.  The change now logs a warning message instead.  This suggests a shift in the severity level of the event being reported",
            "avg_logprobs": -0.16249689005189022
        }
    },
    {
        "commit_hash": "fd18c00e50a048c5d357033e61d402f0b01002e8",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/support/TransactionSynchronizationManager.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+\t\telse if (synchs.size() == 1) {\n+\t\t\treturn Collections.singletonList(synchs.iterator().next());\n+\t\t}",
        "change_count": 3,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Optimize for single TransactionSynchronization",
        "commit_body": "Optimize TransactionSynchronizationManager.getSynchronizations() to\navoid sorting and ArrayList creation in case of a single\nTransactionSynchronization.\n\nSee gh-27335\n",
        "linked_issues": [
            {
                "issue_id": "27335",
                "issue_title": "Optimize for single TransactionSynchronization",
                "issue_body": "Optimize TransactionSynchronizationManager.getSynchronizations() to\r\navoid sorting and ArrayList creation in case of a single\r\nTransactionSynchronization.",
                "issue_state": "closed",
                "issue_comment": [
                    "Spring Batch registers a single `TransactionSynchronization` in `TaskletStep#doExecute(StepExecution)`. In certain extreme cases the `ArrayList` and `Object[]` creation can become noticeable. This PR optimizes the case of a single `TransactionSynchronization`, avoids the sorting and instead calls `Collections#singletonList(Object)`.\r\n\r\nBefore:\r\n\r\n![TransactionSynchronizationManager_getSynchronizations](https://user-images.githubusercontent.com/471021/131330452-bd8c9a7e-5f3a-430d-9c2b-a3d1ebdd54c5.png)\r\n\r\nAfter:\r\n\r\n![after-patch](https://user-images.githubusercontent.com/471021/131330537-ce1d3c6a-985f-46ea-9728-eafad358adb4.png)",
                    "Thank you for merging"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a new `else if` condition to the existing code.  If the `synchs` collection contains exactly one element, it now returns a `List` containing only that element, instead of the original, potentially larger, list.  This optimization likely improves performance by avoiding unnecessary object creation when only a single synchronization object is present",
            "avg_logprobs": -0.1563699377907647
        }
    },
    {
        "commit_hash": "fd69ee541e288687f04adb6446ac1b41a9bf415b",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceTransactionManager.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "-\t\t\t(ConnectionHolder) TransactionSynchronizationManager.getResource(this.dataSource);\n+\t\t\t\t(ConnectionHolder) TransactionSynchronizationManager.getResource(this.dataSource);\n-\t\t\tDataSourceUtils.releaseConnection(con, this.dataSource);\n+\t\t\tif (txObject.isNewConnectionHolder()) {\n+\t\t\t\tDataSourceUtils.releaseConnection(con, this.dataSource);\n+\t\t\t\ttxObject.setConnectionHolder(null, false);\n+\t\t\t}",
        "change_count": 7,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "DataSourceTransactionManager resets ConnectionHolder on doBegin failure",
        "commit_body": "Issue: SPR-12280\n",
        "linked_issues": [
            {
                "issue_id": "16885",
                "issue_title": "DataSourceTransactionManager closes JDBC connection on doBegin failure but leaves it attached to transaction object [SPR-12280]",
                "issue_body": "**[Simon Kitching](https://jira.spring.io/secure/ViewProfile.jspa?name=skitching)** opened **[SPR-12280](https://jira.spring.io/browse/SPR-12280?redirect=false)** and commented\n\nDataSourceTransactionManager.doBegin first allocates a connection from the datasource and stores it in the DataSourceTransactionObject. It then does some other work; if any of this other work throws an exception then that connection is released but is not removed from the DataSourceTransactionObject. The result is a misleading \"java.sql.SQLException: Connection is closed\" exception later.\n\nThis problem is present in current trunk code, and at least as far back as 3.0.7 (the version I'm using):\n* https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceTransactionManager.java\n\nIn my particular case, this line in DataSourceTransactionManager.doBegin is throwing an exception:\nInteger previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\nwhich causes the catch clause in the same method to run.\n\nOf course if I resolve the initial problem that causes prepareConnectionForTransaction to fail (\"SET TRANSACTION must be first statement of transaction\" on oracle), then this issue will no longer occur. However the presence of misleading \"connection closed\" errors makes diagnosis of the real problem more difficult..\n\nThis problem seems similar to/related to the following existing issues:\n* #15381\n* #6783\n* [LDAP-179](https://jira.spring.io/browse/LDAP-179)\n\n---\n\n**Affects:** 3.2.11, 4.0.7, 4.1 GA\n\n**Issue Links:**\n- #15381 JDBC Connection is not released due to incorrectly defined catch\n\n**Backported to:** [4.0.8](https://github.com/spring-projects/spring-framework/milestone/120?closed=1), [3.2.12](https://github.com/spring-projects/spring-framework/milestone/100?closed=1)\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWhere do you get the \"java.sql.SQLException: Connection is closed\" exception from later on? The current code assumes that the newly built ConnectionHolder won't be used anymore after a doBegin failure, and I suppose that assumption is flawed... I'm just wondering where exactly the ConnectionHolder is showing up again.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nDataSourceTransactionManager resets the ConnectionHolder on doBegin failure now. This will be available in the upcoming 4.1.2 snapshot; please give it a try! This is also scheduled for a backport to 4.0.8 and 3.2.12.\n\nJuergen\n",
                    "**[Simon Kitching](https://jira.spring.io/secure/ViewProfile.jspa?name=skitching)** commented\n\nThanks very much.\n\nThe case in which I encounter this is unusual: using a TransactionSynchronization.afterCompletion() callback to try to execute some SQL. If within this callback I don't call PlatformTransactionManager.getTransaction with a PROPAGATION_NEW, then the \"Connection is closed\" occurs. If I do try PROPAGATION_NEW, then a java.lang.IllegalStateException: No value for key [org.apache.ibatis.session.defaults.DefaultSqlSessionFactory@2b3efe3e] bound to thread occurs as the AbstractPlatformTransactionManager tries to suspend the current transaction.\n\nI know this is a weird case : trying to perform SQL from an \"afterCompletion\" callback at which point the current transaction context is partially but not completely destructed. However I have the requirement that if a particular transaction rolls back then some other rows must be inserted into the database (error status). Still working on how to get this functioning somehow :-(\n\nHowever it looks to me like the following would also have triggered this problem before your patch (not actually tried..):\n* start a NEW transaction\n* call a method which starts a SUPPORTS transaction (ie create a new transaction object that shares the existing SQL connection) which then fails somewhere in the middle of doBegin thus causing the SQL connection to be released.\n* in the caller, try to perform some SQL - isn't there then a valid transaction-object whose ConnectionHolder holds a closed connection?\n\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nAligned with DataSourceTransactionManager, I've revised all of our transaction manager implementations for consistent cleanup after doBegin failure. Also, JmsTransactionManager explicitly closes the JMS Session in that case now, right before closing the JMS Connection.\n\nJuergen\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of releasing connections in `DataSourceTransactionManager`.  Previously, `DataSourceUtils.releaseConnection` was unconditionally called.  Now, a check (`txObject.isNewConnectionHolder()`) is added.  If the connection holder is new, the connection is released and the `txObject.setConnectionHolder(null, false)` is called",
            "avg_logprobs": -0.2608517646789551
        }
    },
    {
        "commit_hash": "fdf88c9795269c3e551bc3202e6eaead8cfa3752",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-messaging/src/main/java/org/springframework/messaging/tcp/reactor/ReactorNettyTcpConnection.java",
        "change_type": [
            "Add_Condition"
        ],
        "diff": "+import io.netty.channel.ChannelPipeline;\n+import reactor.ipc.netty.NettyPipeline;\n+\n+\t\t// TODO: workaround for https://github.com/reactor/reactor-netty/issues/22\n+\t\tChannelPipeline pipeline = this.inbound.context().channel().pipeline();\n+\t\tString name = NettyPipeline.OnChannelReadIdle;\n+\t\tif (pipeline.context(name) != null) {\n+\t\t\tpipeline.remove(name);\n+\t\t}\n+",
        "change_count": 9,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Workaround for onReadIdle issue in Reactor TcpClient",
        "commit_body": "https://github.com/reactor/reactor-netty/issues/22\n",
        "linked_issues": [],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The code adds a workaround for an issue in reactor-netty (issue #22).  It removes a specific handler (`OnChannelReadIdle`) from the Netty pipeline if it exists.  This suggests a potential problem with the handler interfering with the expected behavior of the connection. The removal is conditional, ensuring it only happens if the handler is present",
            "avg_logprobs": -0.17288397436272607
        }
    },
    {
        "commit_hash": "fee63fdfb854c072ebfe23db1d7e949647320fd4",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-jms/src/main/java/org/springframework/jms/listener/AbstractMessageListenerContainer.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "- * no redelivery in case of exception thrown.\n+ * best-effort redelivery in case of exception thrown.\n+\n+\n-\t\telse {\n+\t\telse if (isClientAcknowledge(session)) {\n-\t\t\telse {\n+\t\t\telse if (isClientAcknowledge(session)) {",
        "change_count": 6,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "Message listener containers only call Session.recover() in client acknowledge mode",
        "commit_body": "Issue: SPR-13056\n",
        "linked_issues": [
            {
                "issue_id": "17648",
                "issue_title": "ByteBuffer corrupted by ByteBufferConverter when passed through Spring [SPR-13056]",
                "issue_body": "**[Nathan Hull](https://jira.spring.io/secure/ViewProfile.jspa?name=lilnate)** opened **[SPR-13056](https://jira.spring.io/browse/SPR-13056?redirect=false)** and commented\n\nIt looks like spring-core 4.x has a bug in how it handles a ByteBuffer being sent on a Spring channel. It converts the ByteBuffer to a byte array, then takes the first element of that array, converts that to a byte array, and then wraps that byte array in a new ByteBuffer. As a result, when I pass a ByteBuffer on a Spring channel, I get a different ByteBuffer out and it only contains the first element, if the ByteBuffer had one or more elements remaining. Most of this happens in ByteBufferConverter.\n\n\n---\n\n**Attachments:**\n- [springBug-sources.jar](https://jira.spring.io/secure/attachment/22816/springBug-sources.jar) (_2.16 kB_)\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/792b7b9d114b4075c3bbe111ffdf056261c60562, https://github.com/spring-projects/spring-framework/commit/1177f5c0a30b94b42b3aed38eb9d2dcf380c0119, https://github.com/spring-projects/spring-framework/commit/008c9a3b459a5dfd14ae334f03099cbff848d7d9, https://github.com/spring-projects/spring-framework/commit/fee63fdfb854c072ebfe23db1d7e949647320fd4\n",
                "issue_state": "closed",
                "issue_comment": [
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis doesn't seem to be a bug in `ByteBufferConverter` itself since a regular conversion attempt from `ByteBuffer` to `ByteBuffer` works fine, delivering a fresh copy of that buffer.\n\nI assume you're experiencing this issue through Spring Integration? If so, I'd suggest raising it with those guys on their JIRA, since the extraction of a single element probably happens somewhere in the specific conversion handling. If the root of the problem turns out to be in the core `ConversionService`, let me know and I'll revisit it here. However, please provide a test case for it at that point.\n\nJuergen\n",
                    "**[Nathan Hull](https://jira.spring.io/secure/ViewProfile.jspa?name=lilnate)** commented\n\nI just attached sources for a dummy project that demonstrates the bug. All it does is send a ByteBuffer via a gateway to a service activator. I don't know how to tell if it's a problem in core or integration.\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've moved this over to Spring Integration since that's the better starting point for an analysis here...\n\nJuergen\n",
                    "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** commented\n\n[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller), I've just done this test:\n\n```java\npublic class Int3720Tests {\n\n\t@Test\n\tpublic void testIt() {\n\t\tTypeDescriptor typeDescriptor = TypeDescriptor.valueOf(ByteBuffer.class);\n\n\t\tByteBuffer byteBuffer = ByteBuffer.allocate(2);\n\t\tbyteBuffer.put((byte) 1);\n\t\tbyteBuffer.put((byte) 2);\n\n\t\tbyteBuffer.rewind();\n\n\t\tConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Context.class);\n\t\tConversionService conversionService = context.getBean(ConversionService.class);\n\t\tObject result = conversionService.convert(byteBuffer, typeDescriptor, typeDescriptor);\n\n\t\tassertEquals(byteBuffer, result);\n\n\t\tbyteBuffer.rewind();\n\n\t\tConfigurableApplicationContext intContext = new AnnotationConfigApplicationContext(IntegrationContext.class);\n\t\tConversionService intConversionService = intContext.getBean(ConversionService.class);\n\t\tresult = intConversionService.convert(byteBuffer, typeDescriptor, typeDescriptor);\n\n\t\tassertEquals(byteBuffer, result);\n\n\t\tcontext.close();\n\t\tintContext.close();\n\t}\n\n\t@Configuration\n\t@EnableIntegration\n\tpublic static class IntegrationContext {\n\n\t}\n\n\t@Configuration\n\tpublic static class Context {\n\n\t\t@Bean\n\t\tpublic FactoryBean<ConversionService> conversionService() {\n\t\t\treturn new ConversionServiceFactoryBean();\n\t\t}\n\n\t}\n\n}\n```\n\nAnd it really shows me that `ByteBufferConverter` doesn't convert properly `ByteBuffer` to `ByteBuffer`.\nWe fail here on the raw `@Configuration` without Spring Integration.\n\nFrom my perspective we must not even try to convert if the `target` is `ByteBuffer`.\n\nWould you mind sharing your test-case to take a look ?\n\nThanks!\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\n[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan), I was just using this one:\n\n```\n@Test\npublic void byteBufferToByteBuffer() throws Exception {\n     byte[] bytes = new byte[] { 1, 2, 3 };\n     ByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n     ByteBuffer convert = this.conversionService.convert(byteBuffer, ByteBuffer.class);\n     assertThat(convert, not(sameInstance(byteBuffer.rewind())));\n     assertThat(convert, equalTo(byteBuffer.rewind()));\n}\n```\n\nLooking at your test case, you seem to reuse the original `ByteBuffer` instance? That might be the root of the problem here: It's a stateful buffer object after all, with all that `rewind()` business, it's even somewhat odd to write a test case for it. So if there is an easy improvement that we can make to `ByteBufferConverter` itself for such scenarios, I'm up for that. However, generally speaking, you shouldn't pass a previously consumed buffer/stream/etc to the `ConversionService` again. I'd suggest to either create fresh a `ByteBuffer` instance every time or to specifically skip the `ConversionService` invocation for such reuse scenarios.\n",
                    "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** commented\n\nThank you, Juergen, but doesn't work even like this:\n\n```java\n\tbyte[] bytes = new byte[] { 1, 2, 3 };\n\n\tByteBuffer byteBuffer = ByteBuffer.wrap(bytes);\n\n\tConfigurableApplicationContext context = new AnnotationConfigApplicationContext(Context.class);\n\tConversionService conversionService = context.getBean(ConversionService.class);\n\tByteBuffer result = conversionService.convert(byteBuffer, ByteBuffer.class);\n\n\tassertThat(result, equalTo(ByteBuffer.wrap(bytes)));\n```\n\n```\njava.lang.AssertionError: \nExpected: <java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]>\n     but: was <java.nio.HeapByteBuffer[pos=0 lim=1 cap=1]>\n```\n\nWe can't bypass `ConversionService`, becuase SI POJO method invocation is based on SpEL, which uses `ConversionService` for method arguments from `Message` and its `payload`.\nIn this case our `Message` has `payload` as a `ByteBuffer` and the method param is `ByteBuffer`, too. So, or we should bypass conversion `ByteBuffer -> ByteBuffer`, or should copy it to a new one, as you said that we shouldn't reuse a consumed already.\nBut I don't see that it works properly in the `ByteBufferConverter`...\n\nI am on the SF-4.2.0.BULD-SNAPSHOT.\n\nCome back to you later, when I fix some my own issue and prepare a raw test-case just for `ByteBufferConverter`.\n\nThank you for your time anyway!\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nI've found the key difference in the tests: Our `ByteBufferConverterTests` use a `GenericConversionService` with just `ByteBufferConverter` registered. When running them against a full `DefaultConversionService`, two of the existing tests fail, so it's probably some other default converter (the array converter possibly?) interfering.\n\nI'll have a look at the `DefaultConversionService` scenario ASAP. Moving this issue back to the Spring Framework project for that reason.\n\nJuergen\n",
                    "**[Nathan Hull](https://jira.spring.io/secure/ViewProfile.jspa?name=lilnate)** commented\n\nThe logic around the call to `ByteBufferConverter#convertFromByteBuffer()` looks suspect: the preceding logic (`ByteBufferConverter#convert()`) determines that a HeapByteBuffer is assignable to a ByteBuffer, but then it calls `ByteBufferConverter#convertFromByteBuffer()`, which creates a new ByteBuffer. Why not return the original HeapByteBuffer since it's assignable to ByteBuffer?\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nWe intentionally create an independent copy of the `ByteBuffer` there, since each buffer can have its own position state then. But point taken, an explicit code path that duplicates the `ByteBuffer` doesn't hurt, so I've added that now.\n\nGenerally speaking, the root of the problem was that `ByteBufferConverter` didn't explicitly declare `ByteBuffer`->`byte[]` and vice versa as convertible pairs. This allows for other converters, such as the array-to-element converter, to kick in. I've added explicit declarations for `byte[]` next to the general `Object` convertible declarations now, which is sufficient to solve this problem. The explicit duplication code path above is just an optimization.\n\nJuergen\n",
                    "**[Juergen Hoeller](https://jira.spring.io/secure/ViewProfile.jspa?name=juergen.hoeller)** commented\n\nThis is now in master and will be available in the upcoming `4.2.0.BUILD-SNAPSHOT`. I'll backport it to 4.1.7 later today.\n\nJuergen\n",
                    "**[Artem Bilan](https://jira.spring.io/secure/ViewProfile.jspa?name=abilan)** commented\n\nThanks, Juergen!\n\nWorks well now.\n"
                ]
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change modifies the handling of exceptions during message processing in `AbstractMessageListenerContainer`.  Previously, exceptions prevented redelivery.  Now, redelivery is attempted, but only if the session is configured for client acknowledgment (`isClientAcknowledge(session)`).  This introduces a best-effort redelivery strategy, prioritizing client-acknowledged sessions",
            "avg_logprobs": -0.17507667541503907
        }
    },
    {
        "commit_hash": "ff8655846d9c6903f16730efc1650a4ae55866b9",
        "repository_name": "spring-projects/spring-framework",
        "file_name": "spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java",
        "change_type": [
            "Condition_Change"
        ],
        "diff": "-\t\tif (info == null) {\n+\t\tif (info == null || info.transactionStatus == null) {\n-\t\treturn currentTransactionInfo().transactionStatus;\n+\t\treturn info.transactionStatus;",
        "change_count": 4,
        "condition_type": [
            "condition"
        ],
        "commit_subject": "TransactionAspectSupport.currentTransactionStatus() reliably throws NoTransactionException",
        "commit_body": "Issue: SPR-9144\n",
        "linked_issues": [
            {
                "issue_id": "13783",
                "issue_title": "TransactionAspectSupport.currentTransactionStatus() can return null when from the exception signature we'd expect a NoTransactionException [SPR-9144]",
                "issue_body": "**[David Boden](https://jira.spring.io/secure/ViewProfile.jspa?name=daveboden)** opened **[SPR-9144](https://jira.spring.io/browse/SPR-9144?redirect=false)** and commented\n\nAffects version 3.1.0.RELEASE. I haven't tested 3.1.1.RELEASE but assume it still exists there.\n\nThe behaviour I'm seeing is that TransactionStatus.currentTransactionStatus() calls currentTransactionInfo() and gets a valid object.\n\nHowever, it then returns the .transactionStatus attributes from that object. In this case the attribute is null. This null is returned and opens up the potential for an unexpected NullPointerException.\n\n\n---\n\n**Affects:** 3.1 GA\n\n**Referenced from:** commits https://github.com/spring-projects/spring-framework/commit/ff8655846d9c6903f16730efc1650a4ae55866b9\n",
                "issue_state": "closed",
                "issue_comment": []
            }
        ],
        "cc_summary": {
            "model": "gemini",
            "config": {
                "k": 3,
                "temp": 0.2
            },
            "text": "The change adds a null check for `info.transactionStatus` before returning the `transactionStatus`.  Previously, if `info` was null, the code would attempt to access `currentTransactionInfo().transactionStatus`, potentially leading to a `NullPointerException`.  The updated code now returns `info.transactionStatus` directly, only if `info` itself is not null.  This prevents the `NullPointerException` and improves robustness",
            "avg_logprobs": -0.20827061942454134
        }
    }
]